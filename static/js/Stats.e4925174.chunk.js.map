{"version":3,"sources":["../static/js/Stats.e4925174.chunk.js","components/blockchain/Statistics/index.js","../node_modules/echarts/lib/chart/helper/Symbol.js","../node_modules/echarts/lib/chart/line/helper.js","../node_modules/echarts/lib/component/toolbox/featureManager.js","../node_modules/echarts/lib/chart/line.js","../node_modules/echarts/lib/chart/helper/SymbolDraw.js","../node_modules/echarts/lib/chart/line/LineSeries.js","../node_modules/echarts/lib/chart/line/LineView.js","../node_modules/echarts/lib/chart/line/lineAnimationDiff.js","../node_modules/echarts/lib/chart/line/poly.js","../node_modules/echarts/lib/visual/symbol.js","../node_modules/echarts/lib/layout/points.js","../node_modules/echarts/lib/processor/dataSample.js","../node_modules/echarts/lib/component/dataZoom/DataZoomModel.js","../node_modules/echarts/lib/component/dataZoom/DataZoomView.js","../node_modules/echarts/lib/component/helper/listComponent.js","../node_modules/echarts/lib/chart/pie.js","../node_modules/echarts/lib/chart/pie/PieSeries.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/component/helper/selectableMixin.js","../node_modules/echarts/lib/chart/pie/PieView.js","../node_modules/echarts/lib/action/createDataSelectAction.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/chart/pie/pieLayout.js","../node_modules/echarts/lib/chart/pie/labelLayout.js","../node_modules/echarts/lib/processor/dataFilter.js","components/common/LineChart.js","../node_modules/echarts/lib/component/dataZoom/helper.js","../node_modules/echarts/lib/component/helper/sliderMove.js","../node_modules/echarts/lib/component/dataZoom/typeDefaulter.js","../node_modules/echarts/lib/component/helper/interactionMutex.js","../node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js","../node_modules/echarts/lib/component/dataZoom/dataZoomAction.js","../node_modules/echarts/lib/component/dataZoom/history.js","utils/tron.js","components/blockchain/Statistics/RichList.js","components/common/PieChart.js","components/common/LineChartTx.js","../node_modules/echarts/lib/component/dataZoom.js","../node_modules/echarts/lib/component/dataZoom/AxisProxy.js","../node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js","../node_modules/echarts/lib/component/dataZoom/SliderZoomView.js","../node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js","../node_modules/echarts/lib/component/dataZoom/InsideZoomView.js","../node_modules/echarts/lib/component/dataZoom/roams.js","../node_modules/echarts/lib/component/helper/RoamController.js","../node_modules/echarts/lib/component/toolbox.js","../node_modules/echarts/lib/component/toolbox/ToolboxModel.js","../node_modules/echarts/lib/component/toolbox/ToolboxView.js","../node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js","../node_modules/echarts/lib/component/toolbox/feature/MagicType.js","../node_modules/echarts/lib/component/toolbox/feature/DataView.js","../node_modules/echarts/lib/component/toolbox/feature/DataZoom.js","../node_modules/echarts/lib/component/helper/BrushController.js","../node_modules/echarts/lib/component/helper/BrushTargetManager.js","../node_modules/echarts/lib/component/helper/brushHelper.js","../node_modules/echarts/lib/component/helper/cursorHelper.js","../node_modules/echarts/lib/component/dataZoomSelect.js","../node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js","../node_modules/echarts/lib/component/dataZoom/SelectZoomView.js","../node_modules/echarts/lib/component/toolbox/feature/Restore.js","../node_modules/echarts/lib/component/markPoint.js","../node_modules/echarts/lib/component/marker/MarkPointModel.js","../node_modules/echarts/lib/component/marker/MarkerModel.js","../node_modules/echarts/lib/component/marker/MarkPointView.js","../node_modules/echarts/lib/component/marker/markerHelper.js","../node_modules/echarts/lib/component/marker/MarkerView.js"],"names":["webpackJsonp","1185","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_asyncToGenerator","fn","gen","apply","this","arguments","Promise","resolve","reject","step","key","arg","info","value","error","done","then","err","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","mapStateToProps","state","defineProperty","_regenerator","_regenerator2","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_react","_react2","_i18n","_api","_constants","_reactRedux","_reactIntl","_lodash","_tron","_RichList","_loaders","_PieChart","_PieChart2","_LineChart","_LineChart2","_LineChartTx","_LineChartTx2","Statistics","_React$Component","_this","getPrototypeOf","accounts","transactionStats","blockStats","transactionValueStats","txOverviewStats","loadAccounts","loadStats","loadTxOverviewStats","_ref","mark","_callee","_ref2","wrap","_context","prev","next","Client","getAccounts","limit","sort","sent","setState","filter","account","includes","tronAddresses","address","slice","map","name","balance","ONE_TRX","stop","_ref3","_callee2","intl","_ref4","stats","_ref5","transactionTotalStats","valueStats","_context2","getTransferStats","groupby","interval","getBlockStats","total","row","timestamp","formatTime","_ref6","_callee3","_ref7","_context3","getTxOverviewStats","_state","createElement","className","tu","style","height","TronLoader","data","keysData","Component","mapDispatchToProps","connect","injectIntl","1239","getSymbolSize","idx","symbolSize","getItemVisual","Array","getScale","SymbolClz","seriesScope","graphic","Group","updateData","driftSymbol","dx","dy","parent","drift","zrUtil","_symbol","createSymbol","_number","parsePercent","_labelHelper","getDefaultLabel","symbolProto","_createSymbol","symbolType","removeAll","color","symbolPath","attr","z2","culling","scale","_symbolType","add","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","trigger","downplay","setZ","zlevel","z","setDraggable","draggable","cursor","silent","seriesModel","hostModel","isInit","updateProps","_updateCommon","fadeIn","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","getLabelDefaultText","opt","useNameLabel","getName","type","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","labelModel","hoverLabelModel","hoverAnimation","cursorStyle","hasItemOption","itemModel","getItemModel","getModel","getItemStyle","getShallow","extend","elStyle","Math","PI","setColor","symbolInnerColor","setStyle","setLabelStyle","labelFetcher","labelDataIndex","defaultText","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","incremental","ratio","animateTo","max","onNormal","on","fadeOut","cb","keepLabel","text","dataIndex","inherits","_default","1240","prepareDataCoordInfo","coordSys","valueOrigin","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","getValueStart","baseAxisDim","dim","valueAxisDim","valueDim","mapDimension","baseDim","baseDataOffset","stacked","isDimensionStacked","dataDimsForPoint","dimensions","coordDim","stackedOverDimension","getCalculationInfo","extent","getExtent","getStackedOnPoint","dataCoordInfo","NaN","get","isNaN","stackedData","dataToPoint","_dataStackHelper","_util","1249","register","ctor","features","1266","echarts","visualSymbol","layoutPoints","dataSample","registerVisual","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","1267","SymbolDraw","symbolCtor","group","_symbolCtor","symbolNeedsDraw","point","isIgnore","clipShape","contain","normalizeUpdateOpt","isObject","makeSeriesScope","symbolDrawProto","oldData","_data","SymbolCtor","diff","newIdx","getItemLayout","symbolEl","setItemGraphicEl","update","oldIdx","getItemGraphicEl","remove","position","el","execute","isPersistent","updateLayout","eachItemGraphicEl","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","useHoverLayer","start","end","traverse","enableAnimation","1281","_config","createListFromArray","__DEV__","SeriesModel","dependencies","getInitialData","option","ecModel","getSource","defaultOption","coordinateSystem","legendHoverLink","clipOverflow","label","lineStyle","width","smooth","smoothMonotone","symbol","showSymbol","showAllSymbol","connectNulls","sampling","animationEasing","progressive","hoverLayerThreshold","Infinity","1282","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","axis","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","getStackedOnPoints","points","len","count","push","createGridClipShape","cartesian","hasAnimation","xExtent","getAxis","yExtent","isHorizontal","x","min","y","lineWidth","expandSize","clipPath","Rect","shape","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","Sector","cx","cy","r0","r","startAngle","endAngle","clockwise","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","pt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","visualMeta","dimIndex","dimension","dimName","dimInfo","getDimensionInfo","colorStops","stops","coord","toGlobalCoord","dataToCoord","stopLen","outerColors","reverse","minCoord","maxCoord","coordSpan","each","offset","unshift","gradient","LinearGradient","lineAnimationDiff","modelUtil","_poly","Polyline","Polygon","ChartView","_helper","init","lineGroup","symbolDraw","_symbolDraw","_lineGroup","render","api","getData","lineStyleModel","areaStyleModel","mapArray","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","coordSysClipShape","setClipPath","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","defaults","getLineStyle","fill","stroke","lineJoin","stackedOnSeries","stackedOnSmooth","getAreaStyle","_valueOrigin","dispose","payload","queryDataIndex","ignore","categoryAxis","getAxesByScale","isLabelIgnored","bind","current","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","1283","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","diffItem","pointAdded","currentPt","getRawIndex","rawIndex","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","1284","isPointNull","p","drawSegment","ctx","segLen","allLen","smoothMin","smoothMax","isMono","drawMono","drawNonMono","last","lastDiff","prevIdx","k","prevP","ctrlLen","v2Copy","cp0","cp1","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","vec2","sub","v","lenPrevSeg","lenNextSeg","abs","dist","scaleAndAdd","vec2Min","vec2Max","getBoundingBox","smoothConstraint","ptMin","ptMax","Path","fixClipWithShadow","copy","brush","buildPath","result","bbox","stackedOnBBox","closePath","1285","seriesType","defaultSymbolType","legendSymbol","performRawSeries","reset","dataEach","rawValue","getRawValue","params","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize","setVisual","isSeriesFiltered","hasCallback","1286","plan","createRenderPlanner","progress","segCount","isLargeRender","Float32Array","dimLen","tmpIn","tmpOut","dims","setItemLayout","setLayout","pipelineContext","large","1287","size","rate","round","sampler","samplers","setData","downSample","indexSampler","average","frame","sum","nearest","1288","retrieveRaw","ret","hasOwnProperty","updateRangeUse","dataZoomModel","rawOption","rangePropMode","_rangePropMode","rangeModeInOption","names","index","percentSpecified","valueSpecified","env","helper","AxisProxy","eachAxisDim","DataZoomModel","extendComponentModel","orient","xAxisIndex","yAxisIndex","filterMode","throttle","startValue","endValue","minSpan","maxSpan","minValueSpan","maxValueSpan","rangeMode","parentModel","_dataIntervalByAxis","_dataInfo","_axisProxies","textStyleModel","_autoThrottle","mergeDefaultAndTheme","doInit","mergeOption","newOption","merge","thisOption","canvasSupported","realtime","_setDefaultThrottle","_resetTarget","_giveAxisProxies","axisProxies","eachTargetAxis","dimNames","axisIndex","axisModel","dependentModels","axisProxy","__dzAxisProxy","autoMode","_judgeAutoMode","axisIndexName","normalizeToArray","_autoSetAxisIndex","_autoSetOrient","hasIndexSpecified","autoAxisIndex","singleAxis","singleAxisModel","singleAxisIndex","componentIndex","axisIndices","axisModels","eachSeries","_isSeriesHasAllAxesTypeOf","axisId","queryComponents","mainType","id","indexOf","axisType","is","seriesAxisIndex","globalOption","animation","animationDurationUpdate","getFirstTargetAxisModel","firstAxisModel","indices","callback","context","getAxisProxy","getAxisModel","setRawRange","ignoreUpdateRangeUsg","getPercentRange","findRepresentativeAxisProxy","getDataPercentWindow","getValueRange","axisDimName","getDataValueWindow","hostedBy","getRangePropMode","1289","ComponentView","getTargetCoordInfo","save","coordModel","store","coordIndex","item","model","coordSysLists","getComponent","getCoordSysModel","1290","layout","componentModel","boxLayoutParams","getBoxLayoutParams","padding","viewportSize","getWidth","getHeight","rect","getLayoutRect","layoutBox","positionElement","makeBackground","formatUtil","normalizeCssArray","_layout","box","1355","createDataSelectAction","dataColor","pieLayout","dataFilter","event","method","curry","1356","createListSimply","getPercentWithPrecision","dataSelectableMixin","_dataProvider","retrieveRawAttr","PieSeries","extendSeriesModel","superApply","legendDataProvider","getRawData","updateSelectedMap","_createSelectableList","_defaultLabelLine","superCall","targetList","selected","valueList","percent","$vars","defaultEmphasis","labelLineNormalOpt","labelLine","labelLineEmphasisOpt","emphasis","show","center","radius","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","rotate","length2","borderWidth","animationType","mixin","1357","nameList","isArray","coordDimensions","source","dimensionsInfo","createDimensions","list","List","initData","1358","_targetList","_selectTargetMap","reduce","targetMap","set","createHashMap","select","unSelect","toggleSelected","isSelected","1359","updateDataSelected","uid","dispatchAction","from","seriesId","toggleItemSelected","midAngle","cos","sin","animate","when","PiePiece","hoverIgnore","normalIgnore","sector","Text","piePieceProto","firstCreate","sectorShape","_updateLabel","labelText","labelLayout","linePoints","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","useInsideStyle","inside","textAlign","textVerticalAlign","verticalAlign","PieView","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","selectedMode","piePiece","eachChild","child","removeClipPath","_createClipPath","containPoint","itemLayout","sqrt","1360","actionInfos","actionInfo","registerAction","eachComponent","subType","query","1361","getTargetSeries","paletteScope","seiresModelMap","eachSeriesByType","__paletteScope","dataAll","idxMap","rawIdx","filteredIdx","singleDataColor","getColorFromPalette","1362","validDataCount","getSum","unitRadian","roseType","getDataExtent","restAngle","PI2","valueSumLargerThanMinAngle","currentAngle","angle","linearMap","1363","adjustSingleSide","viewWidth","viewHeight","shiftUp","delta","j","changeX","isDownList","lastDeltaX","Number","MAX_VALUE","l","deltaY","len2","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelPosition","labelLineLen","labelLineLen2","isLabelInside","x1","y1","x2","y2","x3","y3","font","getFont","labelRotate","getFormattedLabel","textRect","textContain","getBoundingRect","1364","legendModels","findComponents","filterSelf","1365","LineReact","undefined","_chartConfig","_chartConfig2","_echarts","_echarts2","random","replace","lineId","_props","format","myChart","getInstanceByDom","document","getElementById","lineChart","title","xAxis","series","val","date","formatDate","setOption","initLine","pure","1366","isCoordSupported","coordType","COORDS","createNameEach","attrs","capitalNames","capitalFirst","capitalAttrs","nameObj","capital","createLinkedNodesFinder","forEachNode","forEachEdgeType","edgeIdGetter","isNodeAbsorded","node","nodes","isLinked","hasLink","edgeType","edgeId","records","absorb","sourceNode","processSingleNode","existsLink","AXIS_DIMS","1367","handleEnds","handleIndex","restrict","extentSpan","originalDistSign","getSpanSign","extentMinSpan","realExtent","sign","currDistSign","span","1448","registerSubTypeDefaulter","1449","take","zr","resourceKey","userKey","getStore","release","isTaken","ATTR","1450","seriesModelMap","getTargetSeriesModels","isOverallFilter","overallReset","filterData","percentRange","valueRange","1451","linkedNodesFinder","effectedModels","1452","newSnapshot","giveStore","batchItem","dataZoomId","pop","head","snapshot","clear","1622","1623","_Price","RichList","_Component","richList","totals","coins","load","getRichList","FormattedNumber","to","maximumFractionDigits","minimumFractionDigits","TRXPrice","amount","currency","1624","PieReact","pieId","pieChart","initPie","1625","LineReactTx","_extends","assign","txOverviewChart","temp","totalTransaction","1626","1627","calculateDataExtent","axisDim","seriesModels","dataExtent","seriesData","seriesExtent","getApproximateExtent","fixExtentByAxis","getMin","isCategoryAxis","axisDataLen","getCategories","getMax","setAxisModel","isRestore","percentWindow","_percentWindow","valueWindow","_valueWindow","precision","numberUtil","getPixelPrecision","useOrigin","setRange","toFixed","setMinMaxSpan","minMaxSpan","_minMaxSpan","_dataZoomModel","minMax","valueSpan","parse","_dataExtent","asc","_dimName","_axisIndex","getOtherAxisModel","otherAxisDim","coordSysIndexName","isCartesian","foundOtherAxisModel","otherAxisModel","getMinMaxSpan","clone","calculateDataWindow","percentExtent","prop","boundValue","boundPercent","targetSeries","dataWindow","restore","isInWindow","dataDims","leftOut","rightOut","hasValue","thisHasValue","thisLeftOut","thisRightOut","range","selectRange","setApproximateExtent","1628","SliderZoomModel","layoutMode","right","top","left","bottom","backgroundColor","dataBackground","areaStyle","borderColor","fillerColor","handleIcon","handleSize","handleStyle","labelPrecision","labelFormatter","showDetail","showDataShadow","zoomLock","textStyle","1629","getOtherDim","thisDim","getCursor","eventTool","DataZoomView","sliderMove","HORIZONTAL","LABEL_GAP","SHOW_DATA_SHADOW_SERIES_TYPE","SliderZoomView","_displayables","_orient","_range","_handleEnds","_size","_handleWidth","_handleHeight","_location","_dragging","_dataShadowInfo","createOrUpdate","_buildView","_updateView","thisGroup","_resetLocation","_resetInterval","barGroup","_renderBackground","_renderHandle","_renderDataShadow","_positionGroup","coordRect","_findCoordRect","ecSize","positionInfo","layoutParams","getLayoutParams","layoutRect","location","targetAxisModel","otherAxisInverse","_getViewExtent","onclick","_onClickPanelClick","_prepareDataShadowInfo","otherDim","getShadowDim","otherDataExtent","otherOffset","lastIsEmpty","otherShadowExtent","thisShadowExtent","areaPoints","thisCoord","stride","otherCoord","thisAxis","displaybles","handles","handleLabels","filler","_onDragMove","onmousemove","e","ondragstart","_showDataInfo","ondragend","_onDragEnd","onmouseover","onmouseout","textPosition","subPixelOptimizeRect","path","createIcon","bRect","handleColor","invisible","textFill","getTextColor","textFont","viewExtent","_updateInterval","viewExtend","nonRealtime","handleInterval","handle","handleHeight","_updateDataInfo","setLabel","barTransform","getTransform","direction","transformDirection","textPoint","applyTransform","orderedHandleEnds","labelTexts","dataInterval","_formatLabel","valueStr","getLabel","isFunction","isString","showOrHide","getLocalTransform","vertex","_dispatchZoomAction","localPoint","transformCoordToLocal","offsetX","offsetY","coordInfoList","getRect","1630","disabled","zoomOnMouseWheel","moveOnMouseMove","preventDefaultMouseMove","1631","roams","InsideZoomView","shouldRecordRange","coordSysName","allCoordIds","coordInfo","generateCoordId","dataZoomOption","coordId","containsPoint","throttleRate","panGetRange","_onPan","zoomGetRange","_onZoom","roamControllerOpt","unregister","controller","oldX","oldY","newX","newY","directionInfo","getDirectionInfo","percentDelta","signal","pixel","pixelLength","mouseX","mouseY","percentPoint","pixelStart","grid","oldPoint","newPoint","pointToCoord","1632","dataZoomInfo","theDataZoomId","theCoordId","record","dataZoomInfos","cleanStore","createController","controllerParams","mergeControllerParams","enable","controlType","setPointerChecker","throttleUtil","batch","getZr","newRecord","RoamController","onPan","onZoom","wrapAndDispatch","getRange","typePriority","type_true","type_move","type_false","type_undefined","oneType","1633","pointerChecker","_zr","_opt","mousedownHandler","mousedown","mousemoveHandler","mousemove","mouseupHandler","mouseup","mousewheelHandler","mousewheel","pinchHandler","pinch","Eventful","disable","isDragging","isPinching","_pinching","notLeftMouse","_x","_y","checkKeyBinding","gestureEvent","interactionMutex","wheelDelta","zoomDelta","zoom","pinchScale","pinchX","pinchY","zoomX","zoomY","roamController","setting","1634","1635","featureManager","ToolboxModel","ignoreSize","feature","featureOpt","featureName","Feature","borderRadius","itemSize","itemGap","showTitle","iconStyle","1636","isUserFeatureName","Model","DataDiffer","listComponentHelper","extendComponentView","toolboxModel","processFeature","newIndex","oldIndex","featureNames","oldName","featureOpts","featureModel","unusable","createIconPaths","setIconStatus","iconName","iconPaths","iconStatus","iconStyleModel","iconStyleEmphasisModel","icons","getIcons","titles","icon","iconStr","__title","_features","_featureNames","titleText","makeFont","needPutOnTop","topOffset","updateView","1637","SaveAsImage","lang","saveAsImageLang","toolbox","saveAsImage","excludeComponents","pixelRatio","$a","download","url","getConnectedDataURL","href","MouseEvent","browser","ie","edge","window","navigator","msSaveOrOpenBlob","bstr","atob","split","n","u8arr","Uint8Array","charCodeAt","blob","Blob","html","tab","open","write","evt","view","bubbles","cancelable","dispatchEvent","1638","MagicType","magicTypeLang","magicType","line","bar","stack","tiled","seriesIndex","proto","availableIcons","seriesOptGenreator","markPoint","markLine","radioTypes","generateNewSeriesTypes","newSeriesOpt","boundaryGap","radio","currentType","1639","groupSeries","seriesGroupByCategoryAxis","otherSeries","meta","eachRawSeries","other","assembleSeriesWithCategoryAxis","tables","headers","concat","columns","lines","join","ITEM_SPLITER","items","BLOCK_SPLITER","assembleOtherSeries","vals","argLen","getContentFromModel","str","trim","isTSVFormat","block","parseTSVContents","tsv","tsvLines","shift","itemSplitRegex","categories","header","parseListContents","seriesName","hasName","parseContents","blockMetaList","blocks","RegExp","blockMeta","axisKey","DataView","_dom","tryMergeDataOption","originalData","newVal","original","dataViewLang","dataView","readOnly","optionToContent","contentToOption","textColor","textareaColor","textareaBorderColor","buttonColor","buttonTextColor","close","container","removeChild","root","getDom","cssText","innerHTML","viewMain","textarea","htmlOrDom","getOption","isDom","appendChild","buttonContainer","buttonStyle","closeButton","refreshButton","addEventListener","Error","keyCode","which","selectionStart","selectionEnd","substring","clientHeight","newSeriesOptList","seriesOpt","getSeriesByName","1640","DataZoom","_brushController","BrushController","_onBrush","mount","_isZoomActive","retrieveAxisSetting","updateBackBtnStatus","history","updateZoomBtnStatus","zoomActive","dataZoomSelectActive","brushTargetManager","BrushTargetManager","include","setPanels","makePanelOpts","targetInfo","xAxisDeclared","yAxisDeclared","enableBrush","brushType","brushStyle","dataZoomLang","dataZoom","DATA_ZOOM_ID_BASE","back","handlers","unmount","nextActive","areas","setBatch","findDataZoom","found","dzModel","isEnd","updateCovers","matchOutputRanges","area","coordRange","lineX","lineY","registerPreprocessor","addForAxis","axisName","dataZoomOpt","axisIndicesName","givenAxisIndices","forEachComponent","axisOpt","newOpt","$fromToolbox","dataZoomOpts","opts","toolboxOpt","1641","_brushType","_brushOption","_panels","_track","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_uid","baseUID","_handlers","mouseHandlers","handler","eventName","doEnableBrush","brushOption","MUTEX_RESOURCE_KEY","DEFAULT_BRUSH_OPT","doDisableBrush","createCover","cover","coverRenderers","__brushOption","updateZ","endCreating","creatingCover","coverRenderer","getCoverRenderer","updateCoverShape","COVER_Z","updateCoverAfterCreation","updateCommon","getPanelByPoint","localCursorPoint","panels","panel","transform","_transform","pn","isTargetByCursor","getPanelByCover","panelId","clearCovers","covers","originalLength","removeOnClick","shouldShowCover","track","mathPow","UNSELECT_THRESHOLD","getTrackEnds","tail","createBaseRectCover","doDrift","edgeNames","makeStyle","updateBaseRect","localRange","mathMax","MIN_RESIZE_LINE_WIDTH","xa","ya","x2a","y2a","widtha","heighta","updateRectShape","transformable","mainEl","childOfName","globalDir","getGlobalDirection","CURSOR_MAP","w","h","pointsToRect","clipByPanel","formatRectRange","mathMin","localDirection","s","inverseMap","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","DIRECTION_MAP","driftPolygon","localD","localZero","xmin","ymin","resetCursor","currPanel","setCursorStyle","preventDefault","rawE","mainShapeContain","updateCoverByMouse","eventParams","thisBrushOption","brushMode","determineBrushType","getCreatingRange","defaultBrushType","handleDragEnd","getLineRenderer","xyIndex","localTrack","ends","otherExtent","getLinearBrushOtherExtent","pow","ne","sw","nw","se","panelOpts","enableGlobalPan","eachCover","brushOptionList","getKey","tmpIdPrefix","oldGetKey","addOrUpdate","newBrushOption","oldCovers","newCovers","1642","targetInfoList","_targetInfoList","foundCpts","parseFinder","targetInfoBuilders","builder","formatMinMax","includeMainTypes","INCLUDE_FINDER_MAIN_TYPES","axisConvert","axisNameIndex","rangeOrCoordRange","values","coordToData","toLocalCoord","xyMinMax","axisDiffProcessor","refer","scales","getScales","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","brushHelper","COORD_CONVERTS","setOutputRanges","coordRanges","coordConvert","__rangeOffset","diffProcessor","findTargetInfo","coordSyses","setInputRanges","rangeOffset","getDefaultBrushType","getPanelRect","makeRectPanelClipPath","makeRectIsTargetByCursor","coordSysModel","makeLinearBrushOtherExtent","controlSeries","areaPanelId","targetInfoMatchers","xAxisModels","yAxisModels","gridModels","gridModelMap","xAxesHas","yAxesHas","gridModel","cartesians","getCartesians","panelRectBuilder","geo","geoModels","geoModel","xAxisModel","yAxisModel","xminymin","xmaxymax","1643","normalizeRect","localPoints","graphicUtil","clipPointsByRect","specifiedXYIndex","brushWidth","base","targetModel","onIrrelevantElement","BoundingRect","_cursorHelper","1644","targetCoordSysModel","getComponentByElement","topTarget","IRRELEVANT_EXCLUDES","axisPointer","tooltip","1645","1646","1647","1648","Restore","restoreLang","resetOption","1649","1650","MarkerModel","1651","fillLabel","dataFormatMixin","addCommas","encodeHTML","extraOpt","createdBySelf","hostSeries","__hostSeries","modelPropName","markerOpt","markerModel","formatTooltip","formattedValue","1652","updateMarkerLayout","mpData","xPx","yPx","getMarkerPosition","getValues","createList","mpModel","coordDimsInfos","dataOpt","markerHelper","dataTransform","dimValueGetter","MarkerView","updateTransform","markPointModel","markerGroupMap","renderSeries","symbolDrawMap","dataModel","__keep","1653","hasXOrY","parseFloat","hasXAndY","markerTypeCalculatorWithExtent","mlType","otherDataDim","targetDataDim","otherCoordIndex","targetCoordIndex","coordArr","calcDataDim","numCalculate","indicesOfNearest","getPrecision","axisInfo","getAxisInfo","markerTypeCalculator","baseDataDim","valueDataDim","yAxis","valueIndex","getDimension","dataDimToCoordDim","dataDim","dimItem","containData","1654","markerModelKey"],"mappings":"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","file":"static/js/Stats.e4925174.chunk.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 1185:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(5);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _i18n=__webpack_require__(4);var _api=__webpack_require__(6);var _constants=__webpack_require__(14);var _reactRedux=__webpack_require__(7);var _reactIntl=__webpack_require__(8);var _lodash=__webpack_require__(11);var _tron=__webpack_require__(1622);var _RichList=__webpack_require__(1623);var _RichList2=_interopRequireDefault(_RichList);var _loaders=__webpack_require__(19);var _PieChart=__webpack_require__(1624);var _PieChart2=_interopRequireDefault(_PieChart);var _LineChart=__webpack_require__(1365);var _LineChart2=_interopRequireDefault(_LineChart);var _LineChartTx=__webpack_require__(1625);var _LineChartTx2=_interopRequireDefault(_LineChartTx);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Statistics=function(_React$Component){_inherits(Statistics,_React$Component);function Statistics(){_classCallCheck(this,Statistics);var _this=_possibleConstructorReturn(this,(Statistics.__proto__||Object.getPrototypeOf(Statistics)).call(this));_this.state={accounts:null,transactionStats:null,blockStats:null,transactionValueStats:null,txOverviewStats:null};return _this;}_createClass(Statistics,[{key:\"componentDidMount\",value:function componentDidMount(){this.loadAccounts();this.loadStats();this.loadTxOverviewStats();}},{key:\"loadAccounts\",value:function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var _ref2,accounts;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _api.Client.getAccounts({limit:35,sort:'-balance'});case 2:_ref2=_context.sent;accounts=_ref2.accounts;this.setState({accounts:(0,_lodash.filter)(accounts,function(account){return!(0,_lodash.includes)(_tron.tronAddresses,account.address);}).slice(0,10).map(function(account){return{name:account.address,value:account.balance/_constants.ONE_TRX};})});case 5:case\"end\":return _context.stop();}}},_callee,this);}));function loadAccounts(){return _ref.apply(this,arguments);}return loadAccounts;}()},{key:\"loadStats\",value:function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee2(){var intl,_ref4,stats,_ref5,blockStats,transactionTotalStats,valueStats;return _regenerator2.default.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:intl=this.props.intl;_context2.next=3;return _api.Client.getTransferStats({groupby:'timestamp',interval:'hour'});case 3:_ref4=_context2.sent;stats=_ref4.stats;_context2.next=7;return _api.Client.getBlockStats({info:\"avg-block-size\"});case 7:_ref5=_context2.sent;blockStats=_ref5.stats;transactionTotalStats=stats.total.map(function(row){return{timestamp:intl.formatTime(row.timestamp),value:row.value};});valueStats=stats.value.map(function(row){return{timestamp:intl.formatTime(row.timestamp),value:row.value/_constants.ONE_TRX};});blockStats=blockStats.map(function(row){return{timestamp:intl.formatTime(row.timestamp),value:row.value};});this.setState({transactionStats:transactionTotalStats,transactionValueStats:valueStats,blockStats:blockStats});case 13:case\"end\":return _context2.stop();}}},_callee2,this);}));function loadStats(){return _ref3.apply(this,arguments);}return loadStats;}()},{key:\"loadTxOverviewStats\",value:function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee3(){var _ref7,txOverviewStats;return _regenerator2.default.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return _api.Client.getTxOverviewStats();case 2:_ref7=_context3.sent;txOverviewStats=_ref7.txOverviewStats;this.setState({txOverviewStats:txOverviewStats});case 5:case\"end\":return _context3.stop();}}},_callee3,this);}));function loadTxOverviewStats(){return _ref6.apply(this,arguments);}return loadTxOverviewStats;}()},{key:\"render\",value:function render(){var _state=this.state,txOverviewStats=_state.txOverviewStats,transactionStats=_state.transactionStats,transactionValueStats=_state.transactionValueStats,blockStats=_state.blockStats,accounts=_state.accounts;return _react2.default.createElement(\"main\",{className:\"container header-overlap\"},_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-12 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"TRX_transaction_chart\")),_react2.default.createElement(\"div\",{style:{height:300}},txOverviewStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChartTx2.default,{style:{height:300},data:txOverviewStats})))))),_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"Top\"),\" \",accounts!==null?accounts.length:0,\" \",(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"div\",{style:{height:300}},accounts===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_PieChart2.default,{style:{height:300},data:accounts}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"trx_transferred_past_hour\")),_react2.default.createElement(\"div\",{style:{height:300}},transactionValueStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:transactionValueStats,keysData:['timestamp','value']})))))),_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"transactions_past_hour\")),_react2.default.createElement(\"div\",{style:{height:300}},transactionStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:transactionStats,keysData:['timestamp','value']}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"average_blocksize\"),\" (\",(0,_i18n.tu)(\"bytes\"),\")\"),_react2.default.createElement(\"div\",{style:{height:300}},blockStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:blockStats,keysData:['timestamp','value']})))))));}}]);return Statistics;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps)((0,_reactIntl.injectIntl)(Statistics));\n\n/***/ }),\n\n/***/ 1239:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar _symbol = __webpack_require__(224);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(22);\n\nvar _number = __webpack_require__(27);\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = __webpack_require__(433);\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1240:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = __webpack_require__(2);\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n/***/ }),\n\n/***/ 1249:\n/***/ (function(module, exports) {\n\nvar features = {};\n\nfunction register(name, ctor) {\n  features[name] = ctor;\n}\n\nfunction get(name) {\n  return features[name];\n}\n\nexports.register = register;\nexports.get = get;\n\n/***/ }),\n\n/***/ 1266:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n__webpack_require__(1281);\n\n__webpack_require__(1282);\n\nvar visualSymbol = __webpack_require__(1285);\n\nvar layoutPoints = __webpack_require__(1286);\n\nvar dataSample = __webpack_require__(1287);\n\n__webpack_require__(434);\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n/***/ }),\n\n/***/ 1267:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(22);\n\nvar SymbolClz = __webpack_require__(1239);\n\nvar _util = __webpack_require__(2);\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1281:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = __webpack_require__(226);\n\nvar SeriesModel = __webpack_require__(225);\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1282:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(2);\n\nvar SymbolDraw = __webpack_require__(1267);\n\nvar SymbolClz = __webpack_require__(1239);\n\nvar lineAnimationDiff = __webpack_require__(1283);\n\nvar graphic = __webpack_require__(22);\n\nvar modelUtil = __webpack_require__(12);\n\nvar _poly = __webpack_require__(1284);\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = __webpack_require__(424);\n\nvar _helper = __webpack_require__(1240);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1283:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _helper = __webpack_require__(1240);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1284:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(32);\n\nvar vec2 = __webpack_require__(25);\n\nvar fixClipWithShadow = __webpack_require__(431);\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n/***/ }),\n\n/***/ 1285:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1286:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(2);\n\nvar map = _util.map;\n\nvar createRenderPlanner = __webpack_require__(432);\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1287:\n/***/ (function(module, exports) {\n\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1288:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar env = __webpack_require__(28);\n\nvar modelUtil = __webpack_require__(12);\n\nvar helper = __webpack_require__(1366);\n\nvar AxisProxy = __webpack_require__(1627);\n\nvar each = zrUtil.each;\nvar eachAxisDim = helper.eachAxisDim;\nvar DataZoomModel = echarts.extendComponentModel({\n  type: 'dataZoom',\n  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 4,\n    // Higher than normal component (z: 2).\n    orient: null,\n    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n    xAxisIndex: null,\n    // Default the first horizontal category axis.\n    yAxisIndex: null,\n    // Default the first vertical category axis.\n    filterMode: 'filter',\n    // Possible values: 'filter' or 'empty' or 'weakFilter'.\n    // 'filter': data items which are out of window will be removed. This option is\n    //          applicable when filtering outliers. For each data item, it will be\n    //          filtered if one of the relevant dimensions is out of the window.\n    // 'weakFilter': data items which are out of window will be removed. This option\n    //          is applicable when filtering outliers. For each data item, it will be\n    //          filtered only if all  of the relevant dimensions are out of the same\n    //          side of the window.\n    // 'empty': data items which are out of window will be set to empty.\n    //          This option is applicable when user should not neglect\n    //          that there are some data items out of window.\n    // 'none': Do not filter.\n    // Taking line chart as an example, line will be broken in\n    // the filtered points when filterModel is set to 'empty', but\n    // be connected when set to 'filter'.\n    throttle: null,\n    // Dispatch action by the fixed rate, avoid frequency.\n    // default 100. Do not throttle when use null/undefined.\n    // If animation === true and animationDurationUpdate > 0,\n    // default value is 100, otherwise 20.\n    start: 0,\n    // Start percent. 0 ~ 100\n    end: 100,\n    // End percent. 0 ~ 100\n    startValue: null,\n    // Start value. If startValue specified, start is ignored.\n    endValue: null,\n    // End value. If endValue specified, end is ignored.\n    minSpan: null,\n    // 0 ~ 100\n    maxSpan: null,\n    // 0 ~ 100\n    minValueSpan: null,\n    // The range of dataZoom can not be smaller than that.\n    maxValueSpan: null,\n    // The range of dataZoom can not be larger than that.\n    rangeMode: null // Array, can be 'value' or 'percent'.\n\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel) {\n    /**\n     * key like x_0, y_1\n     * @private\n     * @type {Object}\n     */\n    this._dataIntervalByAxis = {};\n    /**\n     * @private\n     */\n\n    this._dataInfo = {};\n    /**\n     * key like x_0, y_1\n     * @private\n     */\n\n    this._axisProxies = {};\n    /**\n     * @readOnly\n     */\n\n    this.textStyleModel;\n    /**\n     * @private\n     */\n\n    this._autoThrottle = true;\n    /**\n     * 'percent' or 'value'\n     * @private\n     */\n\n    this._rangePropMode = ['percent', 'percent'];\n    var rawOption = retrieveRaw(option);\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (newOption) {\n    var rawOption = retrieveRaw(newOption); //FIX #2591\n\n    zrUtil.merge(this.option, newOption, true);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @protected\n   */\n  doInit: function (rawOption) {\n    var thisOption = this.option; // Disable realtime view update if canvas is not supported.\n\n    if (!env.canvasSupported) {\n      thisOption.realtime = false;\n    }\n\n    this._setDefaultThrottle(rawOption);\n\n    updateRangeUse(this, rawOption);\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n    this.textStyleModel = this.getModel('textStyle');\n\n    this._resetTarget();\n\n    this._giveAxisProxies();\n  },\n\n  /**\n   * @private\n   */\n  _giveAxisProxies: function () {\n    var axisProxies = this._axisProxies;\n    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.\n\n      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.\n      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME\n      // dispose __dzAxisProxy\n\n      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetTarget: function () {\n    var thisOption = this.option;\n\n    var autoMode = this._judgeAutoMode();\n\n    eachAxisDim(function (dimNames) {\n      var axisIndexName = dimNames.axisIndex;\n      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);\n    }, this);\n\n    if (autoMode === 'axisIndex') {\n      this._autoSetAxisIndex();\n    } else if (autoMode === 'orient') {\n      this._autoSetOrient();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _judgeAutoMode: function () {\n    // Auto set only works for setOption at the first time.\n    // The following is user's reponsibility. So using merged\n    // option is OK.\n    var thisOption = this.option;\n    var hasIndexSpecified = false;\n    eachAxisDim(function (dimNames) {\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n      if (thisOption[dimNames.axisIndex] != null) {\n        hasIndexSpecified = true;\n      }\n    }, this);\n    var orient = thisOption.orient;\n\n    if (orient == null && hasIndexSpecified) {\n      return 'orient';\n    } else if (!hasIndexSpecified) {\n      if (orient == null) {\n        thisOption.orient = 'horizontal';\n      }\n\n      return 'axisIndex';\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetAxisIndex: function () {\n    var autoAxisIndex = true;\n    var orient = this.get('orient', true);\n    var thisOption = this.option;\n    var dependentModels = this.dependentModels;\n\n    if (autoAxisIndex) {\n      // Find axis that parallel to dataZoom as default.\n      var dimName = orient === 'vertical' ? 'y' : 'x';\n\n      if (dependentModels[dimName + 'Axis'].length) {\n        thisOption[dimName + 'AxisIndex'] = [0];\n        autoAxisIndex = false;\n      } else {\n        each(dependentModels.singleAxis, function (singleAxisModel) {\n          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n            autoAxisIndex = false;\n          }\n        });\n      }\n    }\n\n    if (autoAxisIndex) {\n      // Find the first category axis as default. (consider polar)\n      eachAxisDim(function (dimNames) {\n        if (!autoAxisIndex) {\n          return;\n        }\n\n        var axisIndices = [];\n        var axisModels = this.dependentModels[dimNames.axis];\n\n        if (axisModels.length && !axisIndices.length) {\n          for (var i = 0, len = axisModels.length; i < len; i++) {\n            if (axisModels[i].get('type') === 'category') {\n              axisIndices.push(i);\n            }\n          }\n        }\n\n        thisOption[dimNames.axisIndex] = axisIndices;\n\n        if (axisIndices.length) {\n          autoAxisIndex = false;\n        }\n      }, this);\n    }\n\n    if (autoAxisIndex) {\n      // FIXME\n      // ec2xAxisIndexyAxisIndexscatterdataZoom\n      // Grid.js#getScaleByOptiontimelogaxis type\n      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n      // dataZoom component auto adopts series that reference to\n      // both xAxis and yAxis which type is 'value'.\n      this.ecModel.eachSeries(function (seriesModel) {\n        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n          eachAxisDim(function (dimNames) {\n            var axisIndices = thisOption[dimNames.axisIndex];\n            var axisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisId = seriesModel.get(dimNames.axisId);\n            var axisModel = seriesModel.ecModel.queryComponents({\n              mainType: dimNames.axis,\n              index: axisIndex,\n              id: axisId\n            })[0];\n            axisIndex = axisModel.componentIndex;\n\n            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n              axisIndices.push(axisIndex);\n            }\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetOrient: function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (dimNames) {\n      !dim && (dim = dimNames.name);\n    }, this);\n    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n  },\n\n  /**\n   * @private\n   */\n  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n    // FIXME\n    // seriesxAxisIndexyAxisIndex\n    // series.type === scatter\n    var is = true;\n    eachAxisDim(function (dimNames) {\n      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n      if (!axisModel || axisModel.get('type') !== axisType) {\n        is = false;\n      }\n    }, this);\n    return is;\n  },\n\n  /**\n   * @private\n   */\n  _setDefaultThrottle: function (rawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (rawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  },\n\n  /**\n   * @public\n   */\n  getFirstTargetAxisModel: function () {\n    var firstAxisModel;\n    eachAxisDim(function (dimNames) {\n      if (firstAxisModel == null) {\n        var indices = this.get(dimNames.axisIndex);\n\n        if (indices.length) {\n          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n        }\n      }\n    }, this);\n    return firstAxisModel;\n  },\n\n  /**\n   * @public\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n  eachTargetAxis: function (callback, context) {\n    var ecModel = this.ecModel;\n    eachAxisDim(function (dimNames) {\n      each(this.get(dimNames.axisIndex), function (axisIndex) {\n        callback.call(context, dimNames, axisIndex, this, ecModel);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n   */\n  getAxisProxy: function (dimName, axisIndex) {\n    return this._axisProxies[dimName + '_' + axisIndex];\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/model/Model} If not found, return null/undefined.\n   */\n  getAxisModel: function (dimName, axisIndex) {\n    var axisProxy = this.getAxisProxy(dimName, axisIndex);\n    return axisProxy && axisProxy.getAxisModel();\n  },\n\n  /**\n   * If not specified, set to undefined.\n   *\n   * @public\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   * @param {boolean} [ignoreUpdateRangeUsg=false]\n   */\n  setRawRange: function (opt, ignoreUpdateRangeUsg) {\n    var option = this.option;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // If only one of 'start' and 'startValue' is not null/undefined, the other\n      // should be cleared, which enable clear the option.\n      // If both of them are not set, keep option with the original value, which\n      // enable use only set start but not set end when calling `dispatchAction`.\n      // The same as 'end' and 'endValue'.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        option[names[0]] = opt[names[0]];\n        option[names[1]] = opt[names[1]];\n      }\n    }, this);\n    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n  },\n\n  /**\n   * @public\n   * @return {Array.<number>} [startPercent, endPercent]\n   */\n  getPercentRange: function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  },\n\n  /**\n   * @public\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @param {string} [axisDimName]\n   * @param {number} [axisIndex]\n   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n   */\n  getValueRange: function (axisDimName, axisIndex) {\n    if (axisDimName == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n    }\n  },\n\n  /**\n   * @public\n   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   * @return {module:echarts/component/dataZoom/AxisProxy}\n   */\n  findRepresentativeAxisProxy: function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var axisProxies = this._axisProxies;\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    } // If no hosted axis find not hosted axisProxy.\n    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n    // and the option.start or option.end settings are different. The percentRange\n    // should follow axisProxy.\n    // (We encounter this problem in toolbox data zoom.)\n\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    }\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getRangePropMode: function () {\n    return this._rangePropMode.slice();\n  }\n});\n\nfunction retrieveRaw(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n  var rangePropMode = dataZoomModel._rangePropMode;\n  var rangeModeInOption = dataZoomModel.get('rangeMode');\n  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n    var percentSpecified = rawOption[names[0]] != null;\n    var valueSpecified = rawOption[names[1]] != null;\n\n    if (percentSpecified && !valueSpecified) {\n      rangePropMode[index] = 'percent';\n    } else if (!percentSpecified && valueSpecified) {\n      rangePropMode[index] = 'value';\n    } else if (rangeModeInOption) {\n      rangePropMode[index] = rangeModeInOption[index];\n    } else if (percentSpecified) {\n      // percentSpecified && valueSpecified\n      rangePropMode[index] = 'percent';\n    } // else remain its original setting.\n\n  });\n}\n\nvar _default = DataZoomModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1289:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ComponentView = __webpack_require__(445);\n\nvar _default = ComponentView.extend({\n  type: 'dataZoom',\n  render: function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  },\n\n  /**\n   * Find the first target coordinate system.\n   *\n   * @protected\n   * @return {Object} {\n   *                   grid: [\n   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n   *                       ...\n   *                   ],  // cartesians must not be null/undefined.\n   *                   polar: [\n   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n   *                       ...\n   *                   ],  // polars must not be null/undefined.\n   *                   singleAxis: [\n   *                       {model: coord0, axisModels: [], coordIndex: 0}\n   *                   ]\n   */\n  getTargetCoordInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var ecModel = this.ecModel;\n    var coordSysLists = {};\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\n      if (axisModel) {\n        var coordModel = axisModel.getCoordSysModel();\n        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);\n      }\n    }, this);\n\n    function save(coordModel, axisModel, store, coordIndex) {\n      var item;\n\n      for (var i = 0; i < store.length; i++) {\n        if (store[i].model === coordModel) {\n          item = store[i];\n          break;\n        }\n      }\n\n      if (!item) {\n        store.push(item = {\n          model: coordModel,\n          axisModels: [],\n          coordIndex: coordIndex\n        });\n      }\n\n      item.axisModels.push(axisModel);\n    }\n\n    return coordSysLists;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1290:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _layout = __webpack_require__(57);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(37);\n\nvar graphic = __webpack_require__(22);\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n/***/ }),\n\n/***/ 1355:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\n__webpack_require__(1356);\n\n__webpack_require__(1359);\n\nvar createDataSelectAction = __webpack_require__(1360);\n\nvar dataColor = __webpack_require__(1361);\n\nvar pieLayout = __webpack_require__(1362);\n\nvar dataFilter = __webpack_require__(1364);\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n/***/ }),\n\n/***/ 1356:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar createListSimply = __webpack_require__(1357);\n\nvar zrUtil = __webpack_require__(2);\n\nvar modelUtil = __webpack_require__(12);\n\nvar _number = __webpack_require__(27);\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = __webpack_require__(1358);\n\nvar _dataProvider = __webpack_require__(95);\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // \n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // \n    clockwise: true,\n    startAngle: 90,\n    // 0\n    minAngle: 0,\n    // \n    selectedOffset: 10,\n    // \n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // singlemultiple\n    // selectedMode: false,\n    // 'radius' | 'area'\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: Tooltip.formatter\n      // TEXTSTYLE\n      // distance: positioninnerlabel()\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // \n      length: 15,\n      // \n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: ,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1357:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(228);\n\nvar List = __webpack_require__(227);\n\nvar _util = __webpack_require__(2);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1358:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1359:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar graphic = __webpack_require__(22);\n\nvar ChartView = __webpack_require__(424);\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1360:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1361:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(2);\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1362:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _number = __webpack_require__(27);\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = __webpack_require__(1363);\n\nvar zrUtil = __webpack_require__(2);\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME  2.0  roseType  area \n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1363:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textContain = __webpack_require__(74);\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // \n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // \n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // \n    ? Number.MAX_VALUE // \n    : 0 // \n    : isDownList // \n    ? Number.MAX_VALUE // \n    : 0; // \n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // \n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // \n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1364:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1365:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.LineReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(8);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1266);__webpack_require__(422);__webpack_require__(423);var _reactRedux=__webpack_require__(7);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var LineReact=exports.LineReact=function(_React$Component){_inherits(LineReact,_React$Component);function LineReact(props){_classCallCheck(this,LineReact);var _this=_possibleConstructorReturn(this,(LineReact.__proto__||Object.getPrototypeOf(LineReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={lineId:'line'+id};return _this;}_createClass(LineReact,[{key:'initLine',value:function initLine(id){var _props=this.props,intl=_props.intl,keysData=_props.keysData,data=_props.data,format=_props.format;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.lineChart.title.text='';_chartConfig2.default.lineChart.xAxis.data=[];_chartConfig2.default.lineChart.series[0].data=[];if(data&&data.length>0){data.map(function(val){if(format&&format[keysData[0]]){if(format.date){_chartConfig2.default.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]]*1000));}else{_chartConfig2.default.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]*1000));}}else _chartConfig2.default.lineChart.xAxis.data.push(val[keysData[0]]);_chartConfig2.default.lineChart.series[0].data.push(val[keysData[1]]);});}if(data&&data.length===0){_chartConfig2.default.lineChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.lineChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initLine(this.state.lineId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initLine(this.state.lineId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.lineId,style:this.props.style}));}}]);return LineReact;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(LineReact));\n\n/***/ }),\n\n/***/ 1366:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar formatUtil = __webpack_require__(37);\n\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.\n\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n/**\n * @param {string} coordType\n * @return {boolean}\n */\n\nfunction isCoordSupported(coordType) {\n  return zrUtil.indexOf(COORDS, coordType) >= 0;\n}\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\n\n\nfunction createNameEach(names, attrs) {\n  names = names.slice();\n  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n  attrs = (attrs || []).slice();\n  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n  return function (callback, context) {\n    zrUtil.each(names, function (name, index) {\n      var nameObj = {\n        name: name,\n        capital: capitalNames[index]\n      };\n\n      for (var j = 0; j < attrs.length; j++) {\n        nameObj[attrs[j]] = name + capitalAttrs[j];\n      }\n\n      callback.call(context, nameObj);\n    });\n  };\n}\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\n\n\nvar eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\n\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n  return function (sourceNode) {\n    var result = {\n      nodes: [],\n      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\n    };\n    forEachEdgeType(function (edgeType) {\n      result.records[edgeType.name] = {};\n    });\n\n    if (!sourceNode) {\n      return result;\n    }\n\n    absorb(sourceNode, result);\n    var existsLink;\n\n    do {\n      existsLink = false;\n      forEachNode(processSingleNode);\n    } while (existsLink);\n\n    function processSingleNode(node) {\n      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n        absorb(node, result);\n        existsLink = true;\n      }\n    }\n\n    return result;\n  };\n\n  function isNodeAbsorded(node, result) {\n    return zrUtil.indexOf(result.nodes, node) >= 0;\n  }\n\n  function isLinked(node, result) {\n    var hasLink = false;\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] && (hasLink = true);\n      });\n    });\n    return hasLink;\n  }\n\n  function absorb(node, result) {\n    result.nodes.push(node);\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] = true;\n      });\n    });\n  }\n}\n\nexports.isCoordSupported = isCoordSupported;\nexports.createNameEach = createNameEach;\nexports.eachAxisDim = eachAxisDim;\nexports.createLinkedNodesFinder = createLinkedNodesFinder;\n\n/***/ }),\n\n/***/ 1367:\n/***/ (function(module, exports) {\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nfunction _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  // Normalize firstly.\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleIndex = 0;\n  }\n\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbinden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1], Math.max(extend[0], value));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1448:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(59);\n\nComponent.registerSubTypeDefaulter('dataZoom', function () {\n  // Default 'slider' when no type specified.\n  return 'slider';\n});\n\n/***/ }),\n\n/***/ 1449:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar ATTR = '\\0_ec_interaction_mutex';\n\nfunction take(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  store[resourceKey] = userKey;\n}\n\nfunction release(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  var uKey = store[resourceKey];\n\n  if (uKey === userKey) {\n    store[resourceKey] = null;\n  }\n}\n\nfunction isTaken(zr, resourceKey) {\n  return !!getStore(zr)[resourceKey];\n}\n\nfunction getStore(zr) {\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n/**\n * payload: {\n *     type: 'takeGlobalCursor',\n *     key: 'dataZoomSelect', or 'brush', or ...,\n *         If no userKey, release global cursor.\n * }\n */\n\n\necharts.registerAction({\n  type: 'takeGlobalCursor',\n  event: 'globalCursorTaken',\n  update: 'update'\n}, function () {});\nexports.take = take;\nexports.release = release;\nexports.isTaken = isTaken;\n\n/***/ }),\n\n/***/ 1450:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar _util = __webpack_require__(2);\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\necharts.registerProcessor({\n  getTargetSeries: function (ecModel) {\n    var seriesModelMap = createHashMap();\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        var axisProxy = dataZoomModel.getAxisProxy(dimNames.name, axisIndex);\n        each(axisProxy.getTargetSeriesModels(), function (seriesModel) {\n          seriesModelMap.set(seriesModel.uid, seriesModel);\n        });\n      });\n    });\n    return seriesModelMap;\n  },\n  isOverallFilter: true,\n  // Consider appendData, where filter should be performed. Because data process is\n  // in block mode currently, it is not need to worry about that the overallProgress\n  // execute every frame.\n  overallReset: function (ecModel, api) {\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // We calculate window and reset axis here but not in model\n      // init stage and not after action dispatch handler, because\n      // reset should be called after seriesData.restoreData.\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel, api);\n      }); // Caution: data zoom filtering is order sensitive when using\n      // percent range and no min/max/scale set on axis.\n      // For example, we have dataZoom definition:\n      // [\n      //      {xAxisIndex: 0, start: 30, end: 70},\n      //      {yAxisIndex: 0, start: 20, end: 80}\n      // ]\n      // In this case, [20, 80] of y-dataZoom should be based on data\n      // that have filtered by x-dataZoom using range of [30, 70],\n      // but should not be based on full raw data. Thus sliding\n      // x-dataZoom will change both ranges of xAxis and yAxis,\n      // while sliding y-dataZoom will only change the range of yAxis.\n      // So we should filter x-axis after reset x-axis immediately,\n      // and then reset y-axis and filter y-axis.\n\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel, api);\n      });\n    });\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // Fullfill all of the range props so that user\n      // is able to get them from chart.getOption().\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n      var percentRange = axisProxy.getDataPercentWindow();\n      var valueRange = axisProxy.getDataValueWindow();\n      dataZoomModel.setRawRange({\n        start: percentRange[0],\n        end: percentRange[1],\n        startValue: valueRange[0],\n        endValue: valueRange[1]\n      }, true);\n    });\n  }\n});\n\n/***/ }),\n\n/***/ 1451:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar helper = __webpack_require__(1366);\n\necharts.registerAction('dataZoom', function (payload, ecModel) {\n  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {\n    return model.get(dimNames.axisIndex);\n  });\n  var effectedModels = [];\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (model, index) {\n    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);\n  });\n  zrUtil.each(effectedModels, function (dataZoomModel, index) {\n    dataZoomModel.setRawRange({\n      start: payload.start,\n      end: payload.end,\n      startValue: payload.startValue,\n      endValue: payload.endValue\n    });\n  });\n});\n\n/***/ }),\n\n/***/ 1452:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar each = zrUtil.each;\nvar ATTR = '\\0_ec_hist_store';\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n */\n\nfunction push(ecModel, newSnapshot) {\n  var store = giveStore(ecModel); // If previous dataZoom can not be found,\n  // complete an range with current range.\n\n  each(newSnapshot, function (batchItem, dataZoomId) {\n    var i = store.length - 1;\n\n    for (; i >= 0; i--) {\n      var snapshot = store[i];\n\n      if (snapshot[dataZoomId]) {\n        break;\n      }\n    }\n\n    if (i < 0) {\n      // No origin range set, create one by current range.\n      var dataZoomModel = ecModel.queryComponents({\n        mainType: 'dataZoom',\n        subType: 'select',\n        id: dataZoomId\n      })[0];\n\n      if (dataZoomModel) {\n        var percentRange = dataZoomModel.getPercentRange();\n        store[0][dataZoomId] = {\n          dataZoomId: dataZoomId,\n          start: percentRange[0],\n          end: percentRange[1]\n        };\n      }\n    }\n  });\n  store.push(newSnapshot);\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} snapshot\n */\n\n\nfunction pop(ecModel) {\n  var store = giveStore(ecModel);\n  var head = store[store.length - 1];\n  store.length > 1 && store.pop(); // Find top for all dataZoom.\n\n  var snapshot = {};\n  each(head, function (batchItem, dataZoomId) {\n    for (var i = store.length - 1; i >= 0; i--) {\n      var batchItem = store[i][dataZoomId];\n\n      if (batchItem) {\n        snapshot[dataZoomId] = batchItem;\n        break;\n      }\n    }\n  });\n  return snapshot;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction clear(ecModel) {\n  ecModel[ATTR] = null;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {number} records. always >= 1.\n */\n\n\nfunction count(ecModel) {\n  return giveStore(ecModel).length;\n}\n/**\n * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n * History length of each dataZoom may be different.\n * this._history[0] is used to store origin range.\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(ecModel) {\n  var store = ecModel[ATTR];\n\n  if (!store) {\n    store = ecModel[ATTR] = [{}];\n  }\n\n  return store;\n}\n\nexports.push = push;\nexports.pop = pop;\nexports.clear = clear;\nexports.count = count;\n\n/***/ }),\n\n/***/ 1622:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var tronAddresses=exports.tronAddresses=['27d3byPxZXKQWfXX7sJvemJJuv5M65F3vjS','27fXgQ46DcjEsZ444tjZPKULcxiUfDrDjqj','27SWXcHuQgFf9uv49FknBBBYBaH3DUk4JPx','27WtBq2KoSy5v8VnVZBZHHJcDuWNiSgjbE3'];\n\n/***/ }),\n\n/***/ 1623:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(5);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _api=__webpack_require__(6);var _reactIntl=__webpack_require__(8);var _Price=__webpack_require__(38);var _i18n=__webpack_require__(4);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var RichList=function(_Component){_inherits(RichList,_Component);function RichList(){_classCallCheck(this,RichList);var _this=_possibleConstructorReturn(this,(RichList.__proto__||Object.getPrototypeOf(RichList)).call(this));_this.state={richList:[],totals:{accounts:0,coins:0}};return _this;}_createClass(RichList,[{key:\"componentDidMount\",value:function componentDidMount(){this.load();}},{key:\"load\",value:function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var _ref2,data,total;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _api.Client.getRichList();case 2:_ref2=_context.sent;data=_ref2.data;total=_ref2.total;this.setState({richList:data,totals:total});case 6:case\"end\":return _context.stop();}}},_callee,this);}));function load(){return _ref.apply(this,arguments);}return load;}()},{key:\"render\",value:function render(){var _state=this.state,richList=_state.richList,totals=_state.totals;return _react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"rich_list\"))),_react2.default.createElement(\"table\",{className:\"table table-hover bg-white m-0 table-striped\"},_react2.default.createElement(\"thead\",{className:\"thead-dark\"},_react2.default.createElement(\"tr\",null,_react2.default.createElement(\"th\",null,(0,_i18n.tu)(\"balance\")),_react2.default.createElement(\"th\",{className:\"d-none d-lg-table-cell\"},(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"th\",{className:\"text-nowrap text-right\"},\"% \",(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"th\",{className:\"text-right d-none d-md-table-cell\"},(0,_i18n.tu)(\"TRX\")),_react2.default.createElement(\"th\",{className:\"text-right\"},\"$ \",(0,_i18n.tu)(\"USD\")),_react2.default.createElement(\"th\",{className:\"text-right  d-none d-md-table-cell\"},\"% \",(0,_i18n.tu)(\"Coins\")))),_react2.default.createElement(\"tbody\",null,richList.map(function(row,index){return _react2.default.createElement(\"tr\",{key:index},_react2.default.createElement(\"th\",null,_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.from}),' - ',_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.to})),_react2.default.createElement(\"td\",{className:\"d-none d-lg-table-cell\"},row.accounts),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap\",style:{width:100}},_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.accounts/totals.accounts*100,maximumFractionDigits:2,minimumFractionDigits:2}),\" %\"),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_Price.TRXPrice,{amount:row.balance})),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap\"},_react2.default.createElement(_Price.TRXPrice,{amount:row.balance,currency:\"USD\"})),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.balance/totals.coins*100,maximumFractionDigits:4,minimumFractionDigits:4}),\" %\"));}))));}}]);return RichList;}(_react.Component);exports.default=RichList;\n\n/***/ }),\n\n/***/ 1624:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.PieReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1355);__webpack_require__(422);__webpack_require__(423);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var PieReact=exports.PieReact=function(_React$Component){_inherits(PieReact,_React$Component);function PieReact(props){_classCallCheck(this,PieReact);var _this=_possibleConstructorReturn(this,(PieReact.__proto__||Object.getPrototypeOf(PieReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={pieId:'pie'+id};return _this;}_createClass(PieReact,[{key:'initPie',value:function initPie(id){var data=this.props.data;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.pieChart.series[0].data=[];_chartConfig2.default.pieChart.title.text=\"\";if(data&&data.length>0){_chartConfig2.default.pieChart.series[0].data=data;}if(data&&data.length===0){_chartConfig2.default.pieChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.pieChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initPie(this.state.pieId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie(this.state.pieId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.pieId,style:this.props.style}));}}]);return PieReact;}(_react2.default.Component);exports.default=PieReact;\n\n/***/ }),\n\n/***/ 1625:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.LineReactTx=undefined;var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(8);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1266);__webpack_require__(422);__webpack_require__(423);__webpack_require__(1626);__webpack_require__(1634);__webpack_require__(1649);var _reactRedux=__webpack_require__(7);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var LineReactTx=exports.LineReactTx=function(_React$Component){_inherits(LineReactTx,_React$Component);function LineReactTx(props){_classCallCheck(this,LineReactTx);var _this=_possibleConstructorReturn(this,(LineReactTx.__proto__||Object.getPrototypeOf(LineReactTx)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={lineId:'lineTx'+id};return _this;}_createClass(LineReactTx,[{key:'initLine',value:function initLine(id){var _props=this.props,intl=_props.intl,data=_props.data;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.txOverviewChart.title.text='';_chartConfig2.default.txOverviewChart.xAxis[0].data=[];_chartConfig2.default.txOverviewChart.series[0].data=[];// config.txOverviewChart.yAxis[0].name =  intl.formatMessage({id: 'transactions_per_day'});\nif(data&&data.length>0){data.map(function(val){var temp=void 0;temp=_extends({},val,{value:val.totalTransaction});_chartConfig2.default.txOverviewChart.xAxis[0].data.push(intl.formatDate(val.date));_chartConfig2.default.txOverviewChart.series[0].data.push(temp);});}if(data&&data.length===0){_chartConfig2.default.txOverviewChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.txOverviewChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initLine(this.state.lineId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initLine(this.state.lineId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.lineId,style:this.props.style}));}}]);return LineReactTx;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(LineReactTx));\n\n/***/ }),\n\n/***/ 1626:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(1448);\n\n__webpack_require__(1288);\n\n__webpack_require__(1289);\n\n__webpack_require__(1628);\n\n__webpack_require__(1629);\n\n__webpack_require__(1630);\n\n__webpack_require__(1631);\n\n__webpack_require__(1450);\n\n__webpack_require__(1451);\n\n/***/ }),\n\n/***/ 1627:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar numberUtil = __webpack_require__(27);\n\nvar helper = __webpack_require__(1366);\n\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n    // Process series data\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1628:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomModel = __webpack_require__(1288);\n\nvar SliderZoomModel = DataZoomModel.extend({\n  type: 'dataZoom.slider',\n  layoutMode: 'box',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    show: true,\n    // ph => placeholder. Using placehoder here because\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    // Default align to grid rect.\n    top: 'ph',\n    // Default align to grid rect.\n    width: 'ph',\n    // Default align to grid rect.\n    height: 'ph',\n    // Default align to grid rect.\n    left: null,\n    // Default align to grid rect.\n    bottom: null,\n    // Default align to grid rect.\n    backgroundColor: 'rgba(47,69,84,0)',\n    // Background of slider zoom component.\n    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n    // highest priority, remain for compatibility of\n    // previous version, but not recommended any more.\n    dataBackground: {\n      lineStyle: {\n        color: '#2f4554',\n        width: 0.5,\n        opacity: 0.3\n      },\n      areaStyle: {\n        color: 'rgba(47,69,84,0.3)',\n        opacity: 0.3\n      }\n    },\n    borderColor: '#ddd',\n    // border color of the box. For compatibility,\n    // if dataBackgroundColor is set, borderColor\n    // is ignored.\n    fillerColor: 'rgba(167,183,204,0.4)',\n    // Color of selected area.\n    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#a7b7cc'\n    },\n    labelPrecision: null,\n    labelFormatter: null,\n    showDetail: true,\n    showDataShadow: 'auto',\n    // Default auto decision.\n    realtime: true,\n    zoomLock: false,\n    // Whether disable zoom.\n    textStyle: {\n      color: '#333'\n    }\n  }\n});\nvar _default = SliderZoomModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1629:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar eventTool = __webpack_require__(93);\n\nvar graphic = __webpack_require__(22);\n\nvar throttle = __webpack_require__(148);\n\nvar DataZoomView = __webpack_require__(1289);\n\nvar numberUtil = __webpack_require__(27);\n\nvar layout = __webpack_require__(57);\n\nvar sliderMove = __webpack_require__(1367);\n\nvar Rect = graphic.Rect;\nvar linearMap = numberUtil.linearMap;\nvar asc = numberUtil.asc;\nvar bind = zrUtil.bind;\nvar each = zrUtil.each; // Constants\n\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar SliderZoomView = DataZoomView.extend({\n  type: 'dataZoom.slider',\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._displayables = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this._orient;\n    /**\n     * [0, 100]\n     * @private\n     */\n\n    this._range;\n    /**\n     * [coord of the first handle, coord of the second handle]\n     * @private\n     */\n\n    this._handleEnds;\n    /**\n     * [length, thick]\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this._size;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleWidth;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleHeight;\n    /**\n     * @private\n     */\n\n    this._location;\n    /**\n     * @private\n     */\n\n    this._dragging;\n    /**\n     * @private\n     */\n\n    this._dataShadowInfo;\n    this.api = api;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    SliderZoomView.superApply(this, 'render', arguments);\n    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.get('orient');\n\n    if (this.dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    } // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\n\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n\n    this._updateView();\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    SliderZoomView.superApply(this, 'remove', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    SliderZoomView.superApply(this, 'dispose', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n  _buildView: function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    this._resetLocation();\n\n    this._resetInterval();\n\n    var barGroup = this._displayables.barGroup = new graphic.Group();\n\n    this._renderBackground();\n\n    this._renderHandle();\n\n    this._renderDataShadow();\n\n    thisGroup.add(barGroup);\n\n    this._positionGroup();\n  },\n\n  /**\n   * @private\n   */\n  _resetLocation: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api; // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n\n    var coordRect = this._findCoordRect();\n\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }; // Default align by coordinate system rect.\n\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      // vertical\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    }; // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n\n    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.\n\n    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  },\n\n  /**\n   * @private\n   */\n  _positionGroup: function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient; // Just use the first axis to determine mapping.\n\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var barGroup = this._displayables.barGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.\n\n    barGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scale: otherAxisInverse ? [1, 1] : [1, -1]\n    } : orient === HORIZONTAL && inverse ? {\n      scale: otherAxisInverse ? [-1, 1] : [-1, -1]\n    } : orient === VERTICAL && !inverse ? {\n      scale: otherAxisInverse ? [1, -1] : [1, 1],\n      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.\n\n    } : {\n      scale: otherAxisInverse ? [-1, -1] : [-1, 1],\n      rotation: Math.PI / 2\n    }); // Position barGroup\n\n    var rect = thisGroup.getBoundingRect([barGroup]);\n    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n  },\n\n  /**\n   * @private\n   */\n  _getViewExtent: function () {\n    return [0, this._size[0]];\n  },\n  _renderBackground: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.barGroup;\n    barGroup.add(new Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    })); // Click panel, over shadow, below handles.\n\n    barGroup.add(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: zrUtil.bind(this._onClickPanelClick, this)\n    }));\n  },\n  _renderDataShadow: function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n    if (!info) {\n      return;\n    }\n\n    var size = this._size;\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n\n    if (otherDim == null) {\n      return;\n    }\n\n    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.\n\n    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];\n    var otherShadowExtent = [0, size[1]];\n    var thisShadowExtent = [0, size[0]];\n    var areaPoints = [[size[0], 0], [0, 0]];\n    var linePoints = [];\n    var step = thisShadowExtent[1] / (data.count() - 1);\n    var thisCoord = 0; // Optimize for large data shadow\n\n    var stride = Math.round(data.count() / size[0]);\n    var lastIsEmpty;\n    data.each([otherDim], function (value, index) {\n      if (stride > 0 && index % stride) {\n        thisCoord += step;\n        return;\n      } // FIXME\n      // Should consider axis.min/axis.max when drawing dataShadow.\n      // FIXME\n      // list\n\n\n      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.\n\n      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.\n\n      if (isEmpty && !lastIsEmpty && index) {\n        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n        linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n      } else if (!isEmpty && lastIsEmpty) {\n        areaPoints.push([thisCoord, 0]);\n        linePoints.push([thisCoord, 0]);\n      }\n\n      areaPoints.push([thisCoord, otherCoord]);\n      linePoints.push([thisCoord, otherCoord]);\n      thisCoord += step;\n      lastIsEmpty = isEmpty;\n    });\n    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\n    this._displayables.barGroup.add(new graphic.Polygon({\n      shape: {\n        points: areaPoints\n      },\n      style: zrUtil.defaults({\n        fill: dataZoomModel.get('dataBackgroundColor')\n      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),\n      silent: true,\n      z2: -20\n    }));\n\n    this._displayables.barGroup.add(new graphic.Polyline({\n      shape: {\n        points: linePoints\n      },\n      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n      silent: true,\n      z2: -19\n    }));\n  },\n  _prepareDataShadowInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n\n    if (showDataShadow === false) {\n      return;\n    } // Find a representative series.\n\n\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();\n      zrUtil.each(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n\n        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n\n        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n        var otherDim = getOtherDim(dimNames.name);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n\n        otherDim = seriesModel.getData().mapDimension(otherDim);\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: dimNames.name,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  },\n  _renderHandle: function () {\n    var displaybles = this._displayables;\n    var handles = displaybles.handles = [];\n    var handleLabels = displaybles.handleLabels = [];\n    var barGroup = this._displayables.barGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    barGroup.add(displaybles.filler = new Rect({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: bind(this._onDragMove, this, 'all'),\n      onmousemove: function (e) {\n        // Fot mobile devicem, prevent screen slider on the button.\n        eventTool.stop(e.event);\n      },\n      ondragstart: bind(this._showDataInfo, this, true),\n      ondragend: bind(this._onDragEnd, this),\n      onmouseover: bind(this._showDataInfo, this, true),\n      onmouseout: bind(this._showDataInfo, this, false),\n      style: {\n        fill: dataZoomModel.get('fillerColor'),\n        textPosition: 'inside'\n      }\n    })); // Frame border.\n\n    barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    })));\n    each([0, 1], function (handleIndex) {\n      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: bind(this._onDragMove, this, handleIndex),\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        ondragend: bind(this._onDragEnd, this),\n        onmouseover: bind(this._showDataInfo, this, true),\n        onmouseout: bind(this._showDataInfo, this, false)\n      }, {\n        x: -1,\n        y: 0,\n        width: 2,\n        height: 2\n      });\n      var bRect = path.getBoundingRect();\n      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version\n\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n\n      barGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.textStyleModel;\n      this.group.add(handleLabels[handleIndex] = new graphic.Text({\n        silent: true,\n        invisible: true,\n        style: {\n          x: 0,\n          y: 0,\n          text: '',\n          textVerticalAlign: 'middle',\n          textAlign: 'center',\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        },\n        z2: 10\n      }));\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetInterval: function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n\n    var viewExtent = this._getViewExtent();\n\n    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];\n  },\n\n  /**\n   * @private\n   * @param {(number|string)} handleIndex 0 or 1 or 'all'\n   * @param {number} delta\n   */\n  _updateInterval: function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n\n    var viewExtend = this._getViewExtent();\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);\n  },\n\n  /**\n   * @private\n   */\n  _updateView: function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = asc(handleEnds.slice());\n    var size = this._size;\n    each([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scale: [handleHeight / 2, handleHeight / 2],\n        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n      });\n    }, this); // Filler\n\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n\n    this._updateDataInfo(nonRealtime);\n  },\n\n  /**\n   * @private\n   */\n  _updateDataInfo: function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', '']; // FIXME\n    // dateformatterautoformatterec2 date.getAutoFormatter\n\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n\n    var orderedHandleEnds = asc(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        textAlign: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _formatLabel: function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n\n    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  },\n\n  /**\n   * @private\n   * @param {boolean} showOrHide true: show, false: hide\n   */\n  _showDataInfo: function (showOrHide) {\n    // Always show when drgging.\n    showOrHide = this._dragging || showOrHide;\n    var handleLabels = this._displayables.handleLabels;\n    handleLabels[0].attr('invisible', !showOrHide);\n    handleLabels[1].attr('invisible', !showOrHide);\n  },\n  _onDragMove: function (handleIndex, dx, dy) {\n    this._dragging = true; // Transform dx, dy to bar coordination.\n\n    var barTransform = this._displayables.barGroup.getLocalTransform();\n\n    var vertex = graphic.applyTransform([dx, dy], barTransform, true);\n\n    this._updateInterval(handleIndex, vertex[0]);\n\n    var realtime = this.dataZoomModel.get('realtime');\n\n    this._updateView(!realtime);\n\n    realtime && this._dispatchZoomAction();\n  },\n  _onDragEnd: function () {\n    this._dragging = false;\n\n    this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when\n    // drag end will cause the whole view rerender, which is unnecessary.\n\n\n    var realtime = this.dataZoomModel.get('realtime');\n    !realtime && this._dispatchZoomAction();\n  },\n  _onClickPanelClick: function (e) {\n    var size = this._size;\n\n    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n    this._updateInterval('all', localPoint[0] - center);\n\n    this._updateView();\n\n    this._dispatchZoomAction();\n  },\n\n  /**\n   * This action will be throttled.\n   * @private\n   */\n  _dispatchZoomAction: function () {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      start: range[0],\n      end: range[1]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _findCoordRect: function () {\n    // Find the grid coresponding to the first axis referred by dataZoom.\n    var rect;\n    each(this.getTargetCoordInfo(), function (coordInfoList) {\n      if (!rect && coordInfoList.length) {\n        var coordSys = coordInfoList[0].model.coordinateSystem;\n        rect = coordSys.getRect && coordSys.getRect();\n      }\n    });\n\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n\n    return rect;\n  }\n});\n\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // getOtherAxis\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\n\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nvar _default = SliderZoomView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1630:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomModel = __webpack_require__(1288);\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    disabled: false,\n    // Whether disable this inside zoom.\n    zoomLock: false,\n    // Whether disable zoom but only pan.\n    zoomOnMouseWheel: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    moveOnMouseMove: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    preventDefaultMouseMove: true\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1631:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar DataZoomView = __webpack_require__(1289);\n\nvar sliderMove = __webpack_require__(1367);\n\nvar roams = __webpack_require__(1632);\n\nvar bind = zrUtil.bind;\nvar InsideZoomView = DataZoomView.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * 'throttle' is used in this.dispatchAction, so we save range\n     * to avoid missing some 'pan' info.\n     * @private\n     * @type {Array.<number>}\n     */\n    this._range;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched\n    // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n    // info will be missed because of 'throttle' of this.dispatchAction.\n\n    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n      this._range = dataZoomModel.getPercentRange();\n    } // Reset controllers.\n\n\n    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n        return roams.generateCoordId(coordInfo.model);\n      });\n      zrUtil.each(coordInfoList, function (coordInfo) {\n        var coordModel = coordInfo.model;\n        var dataZoomOption = dataZoomModel.option;\n        roams.register(api, {\n          coordId: roams.generateCoordId(coordModel),\n          allCoordIds: allCoordIds,\n          containsPoint: function (e, x, y) {\n            return coordModel.coordinateSystem.containPoint([x, y]);\n          },\n          dataZoomId: dataZoomModel.id,\n          throttleRate: dataZoomModel.get('throttle', true),\n          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),\n          zoomLock: dataZoomOption.zoomLock,\n          disabled: dataZoomOption.disabled,\n          roamControllerOpt: {\n            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,\n            moveOnMouseMove: dataZoomOption.moveOnMouseMove,\n            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove\n          }\n        });\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    roams.unregister(this.api, this.dataZoomModel.id);\n    InsideZoomView.superApply(this, 'dispose', arguments);\n    this._range = null;\n  },\n\n  /**\n   * @private\n   */\n  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);\n    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n    sliderMove(percentDelta, range, [0, 100], 'all');\n    return this._range = range;\n  },\n\n  /**\n   * @private\n   */\n  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    scale = Math.max(1 / scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.\n\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    return this._range = range;\n  }\n});\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  }\n};\nvar _default = InsideZoomView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1632:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar RoamController = __webpack_require__(1633);\n\nvar throttleUtil = __webpack_require__(148);\n\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\nvar curry = zrUtil.curry;\nvar ATTR = '\\0_ec_dataZoom_roams';\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} dataZoomInfo\n * @param {string} dataZoomInfo.coordId\n * @param {Function} dataZoomInfo.containsPoint\n * @param {Array.<string>} dataZoomInfo.allCoordIds\n * @param {string} dataZoomInfo.dataZoomId\n * @param {number} dataZoomInfo.throttleRate\n * @param {Function} dataZoomInfo.panGetRange\n * @param {Function} dataZoomInfo.zoomGetRange\n * @param {boolean} [dataZoomInfo.zoomLock]\n * @param {boolean} [dataZoomInfo.disabled]\n */\n\nfunction register(api, dataZoomInfo) {\n  var store = giveStore(api);\n  var theDataZoomId = dataZoomInfo.dataZoomId;\n  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.\n  // Avoid memory leak, dispose all not-used-registered.\n\n  zrUtil.each(store, function (record, coordId) {\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {\n      delete dataZoomInfos[theDataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n  var record = store[theCoordId]; // Create if needed.\n\n  if (!record) {\n    record = store[theCoordId] = {\n      coordId: theCoordId,\n      dataZoomInfos: {},\n      count: 0\n    };\n    record.controller = createController(api, record);\n    record.dispatchAction = zrUtil.curry(dispatchAction, api);\n  } // Update reference of dataZoom.\n\n\n  !record.dataZoomInfos[theDataZoomId] && record.count++;\n  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n  var controllerParams = mergeControllerParams(record.dataZoomInfos);\n  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.\n\n  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.\n\n  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');\n}\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {string} dataZoomId\n */\n\n\nfunction unregister(api, dataZoomId) {\n  var store = giveStore(api);\n  zrUtil.each(store, function (record) {\n    record.controller.dispose();\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[dataZoomId]) {\n      delete dataZoomInfos[dataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n}\n/**\n * @public\n */\n\n\nfunction shouldRecordRange(payload, dataZoomId) {\n  if (payload && payload.type === 'dataZoom' && payload.batch) {\n    for (var i = 0, len = payload.batch.length; i < len; i++) {\n      if (payload.batch[i].dataZoomId === dataZoomId) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @public\n */\n\n\nfunction generateCoordId(coordModel) {\n  return coordModel.type + '\\0_' + coordModel.id;\n}\n/**\n * Key: coordId, value: {dataZoomInfos: [], count, controller}\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(api) {\n  // Mount store on zrender instance, so that we do not\n  // need to worry about dispose.\n  var zr = api.getZr();\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n\nfunction createController(api, newRecord) {\n  var controller = new RoamController(api.getZr());\n  controller.on('pan', curry(onPan, newRecord));\n  controller.on('zoom', curry(onZoom, newRecord));\n  return controller;\n}\n\nfunction cleanStore(store) {\n  zrUtil.each(store, function (record, coordId) {\n    if (!record.count) {\n      record.controller.dispose();\n      delete store[coordId];\n    }\n  });\n}\n\nfunction onPan(record, dx, dy, oldX, oldY, newX, newY) {\n  wrapAndDispatch(record, function (info) {\n    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n  });\n}\n\nfunction onZoom(record, scale, mouseX, mouseY) {\n  wrapAndDispatch(record, function (info) {\n    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n  });\n}\n\nfunction wrapAndDispatch(record, getRange) {\n  var batch = [];\n  zrUtil.each(record.dataZoomInfos, function (info) {\n    var range = getRange(info);\n    !info.disabled && range && batch.push({\n      dataZoomId: info.dataZoomId,\n      start: range[0],\n      end: range[1]\n    });\n  });\n  record.dispatchAction(batch);\n}\n/**\n * This action will be throttled.\n */\n\n\nfunction dispatchAction(api, batch) {\n  api.dispatchAction({\n    type: 'dataZoom',\n    batch: batch\n  });\n}\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\n\n\nfunction mergeControllerParams(dataZoomInfos) {\n  var controlType;\n  var opt = {}; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated\n  // as string, it is probably revert to reserved word by compress tool. See #7411.\n\n  var prefix = 'type_';\n  var typePriority = {\n    'type_true': 2,\n    'type_move': 1,\n    'type_false': 0,\n    'type_undefined': -1\n  };\n  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {\n    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;\n\n    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {\n      controlType = oneType;\n    } // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.\n\n\n    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);\n  });\n  return {\n    controlType: controlType,\n    opt: opt\n  };\n}\n\nexports.register = register;\nexports.unregister = unregister;\nexports.shouldRecordRange = shouldRecordRange;\nexports.generateCoordId = generateCoordId;\n\n/***/ }),\n\n/***/ 1633:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar Eventful = __webpack_require__(94);\n\nvar eventTool = __webpack_require__(93);\n\nvar interactionMutex = __webpack_require__(1449);\n\n/**\n * @alias module:echarts/component/helper/RoamController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\nfunction RoamController(zr) {\n  /**\n   * @type {Function}\n   */\n  this.pointerChecker;\n  /**\n   * @type {module:zrender}\n   */\n\n  this._zr = zr;\n  /**\n   * @type {Object}\n   */\n\n  this._opt = {}; // Avoid two roamController bind the same handler\n\n  var bind = zrUtil.bind;\n  var mousedownHandler = bind(mousedown, this);\n  var mousemoveHandler = bind(mousemove, this);\n  var mouseupHandler = bind(mouseup, this);\n  var mousewheelHandler = bind(mousewheel, this);\n  var pinchHandler = bind(pinch, this);\n  Eventful.call(this);\n  /**\n   * @param {Function} pointerChecker\n   *                   input: x, y\n   *                   output: boolean\n   */\n\n  this.setPointerChecker = function (pointerChecker) {\n    this.pointerChecker = pointerChecker;\n  };\n  /**\n   * Notice: only enable needed types. For example, if 'zoom'\n   * is not needed, 'zoom' should not be enabled, otherwise\n   * default mousewheel behaviour (scroll page) will be disabled.\n   *\n   * @param  {boolean|string} [controlType=true] Specify the control type,\n   *                          which can be null/undefined or true/false\n   *                          or 'pan/move' or 'zoom'/'scale'\n   * @param {Object} [opt]\n   * @param {Object} [opt.zoomOnMouseWheel=true]\n   * @param {Object} [opt.moveOnMouseMove=true]\n   * @param {Object} [opt.preventDefaultMouseMove=true] When pan.\n   */\n\n\n  this.enable = function (controlType, opt) {\n    // Disable previous first\n    this.disable();\n    this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {\n      zoomOnMouseWheel: true,\n      moveOnMouseMove: true,\n      preventDefaultMouseMove: true\n    });\n\n    if (controlType == null) {\n      controlType = true;\n    }\n\n    if (controlType === true || controlType === 'move' || controlType === 'pan') {\n      zr.on('mousedown', mousedownHandler);\n      zr.on('mousemove', mousemoveHandler);\n      zr.on('mouseup', mouseupHandler);\n    }\n\n    if (controlType === true || controlType === 'scale' || controlType === 'zoom') {\n      zr.on('mousewheel', mousewheelHandler);\n      zr.on('pinch', pinchHandler);\n    }\n  };\n\n  this.disable = function () {\n    zr.off('mousedown', mousedownHandler);\n    zr.off('mousemove', mousemoveHandler);\n    zr.off('mouseup', mouseupHandler);\n    zr.off('mousewheel', mousewheelHandler);\n    zr.off('pinch', pinchHandler);\n  };\n\n  this.dispose = this.disable;\n\n  this.isDragging = function () {\n    return this._dragging;\n  };\n\n  this.isPinching = function () {\n    return this._pinching;\n  };\n}\n\nzrUtil.mixin(RoamController, Eventful);\n\nfunction mousedown(e) {\n  if (eventTool.notLeftMouse(e) || e.target && e.target.draggable) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY; // Only check on mosedown, but not mousemove.\n  // Mouse can be out of target when mouse moving.\n\n  if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n    this._x = x;\n    this._y = y;\n    this._dragging = true;\n  }\n}\n\nfunction mousemove(e) {\n  if (eventTool.notLeftMouse(e) || !checkKeyBinding(this, 'moveOnMouseMove', e) || !this._dragging || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY;\n  var oldX = this._x;\n  var oldY = this._y;\n  var dx = x - oldX;\n  var dy = y - oldY;\n  this._x = x;\n  this._y = y;\n  this._opt.preventDefaultMouseMove && eventTool.stop(e.event);\n  this.trigger('pan', dx, dy, oldX, oldY, x, y);\n}\n\nfunction mouseup(e) {\n  if (!eventTool.notLeftMouse(e)) {\n    this._dragging = false;\n  }\n}\n\nfunction mousewheel(e) {\n  // wheelDelta maybe -0 in chrome mac.\n  if (!checkKeyBinding(this, 'zoomOnMouseWheel', e) || e.wheelDelta === 0) {\n    return;\n  } // Convenience:\n  // Mac and VM Windows on Mac: scroll up: zoom out.\n  // Windows: scroll up: zoom in.\n\n\n  var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n  zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n}\n\nfunction pinch(e) {\n  if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n  zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n}\n\nfunction zoom(e, zoomDelta, zoomX, zoomY) {\n  if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {\n    // When mouse is out of roamController rect,\n    // default befavoius should not be be disabled, otherwise\n    // page sliding is disabled, contrary to expectation.\n    eventTool.stop(e.event);\n    this.trigger('zoom', zoomDelta, zoomX, zoomY);\n  }\n}\n\nfunction checkKeyBinding(roamController, prop, e) {\n  var setting = roamController._opt[prop];\n  return setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);\n}\n\nvar _default = RoamController;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1634:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(1635);\n\n__webpack_require__(1636);\n\n__webpack_require__(1637);\n\n__webpack_require__(1638);\n\n__webpack_require__(1639);\n\n__webpack_require__(1640);\n\n__webpack_require__(1648);\n\n/***/ }),\n\n/***/ 1635:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar featureManager = __webpack_require__(1249);\n\nvar ToolboxModel = echarts.extendComponentModel({\n  type: 'toolbox',\n  layoutMode: {\n    type: 'box',\n    ignoreSize: true\n  },\n  mergeDefaultAndTheme: function (option) {\n    ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n    zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n      var Feature = featureManager.get(featureName);\n      Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n    });\n  },\n  defaultOption: {\n    show: true,\n    z: 6,\n    zlevel: 0,\n    orient: 'horizontal',\n    left: 'right',\n    top: 'top',\n    // right\n    // bottom\n    backgroundColor: 'transparent',\n    borderColor: '#ccc',\n    borderRadius: 0,\n    borderWidth: 0,\n    padding: 5,\n    itemSize: 15,\n    itemGap: 8,\n    showTitle: true,\n    iconStyle: {\n      borderColor: '#666',\n      color: 'none'\n    },\n    emphasis: {\n      iconStyle: {\n        borderColor: '#3E98C5'\n      } // textStyle: {},\n      // feature\n\n    }\n  }\n});\nvar _default = ToolboxModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1636:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar textContain = __webpack_require__(74);\n\nvar featureManager = __webpack_require__(1249);\n\nvar graphic = __webpack_require__(22);\n\nvar Model = __webpack_require__(45);\n\nvar DataDiffer = __webpack_require__(437);\n\nvar listComponentHelper = __webpack_require__(1290);\n\nvar _default = echarts.extendComponentView({\n  type: 'toolbox',\n  render: function (toolboxModel, ecModel, api, payload) {\n    var group = this.group;\n    group.removeAll();\n\n    if (!toolboxModel.get('show')) {\n      return;\n    }\n\n    var itemSize = +toolboxModel.get('itemSize');\n    var featureOpts = toolboxModel.get('feature') || {};\n    var features = this._features || (this._features = {});\n    var featureNames = [];\n    zrUtil.each(featureOpts, function (opt, name) {\n      featureNames.push(name);\n    });\n    new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.\n\n    this._featureNames = featureNames;\n\n    function processFeature(newIndex, oldIndex) {\n      var featureName = featureNames[newIndex];\n      var oldName = featureNames[oldIndex];\n      var featureOpt = featureOpts[featureName];\n      var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n      var feature;\n\n      if (featureName && !oldName) {\n        // Create\n        if (isUserFeatureName(featureName)) {\n          feature = {\n            model: featureModel,\n            onclick: featureModel.option.onclick,\n            featureName: featureName\n          };\n        } else {\n          var Feature = featureManager.get(featureName);\n\n          if (!Feature) {\n            return;\n          }\n\n          feature = new Feature(featureModel, ecModel, api);\n        }\n\n        features[featureName] = feature;\n      } else {\n        feature = features[oldName]; // If feature does not exsit.\n\n        if (!feature) {\n          return;\n        }\n\n        feature.model = featureModel;\n        feature.ecModel = ecModel;\n        feature.api = api;\n      }\n\n      if (!featureName && oldName) {\n        feature.dispose && feature.dispose(ecModel, api);\n        return;\n      }\n\n      if (!featureModel.get('show') || feature.unusable) {\n        feature.remove && feature.remove(ecModel, api);\n        return;\n      }\n\n      createIconPaths(featureModel, feature, featureName);\n\n      featureModel.setIconStatus = function (iconName, status) {\n        var option = this.option;\n        var iconPaths = this.iconPaths;\n        option.iconStatus = option.iconStatus || {};\n        option.iconStatus[iconName] = status; // FIXME\n\n        iconPaths[iconName] && iconPaths[iconName].trigger(status);\n      };\n\n      if (feature.render) {\n        feature.render(featureModel, ecModel, api, payload);\n      }\n    }\n\n    function createIconPaths(featureModel, feature, featureName) {\n      var iconStyleModel = featureModel.getModel('iconStyle');\n      var iconStyleEmphasisModel = featureModel.getModel('emphasis.iconStyle'); // If one feature has mutiple icon. they are orginaized as\n      // {\n      //     icon: {\n      //         foo: '',\n      //         bar: ''\n      //     },\n      //     title: {\n      //         foo: '',\n      //         bar: ''\n      //     }\n      // }\n\n      var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n      var titles = featureModel.get('title') || {};\n\n      if (typeof icons === 'string') {\n        var icon = icons;\n        var title = titles;\n        icons = {};\n        titles = {};\n        icons[featureName] = icon;\n        titles[featureName] = title;\n      }\n\n      var iconPaths = featureModel.iconPaths = {};\n      zrUtil.each(icons, function (iconStr, iconName) {\n        var path = graphic.createIcon(iconStr, {}, {\n          x: -itemSize / 2,\n          y: -itemSize / 2,\n          width: itemSize,\n          height: itemSize\n        });\n        path.setStyle(iconStyleModel.getItemStyle());\n        path.hoverStyle = iconStyleEmphasisModel.getItemStyle();\n        graphic.setHoverStyle(path);\n\n        if (toolboxModel.get('showTitle')) {\n          path.__title = titles[iconName];\n          path.on('mouseover', function () {\n            // Should not reuse above hoverStyle, which might be modified.\n            var hoverStyle = iconStyleEmphasisModel.getItemStyle();\n            path.setStyle({\n              text: titles[iconName],\n              textPosition: hoverStyle.textPosition || 'bottom',\n              textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n              textAlign: hoverStyle.textAlign || 'center'\n            });\n          }).on('mouseout', function () {\n            path.setStyle({\n              textFill: null\n            });\n          });\n        }\n\n        path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n        group.add(path);\n        path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));\n        iconPaths[iconName] = path;\n      });\n    }\n\n    listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout\n    // FIXME\n\n    group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen\n\n    group.eachChild(function (icon) {\n      var titleText = icon.__title;\n      var hoverStyle = icon.hoverStyle; // May be background element\n\n      if (hoverStyle && titleText) {\n        var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));\n        var offsetX = icon.position[0] + group.position[0];\n        var offsetY = icon.position[1] + group.position[1] + itemSize;\n        var needPutOnTop = false;\n\n        if (offsetY + rect.height > api.getHeight()) {\n          hoverStyle.textPosition = 'top';\n          needPutOnTop = true;\n        }\n\n        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;\n\n        if (offsetX + rect.width / 2 > api.getWidth()) {\n          hoverStyle.textPosition = ['100%', topOffset];\n          hoverStyle.textAlign = 'right';\n        } else if (offsetX - rect.width / 2 < 0) {\n          hoverStyle.textPosition = [0, topOffset];\n          hoverStyle.textAlign = 'left';\n        }\n      }\n    });\n  },\n  updateView: function (toolboxModel, ecModel, api, payload) {\n    zrUtil.each(this._features, function (feature) {\n      feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n    });\n  },\n  // updateLayout: function (toolboxModel, ecModel, api, payload) {\n  //     zrUtil.each(this._features, function (feature) {\n  //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n  //     });\n  // },\n  remove: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.remove && feature.remove(ecModel, api);\n    });\n    this.group.removeAll();\n  },\n  dispose: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.dispose && feature.dispose(ecModel, api);\n    });\n  }\n});\n\nfunction isUserFeatureName(featureName) {\n  return featureName.indexOf('my') === 0;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1637:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar env = __webpack_require__(28);\n\nvar lang = __webpack_require__(425);\n\nvar featureManager = __webpack_require__(1249);\n\nvar saveAsImageLang = lang.toolbox.saveAsImage;\n\nfunction SaveAsImage(model) {\n  this.model = model;\n}\n\nSaveAsImage.defaultOption = {\n  show: true,\n  icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n  title: saveAsImageLang.title,\n  type: 'png',\n  // Default use option.backgroundColor\n  // backgroundColor: '#fff',\n  name: '',\n  excludeComponents: ['toolbox'],\n  pixelRatio: 1,\n  lang: saveAsImageLang.lang.slice()\n};\nSaveAsImage.prototype.unusable = !env.canvasSupported;\nvar proto = SaveAsImage.prototype;\n\nproto.onclick = function (ecModel, api) {\n  var model = this.model;\n  var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n  var $a = document.createElement('a');\n  var type = model.get('type', true) || 'png';\n  $a.download = title + '.' + type;\n  $a.target = '_blank';\n  var url = api.getConnectedDataURL({\n    type: type,\n    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',\n    excludeComponents: model.get('excludeComponents'),\n    pixelRatio: model.get('pixelRatio')\n  });\n  $a.href = url; // Chrome and Firefox\n\n  if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n    var evt = new MouseEvent('click', {\n      view: window,\n      bubbles: true,\n      cancelable: false\n    });\n    $a.dispatchEvent(evt);\n  } // IE\n  else {\n      if (window.navigator.msSaveOrOpenBlob) {\n        var bstr = atob(url.split(',')[1]);\n        var n = bstr.length;\n        var u8arr = new Uint8Array(n);\n\n        while (n--) {\n          u8arr[n] = bstr.charCodeAt(n);\n        }\n\n        var blob = new Blob([u8arr]);\n        window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);\n      } else {\n        var lang = model.get('lang');\n        var html = '' + '<body style=\"margin:0;\">' + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + (lang && lang[0] || '') + '\" />' + '</body>';\n        var tab = window.open();\n        tab.document.write(html);\n      }\n    }\n};\n\nfeatureManager.register('saveAsImage', SaveAsImage);\nvar _default = SaveAsImage;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1638:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar lang = __webpack_require__(425);\n\nvar featureManager = __webpack_require__(1249);\n\nvar magicTypeLang = lang.toolbox.magicType;\n\nfunction MagicType(model) {\n  this.model = model;\n}\n\nMagicType.defaultOption = {\n  show: true,\n  type: [],\n  // Icon group\n  icon: {\n    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',\n    // jshint ignore:line\n    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n  },\n  // `line`, `bar`, `stack`, `tiled`\n  title: zrUtil.clone(magicTypeLang.title),\n  option: {},\n  seriesIndex: {}\n};\nvar proto = MagicType.prototype;\n\nproto.getIcons = function () {\n  var model = this.model;\n  var availableIcons = model.get('icon');\n  var icons = {};\n  zrUtil.each(model.get('type'), function (type) {\n    if (availableIcons[type]) {\n      icons[type] = availableIcons[type];\n    }\n  });\n  return icons;\n};\n\nvar seriesOptGenreator = {\n  'line': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'line',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.line') || {}, true);\n    }\n  },\n  'bar': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'bar',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.bar') || {}, true);\n    }\n  },\n  'stack': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: '__ec_magicType_stack__'\n      }, model.get('option.stack') || {}, true);\n    }\n  },\n  'tiled': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: ''\n      }, model.get('option.tiled') || {}, true);\n    }\n  }\n};\nvar radioTypes = [['line', 'bar'], ['stack', 'tiled']];\n\nproto.onclick = function (ecModel, api, type) {\n  var model = this.model;\n  var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType\n\n  if (!seriesOptGenreator[type]) {\n    return;\n  }\n\n  var newOption = {\n    series: []\n  };\n\n  var generateNewSeriesTypes = function (seriesModel) {\n    var seriesType = seriesModel.subType;\n    var seriesId = seriesModel.id;\n    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);\n\n    if (newSeriesOpt) {\n      // PENDING If merge original option?\n      zrUtil.defaults(newSeriesOpt, seriesModel.option);\n      newOption.series.push(newSeriesOpt);\n    } // Modify boundaryGap\n\n\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n      if (categoryAxis) {\n        var axisDim = categoryAxis.dim;\n        var axisType = axisDim + 'Axis';\n        var axisModel = ecModel.queryComponents({\n          mainType: axisType,\n          index: seriesModel.get(name + 'Index'),\n          id: seriesModel.get(name + 'Id')\n        })[0];\n        var axisIndex = axisModel.componentIndex;\n        newOption[axisType] = newOption[axisType] || [];\n\n        for (var i = 0; i <= axisIndex; i++) {\n          newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n        }\n\n        newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n      }\n    }\n  };\n\n  zrUtil.each(radioTypes, function (radio) {\n    if (zrUtil.indexOf(radio, type) >= 0) {\n      zrUtil.each(radio, function (item) {\n        model.setIconStatus(item, 'normal');\n      });\n    }\n  });\n  model.setIconStatus(type, 'emphasis');\n  ecModel.eachComponent({\n    mainType: 'series',\n    query: seriesIndex == null ? null : {\n      seriesIndex: seriesIndex\n    }\n  }, generateNewSeriesTypes);\n  api.dispatchAction({\n    type: 'changeMagicType',\n    currentType: type,\n    newOption: newOption\n  });\n};\n\necharts.registerAction({\n  type: 'changeMagicType',\n  event: 'magicTypeChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.mergeOption(payload.newOption);\n});\nfeatureManager.register('magicType', MagicType);\nvar _default = MagicType;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1639:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar eventTool = __webpack_require__(93);\n\nvar lang = __webpack_require__(425);\n\nvar featureManager = __webpack_require__(1249);\n\nvar dataViewLang = lang.toolbox.dataView;\nvar BLOCK_SPLITER = new Array(60).join('-');\nvar ITEM_SPLITER = '\\t';\n/**\n * Group series into two types\n *  1. on category axis, like line, bar\n *  2. others, like scatter, pie\n * @param {module:echarts/model/Global} ecModel\n * @return {Object}\n * @inner\n */\n\nfunction groupSeries(ecModel) {\n  var seriesGroupByCategoryAxis = {};\n  var otherSeries = [];\n  var meta = [];\n  ecModel.eachRawSeries(function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n      var baseAxis = coordSys.getBaseAxis();\n\n      if (baseAxis.type === 'category') {\n        var key = baseAxis.dim + '_' + baseAxis.index;\n\n        if (!seriesGroupByCategoryAxis[key]) {\n          seriesGroupByCategoryAxis[key] = {\n            categoryAxis: baseAxis,\n            valueAxis: coordSys.getOtherAxis(baseAxis),\n            series: []\n          };\n          meta.push({\n            axisDim: baseAxis.dim,\n            axisIndex: baseAxis.index\n          });\n        }\n\n        seriesGroupByCategoryAxis[key].series.push(seriesModel);\n      } else {\n        otherSeries.push(seriesModel);\n      }\n    } else {\n      otherSeries.push(seriesModel);\n    }\n  });\n  return {\n    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n    other: otherSeries,\n    meta: meta\n  };\n}\n/**\n * Assemble content of series on cateogory axis\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleSeriesWithCategoryAxis(series) {\n  var tables = [];\n  zrUtil.each(series, function (group, key) {\n    var categoryAxis = group.categoryAxis;\n    var valueAxis = group.valueAxis;\n    var valueAxisDim = valueAxis.dim;\n    var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n      return series.name;\n    }));\n    var columns = [categoryAxis.model.getCategories()];\n    zrUtil.each(group.series, function (series) {\n      columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n        return val;\n      }));\n    }); // Assemble table content\n\n    var lines = [headers.join(ITEM_SPLITER)];\n\n    for (var i = 0; i < columns[0].length; i++) {\n      var items = [];\n\n      for (var j = 0; j < columns.length; j++) {\n        items.push(columns[j][i]);\n      }\n\n      lines.push(items.join(ITEM_SPLITER));\n    }\n\n    tables.push(lines.join('\\n'));\n  });\n  return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * Assemble content of other series\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleOtherSeries(series) {\n  return zrUtil.map(series, function (series) {\n    var data = series.getRawData();\n    var lines = [series.name];\n    var vals = [];\n    data.each(data.dimensions, function () {\n      var argLen = arguments.length;\n      var dataIndex = arguments[argLen - 1];\n      var name = data.getName(dataIndex);\n\n      for (var i = 0; i < argLen - 1; i++) {\n        vals[i] = arguments[i];\n      }\n\n      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));\n    });\n    return lines.join('\\n');\n  }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * @param {module:echarts/model/Global}\n * @return {Object}\n * @inner\n */\n\n\nfunction getContentFromModel(ecModel) {\n  var result = groupSeries(ecModel);\n  return {\n    value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {\n      return str.replace(/[\\n\\t\\s]/g, '');\n    }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n    meta: result.meta\n  };\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n}\n/**\n * If a block is tsv format\n */\n\n\nfunction isTSVFormat(block) {\n  // Simple method to find out if a block is tsv format\n  var firstLine = block.slice(0, block.indexOf('\\n'));\n\n  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n    return true;\n  }\n}\n\nvar itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n/**\n * @param {string} tsv\n * @return {Object}\n */\n\nfunction parseTSVContents(tsv) {\n  var tsvLines = tsv.split(/\\n+/g);\n  var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n  var categories = [];\n  var series = zrUtil.map(headers, function (header) {\n    return {\n      name: header,\n      data: []\n    };\n  });\n\n  for (var i = 0; i < tsvLines.length; i++) {\n    var items = trim(tsvLines[i]).split(itemSplitRegex);\n    categories.push(items.shift());\n\n    for (var j = 0; j < items.length; j++) {\n      series[j] && (series[j].data[i] = items[j]);\n    }\n  }\n\n  return {\n    series: series,\n    categories: categories\n  };\n}\n/**\n * @param {string} str\n * @return {Array.<Object>}\n * @inner\n */\n\n\nfunction parseListContents(str) {\n  var lines = str.split(/\\n+/g);\n  var seriesName = trim(lines.shift());\n  var data = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    var items = trim(lines[i]).split(itemSplitRegex);\n    var name = '';\n    var value;\n    var hasName = false;\n\n    if (isNaN(items[0])) {\n      // First item is name\n      hasName = true;\n      name = items[0];\n      items = items.slice(1);\n      data[i] = {\n        name: name,\n        value: []\n      };\n      value = data[i].value;\n    } else {\n      value = data[i] = [];\n    }\n\n    for (var j = 0; j < items.length; j++) {\n      value.push(+items[j]);\n    }\n\n    if (value.length === 1) {\n      hasName ? data[i].value = value[0] : data[i] = value[0];\n    }\n  }\n\n  return {\n    name: seriesName,\n    data: data\n  };\n}\n/**\n * @param {string} str\n * @param {Array.<Object>} blockMetaList\n * @return {Object}\n * @inner\n */\n\n\nfunction parseContents(str, blockMetaList) {\n  var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n  var newOption = {\n    series: []\n  };\n  zrUtil.each(blocks, function (block, idx) {\n    if (isTSVFormat(block)) {\n      var result = parseTSVContents(block);\n      var blockMeta = blockMetaList[idx];\n      var axisKey = blockMeta.axisDim + 'Axis';\n\n      if (blockMeta) {\n        newOption[axisKey] = newOption[axisKey] || [];\n        newOption[axisKey][blockMeta.axisIndex] = {\n          data: result.categories\n        };\n        newOption.series = newOption.series.concat(result.series);\n      }\n    } else {\n      var result = parseListContents(block);\n      newOption.series.push(result);\n    }\n  });\n  return newOption;\n}\n/**\n * @alias {module:echarts/component/toolbox/feature/DataView}\n * @constructor\n * @param {module:echarts/model/Model} model\n */\n\n\nfunction DataView(model) {\n  this._dom = null;\n  this.model = model;\n}\n\nDataView.defaultOption = {\n  show: true,\n  readOnly: false,\n  optionToContent: null,\n  contentToOption: null,\n  icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n  title: zrUtil.clone(dataViewLang.title),\n  lang: zrUtil.clone(dataViewLang.lang),\n  backgroundColor: '#fff',\n  textColor: '#000',\n  textareaColor: '#fff',\n  textareaBorderColor: '#333',\n  buttonColor: '#c23531',\n  buttonTextColor: '#fff'\n};\n\nDataView.prototype.onclick = function (ecModel, api) {\n  var container = api.getDom();\n  var model = this.model;\n\n  if (this._dom) {\n    container.removeChild(this._dom);\n  }\n\n  var root = document.createElement('div');\n  root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n  root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements\n\n  var header = document.createElement('h4');\n  var lang = model.get('lang') || [];\n  header.innerHTML = lang[0] || model.get('title');\n  header.style.cssText = 'margin: 10px 20px;';\n  header.style.color = model.get('textColor');\n  var viewMain = document.createElement('div');\n  var textarea = document.createElement('textarea');\n  viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n  var optionToContent = model.get('optionToContent');\n  var contentToOption = model.get('contentToOption');\n  var result = getContentFromModel(ecModel);\n\n  if (typeof optionToContent === 'function') {\n    var htmlOrDom = optionToContent(api.getOption());\n\n    if (typeof htmlOrDom === 'string') {\n      viewMain.innerHTML = htmlOrDom;\n    } else if (zrUtil.isDom(htmlOrDom)) {\n      viewMain.appendChild(htmlOrDom);\n    }\n  } else {\n    // Use default textarea\n    viewMain.appendChild(textarea);\n    textarea.readOnly = model.get('readOnly');\n    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n    textarea.style.color = model.get('textColor');\n    textarea.style.borderColor = model.get('textareaBorderColor');\n    textarea.style.backgroundColor = model.get('textareaColor');\n    textarea.value = result.value;\n  }\n\n  var blockMetaList = result.meta;\n  var buttonContainer = document.createElement('div');\n  buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n  var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n  var closeButton = document.createElement('div');\n  var refreshButton = document.createElement('div');\n  buttonStyle += ';background-color:' + model.get('buttonColor');\n  buttonStyle += ';color:' + model.get('buttonTextColor');\n  var self = this;\n\n  function close() {\n    container.removeChild(root);\n    self._dom = null;\n  }\n\n  eventTool.addEventListener(closeButton, 'click', close);\n  eventTool.addEventListener(refreshButton, 'click', function () {\n    var newOption;\n\n    try {\n      if (typeof contentToOption === 'function') {\n        newOption = contentToOption(viewMain, api.getOption());\n      } else {\n        newOption = parseContents(textarea.value, blockMetaList);\n      }\n    } catch (e) {\n      close();\n      throw new Error('Data view format error ' + e);\n    }\n\n    if (newOption) {\n      api.dispatchAction({\n        type: 'changeDataView',\n        newOption: newOption\n      });\n    }\n\n    close();\n  });\n  closeButton.innerHTML = lang[1];\n  refreshButton.innerHTML = lang[2];\n  refreshButton.style.cssText = buttonStyle;\n  closeButton.style.cssText = buttonStyle;\n  !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n  buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n\n  eventTool.addEventListener(textarea, 'keydown', function (e) {\n    if ((e.keyCode || e.which) === 9) {\n      // get caret position/selection\n      var val = this.value;\n      var start = this.selectionStart;\n      var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret\n\n      this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again\n\n      this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose\n\n      eventTool.stop(e);\n    }\n  });\n  root.appendChild(header);\n  root.appendChild(viewMain);\n  root.appendChild(buttonContainer);\n  viewMain.style.height = container.clientHeight - 80 + 'px';\n  container.appendChild(root);\n  this._dom = root;\n};\n\nDataView.prototype.remove = function (ecModel, api) {\n  this._dom && api.getDom().removeChild(this._dom);\n};\n\nDataView.prototype.dispose = function (ecModel, api) {\n  this.remove(ecModel, api);\n};\n/**\n * @inner\n */\n\n\nfunction tryMergeDataOption(newData, originalData) {\n  return zrUtil.map(newData, function (newVal, idx) {\n    var original = originalData && originalData[idx];\n\n    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n      if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n        newVal = newVal.value;\n      } // Original data has option\n\n\n      return zrUtil.defaults({\n        value: newVal\n      }, original);\n    } else {\n      return newVal;\n    }\n  });\n}\n\nfeatureManager.register('dataView', DataView);\necharts.registerAction({\n  type: 'changeDataView',\n  event: 'dataViewChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  var newSeriesOptList = [];\n  zrUtil.each(payload.newOption.series, function (seriesOpt) {\n    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n\n    if (!seriesModel) {\n      // New created series\n      // Geuss the series type\n      newSeriesOptList.push(zrUtil.extend({\n        // Default is scatter\n        type: 'scatter'\n      }, seriesOpt));\n    } else {\n      var originalData = seriesModel.get('data');\n      newSeriesOptList.push({\n        name: seriesOpt.name,\n        data: tryMergeDataOption(seriesOpt.data, originalData)\n      });\n    }\n  });\n  ecModel.mergeOption(zrUtil.defaults({\n    series: newSeriesOptList\n  }, payload.newOption));\n});\nvar _default = DataView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1640:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar BrushController = __webpack_require__(1641);\n\nvar BrushTargetManager = __webpack_require__(1642);\n\nvar history = __webpack_require__(1452);\n\nvar sliderMove = __webpack_require__(1367);\n\nvar lang = __webpack_require__(425);\n\nvar featureManager = __webpack_require__(1249);\n\n__webpack_require__(1645);\n\n// Use dataZoomSelect\nvar dataZoomLang = lang.toolbox.dataZoom;\nvar each = zrUtil.each; // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n\nvar DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\nfunction DataZoom(model, ecModel, api) {\n  /**\n   * @private\n   * @type {module:echarts/component/helper/BrushController}\n   */\n  (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._isZoomActive;\n}\n\nDataZoom.defaultOption = {\n  show: true,\n  // Icon group\n  icon: {\n    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n  },\n  // `zoom`, `back`\n  title: zrUtil.clone(dataZoomLang.title)\n};\nvar proto = DataZoom.prototype;\n\nproto.render = function (featureModel, ecModel, api, payload) {\n  this.model = featureModel;\n  this.ecModel = ecModel;\n  this.api = api;\n  updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n  updateBackBtnStatus(featureModel, ecModel);\n};\n\nproto.onclick = function (ecModel, api, type) {\n  handlers[type].call(this);\n};\n\nproto.remove = function (ecModel, api) {\n  this._brushController.unmount();\n};\n\nproto.dispose = function (ecModel, api) {\n  this._brushController.dispose();\n};\n/**\n * @private\n */\n\n\nvar handlers = {\n  zoom: function () {\n    var nextActive = !this._isZoomActive;\n    this.api.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: nextActive\n    });\n  },\n  back: function () {\n    this._dispatchZoomAction(history.pop(this.ecModel));\n  }\n};\n/**\n * @private\n */\n\nproto._onBrush = function (areas, opt) {\n  if (!opt.isEnd || !areas.length) {\n    return;\n  }\n\n  var snapshot = {};\n  var ecModel = this.ecModel;\n\n  this._brushController.updateCovers([]); // remove cover\n\n\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {\n    include: ['grid']\n  });\n  brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    if (coordSys.type !== 'cartesian2d') {\n      return;\n    }\n\n    var brushType = area.brushType;\n\n    if (brushType === 'rect') {\n      setBatch('x', coordSys, coordRange[0]);\n      setBatch('y', coordSys, coordRange[1]);\n    } else {\n      setBatch({\n        lineX: 'x',\n        lineY: 'y'\n      }[brushType], coordSys, coordRange);\n    }\n  });\n  history.push(ecModel, snapshot);\n\n  this._dispatchZoomAction(snapshot);\n\n  function setBatch(dimName, coordSys, minMax) {\n    var axis = coordSys.getAxis(dimName);\n    var axisModel = axis.model;\n    var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n\n    if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n      minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);\n    }\n\n    dataZoomModel && (snapshot[dataZoomModel.id] = {\n      dataZoomId: dataZoomModel.id,\n      startValue: minMax[0],\n      endValue: minMax[1]\n    });\n  }\n\n  function findDataZoom(dimName, axisModel, ecModel) {\n    var found;\n    ecModel.eachComponent({\n      mainType: 'dataZoom',\n      subType: 'select'\n    }, function (dzModel) {\n      var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n      has && (found = dzModel);\n    });\n    return found;\n  }\n};\n/**\n * @private\n */\n\n\nproto._dispatchZoomAction = function (snapshot) {\n  var batch = []; // Convert from hash map to array.\n\n  each(snapshot, function (batchItem, dataZoomId) {\n    batch.push(zrUtil.clone(batchItem));\n  });\n  batch.length && this.api.dispatchAction({\n    type: 'dataZoom',\n    from: this.uid,\n    batch: batch\n  });\n};\n\nfunction retrieveAxisSetting(option) {\n  var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.\n\n  zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n    setting[name] = option[name];\n    setting[name] == null && (setting[name] = 'all');\n    (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n  });\n  return setting;\n}\n\nfunction updateBackBtnStatus(featureModel, ecModel) {\n  featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');\n}\n\nfunction updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n  var zoomActive = view._isZoomActive;\n\n  if (payload && payload.type === 'takeGlobalCursor') {\n    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;\n  }\n\n  view._isZoomActive = zoomActive;\n  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {\n    include: ['grid']\n  });\n\n  view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';\n  })).enableBrush(zoomActive ? {\n    brushType: 'auto',\n    brushStyle: {\n      // FIXME user customized?\n      lineWidth: 0,\n      fill: 'rgba(0,0,0,0.2)'\n    }\n  } : false);\n}\n\nfeatureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select\n\necharts.registerPreprocessor(function (option) {\n  if (!option) {\n    return;\n  }\n\n  var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n\n  if (!zrUtil.isArray(dataZoomOpts)) {\n    option.dataZoom = dataZoomOpts = [dataZoomOpts];\n  }\n\n  var toolboxOpt = option.toolbox;\n\n  if (toolboxOpt) {\n    // Assume there is only one toolbox\n    if (zrUtil.isArray(toolboxOpt)) {\n      toolboxOpt = toolboxOpt[0];\n    }\n\n    if (toolboxOpt && toolboxOpt.feature) {\n      var dataZoomOpt = toolboxOpt.feature.dataZoom;\n      addForAxis('xAxis', dataZoomOpt);\n      addForAxis('yAxis', dataZoomOpt);\n    }\n  }\n\n  function addForAxis(axisName, dataZoomOpt) {\n    if (!dataZoomOpt) {\n      return;\n    } // Try not to modify model, because it is not merged yet.\n\n\n    var axisIndicesName = axisName + 'Index';\n    var givenAxisIndices = dataZoomOpt[axisIndicesName];\n\n    if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {\n      givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];\n    }\n\n    forEachComponent(axisName, function (axisOpt, axisIndex) {\n      if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {\n        return;\n      }\n\n      var newOpt = {\n        type: 'select',\n        $fromToolbox: true,\n        // Id for merge mapping.\n        id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n      }; // FIXME\n      // Only support one axis now.\n\n      newOpt[axisIndicesName] = axisIndex;\n      dataZoomOpts.push(newOpt);\n    });\n  }\n\n  function forEachComponent(mainType, cb) {\n    var opts = option[mainType];\n\n    if (!zrUtil.isArray(opts)) {\n      opts = opts ? [opts] : [];\n    }\n\n    each(opts, cb);\n  }\n});\nvar _default = DataZoom;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1641:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(2);\n\nvar Eventful = __webpack_require__(94);\n\nvar graphic = __webpack_require__(22);\n\nvar interactionMutex = __webpack_require__(1449);\n\nvar DataDiffer = __webpack_require__(437);\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd.call(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: handleDragEnd //,\n  // FIXME\n  // in tooltip, globalout should not be triggered.\n  // globalout: handleDragEnd\n\n};\n\nfunction handleDragEnd(e) {\n  if (this._dragging) {\n    preventDefault(e);\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n    this._dragging = false;\n    this._track = [];\n    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(this, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1642:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(2);\n\nvar graphic = __webpack_require__(22);\n\nvar modelUtil = __webpack_require__(12);\n\nvar brushHelper = __webpack_require__(1643);\n\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1643:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BoundingRect = __webpack_require__(33);\n\nvar _cursorHelper = __webpack_require__(1644);\n\nvar onIrrelevantElement = _cursorHelper.onIrrelevantElement;\n\nvar graphicUtil = __webpack_require__(22);\n\nfunction makeRectPanelClipPath(rect) {\n  rect = normalizeRect(rect);\n  return function (localPoints, transform) {\n    return graphicUtil.clipPointsByRect(localPoints, rect);\n  };\n}\n\nfunction makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n  rect = normalizeRect(rect);\n  return function (xyIndex) {\n    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n    var brushWidth = idx ? rect.width : rect.height;\n    var base = idx ? rect.x : rect.y;\n    return [base, base + (brushWidth || 0)];\n  };\n}\n\nfunction makeRectIsTargetByCursor(rect, api, targetModel) {\n  rect = normalizeRect(rect);\n  return function (e, localCursorPoint, transform) {\n    return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);\n  };\n} // Consider width/height is negative.\n\n\nfunction normalizeRect(rect) {\n  return BoundingRect.create(rect);\n}\n\nexports.makeRectPanelClipPath = makeRectPanelClipPath;\nexports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;\nexports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;\n\n/***/ }),\n\n/***/ 1644:\n/***/ (function(module, exports) {\n\nvar IRRELEVANT_EXCLUDES = {\n  'axisPointer': 1,\n  'tooltip': 1,\n  'brush': 1\n};\n/**\n * Avoid that: mouse click on a elements that is over geo or graph,\n * but roam is triggered.\n */\n\nfunction onIrrelevantElement(e, api, targetCoordSysModel) {\n  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.\n\n  var coordSys = model && model.coordinateSystem;\n  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;\n}\n\nexports.onIrrelevantElement = onIrrelevantElement;\n\n/***/ }),\n\n/***/ 1645:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(1448);\n\n__webpack_require__(1288);\n\n__webpack_require__(1289);\n\n__webpack_require__(1646);\n\n__webpack_require__(1647);\n\n__webpack_require__(1450);\n\n__webpack_require__(1451);\n\n/***/ }),\n\n/***/ 1646:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomModel = __webpack_require__(1288);\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1647:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataZoomView = __webpack_require__(1289);\n\nvar _default = DataZoomView.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1648:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar history = __webpack_require__(1452);\n\nvar lang = __webpack_require__(425);\n\nvar featureManager = __webpack_require__(1249);\n\nvar restoreLang = lang.toolbox.restore;\n\nfunction Restore(model) {\n  this.model = model;\n}\n\nRestore.defaultOption = {\n  show: true,\n  icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n  title: restoreLang.title\n};\nvar proto = Restore.prototype;\n\nproto.onclick = function (ecModel, api, type) {\n  history.clear(ecModel);\n  api.dispatchAction({\n    type: 'restore',\n    from: this.uid\n  });\n};\n\nfeatureManager.register('restore', Restore);\necharts.registerAction({\n  type: 'restore',\n  event: 'restore',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.resetOption('recreate');\n});\nvar _default = Restore;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1649:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n__webpack_require__(1650);\n\n__webpack_require__(1652);\n\n// HINT Markpoint can't be used too much\necharts.registerPreprocessor(function (opt) {\n  // Make sure markPoint component is enabled\n  opt.markPoint = opt.markPoint || {};\n});\n\n/***/ }),\n\n/***/ 1650:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MarkerModel = __webpack_require__(1651);\n\nvar _default = MarkerModel.extend({\n  type: 'markPoint',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: 'pin',\n    symbolSize: 50,\n    //symbolRotate: 0,\n    //symbolOffset: [0, 0]\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'inside'\n    },\n    itemStyle: {\n      borderWidth: 2\n    },\n    emphasis: {\n      label: {\n        show: true\n      }\n    }\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1651:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar env = __webpack_require__(28);\n\nvar modelUtil = __webpack_require__(12);\n\nvar formatUtil = __webpack_require__(37);\n\nvar dataFormatMixin = __webpack_require__(444);\n\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt, 'label', ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1652:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar SymbolDraw = __webpack_require__(1267);\n\nvar numberUtil = __webpack_require__(27);\n\nvar List = __webpack_require__(227);\n\nvar markerHelper = __webpack_require__(1653);\n\nvar MarkerView = __webpack_require__(1654);\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  mpData.each(function (idx) {\n    var itemModel = mpData.getItemModel(idx);\n    var point;\n    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n      point = [xPx, yPx];\n    } // Chart like bar may have there own marker positioning logic\n    else if (seriesModel.getMarkerPosition) {\n        // Use the getMarkerPoisition\n        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n      } else if (coordSys) {\n        var x = mpData.get(coordSys.dimensions[0], idx);\n        var y = mpData.get(coordSys.dimensions[1], idx);\n        point = coordSys.dataToPoint([x, y]);\n      } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n\n    mpData.setItemLayout(idx, point);\n  });\n}\n\nvar _default = MarkerView.extend({\n  type: 'markPoint',\n  // updateLayout: function (markPointModel, ecModel, api) {\n  //     ecModel.eachSeries(function (seriesModel) {\n  //         var mpModel = seriesModel.markPointModel;\n  //         if (mpModel) {\n  //             updateMarkerLayout(mpModel.getData(), seriesModel, api);\n  //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n  //         }\n  //     }, this);\n  // },\n  updateTransform: function (markPointModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mpModel = seriesModel.markPointModel;\n\n      if (mpModel) {\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mpModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var symbolDrawMap = this.markerGroupMap;\n    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());\n    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME\n\n    mpModel.setData(mpData);\n    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n    mpData.each(function (idx) {\n      var itemModel = mpData.getItemModel(idx);\n      var symbolSize = itemModel.getShallow('symbolSize');\n\n      if (typeof symbolSize === 'function') {\n        // FIXME  ECharts 2.x2.x \n        symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));\n      }\n\n      mpData.setItemVisual(idx, {\n        symbolSize: symbolSize,\n        color: itemModel.get('itemStyle.color') || seriesData.getVisual('color'),\n        symbol: itemModel.getShallow('symbol')\n      });\n    }); // TODO Text are wrong\n\n    symbolDraw.updateData(mpData);\n    this.group.add(symbolDraw.group); // Set host model for tooltip\n    // FIXME\n\n    mpData.eachItemGraphicEl(function (el) {\n      el.traverse(function (child) {\n        child.dataModel = mpModel;\n      });\n    });\n    symbolDraw.__keep = true;\n    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} [coordSys]\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mpModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return zrUtil.defaults({\n        name: coordDim\n      }, info);\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var mpData = new List(coordDimsInfos, mpModel);\n  var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));\n\n  if (coordSys) {\n    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));\n  }\n\n  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  });\n  return mpData;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1653:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar numberUtil = __webpack_require__(27);\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim, otherDataDim);\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n/***/ }),\n\n/***/ 1654:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/Stats.e4925174.chunk.js","import React from \"react\";\n\nimport {tu} from \"../../../utils/i18n\";\nimport {Client} from \"../../../services/api\";\nimport {ONE_TRX} from \"../../../constants\";\nimport {connect} from \"react-redux\";\nimport {injectIntl} from \"react-intl\";\nimport {filter, includes} from \"lodash\";\nimport {tronAddresses} from \"../../../utils/tron\";\nimport RichList from \"./RichList\";\nimport {TronLoader} from \"../../common/loaders\";\nimport PieReact from \"../../common/PieChart\";\nimport LineReact from \"../../common/LineChart\";\nimport LineReactTx from \"../../common/LineChartTx\";\n\nclass Statistics extends React.Component {\n\n  constructor() {\n    super();\n\n    this.state = {\n      accounts: null,\n      transactionStats: null,\n      blockStats: null,\n      transactionValueStats: null,\n      txOverviewStats:null\n    };\n  }\n\n  componentDidMount() {\n    this.loadAccounts();\n    this.loadStats();\n    this.loadTxOverviewStats();\n  }\n\n  async loadAccounts() {\n\n    let {accounts} = await Client.getAccounts({\n      limit: 35,\n      sort: '-balance',\n    });\n\n    this.setState({\n      accounts: filter(accounts, account => !includes(tronAddresses, account.address))\n          .slice(0, 10)\n          .map(account => ({\n            name: account.address,\n            value: account.balance / ONE_TRX,\n          }))\n    });\n  }\n\n\n  async loadStats() {\n\n    let {intl} = this.props;\n\n    let {stats} = await Client.getTransferStats({\n      groupby: 'timestamp',\n      interval: 'hour',\n    });\n\n    let {stats: blockStats} = await Client.getBlockStats({\n      info: `avg-block-size`,\n    });\n\n    let transactionTotalStats = stats.total.map(row => ({\n      timestamp: intl.formatTime(row.timestamp),\n      value: row.value,\n    }));\n\n    let valueStats = stats.value.map(row => ({\n      timestamp: intl.formatTime(row.timestamp),\n      value: row.value / ONE_TRX,\n    }));\n\n    blockStats = blockStats.map(row => ({\n      timestamp: intl.formatTime(row.timestamp),\n      value: row.value,\n    }));\n\n    this.setState({\n      transactionStats: transactionTotalStats,\n      transactionValueStats: valueStats,\n      blockStats,\n    });\n  }\n\n  async loadTxOverviewStats() {\n    let {txOverviewStats} = await Client.getTxOverviewStats();\n    this.setState({\n      txOverviewStats:txOverviewStats\n    });\n  }\n\n  render() {\n\n    let {txOverviewStats, transactionStats, transactionValueStats, blockStats, accounts} = this.state;\n    return (\n        <main className=\"container header-overlap\">\n          <div className=\"row\">\n            <div className=\"col-md-12 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"TRX_transaction_chart\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      txOverviewStats === null ?\n                          <TronLoader/> :\n                          <LineReactTx style={{height: 300}} data={txOverviewStats}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"Top\")} {accounts !== null ? accounts.length : 0} {tu(\"addresses\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      accounts === null ?\n                          <TronLoader/> :\n                          <PieReact style={{height: 300}} data={accounts}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"trx_transferred_past_hour\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      transactionValueStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={transactionValueStats} keysData={['timestamp','value']}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"transactions_past_hour\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      transactionStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={transactionStats} keysData={['timestamp','value']}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"average_blocksize\")} ({tu(\"bytes\")})</h5>\n                  <div style={{height: 300}}>\n                    {\n                      blockStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={blockStats} keysData={['timestamp','value']}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </main>\n    );\n  }\n}\n\n\nfunction mapStateToProps(state) {\n  return {};\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(injectIntl(Statistics))\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/blockchain/Statistics/index.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Symbol.js\n// module id = 1239\n// module chunks = 2 3 4","var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/helper.js\n// module id = 1240\n// module chunks = 2 3 4","var features = {};\n\nfunction register(name, ctor) {\n  features[name] = ctor;\n}\n\nfunction get(name) {\n  return features[name];\n}\n\nexports.register = register;\nexports.get = get;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/featureManager.js\n// module id = 1249\n// module chunks = 2","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line.js\n// module id = 1266\n// module chunks = 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 1267\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineSeries.js\n// module id = 1281\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineView.js\n// module id = 1282\n// module chunks = 2 3 4","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 1283\n// module chunks = 2 3 4","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/poly.js\n// module id = 1284\n// module chunks = 2 3 4","function _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = 1285\n// module chunks = 2 3 4","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/points.js\n// module id = 1286\n// module chunks = 2 3 4","var samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataSample.js\n// module id = 1287\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar helper = require(\"./helper\");\n\nvar AxisProxy = require(\"./AxisProxy\");\n\nvar each = zrUtil.each;\nvar eachAxisDim = helper.eachAxisDim;\nvar DataZoomModel = echarts.extendComponentModel({\n  type: 'dataZoom',\n  dependencies: ['xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'],\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    zlevel: 0,\n    z: 4,\n    // Higher than normal component (z: 2).\n    orient: null,\n    // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n    xAxisIndex: null,\n    // Default the first horizontal category axis.\n    yAxisIndex: null,\n    // Default the first vertical category axis.\n    filterMode: 'filter',\n    // Possible values: 'filter' or 'empty' or 'weakFilter'.\n    // 'filter': data items which are out of window will be removed. This option is\n    //          applicable when filtering outliers. For each data item, it will be\n    //          filtered if one of the relevant dimensions is out of the window.\n    // 'weakFilter': data items which are out of window will be removed. This option\n    //          is applicable when filtering outliers. For each data item, it will be\n    //          filtered only if all  of the relevant dimensions are out of the same\n    //          side of the window.\n    // 'empty': data items which are out of window will be set to empty.\n    //          This option is applicable when user should not neglect\n    //          that there are some data items out of window.\n    // 'none': Do not filter.\n    // Taking line chart as an example, line will be broken in\n    // the filtered points when filterModel is set to 'empty', but\n    // be connected when set to 'filter'.\n    throttle: null,\n    // Dispatch action by the fixed rate, avoid frequency.\n    // default 100. Do not throttle when use null/undefined.\n    // If animation === true and animationDurationUpdate > 0,\n    // default value is 100, otherwise 20.\n    start: 0,\n    // Start percent. 0 ~ 100\n    end: 100,\n    // End percent. 0 ~ 100\n    startValue: null,\n    // Start value. If startValue specified, start is ignored.\n    endValue: null,\n    // End value. If endValue specified, end is ignored.\n    minSpan: null,\n    // 0 ~ 100\n    maxSpan: null,\n    // 0 ~ 100\n    minValueSpan: null,\n    // The range of dataZoom can not be smaller than that.\n    maxValueSpan: null,\n    // The range of dataZoom can not be larger than that.\n    rangeMode: null // Array, can be 'value' or 'percent'.\n\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel) {\n    /**\n     * key like x_0, y_1\n     * @private\n     * @type {Object}\n     */\n    this._dataIntervalByAxis = {};\n    /**\n     * @private\n     */\n\n    this._dataInfo = {};\n    /**\n     * key like x_0, y_1\n     * @private\n     */\n\n    this._axisProxies = {};\n    /**\n     * @readOnly\n     */\n\n    this.textStyleModel;\n    /**\n     * @private\n     */\n\n    this._autoThrottle = true;\n    /**\n     * 'percent' or 'value'\n     * @private\n     */\n\n    this._rangePropMode = ['percent', 'percent'];\n    var rawOption = retrieveRaw(option);\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (newOption) {\n    var rawOption = retrieveRaw(newOption); //FIX #2591\n\n    zrUtil.merge(this.option, newOption, true);\n    this.doInit(rawOption);\n  },\n\n  /**\n   * @protected\n   */\n  doInit: function (rawOption) {\n    var thisOption = this.option; // Disable realtime view update if canvas is not supported.\n\n    if (!env.canvasSupported) {\n      thisOption.realtime = false;\n    }\n\n    this._setDefaultThrottle(rawOption);\n\n    updateRangeUse(this, rawOption);\n    each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n      // start/end has higher priority over startValue/endValue if they\n      // both set, but we should make chart.setOption({endValue: 1000})\n      // effective, rather than chart.setOption({endValue: 1000, end: null}).\n      if (this._rangePropMode[index] === 'value') {\n        thisOption[names[0]] = null;\n      } // Otherwise do nothing and use the merge result.\n\n    }, this);\n    this.textStyleModel = this.getModel('textStyle');\n\n    this._resetTarget();\n\n    this._giveAxisProxies();\n  },\n\n  /**\n   * @private\n   */\n  _giveAxisProxies: function () {\n    var axisProxies = this._axisProxies;\n    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n      var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels.\n\n      var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy.\n      axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel)); // FIXME\n      // dispose __dzAxisProxy\n\n      axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetTarget: function () {\n    var thisOption = this.option;\n\n    var autoMode = this._judgeAutoMode();\n\n    eachAxisDim(function (dimNames) {\n      var axisIndexName = dimNames.axisIndex;\n      thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);\n    }, this);\n\n    if (autoMode === 'axisIndex') {\n      this._autoSetAxisIndex();\n    } else if (autoMode === 'orient') {\n      this._autoSetOrient();\n    }\n  },\n\n  /**\n   * @private\n   */\n  _judgeAutoMode: function () {\n    // Auto set only works for setOption at the first time.\n    // The following is user's reponsibility. So using merged\n    // option is OK.\n    var thisOption = this.option;\n    var hasIndexSpecified = false;\n    eachAxisDim(function (dimNames) {\n      // When user set axisIndex as a empty array, we think that user specify axisIndex\n      // but do not want use auto mode. Because empty array may be encountered when\n      // some error occured.\n      if (thisOption[dimNames.axisIndex] != null) {\n        hasIndexSpecified = true;\n      }\n    }, this);\n    var orient = thisOption.orient;\n\n    if (orient == null && hasIndexSpecified) {\n      return 'orient';\n    } else if (!hasIndexSpecified) {\n      if (orient == null) {\n        thisOption.orient = 'horizontal';\n      }\n\n      return 'axisIndex';\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetAxisIndex: function () {\n    var autoAxisIndex = true;\n    var orient = this.get('orient', true);\n    var thisOption = this.option;\n    var dependentModels = this.dependentModels;\n\n    if (autoAxisIndex) {\n      // Find axis that parallel to dataZoom as default.\n      var dimName = orient === 'vertical' ? 'y' : 'x';\n\n      if (dependentModels[dimName + 'Axis'].length) {\n        thisOption[dimName + 'AxisIndex'] = [0];\n        autoAxisIndex = false;\n      } else {\n        each(dependentModels.singleAxis, function (singleAxisModel) {\n          if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n            autoAxisIndex = false;\n          }\n        });\n      }\n    }\n\n    if (autoAxisIndex) {\n      // Find the first category axis as default. (consider polar)\n      eachAxisDim(function (dimNames) {\n        if (!autoAxisIndex) {\n          return;\n        }\n\n        var axisIndices = [];\n        var axisModels = this.dependentModels[dimNames.axis];\n\n        if (axisModels.length && !axisIndices.length) {\n          for (var i = 0, len = axisModels.length; i < len; i++) {\n            if (axisModels[i].get('type') === 'category') {\n              axisIndices.push(i);\n            }\n          }\n        }\n\n        thisOption[dimNames.axisIndex] = axisIndices;\n\n        if (axisIndices.length) {\n          autoAxisIndex = false;\n        }\n      }, this);\n    }\n\n    if (autoAxisIndex) {\n      // FIXME\n      // ec2xAxisIndexyAxisIndexscatterdataZoom\n      // Grid.js#getScaleByOptiontimelogaxis type\n      // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n      // dataZoom component auto adopts series that reference to\n      // both xAxis and yAxis which type is 'value'.\n      this.ecModel.eachSeries(function (seriesModel) {\n        if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n          eachAxisDim(function (dimNames) {\n            var axisIndices = thisOption[dimNames.axisIndex];\n            var axisIndex = seriesModel.get(dimNames.axisIndex);\n            var axisId = seriesModel.get(dimNames.axisId);\n            var axisModel = seriesModel.ecModel.queryComponents({\n              mainType: dimNames.axis,\n              index: axisIndex,\n              id: axisId\n            })[0];\n            axisIndex = axisModel.componentIndex;\n\n            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n              axisIndices.push(axisIndex);\n            }\n          });\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  _autoSetOrient: function () {\n    var dim; // Find the first axis\n\n    this.eachTargetAxis(function (dimNames) {\n      !dim && (dim = dimNames.name);\n    }, this);\n    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n  },\n\n  /**\n   * @private\n   */\n  _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n    // FIXME\n    // seriesxAxisIndexyAxisIndex\n    // series.type === scatter\n    var is = true;\n    eachAxisDim(function (dimNames) {\n      var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n      var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n      if (!axisModel || axisModel.get('type') !== axisType) {\n        is = false;\n      }\n    }, this);\n    return is;\n  },\n\n  /**\n   * @private\n   */\n  _setDefaultThrottle: function (rawOption) {\n    // When first time user set throttle, auto throttle ends.\n    if (rawOption.hasOwnProperty('throttle')) {\n      this._autoThrottle = false;\n    }\n\n    if (this._autoThrottle) {\n      var globalOption = this.ecModel.option;\n      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n    }\n  },\n\n  /**\n   * @public\n   */\n  getFirstTargetAxisModel: function () {\n    var firstAxisModel;\n    eachAxisDim(function (dimNames) {\n      if (firstAxisModel == null) {\n        var indices = this.get(dimNames.axisIndex);\n\n        if (indices.length) {\n          firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n        }\n      }\n    }, this);\n    return firstAxisModel;\n  },\n\n  /**\n   * @public\n   * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n   */\n  eachTargetAxis: function (callback, context) {\n    var ecModel = this.ecModel;\n    eachAxisDim(function (dimNames) {\n      each(this.get(dimNames.axisIndex), function (axisIndex) {\n        callback.call(context, dimNames, axisIndex, this, ecModel);\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n   */\n  getAxisProxy: function (dimName, axisIndex) {\n    return this._axisProxies[dimName + '_' + axisIndex];\n  },\n\n  /**\n   * @param {string} dimName\n   * @param {number} axisIndex\n   * @return {module:echarts/model/Model} If not found, return null/undefined.\n   */\n  getAxisModel: function (dimName, axisIndex) {\n    var axisProxy = this.getAxisProxy(dimName, axisIndex);\n    return axisProxy && axisProxy.getAxisModel();\n  },\n\n  /**\n   * If not specified, set to undefined.\n   *\n   * @public\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   * @param {boolean} [ignoreUpdateRangeUsg=false]\n   */\n  setRawRange: function (opt, ignoreUpdateRangeUsg) {\n    var option = this.option;\n    each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n      // If only one of 'start' and 'startValue' is not null/undefined, the other\n      // should be cleared, which enable clear the option.\n      // If both of them are not set, keep option with the original value, which\n      // enable use only set start but not set end when calling `dispatchAction`.\n      // The same as 'end' and 'endValue'.\n      if (opt[names[0]] != null || opt[names[1]] != null) {\n        option[names[0]] = opt[names[0]];\n        option[names[1]] = opt[names[1]];\n      }\n    }, this);\n    !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n  },\n\n  /**\n   * @public\n   * @return {Array.<number>} [startPercent, endPercent]\n   */\n  getPercentRange: function () {\n    var axisProxy = this.findRepresentativeAxisProxy();\n\n    if (axisProxy) {\n      return axisProxy.getDataPercentWindow();\n    }\n  },\n\n  /**\n   * @public\n   * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n   *\n   * @param {string} [axisDimName]\n   * @param {number} [axisIndex]\n   * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n   */\n  getValueRange: function (axisDimName, axisIndex) {\n    if (axisDimName == null && axisIndex == null) {\n      var axisProxy = this.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        return axisProxy.getDataValueWindow();\n      }\n    } else {\n      return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n    }\n  },\n\n  /**\n   * @public\n   * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n   *      corresponding to the axisModel\n   * @return {module:echarts/component/dataZoom/AxisProxy}\n   */\n  findRepresentativeAxisProxy: function (axisModel) {\n    if (axisModel) {\n      return axisModel.__dzAxisProxy;\n    } // Find the first hosted axisProxy\n\n\n    var axisProxies = this._axisProxies;\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    } // If no hosted axis find not hosted axisProxy.\n    // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n    // and the option.start or option.end settings are different. The percentRange\n    // should follow axisProxy.\n    // (We encounter this problem in toolbox data zoom.)\n\n\n    for (var key in axisProxies) {\n      if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n        return axisProxies[key];\n      }\n    }\n  },\n\n  /**\n   * @return {Array.<string>}\n   */\n  getRangePropMode: function () {\n    return this._rangePropMode.slice();\n  }\n});\n\nfunction retrieveRaw(option) {\n  var ret = {};\n  each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n    option.hasOwnProperty(name) && (ret[name] = option[name]);\n  });\n  return ret;\n}\n\nfunction updateRangeUse(dataZoomModel, rawOption) {\n  var rangePropMode = dataZoomModel._rangePropMode;\n  var rangeModeInOption = dataZoomModel.get('rangeMode');\n  each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n    var percentSpecified = rawOption[names[0]] != null;\n    var valueSpecified = rawOption[names[1]] != null;\n\n    if (percentSpecified && !valueSpecified) {\n      rangePropMode[index] = 'percent';\n    } else if (!percentSpecified && valueSpecified) {\n      rangePropMode[index] = 'value';\n    } else if (rangeModeInOption) {\n      rangePropMode[index] = rangeModeInOption[index];\n    } else if (percentSpecified) {\n      // percentSpecified && valueSpecified\n      rangePropMode[index] = 'percent';\n    } // else remain its original setting.\n\n  });\n}\n\nvar _default = DataZoomModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\n// module id = 1288\n// module chunks = 2","var ComponentView = require(\"../../view/Component\");\n\nvar _default = ComponentView.extend({\n  type: 'dataZoom',\n  render: function (dataZoomModel, ecModel, api, payload) {\n    this.dataZoomModel = dataZoomModel;\n    this.ecModel = ecModel;\n    this.api = api;\n  },\n\n  /**\n   * Find the first target coordinate system.\n   *\n   * @protected\n   * @return {Object} {\n   *                   grid: [\n   *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n   *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n   *                       ...\n   *                   ],  // cartesians must not be null/undefined.\n   *                   polar: [\n   *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n   *                       ...\n   *                   ],  // polars must not be null/undefined.\n   *                   singleAxis: [\n   *                       {model: coord0, axisModels: [], coordIndex: 0}\n   *                   ]\n   */\n  getTargetCoordInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var ecModel = this.ecModel;\n    var coordSysLists = {};\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n\n      if (axisModel) {\n        var coordModel = axisModel.getCoordSysModel();\n        coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);\n      }\n    }, this);\n\n    function save(coordModel, axisModel, store, coordIndex) {\n      var item;\n\n      for (var i = 0; i < store.length; i++) {\n        if (store[i].model === coordModel) {\n          item = store[i];\n          break;\n        }\n      }\n\n      if (!item) {\n        store.push(item = {\n          model: coordModel,\n          axisModels: [],\n          coordIndex: coordIndex\n        });\n      }\n\n      item.axisModels.push(axisModel);\n    }\n\n    return coordSysLists;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\n// module id = 1289\n// module chunks = 2","var _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/listComponent.js\n// module id = 1290\n// module chunks = 2 3 4","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./pie/PieSeries\");\n\nrequire(\"./pie/PieView\");\n\nvar createDataSelectAction = require(\"../action/createDataSelectAction\");\n\nvar dataColor = require(\"../visual/dataColor\");\n\nvar pieLayout = require(\"./pie/pieLayout\");\n\nvar dataFilter = require(\"../processor/dataFilter\");\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie.js\n// module id = 1355\n// module chunks = 2 3","var echarts = require(\"../../echarts\");\n\nvar createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _number = require(\"../../util/number\");\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = require(\"../../component/helper/selectableMixin\");\n\nvar _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // \n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // \n    clockwise: true,\n    startAngle: 90,\n    // 0\n    minAngle: 0,\n    // \n    selectedOffset: 10,\n    // \n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // singlemultiple\n    // selectedMode: false,\n    // 'radius' | 'area'\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: Tooltip.formatter\n      // TEXTSTYLE\n      // distance: positioninnerlabel()\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // \n      length: 15,\n      // \n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: ,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n// module id = 1356\n// module chunks = 2 3","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 1357\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/selectableMixin.js\n// module id = 1358\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieView.js\n// module id = 1359\n// module chunks = 2 3","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/action/createDataSelectAction.js\n// module id = 1360\n// module chunks = 2 3","var _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 1361\n// module chunks = 2 3","var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME  2.0  roseType  area \n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n// module id = 1362\n// module chunks = 2 3","var textContain = require(\"zrender/lib/contain/text\");\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // \n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // \n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // \n    ? Number.MAX_VALUE // \n    : 0 // \n    : isDownList // \n    ? Number.MAX_VALUE // \n    : 0; // \n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // \n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // \n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n// module id = 1363\n// module chunks = 2 3","function _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 1364\n// module chunks = 2 3","import React from 'react'\nimport {injectIntl} from \"react-intl\";\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/line'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport {connect} from \"react-redux\";\n\nexport class LineReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      lineId: 'line' + id\n    }\n  }\n\n  initLine(id) {\n    let {intl, keysData, data, format} = this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.lineChart.title.text='';\n    config.lineChart.xAxis.data = [];\n    config.lineChart.series[0].data = [];\n    if(data && data.length>0) {\n      data.map((val) => {\n\n        if (format && format[keysData[0]]) {\n          if (format.date) {\n            config.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]] * 1000));\n          }\n          else {\n            config.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]] * 1000));\n          }\n        }\n        else\n          config.lineChart.xAxis.data.push(val[keysData[0]]);\n\n\n        config.lineChart.series[0].data.push(val[keysData[1]]);\n      })\n    }\n    if(data && data.length===0){\n      config.lineChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.lineChart);\n\n  }\n\n  componentDidMount() {\n    this.initLine(this.state.lineId);\n  }\n\n  componentDidUpdate() {\n    this.initLine(this.state.lineId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.lineId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {}\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(LineReact));\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/LineChart.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords.\n\nvar COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n/**\n * @param {string} coordType\n * @return {boolean}\n */\n\nfunction isCoordSupported(coordType) {\n  return zrUtil.indexOf(COORDS, coordType) >= 0;\n}\n/**\n * Create \"each\" method to iterate names.\n *\n * @pubilc\n * @param  {Array.<string>} names\n * @param  {Array.<string>=} attrs\n * @return {Function}\n */\n\n\nfunction createNameEach(names, attrs) {\n  names = names.slice();\n  var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n  attrs = (attrs || []).slice();\n  var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n  return function (callback, context) {\n    zrUtil.each(names, function (name, index) {\n      var nameObj = {\n        name: name,\n        capital: capitalNames[index]\n      };\n\n      for (var j = 0; j < attrs.length; j++) {\n        nameObj[attrs[j]] = name + capitalAttrs[j];\n      }\n\n      callback.call(context, nameObj);\n    });\n  };\n}\n/**\n * Iterate each dimension name.\n *\n * @public\n * @param {Function} callback The parameter is like:\n *                            {\n *                                name: 'angle',\n *                                capital: 'Angle',\n *                                axis: 'angleAxis',\n *                                axisIndex: 'angleAixs',\n *                                index: 'angleIndex'\n *                            }\n * @param {Object} context\n */\n\n\nvar eachAxisDim = createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n/**\n * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n * dataZoomModels and 'links' make up one or more graphics.\n * This function finds the graphic where the source dataZoomModel is in.\n *\n * @public\n * @param {Function} forEachNode Node iterator.\n * @param {Function} forEachEdgeType edgeType iterator\n * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n */\n\nfunction createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {\n  return function (sourceNode) {\n    var result = {\n      nodes: [],\n      records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n\n    };\n    forEachEdgeType(function (edgeType) {\n      result.records[edgeType.name] = {};\n    });\n\n    if (!sourceNode) {\n      return result;\n    }\n\n    absorb(sourceNode, result);\n    var existsLink;\n\n    do {\n      existsLink = false;\n      forEachNode(processSingleNode);\n    } while (existsLink);\n\n    function processSingleNode(node) {\n      if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n        absorb(node, result);\n        existsLink = true;\n      }\n    }\n\n    return result;\n  };\n\n  function isNodeAbsorded(node, result) {\n    return zrUtil.indexOf(result.nodes, node) >= 0;\n  }\n\n  function isLinked(node, result) {\n    var hasLink = false;\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] && (hasLink = true);\n      });\n    });\n    return hasLink;\n  }\n\n  function absorb(node, result) {\n    result.nodes.push(node);\n    forEachEdgeType(function (edgeType) {\n      zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n        result.records[edgeType.name][edgeId] = true;\n      });\n    });\n  }\n}\n\nexports.isCoordSupported = isCoordSupported;\nexports.createNameEach = createNameEach;\nexports.eachAxisDim = eachAxisDim;\nexports.createLinkedNodesFinder = createLinkedNodesFinder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/helper.js\n// module id = 1366\n// module chunks = 2","/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param {number} delta Move length.\n * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param {Array.<number>} extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n *              where the input minSpan and maxSpan will not work.\n * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n * @return {Array.<number>} The input handleEnds.\n */\nfunction _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  // Normalize firstly.\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleIndex = 0;\n  }\n\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbinden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  var currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1], Math.max(extend[0], value));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/sliderMove.js\n// module id = 1367\n// module chunks = 2","var Component = require(\"../../model/Component\");\n\nComponent.registerSubTypeDefaulter('dataZoom', function () {\n  // Default 'slider' when no type specified.\n  return 'slider';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js\n// module id = 1448\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar ATTR = '\\0_ec_interaction_mutex';\n\nfunction take(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  store[resourceKey] = userKey;\n}\n\nfunction release(zr, resourceKey, userKey) {\n  var store = getStore(zr);\n  var uKey = store[resourceKey];\n\n  if (uKey === userKey) {\n    store[resourceKey] = null;\n  }\n}\n\nfunction isTaken(zr, resourceKey) {\n  return !!getStore(zr)[resourceKey];\n}\n\nfunction getStore(zr) {\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n/**\n * payload: {\n *     type: 'takeGlobalCursor',\n *     key: 'dataZoomSelect', or 'brush', or ...,\n *         If no userKey, release global cursor.\n * }\n */\n\n\necharts.registerAction({\n  type: 'takeGlobalCursor',\n  event: 'globalCursorTaken',\n  update: 'update'\n}, function () {});\nexports.take = take;\nexports.release = release;\nexports.isTaken = isTaken;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/interactionMutex.js\n// module id = 1449\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\necharts.registerProcessor({\n  getTargetSeries: function (ecModel) {\n    var seriesModelMap = createHashMap();\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        var axisProxy = dataZoomModel.getAxisProxy(dimNames.name, axisIndex);\n        each(axisProxy.getTargetSeriesModels(), function (seriesModel) {\n          seriesModelMap.set(seriesModel.uid, seriesModel);\n        });\n      });\n    });\n    return seriesModelMap;\n  },\n  isOverallFilter: true,\n  // Consider appendData, where filter should be performed. Because data process is\n  // in block mode currently, it is not need to worry about that the overallProgress\n  // execute every frame.\n  overallReset: function (ecModel, api) {\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // We calculate window and reset axis here but not in model\n      // init stage and not after action dispatch handler, because\n      // reset should be called after seriesData.restoreData.\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel, api);\n      }); // Caution: data zoom filtering is order sensitive when using\n      // percent range and no min/max/scale set on axis.\n      // For example, we have dataZoom definition:\n      // [\n      //      {xAxisIndex: 0, start: 30, end: 70},\n      //      {yAxisIndex: 0, start: 20, end: 80}\n      // ]\n      // In this case, [20, 80] of y-dataZoom should be based on data\n      // that have filtered by x-dataZoom using range of [30, 70],\n      // but should not be based on full raw data. Thus sliding\n      // x-dataZoom will change both ranges of xAxis and yAxis,\n      // while sliding y-dataZoom will only change the range of yAxis.\n      // So we should filter x-axis after reset x-axis immediately,\n      // and then reset y-axis and filter y-axis.\n\n      dataZoomModel.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel, api);\n      });\n    });\n    ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n      // Fullfill all of the range props so that user\n      // is able to get them from chart.getOption().\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n      var percentRange = axisProxy.getDataPercentWindow();\n      var valueRange = axisProxy.getDataValueWindow();\n      dataZoomModel.setRawRange({\n        start: percentRange[0],\n        end: percentRange[1],\n        startValue: valueRange[0],\n        endValue: valueRange[1]\n      }, true);\n    });\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js\n// module id = 1450\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar helper = require(\"./helper\");\n\necharts.registerAction('dataZoom', function (payload, ecModel) {\n  var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) {\n    return model.get(dimNames.axisIndex);\n  });\n  var effectedModels = [];\n  ecModel.eachComponent({\n    mainType: 'dataZoom',\n    query: payload\n  }, function (model, index) {\n    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);\n  });\n  zrUtil.each(effectedModels, function (dataZoomModel, index) {\n    dataZoomModel.setRawRange({\n      start: payload.start,\n      end: payload.end,\n      startValue: payload.startValue,\n      endValue: payload.endValue\n    });\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js\n// module id = 1451\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar each = zrUtil.each;\nvar ATTR = '\\0_ec_hist_store';\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n */\n\nfunction push(ecModel, newSnapshot) {\n  var store = giveStore(ecModel); // If previous dataZoom can not be found,\n  // complete an range with current range.\n\n  each(newSnapshot, function (batchItem, dataZoomId) {\n    var i = store.length - 1;\n\n    for (; i >= 0; i--) {\n      var snapshot = store[i];\n\n      if (snapshot[dataZoomId]) {\n        break;\n      }\n    }\n\n    if (i < 0) {\n      // No origin range set, create one by current range.\n      var dataZoomModel = ecModel.queryComponents({\n        mainType: 'dataZoom',\n        subType: 'select',\n        id: dataZoomId\n      })[0];\n\n      if (dataZoomModel) {\n        var percentRange = dataZoomModel.getPercentRange();\n        store[0][dataZoomId] = {\n          dataZoomId: dataZoomId,\n          start: percentRange[0],\n          end: percentRange[1]\n        };\n      }\n    }\n  });\n  store.push(newSnapshot);\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {Object} snapshot\n */\n\n\nfunction pop(ecModel) {\n  var store = giveStore(ecModel);\n  var head = store[store.length - 1];\n  store.length > 1 && store.pop(); // Find top for all dataZoom.\n\n  var snapshot = {};\n  each(head, function (batchItem, dataZoomId) {\n    for (var i = store.length - 1; i >= 0; i--) {\n      var batchItem = store[i][dataZoomId];\n\n      if (batchItem) {\n        snapshot[dataZoomId] = batchItem;\n        break;\n      }\n    }\n  });\n  return snapshot;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction clear(ecModel) {\n  ecModel[ATTR] = null;\n}\n/**\n * @param {module:echarts/model/Global} ecModel\n * @return {number} records. always >= 1.\n */\n\n\nfunction count(ecModel) {\n  return giveStore(ecModel).length;\n}\n/**\n * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n * History length of each dataZoom may be different.\n * this._history[0] is used to store origin range.\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(ecModel) {\n  var store = ecModel[ATTR];\n\n  if (!store) {\n    store = ecModel[ATTR] = [{}];\n  }\n\n  return store;\n}\n\nexports.push = push;\nexports.pop = pop;\nexports.clear = clear;\nexports.count = count;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/history.js\n// module id = 1452\n// module chunks = 2","\n\nexport const tronAddresses = [\n  '27d3byPxZXKQWfXX7sJvemJJuv5M65F3vjS',\n  '27fXgQ46DcjEsZ444tjZPKULcxiUfDrDjqj',\n  '27SWXcHuQgFf9uv49FknBBBYBaH3DUk4JPx',\n  '27WtBq2KoSy5v8VnVZBZHHJcDuWNiSgjbE3',\n];\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/tron.js","import React, {Component} from \"react\";\nimport {Client} from \"../../../services/api\";\nimport {FormattedNumber} from \"react-intl\";\nimport {TRXPrice} from \"../../common/Price\";\nimport {tu} from \"../../../utils/i18n\";\n\nexport default class RichList extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      richList: [],\n      totals: {\n        accounts: 0,\n        coins: 0,\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.load();\n  }\n\n  async load() {\n    let {data, total} = await Client.getRichList();\n\n    this.setState({\n      richList: data,\n      totals: total,\n    });\n  }\n\n  render() {\n\n    let {richList, totals} = this.state;\n\n    return (\n        <div className=\"card\">\n          <div className=\"card-body\">\n            <h5 className=\"card-title text-center\">\n              {tu(\"rich_list\")}\n            </h5>\n          </div>\n          <table className=\"table table-hover bg-white m-0 table-striped\">\n            <thead className=\"thead-dark\">\n              <tr>\n                <th>{tu(\"balance\")}</th>\n                <th className=\"d-none d-lg-table-cell\">{tu(\"addresses\")}</th>\n                <th className=\"text-nowrap text-right\">% {tu(\"addresses\")}</th>\n                <th className=\"text-right d-none d-md-table-cell\">{tu(\"TRX\")}</th>\n                <th className=\"text-right\">$ {tu(\"USD\")}</th>\n                <th className=\"text-right  d-none d-md-table-cell\">% {tu(\"Coins\")}</th>\n              </tr>\n            </thead>\n            <tbody>\n            {\n              richList.map((row, index) => (\n                <tr key={index}>\n                  <th>\n                    <FormattedNumber value={row.from}/>{' - '}\n                    <FormattedNumber value={row.to} />\n                  </th>\n                  <td className=\"d-none d-lg-table-cell\">\n                    {row.accounts}\n                  </td>\n                  <td className=\"text-right text-nowrap\" style={{width: 100}}>\n                    <FormattedNumber value={(row.accounts / totals.accounts) * 100}\n                                     maximumFractionDigits={2}\n                                     minimumFractionDigits={2} /> %\n                  </td>\n                  <td className=\"text-right text-nowrap d-none d-md-table-cell\">\n                    <TRXPrice amount={row.balance} />\n                  </td>\n                  <td className=\"text-right text-nowrap\">\n                    <TRXPrice amount={row.balance} currency=\"USD\" />\n                  </td>\n                  <td className=\"text-right text-nowrap d-none d-md-table-cell\">\n                    <FormattedNumber value={(row.balance / totals.coins) * 100}\n                                     maximumFractionDigits={4}\n                                     minimumFractionDigits={4}/> %\n                  </td>\n                </tr>\n              ))\n            }\n            </tbody>\n          </table>\n        </div>\n    )\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/blockchain/Statistics/RichList.js","import React from 'react'\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/pie'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\n\nexport class PieReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      pieId: 'pie' + id\n    }\n  }\n\n  initPie(id) {\n    let { data }=this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.pieChart.series[0].data = [];\n    config.pieChart.title.text=\"\";\n\n    if (data && data.length > 0) {\n      config.pieChart.series[0].data = data;\n    }\n    if(data && data.length===0){\n      config.pieChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.pieChart);\n  }\n\n\n  componentDidMount() {\n    this.initPie(this.state.pieId);\n  }\n\n  componentDidUpdate() {\n    this.initPie(this.state.pieId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.pieId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nexport default PieReact\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/PieChart.js","import React from 'react'\nimport {injectIntl} from \"react-intl\";\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/line'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport 'echarts/lib/component/dataZoom'\nimport 'echarts/lib/component/toolbox'\nimport 'echarts/lib/component/markPoint'\n\nimport {connect} from \"react-redux\";\n\nexport class LineReactTx extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      lineId: 'lineTx' + id\n    }\n  }\n\n  initLine(id) {\n    let {intl, data} = this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.txOverviewChart.title.text='';\n    config.txOverviewChart.xAxis[0].data = [];\n    config.txOverviewChart.series[0].data = [];\n   // config.txOverviewChart.yAxis[0].name =  intl.formatMessage({id: 'transactions_per_day'});\n\n    if(data && data.length>0) {\n      data.map((val) => {\n        let temp;\n        temp={...val,value:val.totalTransaction};\n        config.txOverviewChart.xAxis[0].data.push(intl.formatDate(val.date));\n        config.txOverviewChart.series[0].data.push(temp);\n      })\n    }\n    if(data && data.length===0){\n      config.txOverviewChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.txOverviewChart);\n\n  }\n\n  componentDidMount() {\n    this.initLine(this.state.lineId);\n  }\n\n  componentDidUpdate() {\n    this.initLine(this.state.lineId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.lineId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {}\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(LineReactTx));\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/LineChartTx.js","require(\"./dataZoom/typeDefaulter\");\n\nrequire(\"./dataZoom/DataZoomModel\");\n\nrequire(\"./dataZoom/DataZoomView\");\n\nrequire(\"./dataZoom/SliderZoomModel\");\n\nrequire(\"./dataZoom/SliderZoomView\");\n\nrequire(\"./dataZoom/InsideZoomModel\");\n\nrequire(\"./dataZoom/InsideZoomView\");\n\nrequire(\"./dataZoom/dataZoomProcessor\");\n\nrequire(\"./dataZoom/dataZoomAction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom.js\n// module id = 1626\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar helper = require(\"./helper\");\n\nvar each = zrUtil.each;\nvar asc = numberUtil.asc;\n/**\n * Operate single axis.\n * One axis can only operated by one axis operator.\n * Different dataZoomModels may be defined to operate the same axis.\n * (i.e. 'inside' data zoom and 'slider' data zoom components)\n * So dataZoomModels share one axisProxy in that case.\n *\n * @class\n */\n\nvar AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this._dimName = dimName;\n  /**\n   * @private\n   */\n\n  this._axisIndex = axisIndex;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._valueWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._percentWindow;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._dataExtent;\n  /**\n   * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n   * @private\n   * @type {Object}\n   */\n\n  this._minMaxSpan;\n  /**\n   * @readOnly\n   * @type {module: echarts/model/Global}\n   */\n\n  this.ecModel = ecModel;\n  /**\n   * @private\n   * @type {module: echarts/component/dataZoom/DataZoomModel}\n   */\n\n  this._dataZoomModel = dataZoomModel; // /**\n  //  * @readOnly\n  //  * @private\n  //  */\n  // this.hasSeriesStacked;\n};\n\nAxisProxy.prototype = {\n  constructor: AxisProxy,\n\n  /**\n   * Whether the axisProxy is hosted by dataZoomModel.\n   *\n   * @public\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   * @return {boolean}\n   */\n  hostedBy: function (dataZoomModel) {\n    return this._dataZoomModel === dataZoomModel;\n  },\n\n  /**\n   * @return {Array.<number>} Value can only be NaN or finite value.\n   */\n  getDataValueWindow: function () {\n    return this._valueWindow.slice();\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getDataPercentWindow: function () {\n    return this._percentWindow.slice();\n  },\n\n  /**\n   * @public\n   * @param {number} axisIndex\n   * @return {Array} seriesModels\n   */\n  getTargetSeriesModels: function () {\n    var seriesModels = [];\n    var ecModel = this.ecModel;\n    ecModel.eachSeries(function (seriesModel) {\n      if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n        var dimName = this._dimName;\n        var axisModel = ecModel.queryComponents({\n          mainType: dimName + 'Axis',\n          index: seriesModel.get(dimName + 'AxisIndex'),\n          id: seriesModel.get(dimName + 'AxisId')\n        })[0];\n\n        if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n          seriesModels.push(seriesModel);\n        }\n      }\n    }, this);\n    return seriesModels;\n  },\n  getAxisModel: function () {\n    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n  },\n  getOtherAxisModel: function () {\n    var axisDim = this._dimName;\n    var ecModel = this.ecModel;\n    var axisModel = this.getAxisModel();\n    var isCartesian = axisDim === 'x' || axisDim === 'y';\n    var otherAxisDim;\n    var coordSysIndexName;\n\n    if (isCartesian) {\n      coordSysIndexName = 'gridIndex';\n      otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n    } else {\n      coordSysIndexName = 'polarIndex';\n      otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n    }\n\n    var foundOtherAxisModel;\n    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n      if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {\n        foundOtherAxisModel = otherAxisModel;\n      }\n    });\n    return foundOtherAxisModel;\n  },\n  getMinMaxSpan: function () {\n    return zrUtil.clone(this._minMaxSpan);\n  },\n\n  /**\n   * Only calculate by given range and this._dataExtent, do not change anything.\n   *\n   * @param {Object} opt\n   * @param {number} [opt.start]\n   * @param {number} [opt.end]\n   * @param {number} [opt.startValue]\n   * @param {number} [opt.endValue]\n   */\n  calculateDataWindow: function (opt) {\n    var dataExtent = this._dataExtent;\n    var axisModel = this.getAxisModel();\n    var scale = axisModel.axis.scale;\n\n    var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n    var percentExtent = [0, 100];\n    var percentWindow = [opt.start, opt.end];\n    var valueWindow = [];\n    each(['startValue', 'endValue'], function (prop) {\n      valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n    }); // Normalize bound.\n\n    each([0, 1], function (idx) {\n      var boundValue = valueWindow[idx];\n      var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n      // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n      // for cases that a dataZoom component controls multiple axes with different\n      // unit or extent, and the latter one is suitable for accurate zoom by pixel\n      // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n      // but it is awkward that `percentProp` can not be obtained from `valueProp`\n      // accurately (because all of values that are overflow the `dataExtent` will\n      // be calculated to percent '100%'). So we have to use\n      // `dataZoom.getRangePropMode()` to mark which prop is used.\n      // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n      // it remains its original value.\n\n      if (rangePropMode[idx] === 'percent') {\n        if (boundPercent == null) {\n          boundPercent = percentExtent[idx];\n        } // Use scale.parse to math round for category or time axis.\n\n\n        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));\n      } else {\n        // Calculating `percent` from `value` may be not accurate, because\n        // This calculation can not be inversed, because all of values that\n        // are overflow the `dataExtent` will be calculated to percent '100%'\n        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);\n      } // valueWindow[idx] = round(boundValue);\n      // percentWindow[idx] = round(boundPercent);\n\n\n      valueWindow[idx] = boundValue;\n      percentWindow[idx] = boundPercent;\n    });\n    return {\n      valueWindow: asc(valueWindow),\n      percentWindow: asc(percentWindow)\n    };\n  },\n\n  /**\n   * Notice: reset should not be called before series.restoreData() called,\n   * so it is recommanded to be called in \"process stage\" but not \"model init\n   * stage\".\n   *\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  reset: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var targetSeries = this.getTargetSeriesModels(); // Culculate data window and data extent, and record them.\n\n    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries); // this.hasSeriesStacked = false;\n    // each(targetSeries, function (series) {\n    // var data = series.getData();\n    // var dataDim = data.mapDimension(this._dimName);\n    // var stackedDimension = data.getCalculationInfo('stackedDimension');\n    // if (stackedDimension && stackedDimension === dataDim) {\n    // this.hasSeriesStacked = true;\n    // }\n    // }, this);\n\n    var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n    this._valueWindow = dataWindow.valueWindow;\n    this._percentWindow = dataWindow.percentWindow;\n    setMinMaxSpan(this); // Update axis setting then.\n\n    setAxisModel(this);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  restore: function (dataZoomModel) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    this._valueWindow = this._percentWindow = null;\n    setAxisModel(this, true);\n  },\n\n  /**\n   * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n   */\n  filterData: function (dataZoomModel, api) {\n    if (dataZoomModel !== this._dataZoomModel) {\n      return;\n    }\n\n    var axisDim = this._dimName;\n    var seriesModels = this.getTargetSeriesModels();\n    var filterMode = dataZoomModel.get('filterMode');\n    var valueWindow = this._valueWindow;\n\n    if (filterMode === 'none') {\n      return;\n    } // FIXME\n    // Toolbox may has dataZoom injected. And if there are stacked bar chart\n    // with NaN data, NaN will be filtered and stack will be wrong.\n    // So we need to force the mode to be set empty.\n    // In fect, it is not a big deal that do not support filterMode-'filter'\n    // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n    // selection\" some day, which might need \"adapt to data extent on the\n    // otherAxis\", which is disabled by filterMode-'empty'.\n    // But currently, stack has been fixed to based on value but not index,\n    // so this is not an issue any more.\n    // var otherAxisModel = this.getOtherAxisModel();\n    // if (dataZoomModel.get('$fromToolbox')\n    //     && otherAxisModel\n    //     && otherAxisModel.hasSeriesStacked\n    // ) {\n    //     filterMode = 'empty';\n    // }\n    // TODO\n    // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.\n    // Process series data\n\n\n    each(seriesModels, function (seriesModel) {\n      var seriesData = seriesModel.getData();\n      var dataDims = seriesData.mapDimension(axisDim, true);\n\n      if (filterMode === 'weakFilter') {\n        seriesData.filterSelf(function (dataIndex) {\n          var leftOut;\n          var rightOut;\n          var hasValue;\n\n          for (var i = 0; i < dataDims.length; i++) {\n            var value = seriesData.get(dataDims[i], dataIndex);\n            var thisHasValue = !isNaN(value);\n            var thisLeftOut = value < valueWindow[0];\n            var thisRightOut = value > valueWindow[1];\n\n            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n              return true;\n            }\n\n            thisHasValue && (hasValue = true);\n            thisLeftOut && (leftOut = true);\n            thisRightOut && (rightOut = true);\n          } // If both left out and right out, do not filter.\n\n\n          return hasValue && leftOut && rightOut;\n        });\n      } else {\n        each(dataDims, function (dim) {\n          if (filterMode === 'empty') {\n            seriesModel.setData(seriesData.map(dim, function (value) {\n              return !isInWindow(value) ? NaN : value;\n            }));\n          } else {\n            var range = {};\n            range[dim] = valueWindow; // console.time('select');\n\n            seriesData.selectRange(range); // console.timeEnd('select');\n          }\n        });\n      }\n\n      each(dataDims, function (dim) {\n        seriesData.setApproximateExtent(valueWindow, dim);\n      });\n    });\n\n    function isInWindow(value) {\n      return value >= valueWindow[0] && value <= valueWindow[1];\n    }\n  }\n};\n\nfunction calculateDataExtent(axisProxy, axisDim, seriesModels) {\n  var dataExtent = [Infinity, -Infinity];\n  each(seriesModels, function (seriesModel) {\n    var seriesData = seriesModel.getData();\n\n    if (seriesData) {\n      each(seriesData.mapDimension(axisDim, true), function (dim) {\n        var seriesExtent = seriesData.getApproximateExtent(dim);\n        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n      });\n    }\n  });\n\n  if (dataExtent[1] < dataExtent[0]) {\n    dataExtent = [NaN, NaN];\n  } // It is important to get \"consistent\" extent when more then one axes is\n  // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n  // when zooming. But it is difficult to know what is \"consistent\", considering\n  // axes have different type or even different meanings (For example, two\n  // time axes are used to compare data of the same date in different years).\n  // So basically dataZoom just obtains extent by series.data (in category axis\n  // extent can be obtained from axis.data).\n  // Nevertheless, user can set min/max/scale on axes to make extent of axes\n  // consistent.\n\n\n  fixExtentByAxis(axisProxy, dataExtent);\n  return dataExtent;\n}\n\nfunction fixExtentByAxis(axisProxy, dataExtent) {\n  var axisModel = axisProxy.getAxisModel();\n  var min = axisModel.getMin(true); // For category axis, if min/max/scale are not set, extent is determined\n  // by axis.data by default.\n\n  var isCategoryAxis = axisModel.get('type') === 'category';\n  var axisDataLen = isCategoryAxis && axisModel.getCategories().length;\n\n  if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n    dataExtent[0] = min;\n  } else if (isCategoryAxis) {\n    dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n  }\n\n  var max = axisModel.getMax(true);\n\n  if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n    dataExtent[1] = max;\n  } else if (isCategoryAxis) {\n    dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n  }\n\n  if (!axisModel.get('scale', true)) {\n    dataExtent[0] > 0 && (dataExtent[0] = 0);\n    dataExtent[1] < 0 && (dataExtent[1] = 0);\n  } // For value axis, if min/max/scale are not set, we just use the extent obtained\n  // by series data, which may be a little different from the extent calculated by\n  // `axisHelper.getScaleExtent`. But the different just affects the experience a\n  // little when zooming. So it will not be fixed until some users require it strongly.\n\n\n  return dataExtent;\n}\n\nfunction setAxisModel(axisProxy, isRestore) {\n  var axisModel = axisProxy.getAxisModel();\n  var percentWindow = axisProxy._percentWindow;\n  var valueWindow = axisProxy._valueWindow;\n\n  if (!percentWindow) {\n    return;\n  } // [0, 500]: arbitrary value, guess axis extent.\n\n\n  var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n  precision = Math.min(precision, 20); // isRestore or isFull\n\n  var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;\n  axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));\n}\n\nfunction setMinMaxSpan(axisProxy) {\n  var minMaxSpan = axisProxy._minMaxSpan = {};\n  var dataZoomModel = axisProxy._dataZoomModel;\n  each(['min', 'max'], function (minMax) {\n    minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n\n    var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n\n    if (valueSpan != null) {\n      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n      valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n\n      if (valueSpan != null) {\n        var dataExtent = axisProxy._dataExtent;\n        minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n      }\n    }\n  });\n}\n\nvar _default = AxisProxy;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js\n// module id = 1627\n// module chunks = 2","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar SliderZoomModel = DataZoomModel.extend({\n  type: 'dataZoom.slider',\n  layoutMode: 'box',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    show: true,\n    // ph => placeholder. Using placehoder here because\n    // deault value can only be drived in view stage.\n    right: 'ph',\n    // Default align to grid rect.\n    top: 'ph',\n    // Default align to grid rect.\n    width: 'ph',\n    // Default align to grid rect.\n    height: 'ph',\n    // Default align to grid rect.\n    left: null,\n    // Default align to grid rect.\n    bottom: null,\n    // Default align to grid rect.\n    backgroundColor: 'rgba(47,69,84,0)',\n    // Background of slider zoom component.\n    // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,\n    // highest priority, remain for compatibility of\n    // previous version, but not recommended any more.\n    dataBackground: {\n      lineStyle: {\n        color: '#2f4554',\n        width: 0.5,\n        opacity: 0.3\n      },\n      areaStyle: {\n        color: 'rgba(47,69,84,0.3)',\n        opacity: 0.3\n      }\n    },\n    borderColor: '#ddd',\n    // border color of the box. For compatibility,\n    // if dataBackgroundColor is set, borderColor\n    // is ignored.\n    fillerColor: 'rgba(167,183,204,0.4)',\n    // Color of selected area.\n    // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.\n    // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',\n    handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z',\n    // Percent of the slider height\n    handleSize: '100%',\n    handleStyle: {\n      color: '#a7b7cc'\n    },\n    labelPrecision: null,\n    labelFormatter: null,\n    showDetail: true,\n    showDataShadow: 'auto',\n    // Default auto decision.\n    realtime: true,\n    zoomLock: false,\n    // Whether disable zoom.\n    textStyle: {\n      color: '#333'\n    }\n  }\n});\nvar _default = SliderZoomModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js\n// module id = 1628\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar throttle = require(\"../../util/throttle\");\n\nvar DataZoomView = require(\"./DataZoomView\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar layout = require(\"../../util/layout\");\n\nvar sliderMove = require(\"../helper/sliderMove\");\n\nvar Rect = graphic.Rect;\nvar linearMap = numberUtil.linearMap;\nvar asc = numberUtil.asc;\nvar bind = zrUtil.bind;\nvar each = zrUtil.each; // Constants\n\nvar DEFAULT_LOCATION_EDGE_GAP = 7;\nvar DEFAULT_FRAME_BORDER_WIDTH = 1;\nvar DEFAULT_FILLER_SIZE = 30;\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar LABEL_GAP = 5;\nvar SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\nvar SliderZoomView = DataZoomView.extend({\n  type: 'dataZoom.slider',\n  init: function (ecModel, api) {\n    /**\n     * @private\n     * @type {Object}\n     */\n    this._displayables = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this._orient;\n    /**\n     * [0, 100]\n     * @private\n     */\n\n    this._range;\n    /**\n     * [coord of the first handle, coord of the second handle]\n     * @private\n     */\n\n    this._handleEnds;\n    /**\n     * [length, thick]\n     * @private\n     * @type {Array.<number>}\n     */\n\n    this._size;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleWidth;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this._handleHeight;\n    /**\n     * @private\n     */\n\n    this._location;\n    /**\n     * @private\n     */\n\n    this._dragging;\n    /**\n     * @private\n     */\n\n    this._dataShadowInfo;\n    this.api = api;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    SliderZoomView.superApply(this, 'render', arguments);\n    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');\n    this._orient = dataZoomModel.get('orient');\n\n    if (this.dataZoomModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    } // Notice: this._resetInterval() should not be executed when payload.type\n    // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'\n    // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,\n\n\n    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n      this._buildView();\n    }\n\n    this._updateView();\n  },\n\n  /**\n   * @override\n   */\n  remove: function () {\n    SliderZoomView.superApply(this, 'remove', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    SliderZoomView.superApply(this, 'dispose', arguments);\n    throttle.clear(this, '_dispatchZoomAction');\n  },\n  _buildView: function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n\n    this._resetLocation();\n\n    this._resetInterval();\n\n    var barGroup = this._displayables.barGroup = new graphic.Group();\n\n    this._renderBackground();\n\n    this._renderHandle();\n\n    this._renderDataShadow();\n\n    thisGroup.add(barGroup);\n\n    this._positionGroup();\n  },\n\n  /**\n   * @private\n   */\n  _resetLocation: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var api = this.api; // If some of x/y/width/height are not specified,\n    // auto-adapt according to target grid.\n\n    var coordRect = this._findCoordRect();\n\n    var ecSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    }; // Default align by coordinate system rect.\n\n    var positionInfo = this._orient === HORIZONTAL ? {\n      // Why using 'right', because right should be used in vertical,\n      // and it is better to be consistent for dealing with position param merge.\n      right: ecSize.width - coordRect.x - coordRect.width,\n      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,\n      width: coordRect.width,\n      height: DEFAULT_FILLER_SIZE\n    } : {\n      // vertical\n      right: DEFAULT_LOCATION_EDGE_GAP,\n      top: coordRect.y,\n      width: DEFAULT_FILLER_SIZE,\n      height: coordRect.height\n    }; // Do not write back to option and replace value 'ph', because\n    // the 'ph' value should be recalculated when resize.\n\n    var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value.\n\n    zrUtil.each(['right', 'top', 'width', 'height'], function (name) {\n      if (layoutParams[name] === 'ph') {\n        layoutParams[name] = positionInfo[name];\n      }\n    });\n    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);\n    this._location = {\n      x: layoutRect.x,\n      y: layoutRect.y\n    };\n    this._size = [layoutRect.width, layoutRect.height];\n    this._orient === VERTICAL && this._size.reverse();\n  },\n\n  /**\n   * @private\n   */\n  _positionGroup: function () {\n    var thisGroup = this.group;\n    var location = this._location;\n    var orient = this._orient; // Just use the first axis to determine mapping.\n\n    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n    var inverse = targetAxisModel && targetAxisModel.get('inverse');\n    var barGroup = this._displayables.barGroup;\n    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup.\n\n    barGroup.attr(orient === HORIZONTAL && !inverse ? {\n      scale: otherAxisInverse ? [1, 1] : [1, -1]\n    } : orient === HORIZONTAL && inverse ? {\n      scale: otherAxisInverse ? [-1, 1] : [-1, -1]\n    } : orient === VERTICAL && !inverse ? {\n      scale: otherAxisInverse ? [1, -1] : [1, 1],\n      rotation: Math.PI / 2 // Dont use Math.PI, considering shadow direction.\n\n    } : {\n      scale: otherAxisInverse ? [-1, -1] : [-1, 1],\n      rotation: Math.PI / 2\n    }); // Position barGroup\n\n    var rect = thisGroup.getBoundingRect([barGroup]);\n    thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]);\n  },\n\n  /**\n   * @private\n   */\n  _getViewExtent: function () {\n    return [0, this._size[0]];\n  },\n  _renderBackground: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var size = this._size;\n    var barGroup = this._displayables.barGroup;\n    barGroup.add(new Rect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: dataZoomModel.get('backgroundColor')\n      },\n      z2: -40\n    })); // Click panel, over shadow, below handles.\n\n    barGroup.add(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        fill: 'transparent'\n      },\n      z2: 0,\n      onclick: zrUtil.bind(this._onClickPanelClick, this)\n    }));\n  },\n  _renderDataShadow: function () {\n    var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n    if (!info) {\n      return;\n    }\n\n    var size = this._size;\n    var seriesModel = info.series;\n    var data = seriesModel.getRawData();\n    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick\n    : info.otherDim;\n\n    if (otherDim == null) {\n      return;\n    }\n\n    var otherDataExtent = data.getDataExtent(otherDim); // Nice extent.\n\n    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];\n    var otherShadowExtent = [0, size[1]];\n    var thisShadowExtent = [0, size[0]];\n    var areaPoints = [[size[0], 0], [0, 0]];\n    var linePoints = [];\n    var step = thisShadowExtent[1] / (data.count() - 1);\n    var thisCoord = 0; // Optimize for large data shadow\n\n    var stride = Math.round(data.count() / size[0]);\n    var lastIsEmpty;\n    data.each([otherDim], function (value, index) {\n      if (stride > 0 && index % stride) {\n        thisCoord += step;\n        return;\n      } // FIXME\n      // Should consider axis.min/axis.max when drawing dataShadow.\n      // FIXME\n      // list\n\n\n      var isEmpty = value == null || isNaN(value) || value === ''; // See #4235.\n\n      var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value.\n\n      if (isEmpty && !lastIsEmpty && index) {\n        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n        linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n      } else if (!isEmpty && lastIsEmpty) {\n        areaPoints.push([thisCoord, 0]);\n        linePoints.push([thisCoord, 0]);\n      }\n\n      areaPoints.push([thisCoord, otherCoord]);\n      linePoints.push([thisCoord, otherCoord]);\n      thisCoord += step;\n      lastIsEmpty = isEmpty;\n    });\n    var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground');\n\n    this._displayables.barGroup.add(new graphic.Polygon({\n      shape: {\n        points: areaPoints\n      },\n      style: zrUtil.defaults({\n        fill: dataZoomModel.get('dataBackgroundColor')\n      }, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle()),\n      silent: true,\n      z2: -20\n    }));\n\n    this._displayables.barGroup.add(new graphic.Polyline({\n      shape: {\n        points: linePoints\n      },\n      style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(),\n      silent: true,\n      z2: -19\n    }));\n  },\n  _prepareDataShadowInfo: function () {\n    var dataZoomModel = this.dataZoomModel;\n    var showDataShadow = dataZoomModel.get('showDataShadow');\n\n    if (showDataShadow === false) {\n      return;\n    } // Find a representative series.\n\n\n    var result;\n    var ecModel = this.ecModel;\n    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n      var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();\n      zrUtil.each(seriesModels, function (seriesModel) {\n        if (result) {\n          return;\n        }\n\n        if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n          return;\n        }\n\n        var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;\n        var otherDim = getOtherDim(dimNames.name);\n        var otherAxisInverse;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (otherDim != null && coordSys.getOtherAxis) {\n          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n        }\n\n        otherDim = seriesModel.getData().mapDimension(otherDim);\n        result = {\n          thisAxis: thisAxis,\n          series: seriesModel,\n          thisDim: dimNames.name,\n          otherDim: otherDim,\n          otherAxisInverse: otherAxisInverse\n        };\n      }, this);\n    }, this);\n    return result;\n  },\n  _renderHandle: function () {\n    var displaybles = this._displayables;\n    var handles = displaybles.handles = [];\n    var handleLabels = displaybles.handleLabels = [];\n    var barGroup = this._displayables.barGroup;\n    var size = this._size;\n    var dataZoomModel = this.dataZoomModel;\n    barGroup.add(displaybles.filler = new Rect({\n      draggable: true,\n      cursor: getCursor(this._orient),\n      drift: bind(this._onDragMove, this, 'all'),\n      onmousemove: function (e) {\n        // Fot mobile devicem, prevent screen slider on the button.\n        eventTool.stop(e.event);\n      },\n      ondragstart: bind(this._showDataInfo, this, true),\n      ondragend: bind(this._onDragEnd, this),\n      onmouseover: bind(this._showDataInfo, this, true),\n      onmouseout: bind(this._showDataInfo, this, false),\n      style: {\n        fill: dataZoomModel.get('fillerColor'),\n        textPosition: 'inside'\n      }\n    })); // Frame border.\n\n    barGroup.add(new Rect(graphic.subPixelOptimizeRect({\n      silent: true,\n      shape: {\n        x: 0,\n        y: 0,\n        width: size[0],\n        height: size[1]\n      },\n      style: {\n        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n        fill: 'rgba(0,0,0,0)'\n      }\n    })));\n    each([0, 1], function (handleIndex) {\n      var path = graphic.createIcon(dataZoomModel.get('handleIcon'), {\n        cursor: getCursor(this._orient),\n        draggable: true,\n        drift: bind(this._onDragMove, this, handleIndex),\n        onmousemove: function (e) {\n          // Fot mobile devicem, prevent screen slider on the button.\n          eventTool.stop(e.event);\n        },\n        ondragend: bind(this._onDragEnd, this),\n        onmouseover: bind(this._showDataInfo, this, true),\n        onmouseout: bind(this._showDataInfo, this, false)\n      }, {\n        x: -1,\n        y: 0,\n        width: 2,\n        height: 2\n      });\n      var bRect = path.getBoundingRect();\n      this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]);\n      this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n      var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version\n\n      if (handleColor != null) {\n        path.style.fill = handleColor;\n      }\n\n      barGroup.add(handles[handleIndex] = path);\n      var textStyleModel = dataZoomModel.textStyleModel;\n      this.group.add(handleLabels[handleIndex] = new graphic.Text({\n        silent: true,\n        invisible: true,\n        style: {\n          x: 0,\n          y: 0,\n          text: '',\n          textVerticalAlign: 'middle',\n          textAlign: 'center',\n          textFill: textStyleModel.getTextColor(),\n          textFont: textStyleModel.getFont()\n        },\n        z2: 10\n      }));\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  _resetInterval: function () {\n    var range = this._range = this.dataZoomModel.getPercentRange();\n\n    var viewExtent = this._getViewExtent();\n\n    this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];\n  },\n\n  /**\n   * @private\n   * @param {(number|string)} handleIndex 0 or 1 or 'all'\n   * @param {number} delta\n   */\n  _updateInterval: function (handleIndex, delta) {\n    var dataZoomModel = this.dataZoomModel;\n    var handleEnds = this._handleEnds;\n\n    var viewExtend = this._getViewExtent();\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    var percentExtent = [0, 100];\n    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n    this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);\n  },\n\n  /**\n   * @private\n   */\n  _updateView: function (nonRealtime) {\n    var displaybles = this._displayables;\n    var handleEnds = this._handleEnds;\n    var handleInterval = asc(handleEnds.slice());\n    var size = this._size;\n    each([0, 1], function (handleIndex) {\n      // Handles\n      var handle = displaybles.handles[handleIndex];\n      var handleHeight = this._handleHeight;\n      handle.attr({\n        scale: [handleHeight / 2, handleHeight / 2],\n        position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]\n      });\n    }, this); // Filler\n\n    displaybles.filler.setShape({\n      x: handleInterval[0],\n      y: 0,\n      width: handleInterval[1] - handleInterval[0],\n      height: size[1]\n    });\n\n    this._updateDataInfo(nonRealtime);\n  },\n\n  /**\n   * @private\n   */\n  _updateDataInfo: function (nonRealtime) {\n    var dataZoomModel = this.dataZoomModel;\n    var displaybles = this._displayables;\n    var handleLabels = displaybles.handleLabels;\n    var orient = this._orient;\n    var labelTexts = ['', '']; // FIXME\n    // dateformatterautoformatterec2 date.getAutoFormatter\n\n    if (dataZoomModel.get('showDetail')) {\n      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n      if (axisProxy) {\n        var axis = axisProxy.getAxisModel().axis;\n        var range = this._range;\n        var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.\n        ? axisProxy.calculateDataWindow({\n          start: range[0],\n          end: range[1]\n        }).valueWindow : axisProxy.getDataValueWindow();\n        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n      }\n    }\n\n    var orderedHandleEnds = asc(this._handleEnds.slice());\n    setLabel.call(this, 0);\n    setLabel.call(this, 1);\n\n    function setLabel(handleIndex) {\n      // Label\n      // Text should not transform by barGroup.\n      // Ignore handlers transform\n      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);\n      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n      var offset = this._handleWidth / 2 + LABEL_GAP;\n      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n        textAlign: orient === HORIZONTAL ? direction : 'center',\n        text: labelTexts[handleIndex]\n      });\n    }\n  },\n\n  /**\n   * @private\n   */\n  _formatLabel: function (value, axis) {\n    var dataZoomModel = this.dataZoomModel;\n    var labelFormatter = dataZoomModel.get('labelFormatter');\n    var labelPrecision = dataZoomModel.get('labelPrecision');\n\n    if (labelPrecision == null || labelPrecision === 'auto') {\n      labelPrecision = axis.getPixelPrecision();\n    }\n\n    var valueStr = value == null || isNaN(value) ? '' // FIXME Glue code\n    : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20.\n    : value.toFixed(Math.min(labelPrecision, 20));\n    return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n  },\n\n  /**\n   * @private\n   * @param {boolean} showOrHide true: show, false: hide\n   */\n  _showDataInfo: function (showOrHide) {\n    // Always show when drgging.\n    showOrHide = this._dragging || showOrHide;\n    var handleLabels = this._displayables.handleLabels;\n    handleLabels[0].attr('invisible', !showOrHide);\n    handleLabels[1].attr('invisible', !showOrHide);\n  },\n  _onDragMove: function (handleIndex, dx, dy) {\n    this._dragging = true; // Transform dx, dy to bar coordination.\n\n    var barTransform = this._displayables.barGroup.getLocalTransform();\n\n    var vertex = graphic.applyTransform([dx, dy], barTransform, true);\n\n    this._updateInterval(handleIndex, vertex[0]);\n\n    var realtime = this.dataZoomModel.get('realtime');\n\n    this._updateView(!realtime);\n\n    realtime && this._dispatchZoomAction();\n  },\n  _onDragEnd: function () {\n    this._dragging = false;\n\n    this._showDataInfo(false); // While in realtime mode and stream mode, dispatch action when\n    // drag end will cause the whole view rerender, which is unnecessary.\n\n\n    var realtime = this.dataZoomModel.get('realtime');\n    !realtime && this._dispatchZoomAction();\n  },\n  _onClickPanelClick: function (e) {\n    var size = this._size;\n\n    var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n      return;\n    }\n\n    var handleEnds = this._handleEnds;\n    var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n    this._updateInterval('all', localPoint[0] - center);\n\n    this._updateView();\n\n    this._dispatchZoomAction();\n  },\n\n  /**\n   * This action will be throttled.\n   * @private\n   */\n  _dispatchZoomAction: function () {\n    var range = this._range;\n    this.api.dispatchAction({\n      type: 'dataZoom',\n      from: this.uid,\n      dataZoomId: this.dataZoomModel.id,\n      start: range[0],\n      end: range[1]\n    });\n  },\n\n  /**\n   * @private\n   */\n  _findCoordRect: function () {\n    // Find the grid coresponding to the first axis referred by dataZoom.\n    var rect;\n    each(this.getTargetCoordInfo(), function (coordInfoList) {\n      if (!rect && coordInfoList.length) {\n        var coordSys = coordInfoList[0].model.coordinateSystem;\n        rect = coordSys.getRect && coordSys.getRect();\n      }\n    });\n\n    if (!rect) {\n      var width = this.api.getWidth();\n      var height = this.api.getHeight();\n      rect = {\n        x: width * 0.2,\n        y: height * 0.2,\n        width: width * 0.6,\n        height: height * 0.6\n      };\n    }\n\n    return rect;\n  }\n});\n\nfunction getOtherDim(thisDim) {\n  // FIXME\n  // getOtherAxis\n  var map = {\n    x: 'y',\n    y: 'x',\n    radius: 'angle',\n    angle: 'radius'\n  };\n  return map[thisDim];\n}\n\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n\nvar _default = SliderZoomView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SliderZoomView.js\n// module id = 1629\n// module chunks = 2","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @protected\n   */\n  defaultOption: {\n    disabled: false,\n    // Whether disable this inside zoom.\n    zoomLock: false,\n    // Whether disable zoom but only pan.\n    zoomOnMouseWheel: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    moveOnMouseMove: true,\n    // Can be: true / false / 'shift' / 'ctrl' / 'alt'.\n    preventDefaultMouseMove: true\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js\n// module id = 1630\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar DataZoomView = require(\"./DataZoomView\");\n\nvar sliderMove = require(\"../helper/sliderMove\");\n\nvar roams = require(\"./roams\");\n\nvar bind = zrUtil.bind;\nvar InsideZoomView = DataZoomView.extend({\n  type: 'dataZoom.inside',\n\n  /**\n   * @override\n   */\n  init: function (ecModel, api) {\n    /**\n     * 'throttle' is used in this.dispatchAction, so we save range\n     * to avoid missing some 'pan' info.\n     * @private\n     * @type {Array.<number>}\n     */\n    this._range;\n  },\n\n  /**\n   * @override\n   */\n  render: function (dataZoomModel, ecModel, api, payload) {\n    InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched\n    // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom'\n    // info will be missed because of 'throttle' of this.dispatchAction.\n\n    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {\n      this._range = dataZoomModel.getPercentRange();\n    } // Reset controllers.\n\n\n    zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) {\n      var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {\n        return roams.generateCoordId(coordInfo.model);\n      });\n      zrUtil.each(coordInfoList, function (coordInfo) {\n        var coordModel = coordInfo.model;\n        var dataZoomOption = dataZoomModel.option;\n        roams.register(api, {\n          coordId: roams.generateCoordId(coordModel),\n          allCoordIds: allCoordIds,\n          containsPoint: function (e, x, y) {\n            return coordModel.coordinateSystem.containPoint([x, y]);\n          },\n          dataZoomId: dataZoomModel.id,\n          throttleRate: dataZoomModel.get('throttle', true),\n          panGetRange: bind(this._onPan, this, coordInfo, coordSysName),\n          zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName),\n          zoomLock: dataZoomOption.zoomLock,\n          disabled: dataZoomOption.disabled,\n          roamControllerOpt: {\n            zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel,\n            moveOnMouseMove: dataZoomOption.moveOnMouseMove,\n            preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove\n          }\n        });\n      }, this);\n    }, this);\n  },\n\n  /**\n   * @override\n   */\n  dispose: function () {\n    roams.unregister(this.api, this.dataZoomModel.id);\n    InsideZoomView.superApply(this, 'dispose', arguments);\n    this._range = null;\n  },\n\n  /**\n   * @private\n   */\n  _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName]([oldX, oldY], [newX, newY], axisModel, controller, coordInfo);\n    var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n    sliderMove(percentDelta, range, [0, 100], 'all');\n    return this._range = range;\n  },\n\n  /**\n   * @private\n   */\n  _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) {\n    var range = this._range.slice(); // Calculate transform by the first axis.\n\n\n    var axisModel = coordInfo.axisModels[0];\n\n    if (!axisModel) {\n      return;\n    }\n\n    var directionInfo = getDirectionInfo[coordSysName](null, [mouseX, mouseY], axisModel, controller, coordInfo);\n    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n    scale = Math.max(1 / scale, 0);\n    range[0] = (range[0] - percentPoint) * scale + percentPoint;\n    range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range.\n\n    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n    return this._range = range;\n  }\n});\nvar getDirectionInfo = {\n  grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.dim === 'x') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // axis.dim === 'y'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var ret = {};\n    var polar = coordInfo.model.coordinateSystem;\n    var radiusExtent = polar.getRadiusAxis().getExtent();\n    var angleExtent = polar.getAngleAxis().getExtent();\n    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n    newPoint = polar.pointToCoord(newPoint);\n\n    if (axisModel.mainType === 'radiusAxis') {\n      ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);\n      // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);\n\n      ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n      ret.pixelStart = radiusExtent[0];\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'angleAxis'\n      ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);\n      // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);\n\n      ret.pixelLength = angleExtent[1] - angleExtent[0];\n      ret.pixelStart = angleExtent[0];\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  },\n  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) {\n    var axis = axisModel.axis;\n    var rect = coordInfo.model.coordinateSystem.getRect();\n    var ret = {};\n    oldPoint = oldPoint || [0, 0];\n\n    if (axis.orient === 'horizontal') {\n      ret.pixel = newPoint[0] - oldPoint[0];\n      ret.pixelLength = rect.width;\n      ret.pixelStart = rect.x;\n      ret.signal = axis.inverse ? 1 : -1;\n    } else {\n      // 'vertical'\n      ret.pixel = newPoint[1] - oldPoint[1];\n      ret.pixelLength = rect.height;\n      ret.pixelStart = rect.y;\n      ret.signal = axis.inverse ? -1 : 1;\n    }\n\n    return ret;\n  }\n};\nvar _default = InsideZoomView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/InsideZoomView.js\n// module id = 1631\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar RoamController = require(\"../../component/helper/RoamController\");\n\nvar throttleUtil = require(\"../../util/throttle\");\n\n// Only create one roam controller for each coordinate system.\n// one roam controller might be refered by two inside data zoom\n// components (for example, one for x and one for y). When user\n// pan or zoom, only dispatch one action for those data zoom\n// components.\nvar curry = zrUtil.curry;\nvar ATTR = '\\0_ec_dataZoom_roams';\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {Object} dataZoomInfo\n * @param {string} dataZoomInfo.coordId\n * @param {Function} dataZoomInfo.containsPoint\n * @param {Array.<string>} dataZoomInfo.allCoordIds\n * @param {string} dataZoomInfo.dataZoomId\n * @param {number} dataZoomInfo.throttleRate\n * @param {Function} dataZoomInfo.panGetRange\n * @param {Function} dataZoomInfo.zoomGetRange\n * @param {boolean} [dataZoomInfo.zoomLock]\n * @param {boolean} [dataZoomInfo.disabled]\n */\n\nfunction register(api, dataZoomInfo) {\n  var store = giveStore(api);\n  var theDataZoomId = dataZoomInfo.dataZoomId;\n  var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system.\n  // Avoid memory leak, dispose all not-used-registered.\n\n  zrUtil.each(store, function (record, coordId) {\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {\n      delete dataZoomInfos[theDataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n  var record = store[theCoordId]; // Create if needed.\n\n  if (!record) {\n    record = store[theCoordId] = {\n      coordId: theCoordId,\n      dataZoomInfos: {},\n      count: 0\n    };\n    record.controller = createController(api, record);\n    record.dispatchAction = zrUtil.curry(dispatchAction, api);\n  } // Update reference of dataZoom.\n\n\n  !record.dataZoomInfos[theDataZoomId] && record.count++;\n  record.dataZoomInfos[theDataZoomId] = dataZoomInfo;\n  var controllerParams = mergeControllerParams(record.dataZoomInfos);\n  record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated.\n\n  record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle.\n\n  throttleUtil.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');\n}\n/**\n * @public\n * @param {module:echarts/ExtensionAPI} api\n * @param {string} dataZoomId\n */\n\n\nfunction unregister(api, dataZoomId) {\n  var store = giveStore(api);\n  zrUtil.each(store, function (record) {\n    record.controller.dispose();\n    var dataZoomInfos = record.dataZoomInfos;\n\n    if (dataZoomInfos[dataZoomId]) {\n      delete dataZoomInfos[dataZoomId];\n      record.count--;\n    }\n  });\n  cleanStore(store);\n}\n/**\n * @public\n */\n\n\nfunction shouldRecordRange(payload, dataZoomId) {\n  if (payload && payload.type === 'dataZoom' && payload.batch) {\n    for (var i = 0, len = payload.batch.length; i < len; i++) {\n      if (payload.batch[i].dataZoomId === dataZoomId) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @public\n */\n\n\nfunction generateCoordId(coordModel) {\n  return coordModel.type + '\\0_' + coordModel.id;\n}\n/**\n * Key: coordId, value: {dataZoomInfos: [], count, controller}\n * @type {Array.<Object>}\n */\n\n\nfunction giveStore(api) {\n  // Mount store on zrender instance, so that we do not\n  // need to worry about dispose.\n  var zr = api.getZr();\n  return zr[ATTR] || (zr[ATTR] = {});\n}\n\nfunction createController(api, newRecord) {\n  var controller = new RoamController(api.getZr());\n  controller.on('pan', curry(onPan, newRecord));\n  controller.on('zoom', curry(onZoom, newRecord));\n  return controller;\n}\n\nfunction cleanStore(store) {\n  zrUtil.each(store, function (record, coordId) {\n    if (!record.count) {\n      record.controller.dispose();\n      delete store[coordId];\n    }\n  });\n}\n\nfunction onPan(record, dx, dy, oldX, oldY, newX, newY) {\n  wrapAndDispatch(record, function (info) {\n    return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY);\n  });\n}\n\nfunction onZoom(record, scale, mouseX, mouseY) {\n  wrapAndDispatch(record, function (info) {\n    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);\n  });\n}\n\nfunction wrapAndDispatch(record, getRange) {\n  var batch = [];\n  zrUtil.each(record.dataZoomInfos, function (info) {\n    var range = getRange(info);\n    !info.disabled && range && batch.push({\n      dataZoomId: info.dataZoomId,\n      start: range[0],\n      end: range[1]\n    });\n  });\n  record.dispatchAction(batch);\n}\n/**\n * This action will be throttled.\n */\n\n\nfunction dispatchAction(api, batch) {\n  api.dispatchAction({\n    type: 'dataZoom',\n    batch: batch\n  });\n}\n/**\n * Merge roamController settings when multiple dataZooms share one roamController.\n */\n\n\nfunction mergeControllerParams(dataZoomInfos) {\n  var controlType;\n  var opt = {}; // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated\n  // as string, it is probably revert to reserved word by compress tool. See #7411.\n\n  var prefix = 'type_';\n  var typePriority = {\n    'type_true': 2,\n    'type_move': 1,\n    'type_false': 0,\n    'type_undefined': -1\n  };\n  zrUtil.each(dataZoomInfos, function (dataZoomInfo) {\n    var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true;\n\n    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {\n      controlType = oneType;\n    } // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys.\n\n\n    zrUtil.extend(opt, dataZoomInfo.roamControllerOpt);\n  });\n  return {\n    controlType: controlType,\n    opt: opt\n  };\n}\n\nexports.register = register;\nexports.unregister = unregister;\nexports.shouldRecordRange = shouldRecordRange;\nexports.generateCoordId = generateCoordId;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/roams.js\n// module id = 1632\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\n/**\n * @alias module:echarts/component/helper/RoamController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\nfunction RoamController(zr) {\n  /**\n   * @type {Function}\n   */\n  this.pointerChecker;\n  /**\n   * @type {module:zrender}\n   */\n\n  this._zr = zr;\n  /**\n   * @type {Object}\n   */\n\n  this._opt = {}; // Avoid two roamController bind the same handler\n\n  var bind = zrUtil.bind;\n  var mousedownHandler = bind(mousedown, this);\n  var mousemoveHandler = bind(mousemove, this);\n  var mouseupHandler = bind(mouseup, this);\n  var mousewheelHandler = bind(mousewheel, this);\n  var pinchHandler = bind(pinch, this);\n  Eventful.call(this);\n  /**\n   * @param {Function} pointerChecker\n   *                   input: x, y\n   *                   output: boolean\n   */\n\n  this.setPointerChecker = function (pointerChecker) {\n    this.pointerChecker = pointerChecker;\n  };\n  /**\n   * Notice: only enable needed types. For example, if 'zoom'\n   * is not needed, 'zoom' should not be enabled, otherwise\n   * default mousewheel behaviour (scroll page) will be disabled.\n   *\n   * @param  {boolean|string} [controlType=true] Specify the control type,\n   *                          which can be null/undefined or true/false\n   *                          or 'pan/move' or 'zoom'/'scale'\n   * @param {Object} [opt]\n   * @param {Object} [opt.zoomOnMouseWheel=true]\n   * @param {Object} [opt.moveOnMouseMove=true]\n   * @param {Object} [opt.preventDefaultMouseMove=true] When pan.\n   */\n\n\n  this.enable = function (controlType, opt) {\n    // Disable previous first\n    this.disable();\n    this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {\n      zoomOnMouseWheel: true,\n      moveOnMouseMove: true,\n      preventDefaultMouseMove: true\n    });\n\n    if (controlType == null) {\n      controlType = true;\n    }\n\n    if (controlType === true || controlType === 'move' || controlType === 'pan') {\n      zr.on('mousedown', mousedownHandler);\n      zr.on('mousemove', mousemoveHandler);\n      zr.on('mouseup', mouseupHandler);\n    }\n\n    if (controlType === true || controlType === 'scale' || controlType === 'zoom') {\n      zr.on('mousewheel', mousewheelHandler);\n      zr.on('pinch', pinchHandler);\n    }\n  };\n\n  this.disable = function () {\n    zr.off('mousedown', mousedownHandler);\n    zr.off('mousemove', mousemoveHandler);\n    zr.off('mouseup', mouseupHandler);\n    zr.off('mousewheel', mousewheelHandler);\n    zr.off('pinch', pinchHandler);\n  };\n\n  this.dispose = this.disable;\n\n  this.isDragging = function () {\n    return this._dragging;\n  };\n\n  this.isPinching = function () {\n    return this._pinching;\n  };\n}\n\nzrUtil.mixin(RoamController, Eventful);\n\nfunction mousedown(e) {\n  if (eventTool.notLeftMouse(e) || e.target && e.target.draggable) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY; // Only check on mosedown, but not mousemove.\n  // Mouse can be out of target when mouse moving.\n\n  if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n    this._x = x;\n    this._y = y;\n    this._dragging = true;\n  }\n}\n\nfunction mousemove(e) {\n  if (eventTool.notLeftMouse(e) || !checkKeyBinding(this, 'moveOnMouseMove', e) || !this._dragging || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var x = e.offsetX;\n  var y = e.offsetY;\n  var oldX = this._x;\n  var oldY = this._y;\n  var dx = x - oldX;\n  var dy = y - oldY;\n  this._x = x;\n  this._y = y;\n  this._opt.preventDefaultMouseMove && eventTool.stop(e.event);\n  this.trigger('pan', dx, dy, oldX, oldY, x, y);\n}\n\nfunction mouseup(e) {\n  if (!eventTool.notLeftMouse(e)) {\n    this._dragging = false;\n  }\n}\n\nfunction mousewheel(e) {\n  // wheelDelta maybe -0 in chrome mac.\n  if (!checkKeyBinding(this, 'zoomOnMouseWheel', e) || e.wheelDelta === 0) {\n    return;\n  } // Convenience:\n  // Mac and VM Windows on Mac: scroll up: zoom out.\n  // Windows: scroll up: zoom in.\n\n\n  var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\n  zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);\n}\n\nfunction pinch(e) {\n  if (interactionMutex.isTaken(this._zr, 'globalPan')) {\n    return;\n  }\n\n  var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n  zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);\n}\n\nfunction zoom(e, zoomDelta, zoomX, zoomY) {\n  if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {\n    // When mouse is out of roamController rect,\n    // default befavoius should not be be disabled, otherwise\n    // page sliding is disabled, contrary to expectation.\n    eventTool.stop(e.event);\n    this.trigger('zoom', zoomDelta, zoomX, zoomY);\n  }\n}\n\nfunction checkKeyBinding(roamController, prop, e) {\n  var setting = roamController._opt[prop];\n  return setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']);\n}\n\nvar _default = RoamController;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/RoamController.js\n// module id = 1633\n// module chunks = 2","require(\"./toolbox/ToolboxModel\");\n\nrequire(\"./toolbox/ToolboxView\");\n\nrequire(\"./toolbox/feature/SaveAsImage\");\n\nrequire(\"./toolbox/feature/MagicType\");\n\nrequire(\"./toolbox/feature/DataView\");\n\nrequire(\"./toolbox/feature/DataZoom\");\n\nrequire(\"./toolbox/feature/Restore\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox.js\n// module id = 1634\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar featureManager = require(\"./featureManager\");\n\nvar ToolboxModel = echarts.extendComponentModel({\n  type: 'toolbox',\n  layoutMode: {\n    type: 'box',\n    ignoreSize: true\n  },\n  mergeDefaultAndTheme: function (option) {\n    ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n    zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n      var Feature = featureManager.get(featureName);\n      Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n    });\n  },\n  defaultOption: {\n    show: true,\n    z: 6,\n    zlevel: 0,\n    orient: 'horizontal',\n    left: 'right',\n    top: 'top',\n    // right\n    // bottom\n    backgroundColor: 'transparent',\n    borderColor: '#ccc',\n    borderRadius: 0,\n    borderWidth: 0,\n    padding: 5,\n    itemSize: 15,\n    itemGap: 8,\n    showTitle: true,\n    iconStyle: {\n      borderColor: '#666',\n      color: 'none'\n    },\n    emphasis: {\n      iconStyle: {\n        borderColor: '#3E98C5'\n      } // textStyle: {},\n      // feature\n\n    }\n  }\n});\nvar _default = ToolboxModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/ToolboxModel.js\n// module id = 1635\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar featureManager = require(\"./featureManager\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\nvar listComponentHelper = require(\"../helper/listComponent\");\n\nvar _default = echarts.extendComponentView({\n  type: 'toolbox',\n  render: function (toolboxModel, ecModel, api, payload) {\n    var group = this.group;\n    group.removeAll();\n\n    if (!toolboxModel.get('show')) {\n      return;\n    }\n\n    var itemSize = +toolboxModel.get('itemSize');\n    var featureOpts = toolboxModel.get('feature') || {};\n    var features = this._features || (this._features = {});\n    var featureNames = [];\n    zrUtil.each(featureOpts, function (opt, name) {\n      featureNames.push(name);\n    });\n    new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute(); // Keep for diff.\n\n    this._featureNames = featureNames;\n\n    function processFeature(newIndex, oldIndex) {\n      var featureName = featureNames[newIndex];\n      var oldName = featureNames[oldIndex];\n      var featureOpt = featureOpts[featureName];\n      var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n      var feature;\n\n      if (featureName && !oldName) {\n        // Create\n        if (isUserFeatureName(featureName)) {\n          feature = {\n            model: featureModel,\n            onclick: featureModel.option.onclick,\n            featureName: featureName\n          };\n        } else {\n          var Feature = featureManager.get(featureName);\n\n          if (!Feature) {\n            return;\n          }\n\n          feature = new Feature(featureModel, ecModel, api);\n        }\n\n        features[featureName] = feature;\n      } else {\n        feature = features[oldName]; // If feature does not exsit.\n\n        if (!feature) {\n          return;\n        }\n\n        feature.model = featureModel;\n        feature.ecModel = ecModel;\n        feature.api = api;\n      }\n\n      if (!featureName && oldName) {\n        feature.dispose && feature.dispose(ecModel, api);\n        return;\n      }\n\n      if (!featureModel.get('show') || feature.unusable) {\n        feature.remove && feature.remove(ecModel, api);\n        return;\n      }\n\n      createIconPaths(featureModel, feature, featureName);\n\n      featureModel.setIconStatus = function (iconName, status) {\n        var option = this.option;\n        var iconPaths = this.iconPaths;\n        option.iconStatus = option.iconStatus || {};\n        option.iconStatus[iconName] = status; // FIXME\n\n        iconPaths[iconName] && iconPaths[iconName].trigger(status);\n      };\n\n      if (feature.render) {\n        feature.render(featureModel, ecModel, api, payload);\n      }\n    }\n\n    function createIconPaths(featureModel, feature, featureName) {\n      var iconStyleModel = featureModel.getModel('iconStyle');\n      var iconStyleEmphasisModel = featureModel.getModel('emphasis.iconStyle'); // If one feature has mutiple icon. they are orginaized as\n      // {\n      //     icon: {\n      //         foo: '',\n      //         bar: ''\n      //     },\n      //     title: {\n      //         foo: '',\n      //         bar: ''\n      //     }\n      // }\n\n      var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n      var titles = featureModel.get('title') || {};\n\n      if (typeof icons === 'string') {\n        var icon = icons;\n        var title = titles;\n        icons = {};\n        titles = {};\n        icons[featureName] = icon;\n        titles[featureName] = title;\n      }\n\n      var iconPaths = featureModel.iconPaths = {};\n      zrUtil.each(icons, function (iconStr, iconName) {\n        var path = graphic.createIcon(iconStr, {}, {\n          x: -itemSize / 2,\n          y: -itemSize / 2,\n          width: itemSize,\n          height: itemSize\n        });\n        path.setStyle(iconStyleModel.getItemStyle());\n        path.hoverStyle = iconStyleEmphasisModel.getItemStyle();\n        graphic.setHoverStyle(path);\n\n        if (toolboxModel.get('showTitle')) {\n          path.__title = titles[iconName];\n          path.on('mouseover', function () {\n            // Should not reuse above hoverStyle, which might be modified.\n            var hoverStyle = iconStyleEmphasisModel.getItemStyle();\n            path.setStyle({\n              text: titles[iconName],\n              textPosition: hoverStyle.textPosition || 'bottom',\n              textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n              textAlign: hoverStyle.textAlign || 'center'\n            });\n          }).on('mouseout', function () {\n            path.setStyle({\n              textFill: null\n            });\n          });\n        }\n\n        path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n        group.add(path);\n        path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));\n        iconPaths[iconName] = path;\n      });\n    }\n\n    listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout\n    // FIXME\n\n    group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen\n\n    group.eachChild(function (icon) {\n      var titleText = icon.__title;\n      var hoverStyle = icon.hoverStyle; // May be background element\n\n      if (hoverStyle && titleText) {\n        var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));\n        var offsetX = icon.position[0] + group.position[0];\n        var offsetY = icon.position[1] + group.position[1] + itemSize;\n        var needPutOnTop = false;\n\n        if (offsetY + rect.height > api.getHeight()) {\n          hoverStyle.textPosition = 'top';\n          needPutOnTop = true;\n        }\n\n        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;\n\n        if (offsetX + rect.width / 2 > api.getWidth()) {\n          hoverStyle.textPosition = ['100%', topOffset];\n          hoverStyle.textAlign = 'right';\n        } else if (offsetX - rect.width / 2 < 0) {\n          hoverStyle.textPosition = [0, topOffset];\n          hoverStyle.textAlign = 'left';\n        }\n      }\n    });\n  },\n  updateView: function (toolboxModel, ecModel, api, payload) {\n    zrUtil.each(this._features, function (feature) {\n      feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n    });\n  },\n  // updateLayout: function (toolboxModel, ecModel, api, payload) {\n  //     zrUtil.each(this._features, function (feature) {\n  //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n  //     });\n  // },\n  remove: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.remove && feature.remove(ecModel, api);\n    });\n    this.group.removeAll();\n  },\n  dispose: function (ecModel, api) {\n    zrUtil.each(this._features, function (feature) {\n      feature.dispose && feature.dispose(ecModel, api);\n    });\n  }\n});\n\nfunction isUserFeatureName(featureName) {\n  return featureName.indexOf('my') === 0;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/ToolboxView.js\n// module id = 1636\n// module chunks = 2","var env = require(\"zrender/lib/core/env\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar saveAsImageLang = lang.toolbox.saveAsImage;\n\nfunction SaveAsImage(model) {\n  this.model = model;\n}\n\nSaveAsImage.defaultOption = {\n  show: true,\n  icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n  title: saveAsImageLang.title,\n  type: 'png',\n  // Default use option.backgroundColor\n  // backgroundColor: '#fff',\n  name: '',\n  excludeComponents: ['toolbox'],\n  pixelRatio: 1,\n  lang: saveAsImageLang.lang.slice()\n};\nSaveAsImage.prototype.unusable = !env.canvasSupported;\nvar proto = SaveAsImage.prototype;\n\nproto.onclick = function (ecModel, api) {\n  var model = this.model;\n  var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n  var $a = document.createElement('a');\n  var type = model.get('type', true) || 'png';\n  $a.download = title + '.' + type;\n  $a.target = '_blank';\n  var url = api.getConnectedDataURL({\n    type: type,\n    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',\n    excludeComponents: model.get('excludeComponents'),\n    pixelRatio: model.get('pixelRatio')\n  });\n  $a.href = url; // Chrome and Firefox\n\n  if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n    var evt = new MouseEvent('click', {\n      view: window,\n      bubbles: true,\n      cancelable: false\n    });\n    $a.dispatchEvent(evt);\n  } // IE\n  else {\n      if (window.navigator.msSaveOrOpenBlob) {\n        var bstr = atob(url.split(',')[1]);\n        var n = bstr.length;\n        var u8arr = new Uint8Array(n);\n\n        while (n--) {\n          u8arr[n] = bstr.charCodeAt(n);\n        }\n\n        var blob = new Blob([u8arr]);\n        window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);\n      } else {\n        var lang = model.get('lang');\n        var html = '' + '<body style=\"margin:0;\">' + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + (lang && lang[0] || '') + '\" />' + '</body>';\n        var tab = window.open();\n        tab.document.write(html);\n      }\n    }\n};\n\nfeatureManager.register('saveAsImage', SaveAsImage);\nvar _default = SaveAsImage;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js\n// module id = 1637\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar magicTypeLang = lang.toolbox.magicType;\n\nfunction MagicType(model) {\n  this.model = model;\n}\n\nMagicType.defaultOption = {\n  show: true,\n  type: [],\n  // Icon group\n  icon: {\n    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',\n    // jshint ignore:line\n    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n  },\n  // `line`, `bar`, `stack`, `tiled`\n  title: zrUtil.clone(magicTypeLang.title),\n  option: {},\n  seriesIndex: {}\n};\nvar proto = MagicType.prototype;\n\nproto.getIcons = function () {\n  var model = this.model;\n  var availableIcons = model.get('icon');\n  var icons = {};\n  zrUtil.each(model.get('type'), function (type) {\n    if (availableIcons[type]) {\n      icons[type] = availableIcons[type];\n    }\n  });\n  return icons;\n};\n\nvar seriesOptGenreator = {\n  'line': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'line',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.line') || {}, true);\n    }\n  },\n  'bar': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line') {\n      return zrUtil.merge({\n        id: seriesId,\n        type: 'bar',\n        // Preserve data related option\n        data: seriesModel.get('data'),\n        stack: seriesModel.get('stack'),\n        markPoint: seriesModel.get('markPoint'),\n        markLine: seriesModel.get('markLine')\n      }, model.get('option.bar') || {}, true);\n    }\n  },\n  'stack': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: '__ec_magicType_stack__'\n      }, model.get('option.stack') || {}, true);\n    }\n  },\n  'tiled': function (seriesType, seriesId, seriesModel, model) {\n    if (seriesType === 'line' || seriesType === 'bar') {\n      return zrUtil.merge({\n        id: seriesId,\n        stack: ''\n      }, model.get('option.tiled') || {}, true);\n    }\n  }\n};\nvar radioTypes = [['line', 'bar'], ['stack', 'tiled']];\n\nproto.onclick = function (ecModel, api, type) {\n  var model = this.model;\n  var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType\n\n  if (!seriesOptGenreator[type]) {\n    return;\n  }\n\n  var newOption = {\n    series: []\n  };\n\n  var generateNewSeriesTypes = function (seriesModel) {\n    var seriesType = seriesModel.subType;\n    var seriesId = seriesModel.id;\n    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);\n\n    if (newSeriesOpt) {\n      // PENDING If merge original option?\n      zrUtil.defaults(newSeriesOpt, seriesModel.option);\n      newOption.series.push(newSeriesOpt);\n    } // Modify boundaryGap\n\n\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n      if (categoryAxis) {\n        var axisDim = categoryAxis.dim;\n        var axisType = axisDim + 'Axis';\n        var axisModel = ecModel.queryComponents({\n          mainType: axisType,\n          index: seriesModel.get(name + 'Index'),\n          id: seriesModel.get(name + 'Id')\n        })[0];\n        var axisIndex = axisModel.componentIndex;\n        newOption[axisType] = newOption[axisType] || [];\n\n        for (var i = 0; i <= axisIndex; i++) {\n          newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n        }\n\n        newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n      }\n    }\n  };\n\n  zrUtil.each(radioTypes, function (radio) {\n    if (zrUtil.indexOf(radio, type) >= 0) {\n      zrUtil.each(radio, function (item) {\n        model.setIconStatus(item, 'normal');\n      });\n    }\n  });\n  model.setIconStatus(type, 'emphasis');\n  ecModel.eachComponent({\n    mainType: 'series',\n    query: seriesIndex == null ? null : {\n      seriesIndex: seriesIndex\n    }\n  }, generateNewSeriesTypes);\n  api.dispatchAction({\n    type: 'changeMagicType',\n    currentType: type,\n    newOption: newOption\n  });\n};\n\necharts.registerAction({\n  type: 'changeMagicType',\n  event: 'magicTypeChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.mergeOption(payload.newOption);\n});\nfeatureManager.register('magicType', MagicType);\nvar _default = MagicType;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/MagicType.js\n// module id = 1638\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar eventTool = require(\"zrender/lib/core/event\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar dataViewLang = lang.toolbox.dataView;\nvar BLOCK_SPLITER = new Array(60).join('-');\nvar ITEM_SPLITER = '\\t';\n/**\n * Group series into two types\n *  1. on category axis, like line, bar\n *  2. others, like scatter, pie\n * @param {module:echarts/model/Global} ecModel\n * @return {Object}\n * @inner\n */\n\nfunction groupSeries(ecModel) {\n  var seriesGroupByCategoryAxis = {};\n  var otherSeries = [];\n  var meta = [];\n  ecModel.eachRawSeries(function (seriesModel) {\n    var coordSys = seriesModel.coordinateSystem;\n\n    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n      var baseAxis = coordSys.getBaseAxis();\n\n      if (baseAxis.type === 'category') {\n        var key = baseAxis.dim + '_' + baseAxis.index;\n\n        if (!seriesGroupByCategoryAxis[key]) {\n          seriesGroupByCategoryAxis[key] = {\n            categoryAxis: baseAxis,\n            valueAxis: coordSys.getOtherAxis(baseAxis),\n            series: []\n          };\n          meta.push({\n            axisDim: baseAxis.dim,\n            axisIndex: baseAxis.index\n          });\n        }\n\n        seriesGroupByCategoryAxis[key].series.push(seriesModel);\n      } else {\n        otherSeries.push(seriesModel);\n      }\n    } else {\n      otherSeries.push(seriesModel);\n    }\n  });\n  return {\n    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n    other: otherSeries,\n    meta: meta\n  };\n}\n/**\n * Assemble content of series on cateogory axis\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleSeriesWithCategoryAxis(series) {\n  var tables = [];\n  zrUtil.each(series, function (group, key) {\n    var categoryAxis = group.categoryAxis;\n    var valueAxis = group.valueAxis;\n    var valueAxisDim = valueAxis.dim;\n    var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n      return series.name;\n    }));\n    var columns = [categoryAxis.model.getCategories()];\n    zrUtil.each(group.series, function (series) {\n      columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n        return val;\n      }));\n    }); // Assemble table content\n\n    var lines = [headers.join(ITEM_SPLITER)];\n\n    for (var i = 0; i < columns[0].length; i++) {\n      var items = [];\n\n      for (var j = 0; j < columns.length; j++) {\n        items.push(columns[j][i]);\n      }\n\n      lines.push(items.join(ITEM_SPLITER));\n    }\n\n    tables.push(lines.join('\\n'));\n  });\n  return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * Assemble content of other series\n * @param {Array.<module:echarts/model/Series>} series\n * @return {string}\n * @inner\n */\n\n\nfunction assembleOtherSeries(series) {\n  return zrUtil.map(series, function (series) {\n    var data = series.getRawData();\n    var lines = [series.name];\n    var vals = [];\n    data.each(data.dimensions, function () {\n      var argLen = arguments.length;\n      var dataIndex = arguments[argLen - 1];\n      var name = data.getName(dataIndex);\n\n      for (var i = 0; i < argLen - 1; i++) {\n        vals[i] = arguments[i];\n      }\n\n      lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));\n    });\n    return lines.join('\\n');\n  }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n}\n/**\n * @param {module:echarts/model/Global}\n * @return {Object}\n * @inner\n */\n\n\nfunction getContentFromModel(ecModel) {\n  var result = groupSeries(ecModel);\n  return {\n    value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {\n      return str.replace(/[\\n\\t\\s]/g, '');\n    }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n    meta: result.meta\n  };\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n}\n/**\n * If a block is tsv format\n */\n\n\nfunction isTSVFormat(block) {\n  // Simple method to find out if a block is tsv format\n  var firstLine = block.slice(0, block.indexOf('\\n'));\n\n  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n    return true;\n  }\n}\n\nvar itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n/**\n * @param {string} tsv\n * @return {Object}\n */\n\nfunction parseTSVContents(tsv) {\n  var tsvLines = tsv.split(/\\n+/g);\n  var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n  var categories = [];\n  var series = zrUtil.map(headers, function (header) {\n    return {\n      name: header,\n      data: []\n    };\n  });\n\n  for (var i = 0; i < tsvLines.length; i++) {\n    var items = trim(tsvLines[i]).split(itemSplitRegex);\n    categories.push(items.shift());\n\n    for (var j = 0; j < items.length; j++) {\n      series[j] && (series[j].data[i] = items[j]);\n    }\n  }\n\n  return {\n    series: series,\n    categories: categories\n  };\n}\n/**\n * @param {string} str\n * @return {Array.<Object>}\n * @inner\n */\n\n\nfunction parseListContents(str) {\n  var lines = str.split(/\\n+/g);\n  var seriesName = trim(lines.shift());\n  var data = [];\n\n  for (var i = 0; i < lines.length; i++) {\n    var items = trim(lines[i]).split(itemSplitRegex);\n    var name = '';\n    var value;\n    var hasName = false;\n\n    if (isNaN(items[0])) {\n      // First item is name\n      hasName = true;\n      name = items[0];\n      items = items.slice(1);\n      data[i] = {\n        name: name,\n        value: []\n      };\n      value = data[i].value;\n    } else {\n      value = data[i] = [];\n    }\n\n    for (var j = 0; j < items.length; j++) {\n      value.push(+items[j]);\n    }\n\n    if (value.length === 1) {\n      hasName ? data[i].value = value[0] : data[i] = value[0];\n    }\n  }\n\n  return {\n    name: seriesName,\n    data: data\n  };\n}\n/**\n * @param {string} str\n * @param {Array.<Object>} blockMetaList\n * @return {Object}\n * @inner\n */\n\n\nfunction parseContents(str, blockMetaList) {\n  var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n  var newOption = {\n    series: []\n  };\n  zrUtil.each(blocks, function (block, idx) {\n    if (isTSVFormat(block)) {\n      var result = parseTSVContents(block);\n      var blockMeta = blockMetaList[idx];\n      var axisKey = blockMeta.axisDim + 'Axis';\n\n      if (blockMeta) {\n        newOption[axisKey] = newOption[axisKey] || [];\n        newOption[axisKey][blockMeta.axisIndex] = {\n          data: result.categories\n        };\n        newOption.series = newOption.series.concat(result.series);\n      }\n    } else {\n      var result = parseListContents(block);\n      newOption.series.push(result);\n    }\n  });\n  return newOption;\n}\n/**\n * @alias {module:echarts/component/toolbox/feature/DataView}\n * @constructor\n * @param {module:echarts/model/Model} model\n */\n\n\nfunction DataView(model) {\n  this._dom = null;\n  this.model = model;\n}\n\nDataView.defaultOption = {\n  show: true,\n  readOnly: false,\n  optionToContent: null,\n  contentToOption: null,\n  icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n  title: zrUtil.clone(dataViewLang.title),\n  lang: zrUtil.clone(dataViewLang.lang),\n  backgroundColor: '#fff',\n  textColor: '#000',\n  textareaColor: '#fff',\n  textareaBorderColor: '#333',\n  buttonColor: '#c23531',\n  buttonTextColor: '#fff'\n};\n\nDataView.prototype.onclick = function (ecModel, api) {\n  var container = api.getDom();\n  var model = this.model;\n\n  if (this._dom) {\n    container.removeChild(this._dom);\n  }\n\n  var root = document.createElement('div');\n  root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n  root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements\n\n  var header = document.createElement('h4');\n  var lang = model.get('lang') || [];\n  header.innerHTML = lang[0] || model.get('title');\n  header.style.cssText = 'margin: 10px 20px;';\n  header.style.color = model.get('textColor');\n  var viewMain = document.createElement('div');\n  var textarea = document.createElement('textarea');\n  viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n  var optionToContent = model.get('optionToContent');\n  var contentToOption = model.get('contentToOption');\n  var result = getContentFromModel(ecModel);\n\n  if (typeof optionToContent === 'function') {\n    var htmlOrDom = optionToContent(api.getOption());\n\n    if (typeof htmlOrDom === 'string') {\n      viewMain.innerHTML = htmlOrDom;\n    } else if (zrUtil.isDom(htmlOrDom)) {\n      viewMain.appendChild(htmlOrDom);\n    }\n  } else {\n    // Use default textarea\n    viewMain.appendChild(textarea);\n    textarea.readOnly = model.get('readOnly');\n    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n    textarea.style.color = model.get('textColor');\n    textarea.style.borderColor = model.get('textareaBorderColor');\n    textarea.style.backgroundColor = model.get('textareaColor');\n    textarea.value = result.value;\n  }\n\n  var blockMetaList = result.meta;\n  var buttonContainer = document.createElement('div');\n  buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n  var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n  var closeButton = document.createElement('div');\n  var refreshButton = document.createElement('div');\n  buttonStyle += ';background-color:' + model.get('buttonColor');\n  buttonStyle += ';color:' + model.get('buttonTextColor');\n  var self = this;\n\n  function close() {\n    container.removeChild(root);\n    self._dom = null;\n  }\n\n  eventTool.addEventListener(closeButton, 'click', close);\n  eventTool.addEventListener(refreshButton, 'click', function () {\n    var newOption;\n\n    try {\n      if (typeof contentToOption === 'function') {\n        newOption = contentToOption(viewMain, api.getOption());\n      } else {\n        newOption = parseContents(textarea.value, blockMetaList);\n      }\n    } catch (e) {\n      close();\n      throw new Error('Data view format error ' + e);\n    }\n\n    if (newOption) {\n      api.dispatchAction({\n        type: 'changeDataView',\n        newOption: newOption\n      });\n    }\n\n    close();\n  });\n  closeButton.innerHTML = lang[1];\n  refreshButton.innerHTML = lang[2];\n  refreshButton.style.cssText = buttonStyle;\n  closeButton.style.cssText = buttonStyle;\n  !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n  buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n\n  eventTool.addEventListener(textarea, 'keydown', function (e) {\n    if ((e.keyCode || e.which) === 9) {\n      // get caret position/selection\n      var val = this.value;\n      var start = this.selectionStart;\n      var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret\n\n      this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again\n\n      this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose\n\n      eventTool.stop(e);\n    }\n  });\n  root.appendChild(header);\n  root.appendChild(viewMain);\n  root.appendChild(buttonContainer);\n  viewMain.style.height = container.clientHeight - 80 + 'px';\n  container.appendChild(root);\n  this._dom = root;\n};\n\nDataView.prototype.remove = function (ecModel, api) {\n  this._dom && api.getDom().removeChild(this._dom);\n};\n\nDataView.prototype.dispose = function (ecModel, api) {\n  this.remove(ecModel, api);\n};\n/**\n * @inner\n */\n\n\nfunction tryMergeDataOption(newData, originalData) {\n  return zrUtil.map(newData, function (newVal, idx) {\n    var original = originalData && originalData[idx];\n\n    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n      if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n        newVal = newVal.value;\n      } // Original data has option\n\n\n      return zrUtil.defaults({\n        value: newVal\n      }, original);\n    } else {\n      return newVal;\n    }\n  });\n}\n\nfeatureManager.register('dataView', DataView);\necharts.registerAction({\n  type: 'changeDataView',\n  event: 'dataViewChanged',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  var newSeriesOptList = [];\n  zrUtil.each(payload.newOption.series, function (seriesOpt) {\n    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n\n    if (!seriesModel) {\n      // New created series\n      // Geuss the series type\n      newSeriesOptList.push(zrUtil.extend({\n        // Default is scatter\n        type: 'scatter'\n      }, seriesOpt));\n    } else {\n      var originalData = seriesModel.get('data');\n      newSeriesOptList.push({\n        name: seriesOpt.name,\n        data: tryMergeDataOption(seriesOpt.data, originalData)\n      });\n    }\n  });\n  ecModel.mergeOption(zrUtil.defaults({\n    series: newSeriesOptList\n  }, payload.newOption));\n});\nvar _default = DataView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/DataView.js\n// module id = 1639\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BrushController = require(\"../../helper/BrushController\");\n\nvar BrushTargetManager = require(\"../../helper/BrushTargetManager\");\n\nvar history = require(\"../../dataZoom/history\");\n\nvar sliderMove = require(\"../../helper/sliderMove\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nrequire(\"../../dataZoomSelect\");\n\n// Use dataZoomSelect\nvar dataZoomLang = lang.toolbox.dataZoom;\nvar each = zrUtil.each; // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n\nvar DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\nfunction DataZoom(model, ecModel, api) {\n  /**\n   * @private\n   * @type {module:echarts/component/helper/BrushController}\n   */\n  (this._brushController = new BrushController(api.getZr())).on('brush', zrUtil.bind(this._onBrush, this)).mount();\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._isZoomActive;\n}\n\nDataZoom.defaultOption = {\n  show: true,\n  // Icon group\n  icon: {\n    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n  },\n  // `zoom`, `back`\n  title: zrUtil.clone(dataZoomLang.title)\n};\nvar proto = DataZoom.prototype;\n\nproto.render = function (featureModel, ecModel, api, payload) {\n  this.model = featureModel;\n  this.ecModel = ecModel;\n  this.api = api;\n  updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n  updateBackBtnStatus(featureModel, ecModel);\n};\n\nproto.onclick = function (ecModel, api, type) {\n  handlers[type].call(this);\n};\n\nproto.remove = function (ecModel, api) {\n  this._brushController.unmount();\n};\n\nproto.dispose = function (ecModel, api) {\n  this._brushController.dispose();\n};\n/**\n * @private\n */\n\n\nvar handlers = {\n  zoom: function () {\n    var nextActive = !this._isZoomActive;\n    this.api.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: nextActive\n    });\n  },\n  back: function () {\n    this._dispatchZoomAction(history.pop(this.ecModel));\n  }\n};\n/**\n * @private\n */\n\nproto._onBrush = function (areas, opt) {\n  if (!opt.isEnd || !areas.length) {\n    return;\n  }\n\n  var snapshot = {};\n  var ecModel = this.ecModel;\n\n  this._brushController.updateCovers([]); // remove cover\n\n\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {\n    include: ['grid']\n  });\n  brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    if (coordSys.type !== 'cartesian2d') {\n      return;\n    }\n\n    var brushType = area.brushType;\n\n    if (brushType === 'rect') {\n      setBatch('x', coordSys, coordRange[0]);\n      setBatch('y', coordSys, coordRange[1]);\n    } else {\n      setBatch({\n        lineX: 'x',\n        lineY: 'y'\n      }[brushType], coordSys, coordRange);\n    }\n  });\n  history.push(ecModel, snapshot);\n\n  this._dispatchZoomAction(snapshot);\n\n  function setBatch(dimName, coordSys, minMax) {\n    var axis = coordSys.getAxis(dimName);\n    var axisModel = axis.model;\n    var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range.\n\n    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n\n    if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n      minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);\n    }\n\n    dataZoomModel && (snapshot[dataZoomModel.id] = {\n      dataZoomId: dataZoomModel.id,\n      startValue: minMax[0],\n      endValue: minMax[1]\n    });\n  }\n\n  function findDataZoom(dimName, axisModel, ecModel) {\n    var found;\n    ecModel.eachComponent({\n      mainType: 'dataZoom',\n      subType: 'select'\n    }, function (dzModel) {\n      var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n      has && (found = dzModel);\n    });\n    return found;\n  }\n};\n/**\n * @private\n */\n\n\nproto._dispatchZoomAction = function (snapshot) {\n  var batch = []; // Convert from hash map to array.\n\n  each(snapshot, function (batchItem, dataZoomId) {\n    batch.push(zrUtil.clone(batchItem));\n  });\n  batch.length && this.api.dispatchAction({\n    type: 'dataZoom',\n    from: this.uid,\n    batch: batch\n  });\n};\n\nfunction retrieveAxisSetting(option) {\n  var setting = {}; // Compatible with previous setting: null => all axis, false => no axis.\n\n  zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n    setting[name] = option[name];\n    setting[name] == null && (setting[name] = 'all');\n    (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n  });\n  return setting;\n}\n\nfunction updateBackBtnStatus(featureModel, ecModel) {\n  featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');\n}\n\nfunction updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n  var zoomActive = view._isZoomActive;\n\n  if (payload && payload.type === 'takeGlobalCursor') {\n    zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;\n  }\n\n  view._isZoomActive = zoomActive;\n  featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n  var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {\n    include: ['grid']\n  });\n\n  view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';\n  })).enableBrush(zoomActive ? {\n    brushType: 'auto',\n    brushStyle: {\n      // FIXME user customized?\n      lineWidth: 0,\n      fill: 'rgba(0,0,0,0.2)'\n    }\n  } : false);\n}\n\nfeatureManager.register('dataZoom', DataZoom); // Create special dataZoom option for select\n\necharts.registerPreprocessor(function (option) {\n  if (!option) {\n    return;\n  }\n\n  var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n\n  if (!zrUtil.isArray(dataZoomOpts)) {\n    option.dataZoom = dataZoomOpts = [dataZoomOpts];\n  }\n\n  var toolboxOpt = option.toolbox;\n\n  if (toolboxOpt) {\n    // Assume there is only one toolbox\n    if (zrUtil.isArray(toolboxOpt)) {\n      toolboxOpt = toolboxOpt[0];\n    }\n\n    if (toolboxOpt && toolboxOpt.feature) {\n      var dataZoomOpt = toolboxOpt.feature.dataZoom;\n      addForAxis('xAxis', dataZoomOpt);\n      addForAxis('yAxis', dataZoomOpt);\n    }\n  }\n\n  function addForAxis(axisName, dataZoomOpt) {\n    if (!dataZoomOpt) {\n      return;\n    } // Try not to modify model, because it is not merged yet.\n\n\n    var axisIndicesName = axisName + 'Index';\n    var givenAxisIndices = dataZoomOpt[axisIndicesName];\n\n    if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices)) {\n      givenAxisIndices = givenAxisIndices === false || givenAxisIndices === 'none' ? [] : [givenAxisIndices];\n    }\n\n    forEachComponent(axisName, function (axisOpt, axisIndex) {\n      if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {\n        return;\n      }\n\n      var newOpt = {\n        type: 'select',\n        $fromToolbox: true,\n        // Id for merge mapping.\n        id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n      }; // FIXME\n      // Only support one axis now.\n\n      newOpt[axisIndicesName] = axisIndex;\n      dataZoomOpts.push(newOpt);\n    });\n  }\n\n  function forEachComponent(mainType, cb) {\n    var opts = option[mainType];\n\n    if (!zrUtil.isArray(opts)) {\n      opts = opts ? [opts] : [];\n    }\n\n    each(opts, cb);\n  }\n});\nvar _default = DataZoom;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js\n// module id = 1640\n// module chunks = 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd.call(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: handleDragEnd //,\n  // FIXME\n  // in tooltip, globalout should not be triggered.\n  // globalout: handleDragEnd\n\n};\n\nfunction handleDragEnd(e) {\n  if (this._dragging) {\n    preventDefault(e);\n    var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n    var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n    this._dragging = false;\n    this._track = [];\n    this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(this, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/BrushController.js\n// module id = 1641\n// module chunks = 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar brushHelper = require(\"./brushHelper\");\n\nvar each = zrUtil.each;\nvar indexOf = zrUtil.indexOf;\nvar curry = zrUtil.curry;\nvar COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n/**\n * [option in constructor]:\n * {\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n * }\n *\n *\n * [targetInfo]:\n *\n * There can be multiple axes in a single targetInfo. Consider the case\n * of `grid` component, a targetInfo represents a grid which contains one or more\n * cartesian and one or more axes. And consider the case of parallel system,\n * which has multiple axes in a coordinate system.\n * Can be {\n *     panelId: ...,\n *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n *     coordSyses: all cartesians.\n *     gridModel: <grid component>\n *     xAxes: correspond to coordSyses on index\n *     yAxes: correspond to coordSyses on index\n * }\n * or {\n *     panelId: ...,\n *     coordSys: <geo coord sys>\n *     coordSyses: [<geo coord sys>]\n *     geoModel: <geo component>\n * }\n *\n *\n * [panelOpt]:\n *\n * Make from targetInfo. Input to BrushController.\n * {\n *     panelId: ...,\n *     rect: ...\n * }\n *\n *\n * [area]:\n *\n * Generated by BrushController or user input.\n * {\n *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n *     range: pixel range.\n *     coordRange: representitive coord range (the first one of coordRanges).\n *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n * }\n */\n\n/**\n * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} [opt]\n * @param {Array.<string>} [opt.include] include coordinate system types.\n */\n\nfunction BrushTargetManager(option, ecModel, opt) {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  var targetInfoList = this._targetInfoList = [];\n  var info = {};\n  var foundCpts = parseFinder(ecModel, option);\n  each(targetInfoBuilders, function (builder, type) {\n    if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n      builder(foundCpts, targetInfoList, info);\n    }\n  });\n}\n\nvar proto = BrushTargetManager.prototype;\n\nproto.setOutputRanges = function (areas, ecModel) {\n  this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n    (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n    if (!area.coordRange) {\n      area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n      // rebuild range by coordRange accrately, which may bring trouble when\n      // brushing only one item. So we use __rangeOffset to rebuilding range\n      // by coordRange. And this it only used in brush component so it is no\n      // need to be adapted to coordRanges.\n\n      var result = coordConvert[area.brushType](0, coordSys, coordRange);\n      area.__rangeOffset = {\n        offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n        xyMinMax: result.xyMinMax\n      };\n    }\n  });\n};\n\nproto.matchOutputRanges = function (areas, ecModel, cb) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n\n    if (targetInfo && targetInfo !== true) {\n      zrUtil.each(targetInfo.coordSyses, function (coordSys) {\n        var result = coordConvert[area.brushType](1, coordSys, area.range);\n        cb(area, result.values, coordSys, ecModel);\n      });\n    }\n  }, this);\n};\n\nproto.setInputRanges = function (areas, ecModel) {\n  each(areas, function (area) {\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n    if (targetInfo && targetInfo !== true) {\n      area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n      // not keep its original value, for the sake of the dataZoom scenario,\n      // where area.coordRange remains unchanged but area.range may be changed.\n      // (2) Only support converting one coordRange to pixel range in brush\n      // component. So do not consider `coordRanges`.\n      // (3) About __rangeOffset, see comment above.\n\n      var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n      var rangeOffset = area.__rangeOffset;\n      area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n    }\n  }, this);\n};\n\nproto.makePanelOpts = function (api, getDefaultBrushType) {\n  return zrUtil.map(this._targetInfoList, function (targetInfo) {\n    var rect = targetInfo.getPanelRect();\n    return {\n      panelId: targetInfo.panelId,\n      defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n      clipPath: brushHelper.makeRectPanelClipPath(rect),\n      isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n      getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n    };\n  });\n};\n\nproto.controlSeries = function (area, seriesModel, ecModel) {\n  // Check whether area is bound in coord, and series do not belong to that coord.\n  // If do not do this check, some brush (like lineX) will controll all axes.\n  var targetInfo = this.findTargetInfo(area, ecModel);\n  return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n};\n/**\n * If return Object, a coord found.\n * If reutrn true, global found.\n * Otherwise nothing found.\n *\n * @param {Object} area\n * @param {Array} targetInfoList\n * @return {Object|boolean}\n */\n\n\nproto.findTargetInfo = function (area, ecModel) {\n  var targetInfoList = this._targetInfoList;\n  var foundCpts = parseFinder(ecModel, area);\n\n  for (var i = 0; i < targetInfoList.length; i++) {\n    var targetInfo = targetInfoList[i];\n    var areaPanelId = area.panelId;\n\n    if (areaPanelId) {\n      if (targetInfo.panelId === areaPanelId) {\n        return targetInfo;\n      }\n    } else {\n      for (var i = 0; i < targetInfoMatchers.length; i++) {\n        if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n          return targetInfo;\n        }\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, option) {\n  return modelUtil.parseFinder(ecModel, option, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = zrUtil.createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilder.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilder.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilder = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.grid.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange) {\n    var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n    var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = zrUtil.map(rangeOrCoordRange, function (item) {\n      var p = coordSys[COORD_CONVERTS[to]](item);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return zrUtil.map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nvar _default = BrushTargetManager;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/BrushTargetManager.js\n// module id = 1642\n// module chunks = 2","var BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _cursorHelper = require(\"./cursorHelper\");\n\nvar onIrrelevantElement = _cursorHelper.onIrrelevantElement;\n\nvar graphicUtil = require(\"../../util/graphic\");\n\nfunction makeRectPanelClipPath(rect) {\n  rect = normalizeRect(rect);\n  return function (localPoints, transform) {\n    return graphicUtil.clipPointsByRect(localPoints, rect);\n  };\n}\n\nfunction makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n  rect = normalizeRect(rect);\n  return function (xyIndex) {\n    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n    var brushWidth = idx ? rect.width : rect.height;\n    var base = idx ? rect.x : rect.y;\n    return [base, base + (brushWidth || 0)];\n  };\n}\n\nfunction makeRectIsTargetByCursor(rect, api, targetModel) {\n  rect = normalizeRect(rect);\n  return function (e, localCursorPoint, transform) {\n    return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);\n  };\n} // Consider width/height is negative.\n\n\nfunction normalizeRect(rect) {\n  return BoundingRect.create(rect);\n}\n\nexports.makeRectPanelClipPath = makeRectPanelClipPath;\nexports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;\nexports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/brushHelper.js\n// module id = 1643\n// module chunks = 2","var IRRELEVANT_EXCLUDES = {\n  'axisPointer': 1,\n  'tooltip': 1,\n  'brush': 1\n};\n/**\n * Avoid that: mouse click on a elements that is over geo or graph,\n * but roam is triggered.\n */\n\nfunction onIrrelevantElement(e, api, targetCoordSysModel) {\n  var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem.\n\n  var coordSys = model && model.coordinateSystem;\n  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;\n}\n\nexports.onIrrelevantElement = onIrrelevantElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/cursorHelper.js\n// module id = 1644\n// module chunks = 2","require(\"./dataZoom/typeDefaulter\");\n\nrequire(\"./dataZoom/DataZoomModel\");\n\nrequire(\"./dataZoom/DataZoomView\");\n\nrequire(\"./dataZoom/SelectZoomModel\");\n\nrequire(\"./dataZoom/SelectZoomView\");\n\nrequire(\"./dataZoom/dataZoomProcessor\");\n\nrequire(\"./dataZoom/dataZoomAction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoomSelect.js\n// module id = 1645\n// module chunks = 2","var DataZoomModel = require(\"./DataZoomModel\");\n\nvar _default = DataZoomModel.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js\n// module id = 1646\n// module chunks = 2","var DataZoomView = require(\"./DataZoomView\");\n\nvar _default = DataZoomView.extend({\n  type: 'dataZoom.select'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js\n// module id = 1647\n// module chunks = 2","var echarts = require(\"../../../echarts\");\n\nvar history = require(\"../../dataZoom/history\");\n\nvar lang = require(\"../../../lang\");\n\nvar featureManager = require(\"../featureManager\");\n\nvar restoreLang = lang.toolbox.restore;\n\nfunction Restore(model) {\n  this.model = model;\n}\n\nRestore.defaultOption = {\n  show: true,\n  icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n  title: restoreLang.title\n};\nvar proto = Restore.prototype;\n\nproto.onclick = function (ecModel, api, type) {\n  history.clear(ecModel);\n  api.dispatchAction({\n    type: 'restore',\n    from: this.uid\n  });\n};\n\nfeatureManager.register('restore', Restore);\necharts.registerAction({\n  type: 'restore',\n  event: 'restore',\n  update: 'prepareAndUpdate'\n}, function (payload, ecModel) {\n  ecModel.resetOption('recreate');\n});\nvar _default = Restore;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/Restore.js\n// module id = 1648\n// module chunks = 2","var echarts = require(\"../echarts\");\n\nrequire(\"./marker/MarkPointModel\");\n\nrequire(\"./marker/MarkPointView\");\n\n// HINT Markpoint can't be used too much\necharts.registerPreprocessor(function (opt) {\n  // Make sure markPoint component is enabled\n  opt.markPoint = opt.markPoint || {};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/markPoint.js\n// module id = 1649\n// module chunks = 2","var MarkerModel = require(\"./MarkerModel\");\n\nvar _default = MarkerModel.extend({\n  type: 'markPoint',\n  defaultOption: {\n    zlevel: 0,\n    z: 5,\n    symbol: 'pin',\n    symbolSize: 50,\n    //symbolRotate: 0,\n    //symbolOffset: [0, 0]\n    tooltip: {\n      trigger: 'item'\n    },\n    label: {\n      show: true,\n      position: 'inside'\n    },\n    itemStyle: {\n      borderWidth: 2\n    },\n    emphasis: {\n      label: {\n        show: true\n      }\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkPointModel.js\n// module id = 1650\n// module chunks = 2","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar env = require(\"zrender/lib/core/env\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar formatUtil = require(\"../../util/format\");\n\nvar dataFormatMixin = require(\"../../model/mixin/dataFormat\");\n\nvar addCommas = formatUtil.addCommas;\nvar encodeHTML = formatUtil.encodeHTML;\n\nfunction fillLabel(opt) {\n  modelUtil.defaultEmphasis(opt, 'label', ['show']);\n}\n\nvar MarkerModel = echarts.extendComponentModel({\n  type: 'marker',\n  dependencies: ['series', 'grid', 'polar', 'geo'],\n\n  /**\n   * @overrite\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);\n  },\n\n  /**\n   * @return {boolean}\n   */\n  isAnimationEnabled: function () {\n    if (env.node) {\n      return false;\n    }\n\n    var hostSeries = this.__hostSeries;\n    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n  },\n  mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {\n    var MarkerModel = this.constructor;\n    var modelPropName = this.mainType + 'Model';\n\n    if (!createdBySelf) {\n      ecModel.eachSeries(function (seriesModel) {\n        var markerOpt = seriesModel.get(this.mainType);\n        var markerModel = seriesModel[modelPropName];\n\n        if (!markerOpt || !markerOpt.data) {\n          seriesModel[modelPropName] = null;\n          return;\n        }\n\n        if (!markerModel) {\n          if (isInit) {\n            // Default label emphasis `position` and `show`\n            fillLabel(markerOpt);\n          }\n\n          zrUtil.each(markerOpt.data, function (item) {\n            // FIXME Overwrite fillLabel method ?\n            if (item instanceof Array) {\n              fillLabel(item[0]);\n              fillLabel(item[1]);\n            } else {\n              fillLabel(item);\n            }\n          });\n          markerModel = new MarkerModel(markerOpt, this, ecModel);\n          zrUtil.extend(markerModel, {\n            mainType: this.mainType,\n            // Use the same series index and name\n            seriesIndex: seriesModel.seriesIndex,\n            name: seriesModel.name,\n            createdBySelf: true\n          });\n          markerModel.__hostSeries = seriesModel;\n        } else {\n          markerModel.mergeOption(markerOpt, ecModel, true);\n        }\n\n        seriesModel[modelPropName] = markerModel;\n      }, this);\n    }\n  },\n  formatTooltip: function (dataIndex) {\n    var data = this.getData();\n    var value = this.getRawValue(dataIndex);\n    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);\n    var name = data.getName(dataIndex);\n    var html = encodeHTML(this.name);\n\n    if (value != null || name) {\n      html += '<br />';\n    }\n\n    if (name) {\n      html += encodeHTML(name);\n\n      if (value != null) {\n        html += ' : ';\n      }\n    }\n\n    if (value != null) {\n      html += encodeHTML(formattedValue);\n    }\n\n    return html;\n  },\n  getData: function () {\n    return this._data;\n  },\n  setData: function (data) {\n    this._data = data;\n  }\n});\nzrUtil.mixin(MarkerModel, dataFormatMixin);\nvar _default = MarkerModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkerModel.js\n// module id = 1651\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../../chart/helper/SymbolDraw\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar List = require(\"../../data/List\");\n\nvar markerHelper = require(\"./markerHelper\");\n\nvar MarkerView = require(\"./MarkerView\");\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  mpData.each(function (idx) {\n    var itemModel = mpData.getItemModel(idx);\n    var point;\n    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n      point = [xPx, yPx];\n    } // Chart like bar may have there own marker positioning logic\n    else if (seriesModel.getMarkerPosition) {\n        // Use the getMarkerPoisition\n        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n      } else if (coordSys) {\n        var x = mpData.get(coordSys.dimensions[0], idx);\n        var y = mpData.get(coordSys.dimensions[1], idx);\n        point = coordSys.dataToPoint([x, y]);\n      } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n\n    mpData.setItemLayout(idx, point);\n  });\n}\n\nvar _default = MarkerView.extend({\n  type: 'markPoint',\n  // updateLayout: function (markPointModel, ecModel, api) {\n  //     ecModel.eachSeries(function (seriesModel) {\n  //         var mpModel = seriesModel.markPointModel;\n  //         if (mpModel) {\n  //             updateMarkerLayout(mpModel.getData(), seriesModel, api);\n  //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n  //         }\n  //     }, this);\n  // },\n  updateTransform: function (markPointModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mpModel = seriesModel.markPointModel;\n\n      if (mpModel) {\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);\n      }\n    }, this);\n  },\n  renderSeries: function (seriesModel, mpModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var symbolDrawMap = this.markerGroupMap;\n    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());\n    var mpData = createList(coordSys, seriesModel, mpModel); // FIXME\n\n    mpModel.setData(mpData);\n    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n    mpData.each(function (idx) {\n      var itemModel = mpData.getItemModel(idx);\n      var symbolSize = itemModel.getShallow('symbolSize');\n\n      if (typeof symbolSize === 'function') {\n        // FIXME  ECharts 2.x2.x \n        symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));\n      }\n\n      mpData.setItemVisual(idx, {\n        symbolSize: symbolSize,\n        color: itemModel.get('itemStyle.color') || seriesData.getVisual('color'),\n        symbol: itemModel.getShallow('symbol')\n      });\n    }); // TODO Text are wrong\n\n    symbolDraw.updateData(mpData);\n    this.group.add(symbolDraw.group); // Set host model for tooltip\n    // FIXME\n\n    mpData.eachItemGraphicEl(function (el) {\n      el.traverse(function (child) {\n        child.dataModel = mpModel;\n      });\n    });\n    symbolDraw.__keep = true;\n    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n  }\n});\n/**\n * @inner\n * @param {module:echarts/coord/*} [coordSys]\n * @param {module:echarts/model/Series} seriesModel\n * @param {module:echarts/model/Model} mpModel\n */\n\n\nfunction createList(coordSys, seriesModel, mpModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return zrUtil.defaults({\n        name: coordDim\n      }, info);\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var mpData = new List(coordDimsInfos, mpModel);\n  var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));\n\n  if (coordSys) {\n    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));\n  }\n\n  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  });\n  return mpData;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkPointView.js\n// module id = 1652\n// module chunks = 2","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar numberUtil = require(\"../../util/number\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\nvar indexOf = zrUtil.indexOf;\n\nfunction hasXOrY(item) {\n  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n}\n\nfunction hasXAndY(item) {\n  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n} // Make it simple, do not visit all stacked value to count precision.\n// function getPrecision(data, valueAxisDim, dataIndex) {\n//     var precision = -1;\n//     var stackedDim = data.mapDimension(valueAxisDim);\n//     do {\n//         precision = Math.max(\n//             numberUtil.getPrecision(data.get(stackedDim, dataIndex)),\n//             precision\n//         );\n//         var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n//         if (stackedOnSeries) {\n//             var byValue = data.get(data.getCalculationInfo('stackedByDimension'), dataIndex);\n//             data = stackedOnSeries.getData();\n//             dataIndex = data.indexOf(data.getCalculationInfo('stackedByDimension'), byValue);\n//             stackedDim = data.getCalculationInfo('stackedDimension');\n//         }\n//         else {\n//             data = null;\n//         }\n//     } while (data);\n//     return precision;\n// }\n\n\nfunction markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n  var coordArr = [];\n  var stacked = isDimensionStacked(data, targetDataDim, otherDataDim);\n  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n  var value = numCalculate(data, calcDataDim, mlType);\n  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n  coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex); // Make it simple, do not visit all stacked value to count precision.\n\n  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));\n  precision = Math.min(precision, 20);\n\n  if (precision >= 0) {\n    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n  }\n\n  return coordArr;\n}\n\nvar curry = zrUtil.curry; // TODO Specified percent\n\nvar markerTypeCalculator = {\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  min: curry(markerTypeCalculatorWithExtent, 'min'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  max: curry(markerTypeCalculatorWithExtent, 'max'),\n\n  /**\n   * @method\n   * @param {module:echarts/data/List} data\n   * @param {string} baseAxisDim\n   * @param {string} valueAxisDim\n   */\n  average: curry(markerTypeCalculatorWithExtent, 'average')\n};\n/**\n * Transform markPoint data item to format used in List by do the following\n * 1. Calculate statistic like `max`, `min`, `average`\n * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array\n * @param  {module:echarts/model/Series} seriesModel\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {Object}\n */\n\nfunction dataTransform(seriesModel, item) {\n  var data = seriesModel.getData();\n  var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly\n  // 2. If `coord` is not a data array. Which uses `xAxis`,\n  // `yAxis` to specify the coord on each dimension\n  // parseFloat first because item.x and item.y can be percent string like '20%'\n\n  if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {\n    var dims = coordSys.dimensions;\n    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option\n    // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value\n\n    item = zrUtil.clone(item);\n\n    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n      item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex); // Force to use the value of calculated value.\n\n      item.value = item.coord[targetCoordIndex];\n    } else {\n      // FIXME Only has one of xAxis and yAxis.\n      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis]; // Each coord support max, min, average\n\n      for (var i = 0; i < 2; i++) {\n        if (markerTypeCalculator[coord[i]]) {\n          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n        }\n      }\n\n      item.coord = coord;\n    }\n  }\n\n  return item;\n}\n\nfunction getAxisInfo(item, data, coordSys, seriesModel) {\n  var ret = {};\n\n  if (item.valueIndex != null || item.valueDim != null) {\n    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n  } else {\n    ret.baseAxis = seriesModel.getBaseAxis();\n    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n  }\n\n  return ret;\n}\n\nfunction dataDimToCoordDim(seriesModel, dataDim) {\n  var data = seriesModel.getData();\n  var dimensions = data.dimensions;\n  dataDim = data.getDimension(dataDim);\n\n  for (var i = 0; i < dimensions.length; i++) {\n    var dimItem = data.getDimensionInfo(dimensions[i]);\n\n    if (dimItem.name === dataDim) {\n      return dimItem.coordDim;\n    }\n  }\n}\n/**\n * Filter data which is out of coordinateSystem range\n * [dataFilter description]\n * @param  {module:echarts/coord/*} [coordSys]\n * @param  {Object} item\n * @return {boolean}\n */\n\n\nfunction dataFilter(coordSys, item) {\n  // Alwalys return true if there is no coordSys\n  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n}\n\nfunction dimValueGetter(item, dimName, dataIndex, dimIndex) {\n  // x, y, radius, angle\n  if (dimIndex < 2) {\n    return item.coord && item.coord[dimIndex];\n  }\n\n  return item.value;\n}\n\nfunction numCalculate(data, valueDataDim, type) {\n  if (type === 'average') {\n    var sum = 0;\n    var count = 0;\n    data.each(valueDataDim, function (val, idx) {\n      if (!isNaN(val)) {\n        sum += val;\n        count++;\n      }\n    });\n    return sum / count;\n  } else {\n    return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0];\n  }\n}\n\nexports.dataTransform = dataTransform;\nexports.getAxisInfo = getAxisInfo;\nexports.dataFilter = dataFilter;\nexports.dimValueGetter = dimValueGetter;\nexports.numCalculate = numCalculate;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/markerHelper.js\n// module id = 1653\n// module chunks = 2","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _default = echarts.extendComponentView({\n  type: 'marker',\n  init: function () {\n    /**\n     * Markline grouped by series\n     * @private\n     * @type {module:zrender/core/util.HashMap}\n     */\n    this.markerGroupMap = zrUtil.createHashMap();\n  },\n  render: function (markerModel, ecModel, api) {\n    var markerGroupMap = this.markerGroupMap;\n    markerGroupMap.each(function (item) {\n      item.__keep = false;\n    });\n    var markerModelKey = this.type + 'Model';\n    ecModel.eachSeries(function (seriesModel) {\n      var markerModel = seriesModel[markerModelKey];\n      markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api);\n    }, this);\n    markerGroupMap.each(function (item) {\n      !item.__keep && this.group.remove(item.group);\n    }, this);\n  },\n  renderSeries: function () {}\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/marker/MarkerView.js\n// module id = 1654\n// module chunks = 2"],"sourceRoot":""}
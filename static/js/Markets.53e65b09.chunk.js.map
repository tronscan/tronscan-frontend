{"version":3,"sources":["../static/js/Markets.53e65b09.chunk.js","components/markets/index.js","../node_modules/echarts/lib/chart/helper/Symbol.js","../node_modules/echarts/lib/chart/line/helper.js","../node_modules/echarts/lib/chart/line.js","../node_modules/echarts/lib/chart/helper/SymbolDraw.js","../node_modules/echarts/lib/chart/line/LineSeries.js","../node_modules/echarts/lib/chart/line/LineView.js","../node_modules/echarts/lib/chart/line/lineAnimationDiff.js","../node_modules/echarts/lib/chart/line/poly.js","../node_modules/echarts/lib/visual/symbol.js","../node_modules/echarts/lib/layout/points.js","../node_modules/echarts/lib/processor/dataSample.js","../node_modules/echarts/lib/component/helper/listComponent.js","../node_modules/echarts/lib/component/legend/LegendModel.js","../node_modules/echarts/lib/component/legend/LegendView.js","../node_modules/echarts/lib/chart/pie.js","../node_modules/echarts/lib/chart/pie/PieSeries.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/component/helper/selectableMixin.js","../node_modules/echarts/lib/chart/pie/PieView.js","../node_modules/echarts/lib/action/createDataSelectAction.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/chart/pie/pieLayout.js","../node_modules/echarts/lib/chart/pie/labelLayout.js","../node_modules/echarts/lib/processor/dataFilter.js","components/common/LineChart.js","../node_modules/echarts/lib/component/legend.js","../node_modules/echarts/lib/component/legend/legendAction.js","../node_modules/echarts/lib/component/legend/legendFilter.js","../node_modules/echarts/lib/component/legend/ScrollableLegendModel.js","../node_modules/echarts/lib/component/legend/ScrollableLegendView.js","../node_modules/echarts/lib/component/legend/scrollableLegendAction.js","components/markets/MarketOverview.js","components/common/RingPieChart.js"],"names":["webpackJsonp","1186","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_asyncToGenerator","fn","gen","apply","this","arguments","Promise","resolve","reject","step","key","arg","info","value","error","done","then","err","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","mapStateToProps","state","priceGraph","markets","price","volumeGraph","volume","defineProperty","_regenerator","_regenerator2","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_react","_react2","_reactIntl","_reactRedux","_markets","_i18n","_MarketOverview","_MarketOverview2","_loaders","_api","_LineChart","_LineChart2","_RingPieChart","_RingPieChart2","Markets","_React$Component","_this2","_this","getPrototypeOf","loadMarketData","mark","_callee","wrap","_context","prev","next","loadPriceData","Client","getMarkets","sent","setState","stop","_props","intl","createElement","className","tu","style","height","TronLoader","data","keysData","format","time","date","Component","mapDispatchToProps","connect","pure","injectIntl","1239","getSymbolSize","idx","symbolSize","getItemVisual","Array","slice","getScale","SymbolClz","seriesScope","graphic","Group","updateData","driftSymbol","dx","dy","parent","drift","zrUtil","_symbol","createSymbol","_number","parsePercent","_labelHelper","getDefaultLabel","symbolProto","_createSymbol","symbolType","removeAll","color","symbolPath","attr","z2","culling","scale","_symbolType","add","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","trigger","downplay","setZ","zlevel","z","setDraggable","draggable","cursor","silent","seriesModel","hostModel","isInit","updateProps","_updateCommon","fadeIn","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","getLabelDefaultText","opt","useNameLabel","getName","type","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","labelModel","hoverLabelModel","hoverAnimation","cursorStyle","hasItemOption","itemModel","getItemModel","getModel","getItemStyle","getShallow","extend","elStyle","Math","PI","setColor","symbolInnerColor","setStyle","setLabelStyle","labelFetcher","labelDataIndex","defaultText","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","incremental","ratio","animateTo","max","onNormal","on","fadeOut","cb","keepLabel","text","dataIndex","inherits","_default","1240","prepareDataCoordInfo","coordSys","valueOrigin","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","getValueStart","baseAxisDim","dim","valueAxisDim","valueDim","mapDimension","baseDim","baseDataOffset","stacked","isDimensionStacked","dataDimsForPoint","map","dimensions","coordDim","stackedOverDimension","getCalculationInfo","extent","getExtent","getStackedOnPoint","dataCoordInfo","NaN","get","isNaN","stackedData","dataToPoint","_dataStackHelper","_util","1266","echarts","visualSymbol","layoutPoints","dataSample","registerVisual","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","1267","SymbolDraw","symbolCtor","group","_symbolCtor","symbolNeedsDraw","point","isIgnore","clipShape","contain","normalizeUpdateOpt","isObject","makeSeriesScope","symbolDrawProto","oldData","_data","SymbolCtor","diff","newIdx","getItemLayout","symbolEl","setItemGraphicEl","update","oldIdx","getItemGraphicEl","remove","position","el","execute","isPersistent","updateLayout","eachItemGraphicEl","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","useHoverLayer","start","end","traverse","enableAnimation","1281","_config","createListFromArray","__DEV__","SeriesModel","dependencies","getInitialData","option","ecModel","getSource","defaultOption","coordinateSystem","legendHoverLink","clipOverflow","label","lineStyle","width","smooth","smoothMonotone","symbol","showSymbol","showAllSymbol","connectNulls","sampling","animationEasing","progressive","hoverLayerThreshold","Infinity","1282","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","axis","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","getStackedOnPoints","points","len","count","push","createGridClipShape","cartesian","hasAnimation","xExtent","getAxis","yExtent","isHorizontal","x","min","y","lineWidth","expandSize","clipPath","Rect","shape","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","Sector","cx","cy","r0","r","startAngle","endAngle","clockwise","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","pt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","visualMeta","dimIndex","dimension","dimName","dimInfo","getDimensionInfo","colorStops","stops","coord","toGlobalCoord","dataToCoord","stopLen","outerColors","reverse","minCoord","maxCoord","coordSpan","each","offset","unshift","gradient","LinearGradient","lineAnimationDiff","modelUtil","_poly","Polyline","Polygon","ChartView","_helper","init","lineGroup","symbolDraw","_symbolDraw","_lineGroup","render","api","getData","lineStyleModel","areaStyleModel","mapArray","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","coordSysClipShape","setClipPath","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","defaults","getLineStyle","fill","stroke","lineJoin","stackedOnSeries","stackedOnSmooth","getAreaStyle","_valueOrigin","dispose","payload","queryDataIndex","ignore","categoryAxis","getAxesByScale","isLabelIgnored","bind","current","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","1283","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","diffItem","pointAdded","currentPt","getRawIndex","rawIndex","sort","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","1284","isPointNull","p","drawSegment","ctx","segLen","allLen","smoothMin","smoothMax","isMono","drawMono","drawNonMono","last","lastDiff","prevIdx","k","prevP","ctrlLen","v2Copy","cp0","cp1","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","vec2","sub","v","lenPrevSeg","lenNextSeg","abs","dist","scaleAndAdd","vec2Min","vec2Max","getBoundingBox","smoothConstraint","ptMin","ptMax","Path","fixClipWithShadow","copy","brush","buildPath","result","bbox","stackedOnBBox","closePath","1285","seriesType","defaultSymbolType","legendSymbol","performRawSeries","reset","dataEach","rawValue","getRawValue","params","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize","setVisual","isSeriesFiltered","hasCallback","1286","plan","createRenderPlanner","progress","segCount","isLargeRender","Float32Array","dimLen","tmpIn","tmpOut","dims","setItemLayout","setLayout","pipelineContext","large","1287","size","rate","round","sampler","samplers","setData","downSample","indexSampler","average","frame","sum","nearest","1290","layout","componentModel","boxLayoutParams","getBoxLayoutParams","padding","viewportSize","getWidth","getHeight","rect","getLayoutRect","layoutBox","positionElement","makeBackground","formatUtil","normalizeCssArray","_layout","box","1291","Model","_model","isNameSpecified","LegendModel","extendComponentModel","layoutMode","ignoreSize","parentModel","mergeDefaultAndTheme","selected","mergeOption","superCall","optionUpdated","_updateData","legendData","hasSelected","name","isSelected","select","potentialData","availableNames","eachRawSeries","seriesName","isPotential","legendDataProvider","names","concat","_availableNames","rawData","dataItem","unSelect","toggleSelected","hasOwnProperty","indexOf","show","orient","left","top","align","backgroundColor","borderColor","borderRadius","borderWidth","itemGap","itemWidth","itemHeight","inactiveColor","textStyle","selectedMode","tooltip","1292","dispatchSelectAction","dispatchAction","dispatchHighlightAction","dataName","getZr","storage","getDisplayList","dispatchDownplayAction","_listComponent","layoutUtil","curry","extendComponentView","newlineDisabled","_contentGroup","_backgroundEl","getContentGroup","legendModel","resetInner","itemAlign","renderInner","positionInfo","maxSize","mainRect","layoutInner","layoutRect","contentGroup","legendDrawnMap","createHashMap","selectMode","newline","getSeriesByName","legendSymbolType","itemGroup","_createItem","set","indexOfName","textStyleModel","itemIcon","tooltipModel","legendGlobalTooltipModel","textX","textAlign","formatter","content","replace","Text","setTextStyle","textFill","getTextColor","textVerticalAlign","hitRect","getBoundingRect","invisible","formatterParams","componentType","legendIndex","componentIndex","$vars","eachChild","child","__legendDataIndex","contentRect","1355","createDataSelectAction","dataColor","pieLayout","dataFilter","event","method","1356","createListSimply","getPercentWithPrecision","dataSelectableMixin","_dataProvider","retrieveRawAttr","PieSeries","extendSeriesModel","superApply","getRawData","updateSelectedMap","_createSelectableList","_defaultLabelLine","newOption","targetList","valueList","percent","defaultEmphasis","labelLineNormalOpt","labelLine","labelLineEmphasisOpt","emphasis","center","radius","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","rotate","length2","animationType","mixin","1357","nameList","isArray","coordDimensions","source","dimensionsInfo","createDimensions","list","List","initData","1358","_targetList","_selectTargetMap","reduce","targetMap","id","1359","updateDataSelected","uid","from","seriesId","toggleItemSelected","midAngle","cos","sin","animate","when","PiePiece","hoverIgnore","normalIgnore","sector","piePieceProto","firstCreate","sectorShape","_updateLabel","labelText","labelLayout","linePoints","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","useInsideStyle","inside","verticalAlign","PieView","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","piePiece","removeClipPath","_createClipPath","containPoint","itemLayout","sqrt","1360","actionInfos","actionInfo","registerAction","eachComponent","mainType","subType","query","1361","getTargetSeries","paletteScope","seiresModelMap","eachSeriesByType","__paletteScope","dataAll","idxMap","rawIdx","filteredIdx","singleDataColor","getColorFromPalette","1362","validDataCount","getSum","unitRadian","roseType","getDataExtent","restAngle","PI2","valueSumLargerThanMinAngle","currentAngle","angle","linearMap","1363","adjustSingleSide","viewWidth","viewHeight","shiftUp","delta","j","changeX","isDownList","lastDeltaX","Number","MAX_VALUE","l","deltaY","len2","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textY","labelPosition","labelLineLen","labelLineLen2","isLabelInside","x1","y1","x2","y2","x3","y3","font","getFont","labelRotate","getFormattedLabel","textRect","textContain","1364","legendModels","findComponents","filterSelf","1365","LineReact","undefined","_chartConfig","_chartConfig2","_echarts","_echarts2","random","lineId","myChart","getInstanceByDom","document","getElementById","lineChart","title","xAxis","series","val","formatDate","formatTime","setOption","initLine","1368","legendFilter","registerSubTypeDefaulter","1369","legendSelectActionHandler","methodName","selectedMap","isToggleSelect","model","isItemSelected","1370","filterSeries","1371","mergeAndNormalizeLayoutParams","raw","getOrient","index","mergeLayoutParam","getLayoutParams","ScrollableLegendModel","setScrollDataIndex","scrollDataIndex","pageButtonItemGap","pageButtonGap","pageButtonPosition","pageFormatter","pageIcons","horizontal","vertical","pageIconColor","pageIconInactiveColor","pageIconSize","pageTextStyle","animationDurationUpdate","extraOpt","inputPositionParams","1372","LegendView","WH","XY","ScrollableLegendView","_currentIndex","_containerGroup","_controllerGroup","_showController","__rectSize","createPageButton","iconIdx","pageDataIndexName","icon","createIcon","onclick","me","_pageGo","controllerGroup","pageTextStyleModel","containerGroup","orientIdx","wh","hw","yx","controllerRect","showController","contentPos","containerPos","controllerPos","retrieve2","pageInfo","_getPageInfo","pageIndex","contentPosition","_updatePageInfoView","to","legendId","canJump","childOfName","pageText","total","pageCount","isString","getItemRect","itemRect","clone","xy","pagePrevDataIndex","pageNextDataIndex","targetItemGroup","currDataIndex","containerRectSize","ceil","itemLoc","floor","winRect","startIdx","children","intersect","startItem","startRect","1373","1655","_Links","_Price","MarketOverview","_Component","load","_ref","property","obj1","obj2","market","rank","ExternalLink","url","link","pair","TRXPrice","amount","volumeNative","FormattedNumber","volumePercentage","maximumFractionDigits","1656","_toConsumableArray","arr","arr2","RingPieReact","pieId","compare","ringPieChart","legend","sortObj","pairData","exchanges","temp","subCount","finalExchanges","finalPairData","initPie"],"mappings":"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","file":"static/js/Markets.53e65b09.chunk.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 1186:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(5);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(8);var _reactRedux=__webpack_require__(7);var _markets=__webpack_require__(440);var _i18n=__webpack_require__(4);var _MarketOverview=__webpack_require__(1655);var _MarketOverview2=_interopRequireDefault(_MarketOverview);var _loaders=__webpack_require__(19);var _api=__webpack_require__(6);var _LineChart=__webpack_require__(1365);var _LineChart2=_interopRequireDefault(_LineChart);var _RingPieChart=__webpack_require__(1656);var _RingPieChart2=_interopRequireDefault(_RingPieChart);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Markets=function(_React$Component){_inherits(Markets,_React$Component);function Markets(){var _this2=this;_classCallCheck(this,Markets);var _this=_possibleConstructorReturn(this,(Markets.__proto__||Object.getPrototypeOf(Markets)).call(this));_this.loadMarketData=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var markets;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_this.props.loadPriceData();_context.next=3;return _api.Client.getMarkets();case 3:markets=_context.sent;_this.setState({markets:markets});case 5:case\"end\":return _context.stop();}}},_callee,_this2);}));_this.state={priceGraph:[],volumeGraph:[],markets:[]};return _this;}_createClass(Markets,[{key:\"componentDidMount\",value:function componentDidMount(){this.loadMarketData();}},{key:\"render\",value:function render(){var _props=this.props,intl=_props.intl,priceGraph=_props.priceGraph,volumeGraph=_props.volumeGraph;var markets=this.state.markets;return _react2.default.createElement(\"main\",{className:\"container header-overlap pb-3\"},_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3 mt-md-0\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"average_price_usd\")),_react2.default.createElement(\"div\",{style:{height:300}},priceGraph.length===0?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:priceGraph,keysData:['time','close'],format:{time:true,date:true}}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3 mt-md-0\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"average_volume_usd\")),_react2.default.createElement(\"div\",{style:{height:300}},volumeGraph.length===0?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:volumeGraph,keysData:['time','volume'],format:{time:true}})))))),_react2.default.createElement(\"div\",{className:\"row mt-3\"},_react2.default.createElement(\"div\",{className:\"col-md-12\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"Trade Volume\"),' Top 10'),_react2.default.createElement(_RingPieChart2.default,{style:{height:700},data:markets}))))),_react2.default.createElement(\"div\",{className:\"row mt-3\"},_react2.default.createElement(\"div\",{className:\"col-md-12\"},_react2.default.createElement(_MarketOverview2.default,{markets:markets}))));}}]);return Markets;}(_react2.default.Component);function mapStateToProps(state){return{priceGraph:state.markets.price,volumeGraph:state.markets.volume};}var mapDispatchToProps={loadPriceData:_markets.loadPriceData};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(Markets));\n\n/***/ }),\n\n/***/ 1239:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar _symbol = __webpack_require__(224);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(22);\n\nvar _number = __webpack_require__(27);\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = __webpack_require__(433);\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1240:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = __webpack_require__(2);\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n/***/ }),\n\n/***/ 1266:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n__webpack_require__(1281);\n\n__webpack_require__(1282);\n\nvar visualSymbol = __webpack_require__(1285);\n\nvar layoutPoints = __webpack_require__(1286);\n\nvar dataSample = __webpack_require__(1287);\n\n__webpack_require__(434);\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n/***/ }),\n\n/***/ 1267:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(22);\n\nvar SymbolClz = __webpack_require__(1239);\n\nvar _util = __webpack_require__(2);\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1281:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = __webpack_require__(226);\n\nvar SeriesModel = __webpack_require__(225);\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1282:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(2);\n\nvar SymbolDraw = __webpack_require__(1267);\n\nvar SymbolClz = __webpack_require__(1239);\n\nvar lineAnimationDiff = __webpack_require__(1283);\n\nvar graphic = __webpack_require__(22);\n\nvar modelUtil = __webpack_require__(12);\n\nvar _poly = __webpack_require__(1284);\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = __webpack_require__(424);\n\nvar _helper = __webpack_require__(1240);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1283:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _helper = __webpack_require__(1240);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1284:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(32);\n\nvar vec2 = __webpack_require__(25);\n\nvar fixClipWithShadow = __webpack_require__(431);\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n/***/ }),\n\n/***/ 1285:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1286:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(2);\n\nvar map = _util.map;\n\nvar createRenderPlanner = __webpack_require__(432);\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1287:\n/***/ (function(module, exports) {\n\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1290:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _layout = __webpack_require__(57);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(37);\n\nvar graphic = __webpack_require__(22);\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n/***/ }),\n\n/***/ 1291:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar Model = __webpack_require__(45);\n\nvar _model = __webpack_require__(12);\n\nvar isNameSpecified = _model.isNameSpecified;\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // \n    zlevel: 0,\n    // \n    z: 4,\n    show: true,\n    // \n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // \n    // 'auto' | 'left' | 'right'\n    //  'auto',  x \n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // \n    borderColor: '#ccc',\n    borderRadius: 0,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // itempx10\n    // \n    itemGap: 10,\n    // \n    itemWidth: 25,\n    // \n    itemHeight: 14,\n    // \n    inactiveColor: '#ccc',\n    textStyle: {\n      // \n      color: '#333'\n    },\n    // formatter: '',\n    // \n    selectedMode: true,\n    // LEGEND.SELECTED\n    // selected: null,\n    // legend.dataitem\n    // data: [],\n    // Tooltip \n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1292:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(23);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar _symbol = __webpack_require__(224);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(22);\n\nvar _listComponent = __webpack_require__(1290);\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = __webpack_require__(57);\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1355:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\n__webpack_require__(1356);\n\n__webpack_require__(1359);\n\nvar createDataSelectAction = __webpack_require__(1360);\n\nvar dataColor = __webpack_require__(1361);\n\nvar pieLayout = __webpack_require__(1362);\n\nvar dataFilter = __webpack_require__(1364);\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n/***/ }),\n\n/***/ 1356:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar createListSimply = __webpack_require__(1357);\n\nvar zrUtil = __webpack_require__(2);\n\nvar modelUtil = __webpack_require__(12);\n\nvar _number = __webpack_require__(27);\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = __webpack_require__(1358);\n\nvar _dataProvider = __webpack_require__(95);\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // \n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // \n    clockwise: true,\n    startAngle: 90,\n    // 0\n    minAngle: 0,\n    // \n    selectedOffset: 10,\n    // \n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // singlemultiple\n    // selectedMode: false,\n    // 'radius' | 'area'\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: Tooltip.formatter\n      // TEXTSTYLE\n      // distance: positioninnerlabel()\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // \n      length: 15,\n      // \n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: ,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1357:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(228);\n\nvar List = __webpack_require__(227);\n\nvar _util = __webpack_require__(2);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1358:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1359:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar graphic = __webpack_require__(22);\n\nvar ChartView = __webpack_require__(424);\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1360:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1361:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(2);\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1362:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _number = __webpack_require__(27);\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = __webpack_require__(1363);\n\nvar zrUtil = __webpack_require__(2);\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME  2.0  roseType  area \n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1363:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textContain = __webpack_require__(74);\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // \n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // \n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // \n    ? Number.MAX_VALUE // \n    : 0 // \n    : isDownList // \n    ? Number.MAX_VALUE // \n    : 0; // \n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // \n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // \n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1364:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1365:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.LineReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(8);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1266);__webpack_require__(422);__webpack_require__(423);var _reactRedux=__webpack_require__(7);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var LineReact=exports.LineReact=function(_React$Component){_inherits(LineReact,_React$Component);function LineReact(props){_classCallCheck(this,LineReact);var _this=_possibleConstructorReturn(this,(LineReact.__proto__||Object.getPrototypeOf(LineReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={lineId:'line'+id};return _this;}_createClass(LineReact,[{key:'initLine',value:function initLine(id){var _props=this.props,intl=_props.intl,keysData=_props.keysData,data=_props.data,format=_props.format;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.lineChart.title.text='';_chartConfig2.default.lineChart.xAxis.data=[];_chartConfig2.default.lineChart.series[0].data=[];if(data&&data.length>0){data.map(function(val){if(format&&format[keysData[0]]){if(format.date){_chartConfig2.default.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]]*1000));}else{_chartConfig2.default.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]*1000));}}else _chartConfig2.default.lineChart.xAxis.data.push(val[keysData[0]]);_chartConfig2.default.lineChart.series[0].data.push(val[keysData[1]]);});}if(data&&data.length===0){_chartConfig2.default.lineChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.lineChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initLine(this.state.lineId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initLine(this.state.lineId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.lineId,style:this.props.style}));}}]);return LineReact;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(LineReact));\n\n/***/ }),\n\n/***/ 1368:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n__webpack_require__(1291);\n\n__webpack_require__(1369);\n\n__webpack_require__(1292);\n\nvar legendFilter = __webpack_require__(1370);\n\nvar Component = __webpack_require__(59);\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n/***/ }),\n\n/***/ 1369:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n/***/ }),\n\n/***/ 1370:\n/***/ (function(module, exports) {\n\nfunction _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1371:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar LegendModel = __webpack_require__(1291);\n\nvar _layout = __webpack_require__(57);\n\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar getLayoutParams = _layout.getLayoutParams;\nvar ScrollableLegendModel = LegendModel.extend({\n  type: 'legend.scroll',\n\n  /**\n   * @param {number} scrollDataIndex\n   */\n  setScrollDataIndex: function (scrollDataIndex) {\n    this.option.scrollDataIndex = scrollDataIndex;\n  },\n  defaultOption: {\n    scrollDataIndex: 0,\n    pageButtonItemGap: 5,\n    pageButtonGap: null,\n    pageButtonPosition: 'end',\n    // 'start' or 'end'\n    pageFormatter: '{current}/{total}',\n    // If null/undefined, do not show page.\n    pageIcons: {\n      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n    },\n    pageIconColor: '#2f4554',\n    pageIconInactiveColor: '#aaa',\n    pageIconSize: 15,\n    // Can be [10, 3], which represents [width, height]\n    pageTextStyle: {\n      color: '#333'\n    },\n    animationDurationUpdate: 800\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    var inputPositionParams = getLayoutParams(option);\n    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);\n    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (option, extraOpt) {\n    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);\n    mergeAndNormalizeLayoutParams(this, this.option, option);\n  },\n  getOrient: function () {\n    return this.get('orient') === 'vertical' ? {\n      index: 1,\n      name: 'vertical'\n    } : {\n      index: 0,\n      name: 'horizontal'\n    };\n  }\n}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.\n\nfunction mergeAndNormalizeLayoutParams(legendModel, target, raw) {\n  var orient = legendModel.getOrient();\n  var ignoreSize = [1, 1];\n  ignoreSize[orient.index] = 0;\n  mergeLayoutParam(target, raw, {\n    type: 'box',\n    ignoreSize: ignoreSize\n  });\n}\n\nvar _default = ScrollableLegendModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1372:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar graphic = __webpack_require__(22);\n\nvar layoutUtil = __webpack_require__(57);\n\nvar LegendView = __webpack_require__(1292);\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup;\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n\n    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    // Align left or top by the current dataIndex.\n    var currDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var contentRect = contentGroup.getBoundingRect();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var xy = XY[orientIdx];\n    var contentPos = contentGroup.position.slice();\n    var pageIndex;\n    var pagePrevDataIndex;\n    var pageNextDataIndex;\n    var targetItemGroup;\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child) {\n        if (child.__legendDataIndex === currDataIndex) {\n          targetItemGroup = child;\n        }\n      });\n    } else {\n      targetItemGroup = contentGroup.childAt(0);\n    }\n\n    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n    if (targetItemGroup) {\n      var itemRect = targetItemGroup.getBoundingRect();\n      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n      contentPos[orientIdx] = -itemLoc - contentRect[xy];\n      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);\n      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;\n      var winRect = {\n        x: 0,\n        y: 0\n      };\n      winRect[wh] = containerRectSize;\n      winRect[hw] = contentRect[hw];\n      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n      var startIdx;\n      var children = contentGroup.children();\n      contentGroup.eachChild(function (child, index) {\n        var itemRect = getItemRect(child);\n\n        if (itemRect.intersect(winRect)) {\n          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the\n          // current window is shown at the begining of next window.\n\n          pageNextDataIndex = child.__legendDataIndex;\n        } // If the last item is shown entirely, no next page.\n\n\n        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {\n          pageNextDataIndex = null;\n        }\n      }); // Always align based on the left/top most item, so the left/top most\n      // item in the previous window is needed to be found here.\n\n      if (startIdx != null) {\n        var startItem = children[startIdx];\n        var startRect = getItemRect(startItem);\n        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.\n\n        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n          pagePrevDataIndex = null;\n        } else {\n          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n            startIdx--;\n          }\n\n          pagePrevDataIndex = children[startIdx].__legendDataIndex;\n        }\n      }\n    }\n\n    return {\n      contentPosition: contentPos,\n      pageIndex: pageIndex,\n      pageCount: pageCount,\n      pagePrevDataIndex: pagePrevDataIndex,\n      pageNextDataIndex: pageNextDataIndex\n    };\n\n    function getItemRect(el) {\n      var itemRect = el.getBoundingRect().clone();\n      itemRect[xy] += el.position[orientIdx];\n      return itemRect;\n    }\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1373:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n/**\n * @event legendScroll\n * @type {Object}\n * @property {string} type 'legendScroll'\n * @property {string} scrollDataIndex\n */\necharts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {\n  var scrollDataIndex = payload.scrollDataIndex;\n  scrollDataIndex != null && ecModel.eachComponent({\n    mainType: 'legend',\n    subType: 'scroll',\n    query: payload\n  }, function (legendModel) {\n    legendModel.setScrollDataIndex(scrollDataIndex);\n  });\n});\n\n/***/ }),\n\n/***/ 1655:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(5);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _i18n=__webpack_require__(4);var _api=__webpack_require__(6);var _Links=__webpack_require__(10);var _reactIntl=__webpack_require__(8);var _Price=__webpack_require__(38);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var MarketOverview=function(_Component){_inherits(MarketOverview,_Component);function MarketOverview(){_classCallCheck(this,MarketOverview);var _this=_possibleConstructorReturn(this,(MarketOverview.__proto__||Object.getPrototypeOf(MarketOverview)).call(this));_this.state={markets:[]};return _this;}_createClass(MarketOverview,[{key:\"componentDidMount\",value:function componentDidMount(){// this.load();\n}},{key:\"load\",value:function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var markets;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _api.Client.getMarkets();case 2:markets=_context.sent;this.setState({markets:markets});case 4:case\"end\":return _context.stop();}}},_callee,this);}));function load(){return _ref.apply(this,arguments);}return load;}()},{key:\"render\",value:function render(){var markets=this.props.markets;function compare(property){return function(obj1,obj2){if(obj1[property]>obj2[property]){return 1;}else if(obj1[property]<obj2[property]){return-1;}else{return 0;}};}markets=markets.sort(compare(\"rank\")).slice(0,99);return _react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"table\",{className:\"table table-hover bg-white m-0 table-striped\"},_react2.default.createElement(\"thead\",{className:\"thead-dark\"},_react2.default.createElement(\"tr\",null,_react2.default.createElement(\"th\",{style:{width:25}},(0,_i18n.tu)(\"rank\")),_react2.default.createElement(\"th\",null,(0,_i18n.tu)(\"exchange\")),_react2.default.createElement(\"th\",{className:\"d-none d-sm-table-cell\",style:{width:75}},(0,_i18n.tu)(\"pair\")),_react2.default.createElement(\"th\",{className:\"d-none d-md-table-cell\",style:{width:100}},(0,_i18n.tu)(\"volume\")),_react2.default.createElement(\"th\",{className:\"d-none d-md-table-cell\",style:{width:75}},\"%\"),_react2.default.createElement(\"th\",{className:\"text-right\",style:{width:100}},(0,_i18n.tu)(\"price\")))),_react2.default.createElement(\"tbody\",null,markets.map(function(market){return _react2.default.createElement(\"tr\",{key:market.rank},_react2.default.createElement(\"th\",null,market.rank),_react2.default.createElement(\"td\",null,_react2.default.createElement(_Links.ExternalLink,{url:market.link},market.name)),_react2.default.createElement(\"td\",{className:\"d-none d-sm-table-cell\",style:{width:75}},_react2.default.createElement(_Links.ExternalLink,{url:market.link},market.pair)),_react2.default.createElement(\"td\",{className:\"text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_Price.TRXPrice,{amount:market.volumeNative})),_react2.default.createElement(\"td\",{className:\"text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_reactIntl.FormattedNumber,{value:market.volumePercentage,maximumFractionDigits:2}),\"%\"),_react2.default.createElement(\"td\",{className:\"text-right\"},\"$\",_react2.default.createElement(_reactIntl.FormattedNumber,{value:market.price,maximumFractionDigits:8})));}))));}}]);return MarketOverview;}(_react.Component);exports.default=MarketOverview;\n\n/***/ }),\n\n/***/ 1656:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.RingPieReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1355);__webpack_require__(422);__webpack_require__(423);__webpack_require__(1368);__webpack_require__(1371);__webpack_require__(1372);__webpack_require__(1373);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var RingPieReact=exports.RingPieReact=function(_React$Component){_inherits(RingPieReact,_React$Component);function RingPieReact(props){_classCallCheck(this,RingPieReact);var _this=_possibleConstructorReturn(this,(RingPieReact.__proto__||Object.getPrototypeOf(RingPieReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={pieId:'ringPie'+id};return _this;}_createClass(RingPieReact,[{key:'initPie',value:function initPie(id){var data=this.props.data;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.ringPieChart.series[0].data=[];_chartConfig2.default.ringPieChart.series[1].data=[];_chartConfig2.default.ringPieChart.legend.data=[];_chartConfig2.default.ringPieChart.title.text=\"\";function compare(property){return function(obj1,obj2){if(obj1[property]>obj2[property]){return 1;}else if(obj1[property]<obj2[property]){return-1;}else{return 0;}};}if(data&&data.length>0){var sortObj=data.sort(compare(\"name\"));var pairData=[];var exchanges=[];var temp=[];for(var index in sortObj){pairData.push({name:sortObj[index].pair,value:sortObj[index].volume});if(temp.indexOf(sortObj[index].name)<0){temp.push(sortObj[index].name);exchanges.push({name:sortObj[index].name,value:0,subCount:[]});}}for(var _index in exchanges){for(var idx in sortObj){if(sortObj[idx].name===exchanges[_index].name){exchanges[_index].value=exchanges[_index].value+sortObj[idx].volume;exchanges[_index].subCount.push({name:sortObj[idx].pair,value:sortObj[idx].volume});}}}exchanges.sort(compare(\"value\"));var finalExchanges=exchanges.slice(exchanges.length-10,exchanges.length);var finalPairData=[];for(var _index2 in finalExchanges){finalPairData.push.apply(finalPairData,_toConsumableArray(finalExchanges[_index2].subCount));}_chartConfig2.default.ringPieChart.series[0].data=[];_chartConfig2.default.ringPieChart.series[1].data=[];_chartConfig2.default.ringPieChart.legend.data=temp;_chartConfig2.default.ringPieChart.series[0].data=finalExchanges;_chartConfig2.default.ringPieChart.series[1].data=finalPairData;}if(data&&data.length===0){_chartConfig2.default.ringPieChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.ringPieChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initPie(this.state.pieId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie(this.state.pieId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.pieId,style:this.props.style}));}}]);return RingPieReact;}(_react2.default.Component);exports.default=RingPieReact;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/Markets.53e65b09.chunk.js","import React, {Fragment} from \"react\";\nimport {injectIntl} from \"react-intl\";\nimport {connect} from \"react-redux\";\nimport {loadPriceData} from \"../../actions/markets\";\nimport {tu} from \"../../utils/i18n\";\nimport MarketOverview from \"./MarketOverview\";\nimport {TronLoader} from \"../common/loaders\";\nimport {Client} from \"../../services/api\";\nimport LineReact from \"../common/LineChart\";\nimport RingPieReact from \"../common/RingPieChart\";\n\nclass Markets extends React.Component {\n\n  constructor() {\n    super();\n\n    this.state = {\n      priceGraph: [],\n      volumeGraph: [],\n      markets: [],\n    };\n  }\n\n  componentDidMount() {\n    this.loadMarketData();\n  }\n\n  loadMarketData = async () => {\n    this.props.loadPriceData();\n\n    let markets = await Client.getMarkets();\n\n    this.setState({\n      markets,\n    });\n  };\n\n  render() {\n\n    let {intl, priceGraph, volumeGraph} = this.props;\n    let {markets} = this.state;\n\n    return (\n        <main className=\"container header-overlap pb-3\">\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3 mt-md-0\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"average_price_usd\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      priceGraph.length === 0 ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={priceGraph} keysData={['time', 'close']}\n                                     format={{time: true, date: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3 mt-md-0\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"average_volume_usd\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      volumeGraph.length === 0 ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={volumeGraph} keysData={['time', 'volume']}\n                                     format={{time: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row mt-3\">\n            <div className=\"col-md-12\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"Trade Volume\")}{' Top 10'}</h5>\n                  <RingPieReact style={{height: 700}} data={markets}/>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row mt-3\">\n            <div className=\"col-md-12\">\n              <MarketOverview markets={markets}/>\n            </div>\n          </div>\n        </main>\n    );\n  }\n}\n\n\nfunction mapStateToProps(state) {\n  return {\n    priceGraph: state.markets.price,\n    volumeGraph: state.markets.volume,\n  };\n}\n\nconst mapDispatchToProps = {\n  loadPriceData,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(Markets));\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/markets/index.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Symbol.js\n// module id = 1239\n// module chunks = 2 3 4","var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/helper.js\n// module id = 1240\n// module chunks = 2 3 4","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line.js\n// module id = 1266\n// module chunks = 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 1267\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineSeries.js\n// module id = 1281\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineView.js\n// module id = 1282\n// module chunks = 2 3 4","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 1283\n// module chunks = 2 3 4","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/poly.js\n// module id = 1284\n// module chunks = 2 3 4","function _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = 1285\n// module chunks = 2 3 4","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/points.js\n// module id = 1286\n// module chunks = 2 3 4","var samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataSample.js\n// module id = 1287\n// module chunks = 2 3 4","var _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/listComponent.js\n// module id = 1290\n// module chunks = 2 3 4","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _model = require(\"../../util/model\");\n\nvar isNameSpecified = _model.isNameSpecified;\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // \n    zlevel: 0,\n    // \n    z: 4,\n    show: true,\n    // \n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // \n    // 'auto' | 'left' | 'right'\n    //  'auto',  x \n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // \n    borderColor: '#ccc',\n    borderRadius: 0,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // itempx10\n    // \n    itemGap: 10,\n    // \n    itemWidth: 25,\n    // \n    itemHeight: 14,\n    // \n    inactiveColor: '#ccc',\n    textStyle: {\n      // \n      color: '#333'\n    },\n    // formatter: '',\n    // \n    selectedMode: true,\n    // LEGEND.SELECTED\n    // selected: null,\n    // legend.dataitem\n    // data: [],\n    // Tooltip \n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendModel.js\n// module id = 1291\n// module chunks = 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _listComponent = require(\"../helper/listComponent\");\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendView.js\n// module id = 1292\n// module chunks = 3 4","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./pie/PieSeries\");\n\nrequire(\"./pie/PieView\");\n\nvar createDataSelectAction = require(\"../action/createDataSelectAction\");\n\nvar dataColor = require(\"../visual/dataColor\");\n\nvar pieLayout = require(\"./pie/pieLayout\");\n\nvar dataFilter = require(\"../processor/dataFilter\");\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie.js\n// module id = 1355\n// module chunks = 2 3","var echarts = require(\"../../echarts\");\n\nvar createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _number = require(\"../../util/number\");\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = require(\"../../component/helper/selectableMixin\");\n\nvar _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // \n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // \n    clockwise: true,\n    startAngle: 90,\n    // 0\n    minAngle: 0,\n    // \n    selectedOffset: 10,\n    // \n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // singlemultiple\n    // selectedMode: false,\n    // 'radius' | 'area'\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: Tooltip.formatter\n      // TEXTSTYLE\n      // distance: positioninnerlabel()\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // \n      length: 15,\n      // \n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: ,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n// module id = 1356\n// module chunks = 2 3","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 1357\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/selectableMixin.js\n// module id = 1358\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieView.js\n// module id = 1359\n// module chunks = 2 3","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/action/createDataSelectAction.js\n// module id = 1360\n// module chunks = 2 3","var _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 1361\n// module chunks = 2 3","var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME  2.0  roseType  area \n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n// module id = 1362\n// module chunks = 2 3","var textContain = require(\"zrender/lib/contain/text\");\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // \n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // \n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // \n    ? Number.MAX_VALUE // \n    : 0 // \n    : isDownList // \n    ? Number.MAX_VALUE // \n    : 0; // \n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // \n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // \n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n// module id = 1363\n// module chunks = 2 3","function _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 1364\n// module chunks = 2 3","import React from 'react'\nimport {injectIntl} from \"react-intl\";\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/line'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport {connect} from \"react-redux\";\n\nexport class LineReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      lineId: 'line' + id\n    }\n  }\n\n  initLine(id) {\n    let {intl, keysData, data, format} = this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.lineChart.title.text='';\n    config.lineChart.xAxis.data = [];\n    config.lineChart.series[0].data = [];\n    if(data && data.length>0) {\n      data.map((val) => {\n\n        if (format && format[keysData[0]]) {\n          if (format.date) {\n            config.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]] * 1000));\n          }\n          else {\n            config.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]] * 1000));\n          }\n        }\n        else\n          config.lineChart.xAxis.data.push(val[keysData[0]]);\n\n\n        config.lineChart.series[0].data.push(val[keysData[1]]);\n      })\n    }\n    if(data && data.length===0){\n      config.lineChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.lineChart);\n\n  }\n\n  componentDidMount() {\n    this.initLine(this.state.lineId);\n  }\n\n  componentDidUpdate() {\n    this.initLine(this.state.lineId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.lineId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {}\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(LineReact));\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/LineChart.js","var echarts = require(\"../echarts\");\n\nrequire(\"./legend/LegendModel\");\n\nrequire(\"./legend/legendAction\");\n\nrequire(\"./legend/LegendView\");\n\nvar legendFilter = require(\"./legend/legendFilter\");\n\nvar Component = require(\"../model/Component\");\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend.js\n// module id = 1368\n// module chunks = 3 4","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendAction.js\n// module id = 1369\n// module chunks = 3 4","function _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendFilter.js\n// module id = 1370\n// module chunks = 3 4","var LegendModel = require(\"./LegendModel\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar getLayoutParams = _layout.getLayoutParams;\nvar ScrollableLegendModel = LegendModel.extend({\n  type: 'legend.scroll',\n\n  /**\n   * @param {number} scrollDataIndex\n   */\n  setScrollDataIndex: function (scrollDataIndex) {\n    this.option.scrollDataIndex = scrollDataIndex;\n  },\n  defaultOption: {\n    scrollDataIndex: 0,\n    pageButtonItemGap: 5,\n    pageButtonGap: null,\n    pageButtonPosition: 'end',\n    // 'start' or 'end'\n    pageFormatter: '{current}/{total}',\n    // If null/undefined, do not show page.\n    pageIcons: {\n      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n    },\n    pageIconColor: '#2f4554',\n    pageIconInactiveColor: '#aaa',\n    pageIconSize: 15,\n    // Can be [10, 3], which represents [width, height]\n    pageTextStyle: {\n      color: '#333'\n    },\n    animationDurationUpdate: 800\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    var inputPositionParams = getLayoutParams(option);\n    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);\n    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (option, extraOpt) {\n    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);\n    mergeAndNormalizeLayoutParams(this, this.option, option);\n  },\n  getOrient: function () {\n    return this.get('orient') === 'vertical' ? {\n      index: 1,\n      name: 'vertical'\n    } : {\n      index: 0,\n      name: 'horizontal'\n    };\n  }\n}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.\n\nfunction mergeAndNormalizeLayoutParams(legendModel, target, raw) {\n  var orient = legendModel.getOrient();\n  var ignoreSize = [1, 1];\n  ignoreSize[orient.index] = 0;\n  mergeLayoutParam(target, raw, {\n    type: 'box',\n    ignoreSize: ignoreSize\n  });\n}\n\nvar _default = ScrollableLegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js\n// module id = 1371\n// module chunks = 3 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup;\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n\n    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    // Align left or top by the current dataIndex.\n    var currDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var contentRect = contentGroup.getBoundingRect();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var xy = XY[orientIdx];\n    var contentPos = contentGroup.position.slice();\n    var pageIndex;\n    var pagePrevDataIndex;\n    var pageNextDataIndex;\n    var targetItemGroup;\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child) {\n        if (child.__legendDataIndex === currDataIndex) {\n          targetItemGroup = child;\n        }\n      });\n    } else {\n      targetItemGroup = contentGroup.childAt(0);\n    }\n\n    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n    if (targetItemGroup) {\n      var itemRect = targetItemGroup.getBoundingRect();\n      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n      contentPos[orientIdx] = -itemLoc - contentRect[xy];\n      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);\n      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;\n      var winRect = {\n        x: 0,\n        y: 0\n      };\n      winRect[wh] = containerRectSize;\n      winRect[hw] = contentRect[hw];\n      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n      var startIdx;\n      var children = contentGroup.children();\n      contentGroup.eachChild(function (child, index) {\n        var itemRect = getItemRect(child);\n\n        if (itemRect.intersect(winRect)) {\n          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the\n          // current window is shown at the begining of next window.\n\n          pageNextDataIndex = child.__legendDataIndex;\n        } // If the last item is shown entirely, no next page.\n\n\n        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {\n          pageNextDataIndex = null;\n        }\n      }); // Always align based on the left/top most item, so the left/top most\n      // item in the previous window is needed to be found here.\n\n      if (startIdx != null) {\n        var startItem = children[startIdx];\n        var startRect = getItemRect(startItem);\n        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.\n\n        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n          pagePrevDataIndex = null;\n        } else {\n          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n            startIdx--;\n          }\n\n          pagePrevDataIndex = children[startIdx].__legendDataIndex;\n        }\n      }\n    }\n\n    return {\n      contentPosition: contentPos,\n      pageIndex: pageIndex,\n      pageCount: pageCount,\n      pagePrevDataIndex: pagePrevDataIndex,\n      pageNextDataIndex: pageNextDataIndex\n    };\n\n    function getItemRect(el) {\n      var itemRect = el.getBoundingRect().clone();\n      itemRect[xy] += el.position[orientIdx];\n      return itemRect;\n    }\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/ScrollableLegendView.js\n// module id = 1372\n// module chunks = 3 4","var echarts = require(\"../../echarts\");\n\n/**\n * @event legendScroll\n * @type {Object}\n * @property {string} type 'legendScroll'\n * @property {string} scrollDataIndex\n */\necharts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {\n  var scrollDataIndex = payload.scrollDataIndex;\n  scrollDataIndex != null && ecModel.eachComponent({\n    mainType: 'legend',\n    subType: 'scroll',\n    query: payload\n  }, function (legendModel) {\n    legendModel.setScrollDataIndex(scrollDataIndex);\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/scrollableLegendAction.js\n// module id = 1373\n// module chunks = 3 4","import React, {Component} from \"react\";\nimport {tu} from \"../../utils/i18n\";\nimport {Client} from \"../../services/api\";\nimport {ExternalLink} from \"../common/Links\";\nimport {FormattedNumber} from \"react-intl\";\nimport {TRXPrice} from \"../common/Price\";\n\nexport default class MarketOverview extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      markets: [],\n    }\n  }\n\n  componentDidMount() {\n    // this.load();\n  }\n\n  async load() {\n    let markets = await Client.getMarkets();\n\n    this.setState({\n      markets,\n    });\n  }\n\n  render() {\n\n    let {markets} = this.props;\n\n    function compare(property) {\n      return function (obj1, obj2) {\n\n        if (obj1[property] > obj2[property]) {\n          return 1;\n        } else if (obj1[property] < obj2[property]) {\n          return -1;\n        } else {\n          return 0;\n        }\n\n      }\n    }\n    markets = markets.sort(compare(\"rank\")).slice(0, 99);\n\n    return (\n        <div className=\"card\">\n          <table className=\"table table-hover bg-white m-0 table-striped\">\n            <thead className=\"thead-dark\">\n              <tr>\n                <th style={{width: 25}}>{tu(\"rank\")}</th>\n                <th>{tu(\"exchange\")}</th>\n                <th className=\"d-none d-sm-table-cell\" style={{width: 75}}>{tu(\"pair\")}</th>\n                <th className=\"d-none d-md-table-cell\" style={{width: 100}}>{tu(\"volume\")}</th>\n                <th className=\"d-none d-md-table-cell\" style={{width: 75}}>%</th>\n                <th className=\"text-right\" style={{width: 100}}>{tu(\"price\")}</th>\n              </tr>\n            </thead>\n            <tbody>\n            {\n              markets.map(market => (\n                <tr key={market.rank}>\n                  <th>\n                    {market.rank}\n                  </th>\n                  <td>\n                    <ExternalLink url={market.link}>{market.name}</ExternalLink>\n                  </td>\n                  <td className=\"d-none d-sm-table-cell\" style={{width: 75}}>\n                    <ExternalLink url={market.link}>{market.pair}</ExternalLink>\n                  </td>\n                  <td className=\"text-nowrap d-none d-md-table-cell\">\n                    <TRXPrice amount={market.volumeNative} />\n                  </td>\n                  <td className=\"text-nowrap d-none d-md-table-cell\">\n                    <FormattedNumber value={market.volumePercentage} maximumFractionDigits={2} />%\n                  </td>\n                  <td className=\"text-right\">\n                    $<FormattedNumber value={market.price} maximumFractionDigits={8} />\n                  </td>\n                </tr>\n              ))\n            }\n            </tbody>\n          </table>\n        </div>\n    )\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/markets/MarketOverview.js","import React from 'react'\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/pie'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport 'echarts/lib/component/legend'\nimport 'echarts/lib/component/legend/ScrollableLegendModel.js'\nimport 'echarts/lib/component/legend/ScrollableLegendView.js'\nimport 'echarts/lib/component/legend/scrollableLegendAction.js'\n\nexport class RingPieReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      pieId: 'ringPie' + id\n    }\n  }\n\n  initPie(id) {\n    let {data} = this.props;\n\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.ringPieChart.series[0].data = [];\n    config.ringPieChart.series[1].data = [];\n    config.ringPieChart.legend.data = [];\n    config.ringPieChart.title.text=\"\";\n\n    function compare(property) {\n      return function (obj1, obj2) {\n\n        if (obj1[property] > obj2[property]) {\n          return 1;\n        } else if (obj1[property] < obj2[property]) {\n          return -1;\n        } else {\n          return 0;\n        }\n\n      }\n    }\n\n    if (data && data.length > 0) {\n      let sortObj = data.sort(compare(\"name\"));\n      let pairData = [];\n      let exchanges = []\n      let temp = [];\n      for (let index in sortObj) {\n        pairData.push({name: sortObj[index].pair, value: sortObj[index].volume});\n        if (temp.indexOf(sortObj[index].name) < 0) {\n          temp.push(sortObj[index].name)\n          exchanges.push({name: sortObj[index].name, value: 0, subCount: []});\n        }\n      }\n\n      for (let index in exchanges) {\n        for (let idx in sortObj) {\n          if (sortObj[idx].name === exchanges[index].name) {\n            exchanges[index].value = exchanges[index].value + sortObj[idx].volume;\n            exchanges[index].subCount.push({name: sortObj[idx].pair, value: sortObj[idx].volume});\n          }\n        }\n      }\n\n      exchanges.sort(compare(\"value\"));\n      let finalExchanges = exchanges.slice(exchanges.length - 10, exchanges.length);\n      let finalPairData = []\n      for (let index in finalExchanges) {\n        finalPairData.push(...finalExchanges[index].subCount);\n      }\n\n      config.ringPieChart.series[0].data = [];\n      config.ringPieChart.series[1].data = [];\n\n      config.ringPieChart.legend.data = temp;\n\n      config.ringPieChart.series[0].data = finalExchanges;\n      config.ringPieChart.series[1].data = finalPairData;\n\n    }\n    if(data && data.length===0){\n      config.ringPieChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.ringPieChart);\n  }\n\n\n  componentDidMount() {\n    this.initPie(this.state.pieId);\n  }\n\n  componentDidUpdate() {\n    this.initPie(this.state.pieId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.pieId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nexport default RingPieReact\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/RingPieChart.js"],"sourceRoot":""}
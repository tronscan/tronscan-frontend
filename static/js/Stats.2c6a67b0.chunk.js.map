{"version":3,"sources":["../static/js/Stats.2c6a67b0.chunk.js","components/blockchain/Statistics/index.js","../node_modules/echarts/lib/chart/helper/Symbol.js","../node_modules/echarts/lib/chart/line/helper.js","../node_modules/echarts/lib/chart/line.js","../node_modules/echarts/lib/chart/line/LineSeries.js","../node_modules/echarts/lib/chart/line/LineView.js","../node_modules/echarts/lib/chart/helper/SymbolDraw.js","../node_modules/echarts/lib/chart/line/lineAnimationDiff.js","../node_modules/echarts/lib/chart/line/poly.js","../node_modules/echarts/lib/visual/symbol.js","../node_modules/echarts/lib/layout/points.js","../node_modules/echarts/lib/processor/dataSample.js","../node_modules/echarts/lib/chart/pie.js","../node_modules/echarts/lib/chart/pie/PieSeries.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/component/helper/selectableMixin.js","../node_modules/echarts/lib/chart/pie/PieView.js","../node_modules/echarts/lib/action/createDataSelectAction.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/chart/pie/pieLayout.js","../node_modules/echarts/lib/chart/pie/labelLayout.js","../node_modules/echarts/lib/processor/dataFilter.js","components/common/LineChart.js","utils/tron.js","components/blockchain/Statistics/RichList.js","components/common/PieChart.js"],"names":["webpackJsonp","1183","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_asyncToGenerator","fn","gen","apply","this","arguments","Promise","resolve","reject","step","key","arg","info","value","error","done","then","err","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","mapStateToProps","state","defineProperty","_regenerator","_regenerator2","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_react","_react2","_i18n","_api","_constants","_reactRedux","_reactIntl","_lodash","_tron","_RichList","_loaders","_PieChart","_PieChart2","_LineChart","_LineChart2","Statistics","_React$Component","_this","getPrototypeOf","accounts","transactionStats","blockStats","transactionValueStats","loadAccounts","loadStats","_ref","mark","_callee","_ref2","wrap","_context","prev","next","Client","getAccounts","limit","sort","sent","setState","filter","account","includes","tronAddresses","address","slice","map","name","balance","ONE_TRX","stop","_ref3","_callee2","intl","_ref4","stats","_ref5","transactionTotalStats","valueStats","_context2","getTransferStats","groupby","interval","getBlockStats","total","row","timestamp","formatTime","_state","createElement","className","tu","style","height","TronLoader","data","keysData","Component","mapDispatchToProps","connect","injectIntl","1237","getSymbolSize","idx","symbolSize","getItemVisual","Array","getScale","SymbolClz","seriesScope","graphic","Group","updateData","driftSymbol","dx","dy","parent","drift","zrUtil","_symbol","createSymbol","_number","parsePercent","_labelHelper","getDefaultLabel","symbolProto","_createSymbol","symbolType","removeAll","color","symbolPath","attr","z2","culling","scale","_symbolType","add","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","trigger","downplay","setZ","zlevel","z","setDraggable","draggable","cursor","silent","seriesModel","hostModel","isInit","updateProps","_updateCommon","fadeIn","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","getLabelDefaultText","opt","useNameLabel","getName","type","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","labelModel","hoverLabelModel","hoverAnimation","cursorStyle","hasItemOption","itemModel","getItemModel","getModel","getItemStyle","getShallow","extend","elStyle","Math","PI","setColor","symbolInnerColor","setStyle","setLabelStyle","labelFetcher","labelDataIndex","defaultText","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","incremental","ratio","animateTo","max","onNormal","on","fadeOut","cb","keepLabel","text","dataIndex","inherits","_default","1238","prepareDataCoordInfo","coordSys","valueOrigin","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","getValueStart","baseAxisDim","dim","valueAxisDim","valueDim","mapDimension","baseDim","baseDataOffset","stacked","isDimensionStacked","dataDimsForPoint","dimensions","coordDim","stackedOverDimension","getCalculationInfo","extent","getExtent","getStackedOnPoint","dataCoordInfo","NaN","get","isNaN","stackedData","dataToPoint","_dataStackHelper","_util","1276","echarts","visualSymbol","layoutPoints","dataSample","registerVisual","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","1277","_config","createListFromArray","__DEV__","SeriesModel","dependencies","getInitialData","option","ecModel","getSource","defaultOption","coordinateSystem","legendHoverLink","clipOverflow","label","position","lineStyle","width","smooth","smoothMonotone","symbol","showSymbol","showAllSymbol","connectNulls","sampling","animationEasing","progressive","hoverLayerThreshold","Infinity","1278","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","axis","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","getStackedOnPoints","points","len","count","push","createGridClipShape","cartesian","hasAnimation","xExtent","getAxis","yExtent","isHorizontal","x","min","y","lineWidth","expandSize","clipPath","Rect","shape","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","Sector","cx","cy","r0","r","startAngle","endAngle","clockwise","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","pt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","visualMeta","dimIndex","dimension","dimName","dimInfo","getDimensionInfo","colorStops","stops","coord","toGlobalCoord","dataToCoord","stopLen","outerColors","reverse","minCoord","maxCoord","coordSpan","each","offset","unshift","gradient","LinearGradient","SymbolDraw","lineAnimationDiff","modelUtil","_poly","Polyline","Polygon","ChartView","_helper","init","lineGroup","symbolDraw","group","_symbolDraw","_lineGroup","render","api","getData","lineStyleModel","areaStyleModel","mapArray","getItemLayout","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","oldData","_data","eachItemGraphicEl","el","__temp","remove","setItemGraphicEl","_step","_newPolygon","coordSysClipShape","setClipPath","isIgnore","clipShape","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","defaults","getLineStyle","fill","stroke","lineJoin","stackedOnSeries","stackedOnSmooth","getAreaStyle","_valueOrigin","dispose","payload","queryDataIndex","getItemGraphicEl","ignore","categoryAxis","getAxesByScale","isLabelIgnored","bind","diff","current","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","1279","symbolCtor","_symbolCtor","symbolNeedsDraw","point","contain","normalizeUpdateOpt","isObject","makeSeriesScope","symbolDrawProto","SymbolCtor","newIdx","symbolEl","update","oldIdx","execute","isPersistent","updateLayout","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","useHoverLayer","start","end","traverse","enableAnimation","1280","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","diffItem","pointAdded","currentPt","getRawIndex","rawIndex","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","1281","isPointNull","p","drawSegment","ctx","segLen","allLen","smoothMin","smoothMax","isMono","drawMono","drawNonMono","last","lastDiff","prevIdx","k","prevP","ctrlLen","v2Copy","cp0","cp1","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","vec2","sub","v","lenPrevSeg","lenNextSeg","abs","dist","scaleAndAdd","vec2Min","vec2Max","getBoundingBox","smoothConstraint","ptMin","ptMax","Path","fixClipWithShadow","copy","brush","buildPath","result","bbox","stackedOnBBox","closePath","1282","seriesType","defaultSymbolType","legendSymbol","performRawSeries","reset","dataEach","rawValue","getRawValue","params","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize","setVisual","isSeriesFiltered","hasCallback","1283","plan","createRenderPlanner","progress","segCount","isLargeRender","Float32Array","dimLen","tmpIn","tmpOut","dims","setItemLayout","setLayout","pipelineContext","large","1284","size","rate","round","sampler","samplers","setData","downSample","indexSampler","average","frame","sum","nearest","1349","createDataSelectAction","dataColor","pieLayout","dataFilter","event","method","curry","1350","createListSimply","getPercentWithPrecision","dataSelectableMixin","_dataProvider","retrieveRawAttr","PieSeries","extendSeriesModel","superApply","legendDataProvider","getRawData","updateSelectedMap","_createSelectableList","_defaultLabelLine","mergeOption","newOption","superCall","targetList","selected","valueList","percent","$vars","defaultEmphasis","labelLineNormalOpt","labelLine","labelLineEmphasisOpt","emphasis","show","center","radius","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","rotate","length2","borderWidth","animationType","mixin","1351","nameList","isArray","coordDimensions","source","dimensionsInfo","createDimensions","list","List","initData","1352","_targetList","_selectTargetMap","reduce","targetMap","set","createHashMap","select","id","unSelect","toggleSelected","isSelected","1353","updateDataSelected","uid","dispatchAction","from","seriesId","toggleItemSelected","layout","midAngle","cos","sin","animate","when","PiePiece","hoverIgnore","normalIgnore","sector","Text","piePieceProto","firstCreate","sectorShape","_updateLabel","labelText","labelLayout","linePoints","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","useInsideStyle","inside","textAlign","textVerticalAlign","verticalAlign","PieView","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","selectedMode","piePiece","eachChild","child","getWidth","getHeight","removeClipPath","_createClipPath","containPoint","itemLayout","sqrt","1354","actionInfos","actionInfo","registerAction","eachComponent","mainType","subType","query","1355","getTargetSeries","paletteScope","seiresModelMap","eachSeriesByType","__paletteScope","dataAll","idxMap","rawIdx","filteredIdx","singleDataColor","getColorFromPalette","1356","validDataCount","getSum","unitRadian","roseType","getDataExtent","restAngle","PI2","valueSumLargerThanMinAngle","currentAngle","angle","linearMap","1357","adjustSingleSide","viewWidth","viewHeight","shiftUp","delta","j","changeX","isDownList","lastDeltaX","Number","MAX_VALUE","l","deltaY","len2","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textX","textY","labelPosition","labelLineLen","labelLineLen2","isLabelInside","x1","y1","x2","y2","x3","y3","font","getFont","labelRotate","getFormattedLabel","textRect","textContain","getBoundingRect","1358","legendModels","findComponents","filterSelf","1359","LineReact","undefined","_chartConfig","_chartConfig2","_echarts","_echarts2","random","replace","lineId","_props","format","myChart","getInstanceByDom","document","getElementById","lineChart","title","xAxis","series","val","date","formatDate","setOption","initLine","pure","1610","1611","_Price","RichList","_Component","richList","totals","coins","load","getRichList","index","FormattedNumber","to","maximumFractionDigits","minimumFractionDigits","TRXPrice","amount","currency","1612","PieReact","pieId","pieChart","initPie"],"mappings":"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","file":"static/js/Stats.2c6a67b0.chunk.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 1183:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(4);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _i18n=__webpack_require__(5);var _api=__webpack_require__(6);var _constants=__webpack_require__(14);var _reactRedux=__webpack_require__(7);var _reactIntl=__webpack_require__(8);var _lodash=__webpack_require__(11);var _tron=__webpack_require__(1610);var _RichList=__webpack_require__(1611);var _RichList2=_interopRequireDefault(_RichList);var _loaders=__webpack_require__(19);var _PieChart=__webpack_require__(1612);var _PieChart2=_interopRequireDefault(_PieChart);var _LineChart=__webpack_require__(1359);var _LineChart2=_interopRequireDefault(_LineChart);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Statistics=function(_React$Component){_inherits(Statistics,_React$Component);function Statistics(){_classCallCheck(this,Statistics);var _this=_possibleConstructorReturn(this,(Statistics.__proto__||Object.getPrototypeOf(Statistics)).call(this));_this.state={accounts:null,transactionStats:null,blockStats:null,transactionValueStats:null};return _this;}_createClass(Statistics,[{key:\"componentDidMount\",value:function componentDidMount(){this.loadAccounts();this.loadStats();}},{key:\"loadAccounts\",value:function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var _ref2,accounts;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _api.Client.getAccounts({limit:35,sort:'-balance'});case 2:_ref2=_context.sent;accounts=_ref2.accounts;this.setState({accounts:(0,_lodash.filter)(accounts,function(account){return!(0,_lodash.includes)(_tron.tronAddresses,account.address);}).slice(0,25).map(function(account){return{name:account.address,value:account.balance/_constants.ONE_TRX};})});case 5:case\"end\":return _context.stop();}}},_callee,this);}));function loadAccounts(){return _ref.apply(this,arguments);}return loadAccounts;}()},{key:\"loadStats\",value:function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee2(){var intl,_ref4,stats,_ref5,blockStats,transactionTotalStats,valueStats;return _regenerator2.default.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:intl=this.props.intl;_context2.next=3;return _api.Client.getTransferStats({groupby:'timestamp',interval:'hour'});case 3:_ref4=_context2.sent;stats=_ref4.stats;_context2.next=7;return _api.Client.getBlockStats({info:\"avg-block-size\"});case 7:_ref5=_context2.sent;blockStats=_ref5.stats;transactionTotalStats=stats.total.map(function(row){return{timestamp:intl.formatTime(row.timestamp),value:row.value};});valueStats=stats.value.map(function(row){return{timestamp:intl.formatTime(row.timestamp),value:row.value/_constants.ONE_TRX};});blockStats=blockStats.map(function(row){return{timestamp:intl.formatTime(row.timestamp),value:row.value};});this.setState({transactionStats:transactionTotalStats,transactionValueStats:valueStats,blockStats:blockStats});case 13:case\"end\":return _context2.stop();}}},_callee2,this);}));function loadStats(){return _ref3.apply(this,arguments);}return loadStats;}()},{key:\"render\",value:function render(){var _state=this.state,transactionStats=_state.transactionStats,transactionValueStats=_state.transactionValueStats,blockStats=_state.blockStats,accounts=_state.accounts;return _react2.default.createElement(\"main\",{className:\"container header-overlap\"},_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"Top\"),\" \",accounts!==null?accounts.length:0,\" \",(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"div\",{style:{height:300}},accounts===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_PieChart2.default,{style:{height:300},data:accounts}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"trx_transferred_past_hour\")),_react2.default.createElement(\"div\",{style:{height:300}},transactionValueStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:transactionValueStats,keysData:['timestamp','value']})))))),_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"transactions_past_hour\")),_react2.default.createElement(\"div\",{style:{height:300}},transactionStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:transactionStats,keysData:['timestamp','value']}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"text-center\"},(0,_i18n.tu)(\"average_blocksize\"),\" (\",(0,_i18n.tu)(\"bytes\"),\")\"),_react2.default.createElement(\"div\",{style:{height:300}},blockStats===null?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:blockStats,keysData:['timestamp','value']})))))));}}]);return Statistics;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps)((0,_reactIntl.injectIntl)(Statistics));\n\n/***/ }),\n\n/***/ 1237:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar _symbol = __webpack_require__(224);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(22);\n\nvar _number = __webpack_require__(27);\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = __webpack_require__(432);\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1238:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = __webpack_require__(2);\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n/***/ }),\n\n/***/ 1276:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n__webpack_require__(1277);\n\n__webpack_require__(1278);\n\nvar visualSymbol = __webpack_require__(1282);\n\nvar layoutPoints = __webpack_require__(1283);\n\nvar dataSample = __webpack_require__(1284);\n\n__webpack_require__(433);\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n/***/ }),\n\n/***/ 1277:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(24);\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = __webpack_require__(226);\n\nvar SeriesModel = __webpack_require__(225);\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1278:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(24);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(2);\n\nvar SymbolDraw = __webpack_require__(1279);\n\nvar SymbolClz = __webpack_require__(1237);\n\nvar lineAnimationDiff = __webpack_require__(1280);\n\nvar graphic = __webpack_require__(22);\n\nvar modelUtil = __webpack_require__(12);\n\nvar _poly = __webpack_require__(1281);\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = __webpack_require__(422);\n\nvar _helper = __webpack_require__(1238);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1279:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(22);\n\nvar SymbolClz = __webpack_require__(1237);\n\nvar _util = __webpack_require__(2);\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1280:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _helper = __webpack_require__(1238);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1281:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(32);\n\nvar vec2 = __webpack_require__(25);\n\nvar fixClipWithShadow = __webpack_require__(430);\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n/***/ }),\n\n/***/ 1282:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1283:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(2);\n\nvar map = _util.map;\n\nvar createRenderPlanner = __webpack_require__(431);\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1284:\n/***/ (function(module, exports) {\n\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1349:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\n__webpack_require__(1350);\n\n__webpack_require__(1353);\n\nvar createDataSelectAction = __webpack_require__(1354);\n\nvar dataColor = __webpack_require__(1355);\n\nvar pieLayout = __webpack_require__(1356);\n\nvar dataFilter = __webpack_require__(1358);\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n/***/ }),\n\n/***/ 1350:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar createListSimply = __webpack_require__(1351);\n\nvar zrUtil = __webpack_require__(2);\n\nvar modelUtil = __webpack_require__(12);\n\nvar _number = __webpack_require__(27);\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = __webpack_require__(1352);\n\nvar _dataProvider = __webpack_require__(93);\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // \n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // \n    clockwise: true,\n    startAngle: 90,\n    // 0\n    minAngle: 0,\n    // \n    selectedOffset: 10,\n    // \n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // singlemultiple\n    // selectedMode: false,\n    // 'radius' | 'area'\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: Tooltip.formatter\n      // TEXTSTYLE\n      // distance: positioninnerlabel()\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // \n      length: 15,\n      // \n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: ,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1351:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(228);\n\nvar List = __webpack_require__(227);\n\nvar _util = __webpack_require__(2);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1352:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1353:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar graphic = __webpack_require__(22);\n\nvar ChartView = __webpack_require__(422);\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1354:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1355:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(2);\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1356:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _number = __webpack_require__(27);\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = __webpack_require__(1357);\n\nvar zrUtil = __webpack_require__(2);\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME  2.0  roseType  area \n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1357:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textContain = __webpack_require__(74);\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // \n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // \n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // \n    ? Number.MAX_VALUE // \n    : 0 // \n    : isDownList // \n    ? Number.MAX_VALUE // \n    : 0; // \n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // \n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // \n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1358:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1359:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.LineReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(8);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1276);__webpack_require__(423);__webpack_require__(424);var _reactRedux=__webpack_require__(7);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var LineReact=exports.LineReact=function(_React$Component){_inherits(LineReact,_React$Component);function LineReact(props){_classCallCheck(this,LineReact);var _this=_possibleConstructorReturn(this,(LineReact.__proto__||Object.getPrototypeOf(LineReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={lineId:'line'+id};return _this;}_createClass(LineReact,[{key:'initLine',value:function initLine(id){var _props=this.props,intl=_props.intl,keysData=_props.keysData,data=_props.data,format=_props.format;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.lineChart.title.text='';_chartConfig2.default.lineChart.xAxis.data=[];_chartConfig2.default.lineChart.series[0].data=[];if(data&&data.length>0){data.map(function(val){if(format&&format[keysData[0]]){if(format.date){_chartConfig2.default.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]]*1000));}else{_chartConfig2.default.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]*1000));}}else _chartConfig2.default.lineChart.xAxis.data.push(val[keysData[0]]);_chartConfig2.default.lineChart.series[0].data.push(val[keysData[1]]);});}if(data&&data.length===0){_chartConfig2.default.lineChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.lineChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initLine(this.state.lineId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initLine(this.state.lineId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.lineId,style:this.props.style}));}}]);return LineReact;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(LineReact));\n\n/***/ }),\n\n/***/ 1610:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var tronAddresses=exports.tronAddresses=['27d3byPxZXKQWfXX7sJvemJJuv5M65F3vjS','27fXgQ46DcjEsZ444tjZPKULcxiUfDrDjqj','27SWXcHuQgFf9uv49FknBBBYBaH3DUk4JPx','27WtBq2KoSy5v8VnVZBZHHJcDuWNiSgjbE3'];\n\n/***/ }),\n\n/***/ 1611:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(4);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _api=__webpack_require__(6);var _reactIntl=__webpack_require__(8);var _Price=__webpack_require__(37);var _i18n=__webpack_require__(5);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var RichList=function(_Component){_inherits(RichList,_Component);function RichList(){_classCallCheck(this,RichList);var _this=_possibleConstructorReturn(this,(RichList.__proto__||Object.getPrototypeOf(RichList)).call(this));_this.state={richList:[],totals:{accounts:0,coins:0}};return _this;}_createClass(RichList,[{key:\"componentDidMount\",value:function componentDidMount(){this.load();}},{key:\"load\",value:function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var _ref2,data,total;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _api.Client.getRichList();case 2:_ref2=_context.sent;data=_ref2.data;total=_ref2.total;this.setState({richList:data,totals:total});case 6:case\"end\":return _context.stop();}}},_callee,this);}));function load(){return _ref.apply(this,arguments);}return load;}()},{key:\"render\",value:function render(){var _state=this.state,richList=_state.richList,totals=_state.totals;return _react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"rich_list\"))),_react2.default.createElement(\"table\",{className:\"table table-hover bg-white m-0 table-striped\"},_react2.default.createElement(\"thead\",{className:\"thead-dark\"},_react2.default.createElement(\"tr\",null,_react2.default.createElement(\"th\",null,(0,_i18n.tu)(\"balance\")),_react2.default.createElement(\"th\",{className:\"d-none d-lg-table-cell\"},(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"th\",{className:\"text-nowrap text-right\"},\"% \",(0,_i18n.tu)(\"addresses\")),_react2.default.createElement(\"th\",{className:\"text-right d-none d-md-table-cell\"},(0,_i18n.tu)(\"TRX\")),_react2.default.createElement(\"th\",{className:\"text-right\"},\"$ \",(0,_i18n.tu)(\"USD\")),_react2.default.createElement(\"th\",{className:\"text-right  d-none d-md-table-cell\"},\"% \",(0,_i18n.tu)(\"Coins\")))),_react2.default.createElement(\"tbody\",null,richList.map(function(row,index){return _react2.default.createElement(\"tr\",{key:index},_react2.default.createElement(\"th\",null,_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.from}),' - ',_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.to})),_react2.default.createElement(\"td\",{className:\"d-none d-lg-table-cell\"},row.accounts),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap\",style:{width:100}},_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.accounts/totals.accounts*100,maximumFractionDigits:2,minimumFractionDigits:2}),\" %\"),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_Price.TRXPrice,{amount:row.balance})),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap\"},_react2.default.createElement(_Price.TRXPrice,{amount:row.balance,currency:\"USD\"})),_react2.default.createElement(\"td\",{className:\"text-right text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_reactIntl.FormattedNumber,{value:row.balance/totals.coins*100,maximumFractionDigits:4,minimumFractionDigits:4}),\" %\"));}))));}}]);return RichList;}(_react.Component);exports.default=RichList;\n\n/***/ }),\n\n/***/ 1612:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.PieReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1349);__webpack_require__(423);__webpack_require__(424);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var PieReact=exports.PieReact=function(_React$Component){_inherits(PieReact,_React$Component);function PieReact(props){_classCallCheck(this,PieReact);var _this=_possibleConstructorReturn(this,(PieReact.__proto__||Object.getPrototypeOf(PieReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={pieId:'pie'+id};return _this;}_createClass(PieReact,[{key:'initPie',value:function initPie(id){var data=this.props.data;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.pieChart.series[0].data=[];_chartConfig2.default.pieChart.title.text=\"\";if(data&&data.length>0){_chartConfig2.default.pieChart.series[0].data=data;}if(data&&data.length===0){_chartConfig2.default.pieChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.pieChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initPie(this.state.pieId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie(this.state.pieId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.pieId,style:this.props.style}));}}]);return PieReact;}(_react2.default.Component);exports.default=PieReact;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/Stats.2c6a67b0.chunk.js","import React from \"react\";\n\nimport {tu} from \"../../../utils/i18n\";\nimport {Client} from \"../../../services/api\";\nimport {ONE_TRX} from \"../../../constants\";\nimport {connect} from \"react-redux\";\nimport {injectIntl} from \"react-intl\";\nimport {filter, includes} from \"lodash\";\nimport {tronAddresses} from \"../../../utils/tron\";\nimport RichList from \"./RichList\";\nimport {TronLoader} from \"../../common/loaders\";\nimport PieReact from \"../../common/PieChart\";\nimport LineReact from \"../../common/LineChart\";\n\n\nclass Statistics extends React.Component {\n\n  constructor() {\n    super();\n\n    this.state = {\n      accounts: null,\n      transactionStats: null,\n      blockStats: null,\n      transactionValueStats: null\n    };\n  }\n\n  componentDidMount() {\n    this.loadAccounts();\n    this.loadStats();\n  }\n\n  async loadAccounts() {\n\n    let {accounts} = await Client.getAccounts({\n      limit: 35,\n      sort: '-balance',\n    });\n\n    this.setState({\n      accounts: filter(accounts, account => !includes(tronAddresses, account.address))\n          .slice(0, 25)\n          .map(account => ({\n            name: account.address,\n            value: account.balance / ONE_TRX,\n          }))\n    });\n  }\n\n\n  async loadStats() {\n\n    let {intl} = this.props;\n\n    let {stats} = await Client.getTransferStats({\n      groupby: 'timestamp',\n      interval: 'hour',\n    });\n\n    let {stats: blockStats} = await Client.getBlockStats({\n      info: `avg-block-size`,\n    });\n\n\n    let transactionTotalStats = stats.total.map(row => ({\n      timestamp: intl.formatTime(row.timestamp),\n      value: row.value,\n    }));\n\n    let valueStats = stats.value.map(row => ({\n      timestamp: intl.formatTime(row.timestamp),\n      value: row.value / ONE_TRX,\n    }));\n\n    blockStats = blockStats.map(row => ({\n      timestamp: intl.formatTime(row.timestamp),\n      value: row.value,\n    }));\n\n    this.setState({\n      transactionStats: transactionTotalStats,\n      transactionValueStats: valueStats,\n      blockStats,\n    });\n  }\n\n  render() {\n\n    let {transactionStats, transactionValueStats, blockStats, accounts} = this.state;\n    return (\n        <main className=\"container header-overlap\">\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"Top\")} {accounts !== null ? accounts.length : 0} {tu(\"addresses\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      accounts === null ?\n                          <TronLoader/> :\n                          <PieReact style={{height: 300}} data={accounts}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"trx_transferred_past_hour\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      transactionValueStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={transactionValueStats} keysData={['timestamp','value']}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"transactions_past_hour\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      transactionStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={transactionStats} keysData={['timestamp','value']}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"text-center\">{tu(\"average_blocksize\")} ({tu(\"bytes\")})</h5>\n                  <div style={{height: 300}}>\n                    {\n                      blockStats === null ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={blockStats} keysData={['timestamp','value']}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </main>\n    );\n  }\n}\n\n\nfunction mapStateToProps(state) {\n  return {};\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(injectIntl(Statistics))\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/blockchain/Statistics/index.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Symbol.js\n// module id = 1237\n// module chunks = 2 3 4","var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/helper.js\n// module id = 1238\n// module chunks = 2 3 4","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line.js\n// module id = 1276\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineSeries.js\n// module id = 1277\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineView.js\n// module id = 1278\n// module chunks = 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 1279\n// module chunks = 2 3 4","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 1280\n// module chunks = 2 3 4","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/poly.js\n// module id = 1281\n// module chunks = 2 3 4","function _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = 1282\n// module chunks = 2 3 4","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/points.js\n// module id = 1283\n// module chunks = 2 3 4","var samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataSample.js\n// module id = 1284\n// module chunks = 2 3 4","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./pie/PieSeries\");\n\nrequire(\"./pie/PieView\");\n\nvar createDataSelectAction = require(\"../action/createDataSelectAction\");\n\nvar dataColor = require(\"../visual/dataColor\");\n\nvar pieLayout = require(\"./pie/pieLayout\");\n\nvar dataFilter = require(\"../processor/dataFilter\");\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie.js\n// module id = 1349\n// module chunks = 2 3","var echarts = require(\"../../echarts\");\n\nvar createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _number = require(\"../../util/number\");\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = require(\"../../component/helper/selectableMixin\");\n\nvar _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // \n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // \n    clockwise: true,\n    startAngle: 90,\n    // 0\n    minAngle: 0,\n    // \n    selectedOffset: 10,\n    // \n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // singlemultiple\n    // selectedMode: false,\n    // 'radius' | 'area'\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: Tooltip.formatter\n      // TEXTSTYLE\n      // distance: positioninnerlabel()\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // \n      length: 15,\n      // \n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: ,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n// module id = 1350\n// module chunks = 2 3","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 1351\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/selectableMixin.js\n// module id = 1352\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieView.js\n// module id = 1353\n// module chunks = 2 3","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/action/createDataSelectAction.js\n// module id = 1354\n// module chunks = 2 3","var _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 1355\n// module chunks = 2 3","var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME  2.0  roseType  area \n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n// module id = 1356\n// module chunks = 2 3","var textContain = require(\"zrender/lib/contain/text\");\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // \n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // \n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // \n    ? Number.MAX_VALUE // \n    : 0 // \n    : isDownList // \n    ? Number.MAX_VALUE // \n    : 0; // \n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // \n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // \n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n// module id = 1357\n// module chunks = 2 3","function _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 1358\n// module chunks = 2 3","import React from 'react'\nimport {injectIntl} from \"react-intl\";\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/line'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport {connect} from \"react-redux\";\n\nexport class LineReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      lineId: 'line' + id\n    }\n  }\n\n  initLine(id) {\n    let {intl, keysData, data, format} = this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.lineChart.title.text='';\n    config.lineChart.xAxis.data = [];\n    config.lineChart.series[0].data = [];\n    if(data && data.length>0) {\n      data.map((val) => {\n\n        if (format && format[keysData[0]]) {\n          if (format.date) {\n            config.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]] * 1000));\n          }\n          else {\n            config.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]] * 1000));\n          }\n        }\n        else\n          config.lineChart.xAxis.data.push(val[keysData[0]]);\n\n\n        config.lineChart.series[0].data.push(val[keysData[1]]);\n      })\n    }\n    if(data && data.length===0){\n      config.lineChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.lineChart);\n\n  }\n\n  componentDidMount() {\n    this.initLine(this.state.lineId);\n  }\n\n  componentDidUpdate() {\n    this.initLine(this.state.lineId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.lineId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {}\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(LineReact));\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/LineChart.js","\n\nexport const tronAddresses = [\n  '27d3byPxZXKQWfXX7sJvemJJuv5M65F3vjS',\n  '27fXgQ46DcjEsZ444tjZPKULcxiUfDrDjqj',\n  '27SWXcHuQgFf9uv49FknBBBYBaH3DUk4JPx',\n  '27WtBq2KoSy5v8VnVZBZHHJcDuWNiSgjbE3',\n];\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/tron.js","import React, {Component} from \"react\";\nimport {Client} from \"../../../services/api\";\nimport {FormattedNumber} from \"react-intl\";\nimport {TRXPrice} from \"../../common/Price\";\nimport {tu} from \"../../../utils/i18n\";\n\nexport default class RichList extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      richList: [],\n      totals: {\n        accounts: 0,\n        coins: 0,\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.load();\n  }\n\n  async load() {\n    let {data, total} = await Client.getRichList();\n\n    this.setState({\n      richList: data,\n      totals: total,\n    });\n  }\n\n  render() {\n\n    let {richList, totals} = this.state;\n\n    return (\n        <div className=\"card\">\n          <div className=\"card-body\">\n            <h5 className=\"card-title text-center\">\n              {tu(\"rich_list\")}\n            </h5>\n          </div>\n          <table className=\"table table-hover bg-white m-0 table-striped\">\n            <thead className=\"thead-dark\">\n              <tr>\n                <th>{tu(\"balance\")}</th>\n                <th className=\"d-none d-lg-table-cell\">{tu(\"addresses\")}</th>\n                <th className=\"text-nowrap text-right\">% {tu(\"addresses\")}</th>\n                <th className=\"text-right d-none d-md-table-cell\">{tu(\"TRX\")}</th>\n                <th className=\"text-right\">$ {tu(\"USD\")}</th>\n                <th className=\"text-right  d-none d-md-table-cell\">% {tu(\"Coins\")}</th>\n              </tr>\n            </thead>\n            <tbody>\n            {\n              richList.map((row, index) => (\n                <tr key={index}>\n                  <th>\n                    <FormattedNumber value={row.from}/>{' - '}\n                    <FormattedNumber value={row.to} />\n                  </th>\n                  <td className=\"d-none d-lg-table-cell\">\n                    {row.accounts}\n                  </td>\n                  <td className=\"text-right text-nowrap\" style={{width: 100}}>\n                    <FormattedNumber value={(row.accounts / totals.accounts) * 100}\n                                     maximumFractionDigits={2}\n                                     minimumFractionDigits={2} /> %\n                  </td>\n                  <td className=\"text-right text-nowrap d-none d-md-table-cell\">\n                    <TRXPrice amount={row.balance} />\n                  </td>\n                  <td className=\"text-right text-nowrap\">\n                    <TRXPrice amount={row.balance} currency=\"USD\" />\n                  </td>\n                  <td className=\"text-right text-nowrap d-none d-md-table-cell\">\n                    <FormattedNumber value={(row.balance / totals.coins) * 100}\n                                     maximumFractionDigits={4}\n                                     minimumFractionDigits={4}/> %\n                  </td>\n                </tr>\n              ))\n            }\n            </tbody>\n          </table>\n        </div>\n    )\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/blockchain/Statistics/RichList.js","import React from 'react'\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/pie'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\n\nexport class PieReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      pieId: 'pie' + id\n    }\n  }\n\n  initPie(id) {\n    let { data }=this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.pieChart.series[0].data = [];\n    config.pieChart.title.text=\"\";\n\n    if (data && data.length > 0) {\n      config.pieChart.series[0].data = data;\n    }\n    if(data && data.length===0){\n      config.pieChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.pieChart);\n  }\n\n\n  componentDidMount() {\n    this.initPie(this.state.pieId);\n  }\n\n  componentDidUpdate() {\n    this.initPie(this.state.pieId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.pieId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nexport default PieReact\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/PieChart.js"],"sourceRoot":""}
{"version":3,"sources":["../static/js/Markets.9e30d3aa.chunk.js","components/markets/index.js","../node_modules/echarts/lib/chart/helper/Symbol.js","../node_modules/echarts/lib/chart/line/helper.js","../node_modules/echarts/lib/chart/line.js","../node_modules/echarts/lib/chart/line/LineSeries.js","../node_modules/echarts/lib/chart/line/LineView.js","../node_modules/echarts/lib/chart/helper/SymbolDraw.js","../node_modules/echarts/lib/chart/line/lineAnimationDiff.js","../node_modules/echarts/lib/chart/line/poly.js","../node_modules/echarts/lib/visual/symbol.js","../node_modules/echarts/lib/layout/points.js","../node_modules/echarts/lib/processor/dataSample.js","../node_modules/echarts/lib/component/legend/LegendModel.js","../node_modules/echarts/lib/component/legend/LegendView.js","../node_modules/echarts/lib/chart/pie.js","../node_modules/echarts/lib/chart/pie/PieSeries.js","../node_modules/echarts/lib/chart/helper/createListSimply.js","../node_modules/echarts/lib/component/helper/selectableMixin.js","../node_modules/echarts/lib/chart/pie/PieView.js","../node_modules/echarts/lib/action/createDataSelectAction.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/chart/pie/pieLayout.js","../node_modules/echarts/lib/chart/pie/labelLayout.js","../node_modules/echarts/lib/processor/dataFilter.js","components/common/LineChart.js","../node_modules/echarts/lib/component/legend.js","../node_modules/echarts/lib/component/legend/legendAction.js","../node_modules/echarts/lib/component/helper/listComponent.js","../node_modules/echarts/lib/component/legend/legendFilter.js","../node_modules/echarts/lib/component/legend/ScrollableLegendModel.js","../node_modules/echarts/lib/component/legend/ScrollableLegendView.js","../node_modules/echarts/lib/component/legend/scrollableLegendAction.js","components/markets/MarketOverview.js","components/common/RingPieChart.js"],"names":["webpackJsonp","1184","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_asyncToGenerator","fn","gen","apply","this","arguments","Promise","resolve","reject","step","key","arg","info","value","error","done","then","err","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","mapStateToProps","state","priceGraph","markets","price","volumeGraph","volume","defineProperty","_regenerator","_regenerator2","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_react","_react2","_reactIntl","_reactRedux","_markets","_i18n","_MarketOverview","_MarketOverview2","_loaders","_api","_LineChart","_LineChart2","_RingPieChart","_RingPieChart2","Markets","_React$Component","_this2","_this","getPrototypeOf","loadMarketData","mark","_callee","wrap","_context","prev","next","loadPriceData","Client","getMarkets","sent","setState","stop","_props","intl","createElement","className","tu","style","height","TronLoader","data","keysData","format","time","date","Component","mapDispatchToProps","connect","pure","injectIntl","1237","getSymbolSize","idx","symbolSize","getItemVisual","Array","slice","getScale","SymbolClz","seriesScope","graphic","Group","updateData","driftSymbol","dx","dy","parent","drift","zrUtil","_symbol","createSymbol","_number","parsePercent","_labelHelper","getDefaultLabel","symbolProto","_createSymbol","symbolType","removeAll","color","symbolPath","attr","z2","culling","scale","_symbolType","add","stopSymbolAnimation","toLastFrame","childAt","stopAnimation","getSymbolPath","highlight","trigger","downplay","setZ","zlevel","z","setDraggable","draggable","cursor","silent","seriesModel","hostModel","isInit","updateProps","_updateCommon","fadeIn","opacity","initProps","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","getLabelDefaultText","opt","useNameLabel","getName","type","useStyle","strokeNoScale","itemStyle","hoverItemStyle","symbolRotate","symbolOffset","labelModel","hoverLabelModel","hoverAnimation","cursorStyle","hasItemOption","itemModel","getItemModel","getModel","getItemStyle","getShallow","extend","elStyle","Math","PI","setColor","symbolInnerColor","setStyle","setLabelStyle","labelFetcher","labelDataIndex","defaultText","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","incremental","ratio","animateTo","max","onNormal","on","fadeOut","cb","keepLabel","text","dataIndex","inherits","_default","1238","prepareDataCoordInfo","coordSys","valueOrigin","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","getValueStart","baseAxisDim","dim","valueAxisDim","valueDim","mapDimension","baseDim","baseDataOffset","stacked","isDimensionStacked","dataDimsForPoint","map","dimensions","coordDim","stackedOverDimension","getCalculationInfo","extent","getExtent","getStackedOnPoint","dataCoordInfo","NaN","get","isNaN","stackedData","dataToPoint","_dataStackHelper","_util","1276","echarts","visualSymbol","layoutPoints","dataSample","registerVisual","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","1277","_config","createListFromArray","__DEV__","SeriesModel","dependencies","getInitialData","option","ecModel","getSource","defaultOption","coordinateSystem","legendHoverLink","clipOverflow","label","position","lineStyle","width","smooth","smoothMonotone","symbol","showSymbol","showAllSymbol","connectNulls","sampling","animationEasing","progressive","hoverLayerThreshold","Infinity","1278","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","axis","getGlobalExtent","onBand","halfBandWidth","getBandWidth","dir","getStackedOnPoints","points","len","count","push","createGridClipShape","cartesian","hasAnimation","xExtent","getAxis","yExtent","isHorizontal","x","min","y","lineWidth","expandSize","clipPath","Rect","shape","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","angleExtent","RADIAN","Sector","cx","cy","r0","r","startAngle","endAngle","clockwise","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","pt","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","visualMeta","dimIndex","dimension","dimName","dimInfo","getDimensionInfo","colorStops","stops","coord","toGlobalCoord","dataToCoord","stopLen","outerColors","reverse","minCoord","maxCoord","coordSpan","each","offset","unshift","gradient","LinearGradient","SymbolDraw","lineAnimationDiff","modelUtil","_poly","Polyline","Polygon","ChartView","_helper","init","lineGroup","symbolDraw","group","_symbolDraw","_lineGroup","render","api","getData","lineStyleModel","areaStyleModel","mapArray","getItemLayout","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","oldData","_data","eachItemGraphicEl","el","__temp","remove","setItemGraphicEl","_step","_newPolygon","coordSysClipShape","setClipPath","isIgnore","clipShape","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","defaults","getLineStyle","fill","stroke","lineJoin","stackedOnSeries","stackedOnSmooth","getAreaStyle","_valueOrigin","dispose","payload","queryDataIndex","getItemGraphicEl","ignore","categoryAxis","getAxesByScale","isLabelIgnored","bind","diff","current","stackedOnCurrent","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","1279","symbolCtor","_symbolCtor","symbolNeedsDraw","point","contain","normalizeUpdateOpt","isObject","makeSeriesScope","symbolDrawProto","SymbolCtor","newIdx","symbolEl","update","oldIdx","execute","isPersistent","updateLayout","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","useHoverLayer","start","end","traverse","enableAnimation","1280","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","diffItem","pointAdded","currentPt","getRawIndex","rawIndex","sort","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","1281","isPointNull","p","drawSegment","ctx","segLen","allLen","smoothMin","smoothMax","isMono","drawMono","drawNonMono","last","lastDiff","prevIdx","k","prevP","ctrlLen","v2Copy","cp0","cp1","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","vec2","sub","v","lenPrevSeg","lenNextSeg","abs","dist","scaleAndAdd","vec2Min","vec2Max","getBoundingBox","smoothConstraint","ptMin","ptMax","Path","fixClipWithShadow","copy","brush","buildPath","result","bbox","stackedOnBBox","closePath","1282","seriesType","defaultSymbolType","legendSymbol","performRawSeries","reset","dataEach","rawValue","getRawValue","params","getDataParams","setItemVisual","itemSymbolType","itemSymbolSize","setVisual","isSeriesFiltered","hasCallback","1283","plan","createRenderPlanner","progress","segCount","isLargeRender","Float32Array","dimLen","tmpIn","tmpOut","dims","setItemLayout","setLayout","pipelineContext","large","1284","size","rate","round","sampler","samplers","setData","downSample","indexSampler","average","frame","sum","nearest","1285","Model","_model","isNameSpecified","LegendModel","extendComponentModel","layoutMode","ignoreSize","parentModel","mergeDefaultAndTheme","selected","mergeOption","superCall","optionUpdated","_updateData","legendData","hasSelected","name","isSelected","select","potentialData","availableNames","eachRawSeries","seriesName","isPotential","legendDataProvider","names","concat","_availableNames","rawData","dataItem","unSelect","toggleSelected","hasOwnProperty","indexOf","show","orient","left","top","align","backgroundColor","borderColor","borderRadius","borderWidth","padding","itemGap","itemWidth","itemHeight","inactiveColor","textStyle","selectedMode","tooltip","1286","dispatchSelectAction","dispatchAction","dispatchHighlightAction","dataName","getZr","storage","getDisplayList","dispatchDownplayAction","_listComponent","makeBackground","layoutUtil","curry","extendComponentView","newlineDisabled","_contentGroup","_backgroundEl","getContentGroup","legendModel","resetInner","itemAlign","renderInner","positionInfo","getBoxLayoutParams","viewportSize","getWidth","getHeight","maxSize","getLayoutRect","mainRect","layoutInner","layoutRect","contentGroup","legendDrawnMap","createHashMap","selectMode","newline","getSeriesByName","legendSymbolType","itemGroup","_createItem","set","indexOfName","textStyleModel","itemIcon","tooltipModel","legendGlobalTooltipModel","textX","textAlign","formatter","content","replace","Text","setTextStyle","textFill","getTextColor","textVerticalAlign","hitRect","getBoundingRect","invisible","formatterParams","componentType","legendIndex","componentIndex","$vars","eachChild","child","__legendDataIndex","box","contentRect","1349","createDataSelectAction","dataColor","pieLayout","dataFilter","event","method","1350","createListSimply","getPercentWithPrecision","dataSelectableMixin","_dataProvider","retrieveRawAttr","PieSeries","extendSeriesModel","superApply","getRawData","updateSelectedMap","_createSelectableList","_defaultLabelLine","newOption","targetList","valueList","percent","defaultEmphasis","labelLineNormalOpt","labelLine","labelLineEmphasisOpt","emphasis","center","radius","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","rotate","length2","animationType","mixin","1351","nameList","isArray","coordDimensions","source","dimensionsInfo","createDimensions","list","List","initData","1352","_targetList","_selectTargetMap","reduce","targetMap","id","1353","updateDataSelected","uid","from","seriesId","toggleItemSelected","layout","midAngle","cos","sin","animate","when","PiePiece","hoverIgnore","normalIgnore","sector","piePieceProto","firstCreate","sectorShape","_updateLabel","labelText","labelLayout","linePoints","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","useInsideStyle","inside","verticalAlign","PieView","sectorGroup","_sectorGroup","isFirstRender","onSectorClick","piePiece","removeClipPath","_createClipPath","containPoint","itemLayout","sqrt","1354","actionInfos","actionInfo","registerAction","eachComponent","mainType","subType","query","1355","getTargetSeries","paletteScope","seiresModelMap","eachSeriesByType","__paletteScope","dataAll","idxMap","rawIdx","filteredIdx","singleDataColor","getColorFromPalette","1356","validDataCount","getSum","unitRadian","roseType","getDataExtent","restAngle","PI2","valueSumLargerThanMinAngle","currentAngle","angle","linearMap","1357","adjustSingleSide","viewWidth","viewHeight","shiftUp","delta","j","changeX","isDownList","lastDeltaX","Number","MAX_VALUE","l","deltaY","len2","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","textY","labelPosition","labelLineLen","labelLineLen2","isLabelInside","x1","y1","x2","y2","x3","y3","font","getFont","labelRotate","getFormattedLabel","textRect","textContain","1358","legendModels","findComponents","filterSelf","1359","LineReact","undefined","_chartConfig","_chartConfig2","_echarts","_echarts2","random","lineId","myChart","getInstanceByDom","document","getElementById","lineChart","title","xAxis","series","val","formatDate","formatTime","setOption","initLine","1360","legendFilter","registerSubTypeDefaulter","1361","legendSelectActionHandler","methodName","selectedMap","isToggleSelect","model","isItemSelected","1362","componentModel","boxLayoutParams","rect","layoutBox","positionElement","formatUtil","normalizeCssArray","_layout","1363","filterSeries","1364","mergeAndNormalizeLayoutParams","raw","getOrient","index","mergeLayoutParam","getLayoutParams","ScrollableLegendModel","setScrollDataIndex","scrollDataIndex","pageButtonItemGap","pageButtonGap","pageButtonPosition","pageFormatter","pageIcons","horizontal","vertical","pageIconColor","pageIconInactiveColor","pageIconSize","pageTextStyle","animationDurationUpdate","extraOpt","inputPositionParams","1365","LegendView","WH","XY","ScrollableLegendView","_currentIndex","_containerGroup","_controllerGroup","_showController","__rectSize","createPageButton","iconIdx","pageDataIndexName","icon","createIcon","onclick","me","_pageGo","controllerGroup","pageTextStyleModel","containerGroup","orientIdx","wh","hw","yx","controllerRect","showController","contentPos","containerPos","controllerPos","retrieve2","pageInfo","_getPageInfo","pageIndex","contentPosition","_updatePageInfoView","to","legendId","canJump","childOfName","pageText","total","pageCount","isString","getItemRect","itemRect","clone","xy","pagePrevDataIndex","pageNextDataIndex","targetItemGroup","currDataIndex","containerRectSize","ceil","itemLoc","floor","winRect","startIdx","children","intersect","startItem","startRect","1366","1613","_Links","_Price","MarketOverview","_Component","load","_ref","property","obj1","obj2","market","rank","ExternalLink","url","link","pair","TRXPrice","amount","volumeNative","FormattedNumber","volumePercentage","maximumFractionDigits","1614","_toConsumableArray","arr","arr2","RingPieReact","pieId","compare","ringPieChart","legend","sortObj","pairData","exchanges","temp","subCount","finalExchanges","finalPairData","initPie"],"mappings":"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","file":"static/js/Markets.9e30d3aa.chunk.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 1184:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(4);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(8);var _reactRedux=__webpack_require__(7);var _markets=__webpack_require__(438);var _i18n=__webpack_require__(5);var _MarketOverview=__webpack_require__(1613);var _MarketOverview2=_interopRequireDefault(_MarketOverview);var _loaders=__webpack_require__(19);var _api=__webpack_require__(6);var _LineChart=__webpack_require__(1359);var _LineChart2=_interopRequireDefault(_LineChart);var _RingPieChart=__webpack_require__(1614);var _RingPieChart2=_interopRequireDefault(_RingPieChart);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Markets=function(_React$Component){_inherits(Markets,_React$Component);function Markets(){var _this2=this;_classCallCheck(this,Markets);var _this=_possibleConstructorReturn(this,(Markets.__proto__||Object.getPrototypeOf(Markets)).call(this));_this.loadMarketData=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var markets;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_this.props.loadPriceData();_context.next=3;return _api.Client.getMarkets();case 3:markets=_context.sent;_this.setState({markets:markets});case 5:case\"end\":return _context.stop();}}},_callee,_this2);}));_this.state={priceGraph:[],volumeGraph:[],markets:[]};return _this;}_createClass(Markets,[{key:\"componentDidMount\",value:function componentDidMount(){this.loadMarketData();}},{key:\"render\",value:function render(){var _props=this.props,intl=_props.intl,priceGraph=_props.priceGraph,volumeGraph=_props.volumeGraph;var markets=this.state.markets;return _react2.default.createElement(\"main\",{className:\"container header-overlap pb-3\"},_react2.default.createElement(\"div\",{className:\"row\"},_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3 mt-md-0\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"average_price_usd\")),_react2.default.createElement(\"div\",{style:{height:300}},priceGraph.length===0?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:priceGraph,keysData:['time','close'],format:{time:true,date:true}}))))),_react2.default.createElement(\"div\",{className:\"col-md-6 mt-3 mt-md-0\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"average_volume_usd\")),_react2.default.createElement(\"div\",{style:{height:300}},volumeGraph.length===0?_react2.default.createElement(_loaders.TronLoader,null):_react2.default.createElement(_LineChart2.default,{style:{height:300},data:volumeGraph,keysData:['time','volume'],format:{time:true}})))))),_react2.default.createElement(\"div\",{className:\"row mt-3\"},_react2.default.createElement(\"div\",{className:\"col-md-12\"},_react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"div\",{className:\"card-body\"},_react2.default.createElement(\"h5\",{className:\"card-title text-center\"},(0,_i18n.tu)(\"Trade Volume\"),' Top 10'),_react2.default.createElement(_RingPieChart2.default,{style:{height:700},data:markets}))))),_react2.default.createElement(\"div\",{className:\"row mt-3\"},_react2.default.createElement(\"div\",{className:\"col-md-12\"},_react2.default.createElement(_MarketOverview2.default,{markets:markets}))));}}]);return Markets;}(_react2.default.Component);function mapStateToProps(state){return{priceGraph:state.markets.price,volumeGraph:state.markets.volume};}var mapDispatchToProps={loadPriceData:_markets.loadPriceData};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(Markets));\n\n/***/ }),\n\n/***/ 1237:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar _symbol = __webpack_require__(224);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(22);\n\nvar _number = __webpack_require__(27);\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = __webpack_require__(432);\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1238:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = __webpack_require__(2);\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n/***/ }),\n\n/***/ 1276:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n__webpack_require__(1277);\n\n__webpack_require__(1278);\n\nvar visualSymbol = __webpack_require__(1282);\n\nvar layoutPoints = __webpack_require__(1283);\n\nvar dataSample = __webpack_require__(1284);\n\n__webpack_require__(433);\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n/***/ }),\n\n/***/ 1277:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(24);\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = __webpack_require__(226);\n\nvar SeriesModel = __webpack_require__(225);\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1278:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(24);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(2);\n\nvar SymbolDraw = __webpack_require__(1279);\n\nvar SymbolClz = __webpack_require__(1237);\n\nvar lineAnimationDiff = __webpack_require__(1280);\n\nvar graphic = __webpack_require__(22);\n\nvar modelUtil = __webpack_require__(12);\n\nvar _poly = __webpack_require__(1281);\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = __webpack_require__(422);\n\nvar _helper = __webpack_require__(1238);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1279:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(22);\n\nvar SymbolClz = __webpack_require__(1237);\n\nvar _util = __webpack_require__(2);\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1280:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _helper = __webpack_require__(1238);\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1281:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Path = __webpack_require__(32);\n\nvar vec2 = __webpack_require__(25);\n\nvar fixClipWithShadow = __webpack_require__(430);\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n/***/ }),\n\n/***/ 1282:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1283:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(2);\n\nvar map = _util.map;\n\nvar createRenderPlanner = __webpack_require__(431);\n\nvar _dataStackHelper = __webpack_require__(145);\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1284:\n/***/ (function(module, exports) {\n\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1285:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar Model = __webpack_require__(46);\n\nvar _model = __webpack_require__(12);\n\nvar isNameSpecified = _model.isNameSpecified;\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // \n    zlevel: 0,\n    // \n    z: 4,\n    show: true,\n    // \n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // \n    // 'auto' | 'left' | 'right'\n    //  'auto',  x \n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // \n    borderColor: '#ccc',\n    borderRadius: 0,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // itempx10\n    // \n    itemGap: 10,\n    // \n    itemWidth: 25,\n    // \n    itemHeight: 14,\n    // \n    inactiveColor: '#ccc',\n    textStyle: {\n      // \n      color: '#333'\n    },\n    // formatter: '',\n    // \n    selectedMode: true,\n    // LEGEND.SELECTED\n    // selected: null,\n    // legend.dataitem\n    // data: [],\n    // Tooltip \n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1286:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(24);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nvar _symbol = __webpack_require__(224);\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = __webpack_require__(22);\n\nvar _listComponent = __webpack_require__(1362);\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = __webpack_require__(57);\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1349:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\n__webpack_require__(1350);\n\n__webpack_require__(1353);\n\nvar createDataSelectAction = __webpack_require__(1354);\n\nvar dataColor = __webpack_require__(1355);\n\nvar pieLayout = __webpack_require__(1356);\n\nvar dataFilter = __webpack_require__(1358);\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n/***/ }),\n\n/***/ 1350:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar createListSimply = __webpack_require__(1351);\n\nvar zrUtil = __webpack_require__(2);\n\nvar modelUtil = __webpack_require__(12);\n\nvar _number = __webpack_require__(27);\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = __webpack_require__(1352);\n\nvar _dataProvider = __webpack_require__(93);\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // \n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // \n    clockwise: true,\n    startAngle: 90,\n    // 0\n    minAngle: 0,\n    // \n    selectedOffset: 10,\n    // \n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // singlemultiple\n    // selectedMode: false,\n    // 'radius' | 'area'\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: Tooltip.formatter\n      // TEXTSTYLE\n      // distance: positioninnerlabel()\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // \n      length: 15,\n      // \n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: ,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1351:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createDimensions = __webpack_require__(228);\n\nvar List = __webpack_require__(227);\n\nvar _util = __webpack_require__(2);\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1352:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1353:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar graphic = __webpack_require__(22);\n\nvar ChartView = __webpack_require__(422);\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1354:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1355:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _util = __webpack_require__(2);\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1356:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _number = __webpack_require__(27);\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = __webpack_require__(1357);\n\nvar zrUtil = __webpack_require__(2);\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME  2.0  roseType  area \n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1357:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar textContain = __webpack_require__(74);\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // \n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // \n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // \n    ? Number.MAX_VALUE // \n    : 0 // \n    : isDownList // \n    ? Number.MAX_VALUE // \n    : 0; // \n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // \n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // \n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1358:\n/***/ (function(module, exports) {\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1359:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.LineReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _reactIntl=__webpack_require__(8);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1276);__webpack_require__(423);__webpack_require__(424);var _reactRedux=__webpack_require__(7);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var LineReact=exports.LineReact=function(_React$Component){_inherits(LineReact,_React$Component);function LineReact(props){_classCallCheck(this,LineReact);var _this=_possibleConstructorReturn(this,(LineReact.__proto__||Object.getPrototypeOf(LineReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={lineId:'line'+id};return _this;}_createClass(LineReact,[{key:'initLine',value:function initLine(id){var _props=this.props,intl=_props.intl,keysData=_props.keysData,data=_props.data,format=_props.format;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.lineChart.title.text='';_chartConfig2.default.lineChart.xAxis.data=[];_chartConfig2.default.lineChart.series[0].data=[];if(data&&data.length>0){data.map(function(val){if(format&&format[keysData[0]]){if(format.date){_chartConfig2.default.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]]*1000));}else{_chartConfig2.default.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]]*1000));}}else _chartConfig2.default.lineChart.xAxis.data.push(val[keysData[0]]);_chartConfig2.default.lineChart.series[0].data.push(val[keysData[1]]);});}if(data&&data.length===0){_chartConfig2.default.lineChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.lineChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initLine(this.state.lineId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initLine(this.state.lineId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.lineId,style:this.props.style}));}}]);return LineReact;}(_react2.default.Component);function mapStateToProps(state){return{};}var mapDispatchToProps={};exports.default=(0,_reactRedux.connect)(mapStateToProps,mapDispatchToProps,null,{pure:false})((0,_reactIntl.injectIntl)(LineReact));\n\n/***/ }),\n\n/***/ 1360:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n__webpack_require__(1285);\n\n__webpack_require__(1361);\n\n__webpack_require__(1286);\n\nvar legendFilter = __webpack_require__(1363);\n\nvar Component = __webpack_require__(61);\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n/***/ }),\n\n/***/ 1361:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\nvar zrUtil = __webpack_require__(2);\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n/***/ }),\n\n/***/ 1362:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _layout = __webpack_require__(57);\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = __webpack_require__(38);\n\nvar graphic = __webpack_require__(22);\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n/***/ }),\n\n/***/ 1363:\n/***/ (function(module, exports) {\n\nfunction _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1364:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar LegendModel = __webpack_require__(1285);\n\nvar _layout = __webpack_require__(57);\n\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar getLayoutParams = _layout.getLayoutParams;\nvar ScrollableLegendModel = LegendModel.extend({\n  type: 'legend.scroll',\n\n  /**\n   * @param {number} scrollDataIndex\n   */\n  setScrollDataIndex: function (scrollDataIndex) {\n    this.option.scrollDataIndex = scrollDataIndex;\n  },\n  defaultOption: {\n    scrollDataIndex: 0,\n    pageButtonItemGap: 5,\n    pageButtonGap: null,\n    pageButtonPosition: 'end',\n    // 'start' or 'end'\n    pageFormatter: '{current}/{total}',\n    // If null/undefined, do not show page.\n    pageIcons: {\n      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n    },\n    pageIconColor: '#2f4554',\n    pageIconInactiveColor: '#aaa',\n    pageIconSize: 15,\n    // Can be [10, 3], which represents [width, height]\n    pageTextStyle: {\n      color: '#333'\n    },\n    animationDurationUpdate: 800\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    var inputPositionParams = getLayoutParams(option);\n    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);\n    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (option, extraOpt) {\n    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);\n    mergeAndNormalizeLayoutParams(this, this.option, option);\n  },\n  getOrient: function () {\n    return this.get('orient') === 'vertical' ? {\n      index: 1,\n      name: 'vertical'\n    } : {\n      index: 0,\n      name: 'horizontal'\n    };\n  }\n}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.\n\nfunction mergeAndNormalizeLayoutParams(legendModel, target, raw) {\n  var orient = legendModel.getOrient();\n  var ignoreSize = [1, 1];\n  ignoreSize[orient.index] = 0;\n  mergeLayoutParam(target, raw, {\n    type: 'box',\n    ignoreSize: ignoreSize\n  });\n}\n\nvar _default = ScrollableLegendModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1365:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(2);\n\nvar graphic = __webpack_require__(22);\n\nvar layoutUtil = __webpack_require__(57);\n\nvar LegendView = __webpack_require__(1286);\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup;\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n\n    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    // Align left or top by the current dataIndex.\n    var currDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var contentRect = contentGroup.getBoundingRect();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var xy = XY[orientIdx];\n    var contentPos = contentGroup.position.slice();\n    var pageIndex;\n    var pagePrevDataIndex;\n    var pageNextDataIndex;\n    var targetItemGroup;\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child) {\n        if (child.__legendDataIndex === currDataIndex) {\n          targetItemGroup = child;\n        }\n      });\n    } else {\n      targetItemGroup = contentGroup.childAt(0);\n    }\n\n    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n    if (targetItemGroup) {\n      var itemRect = targetItemGroup.getBoundingRect();\n      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n      contentPos[orientIdx] = -itemLoc - contentRect[xy];\n      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);\n      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;\n      var winRect = {\n        x: 0,\n        y: 0\n      };\n      winRect[wh] = containerRectSize;\n      winRect[hw] = contentRect[hw];\n      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n      var startIdx;\n      var children = contentGroup.children();\n      contentGroup.eachChild(function (child, index) {\n        var itemRect = getItemRect(child);\n\n        if (itemRect.intersect(winRect)) {\n          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the\n          // current window is shown at the begining of next window.\n\n          pageNextDataIndex = child.__legendDataIndex;\n        } // If the last item is shown entirely, no next page.\n\n\n        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {\n          pageNextDataIndex = null;\n        }\n      }); // Always align based on the left/top most item, so the left/top most\n      // item in the previous window is needed to be found here.\n\n      if (startIdx != null) {\n        var startItem = children[startIdx];\n        var startRect = getItemRect(startItem);\n        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.\n\n        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n          pagePrevDataIndex = null;\n        } else {\n          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n            startIdx--;\n          }\n\n          pagePrevDataIndex = children[startIdx].__legendDataIndex;\n        }\n      }\n    }\n\n    return {\n      contentPosition: contentPos,\n      pageIndex: pageIndex,\n      pageCount: pageCount,\n      pagePrevDataIndex: pagePrevDataIndex,\n      pageNextDataIndex: pageNextDataIndex\n    };\n\n    function getItemRect(el) {\n      var itemRect = el.getBoundingRect().clone();\n      itemRect[xy] += el.position[orientIdx];\n      return itemRect;\n    }\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 1366:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(30);\n\n/**\n * @event legendScroll\n * @type {Object}\n * @property {string} type 'legendScroll'\n * @property {string} scrollDataIndex\n */\necharts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {\n  var scrollDataIndex = payload.scrollDataIndex;\n  scrollDataIndex != null && ecModel.eachComponent({\n    mainType: 'legend',\n    subType: 'scroll',\n    query: payload\n  }, function (legendModel) {\n    legendModel.setScrollDataIndex(scrollDataIndex);\n  });\n});\n\n/***/ }),\n\n/***/ 1613:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});var _regenerator=__webpack_require__(4);var _regenerator2=_interopRequireDefault(_regenerator);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _i18n=__webpack_require__(5);var _api=__webpack_require__(6);var _Links=__webpack_require__(10);var _reactIntl=__webpack_require__(8);var _Price=__webpack_require__(37);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{return Promise.resolve(value).then(function(value){step(\"next\",value);},function(err){step(\"throw\",err);});}}return step(\"next\");});};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var MarketOverview=function(_Component){_inherits(MarketOverview,_Component);function MarketOverview(){_classCallCheck(this,MarketOverview);var _this=_possibleConstructorReturn(this,(MarketOverview.__proto__||Object.getPrototypeOf(MarketOverview)).call(this));_this.state={markets:[]};return _this;}_createClass(MarketOverview,[{key:\"componentDidMount\",value:function componentDidMount(){// this.load();\n}},{key:\"load\",value:function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regenerator2.default.mark(function _callee(){var markets;return _regenerator2.default.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return _api.Client.getMarkets();case 2:markets=_context.sent;this.setState({markets:markets});case 4:case\"end\":return _context.stop();}}},_callee,this);}));function load(){return _ref.apply(this,arguments);}return load;}()},{key:\"render\",value:function render(){var markets=this.props.markets;function compare(property){return function(obj1,obj2){if(obj1[property]>obj2[property]){return 1;}else if(obj1[property]<obj2[property]){return-1;}else{return 0;}};}markets=markets.sort(compare(\"rank\")).slice(0,99);return _react2.default.createElement(\"div\",{className:\"card\"},_react2.default.createElement(\"table\",{className:\"table table-hover bg-white m-0 table-striped\"},_react2.default.createElement(\"thead\",{className:\"thead-dark\"},_react2.default.createElement(\"tr\",null,_react2.default.createElement(\"th\",{style:{width:25}},(0,_i18n.tu)(\"rank\")),_react2.default.createElement(\"th\",null,(0,_i18n.tu)(\"exchange\")),_react2.default.createElement(\"th\",{className:\"d-none d-sm-table-cell\",style:{width:75}},(0,_i18n.tu)(\"pair\")),_react2.default.createElement(\"th\",{className:\"d-none d-md-table-cell\",style:{width:100}},(0,_i18n.tu)(\"volume\")),_react2.default.createElement(\"th\",{className:\"d-none d-md-table-cell\",style:{width:75}},\"%\"),_react2.default.createElement(\"th\",{className:\"text-right\",style:{width:100}},(0,_i18n.tu)(\"price\")))),_react2.default.createElement(\"tbody\",null,markets.map(function(market){return _react2.default.createElement(\"tr\",{key:market.rank},_react2.default.createElement(\"th\",null,market.rank),_react2.default.createElement(\"td\",null,_react2.default.createElement(_Links.ExternalLink,{url:market.link},market.name)),_react2.default.createElement(\"td\",{className:\"d-none d-sm-table-cell\",style:{width:75}},_react2.default.createElement(_Links.ExternalLink,{url:market.link},market.pair)),_react2.default.createElement(\"td\",{className:\"text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_Price.TRXPrice,{amount:market.volumeNative})),_react2.default.createElement(\"td\",{className:\"text-nowrap d-none d-md-table-cell\"},_react2.default.createElement(_reactIntl.FormattedNumber,{value:market.volumePercentage,maximumFractionDigits:2}),\"%\"),_react2.default.createElement(\"td\",{className:\"text-right\"},\"$\",_react2.default.createElement(_reactIntl.FormattedNumber,{value:market.price,maximumFractionDigits:8})));}))));}}]);return MarketOverview;}(_react.Component);exports.default=MarketOverview;\n\n/***/ }),\n\n/***/ 1614:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.RingPieReact=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _react=__webpack_require__(0);var _react2=_interopRequireDefault(_react);var _chartConfig=__webpack_require__(421);var _chartConfig2=_interopRequireDefault(_chartConfig);var _echarts=__webpack_require__(30);var _echarts2=_interopRequireDefault(_echarts);__webpack_require__(1349);__webpack_require__(423);__webpack_require__(424);__webpack_require__(1360);__webpack_require__(1364);__webpack_require__(1365);__webpack_require__(1366);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var RingPieReact=exports.RingPieReact=function(_React$Component){_inherits(RingPieReact,_React$Component);function RingPieReact(props){_classCallCheck(this,RingPieReact);var _this=_possibleConstructorReturn(this,(RingPieReact.__proto__||Object.getPrototypeOf(RingPieReact)).call(this,props));var id=('_'+Math.random()).replace('.','_');_this.state={pieId:'pie'+id};return _this;}_createClass(RingPieReact,[{key:'initPie',value:function initPie(id){var data=this.props.data;var myChart=_echarts2.default.getInstanceByDom(document.getElementById(id));if(myChart===undefined){myChart=_echarts2.default.init(document.getElementById(id));}_chartConfig2.default.ringPieChart.series[0].data=[];_chartConfig2.default.ringPieChart.series[1].data=[];_chartConfig2.default.ringPieChart.legend.data=[];_chartConfig2.default.ringPieChart.title.text=\"\";function compare(property){return function(obj1,obj2){if(obj1[property]>obj2[property]){return 1;}else if(obj1[property]<obj2[property]){return-1;}else{return 0;}};}if(data&&data.length>0){var sortObj=data.sort(compare(\"name\"));var pairData=[];var exchanges=[];var temp=[];for(var index in sortObj){pairData.push({name:sortObj[index].pair,value:sortObj[index].volume});if(temp.indexOf(sortObj[index].name)<0){temp.push(sortObj[index].name);exchanges.push({name:sortObj[index].name,value:0,subCount:[]});}}for(var _index in exchanges){for(var idx in sortObj){if(sortObj[idx].name===exchanges[_index].name){exchanges[_index].value=exchanges[_index].value+sortObj[idx].volume;exchanges[_index].subCount.push({name:sortObj[idx].pair,value:sortObj[idx].volume});}}}exchanges.sort(compare(\"value\"));var finalExchanges=exchanges.slice(exchanges.length-10,exchanges.length);var finalPairData=[];for(var _index2 in finalExchanges){finalPairData.push.apply(finalPairData,_toConsumableArray(finalExchanges[_index2].subCount));}_chartConfig2.default.ringPieChart.series[0].data=[];_chartConfig2.default.ringPieChart.series[1].data=[];_chartConfig2.default.ringPieChart.legend.data=temp;_chartConfig2.default.ringPieChart.series[0].data=finalExchanges;_chartConfig2.default.ringPieChart.series[1].data=finalPairData;}if(data&&data.length===0){_chartConfig2.default.ringPieChart.title.text=\"No data\";}myChart.setOption(_chartConfig2.default.ringPieChart);}},{key:'componentDidMount',value:function componentDidMount(){this.initPie(this.state.pieId);}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie(this.state.pieId);}},{key:'render',value:function render(){return _react2.default.createElement('div',null,_react2.default.createElement('div',{id:this.state.pieId,style:this.props.style}));}}]);return RingPieReact;}(_react2.default.Component);exports.default=RingPieReact;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/Markets.9e30d3aa.chunk.js","import React, {Fragment} from \"react\";\nimport {injectIntl} from \"react-intl\";\nimport {connect} from \"react-redux\";\nimport {loadPriceData} from \"../../actions/markets\";\nimport {tu} from \"../../utils/i18n\";\nimport MarketOverview from \"./MarketOverview\";\nimport {TronLoader} from \"../common/loaders\";\nimport {Client} from \"../../services/api\";\nimport LineReact from \"../common/LineChart\";\nimport RingPieReact from \"../common/RingPieChart\";\n\nclass Markets extends React.Component {\n\n  constructor() {\n    super();\n\n    this.state = {\n      priceGraph: [],\n      volumeGraph: [],\n      markets: [],\n    };\n  }\n\n  componentDidMount() {\n    this.loadMarketData();\n  }\n\n  loadMarketData = async () => {\n    this.props.loadPriceData();\n\n    let markets = await Client.getMarkets();\n\n    this.setState({\n      markets,\n    });\n  };\n\n  render() {\n\n    let {intl, priceGraph, volumeGraph} = this.props;\n    let {markets} = this.state;\n\n    return (\n        <main className=\"container header-overlap pb-3\">\n          <div className=\"row\">\n            <div className=\"col-md-6 mt-3 mt-md-0\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"average_price_usd\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      priceGraph.length === 0 ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={priceGraph} keysData={['time', 'close']}\n                                     format={{time: true, date: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"col-md-6 mt-3 mt-md-0\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"average_volume_usd\")}</h5>\n                  <div style={{height: 300}}>\n                    {\n                      volumeGraph.length === 0 ?\n                          <TronLoader/> :\n                          <LineReact style={{height: 300}} data={volumeGraph} keysData={['time', 'volume']}\n                                     format={{time: true}}/>\n                    }\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row mt-3\">\n            <div className=\"col-md-12\">\n              <div className=\"card\">\n                <div className=\"card-body\">\n                  <h5 className=\"card-title text-center\">{tu(\"Trade Volume\")}{' Top 10'}</h5>\n                  <RingPieReact style={{height: 700}} data={markets}/>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"row mt-3\">\n            <div className=\"col-md-12\">\n              <MarketOverview markets={markets}/>\n            </div>\n          </div>\n        </main>\n    );\n  }\n}\n\n\nfunction mapStateToProps(state) {\n  return {\n    priceGraph: state.markets.price,\n    volumeGraph: state.markets.volume,\n  };\n}\n\nconst mapDispatchToProps = {\n  loadPriceData,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(Markets));\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/markets/index.js","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/**\n * @module echarts/chart/helper/Symbol\n */\nfunction getSymbolSize(data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n}\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    this._createSymbol(symbolType, data, idx, symbolSize);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/Symbol.js\n// module id = 1237\n// module chunks = 2 3 4","var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var stacked = isDimensionStacked(data, valueDim, baseDim);\n  var dataDimsForPoint = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  return {\n    dataDimsForPoint: dataDimsForPoint,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/helper.js\n// module id = 1238\n// module chunks = 2 3 4","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line.js\n// module id = 1276\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    // \n    symbol: 'emptyCircle',\n    // \n    symbolSize: 4,\n    // \n    symbolRotate: null,\n    //  symbol,  tooltip hover \n    showSymbol: true,\n    // \n    showAllSymbol: false,\n    // \n    connectNulls: false,\n    // 'average', 'max', 'min', 'sum'\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineSeries.js\n// module id = 1277\n// module chunks = 2 3 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y;\n  var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n  var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n  if (isHorizontal) {\n    y -= expandSize;\n    height += expandSize * 2;\n  } else {\n    x -= expandSize;\n    width += expandSize * 2;\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180;\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: polar.cx,\n      cy: polar.cy,\n      r0: radiusExtent[0],\n      r: radiusExtent[1],\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n\n    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols\n\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: createClipShape(coordSys, false, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      }\n\n      var coordSysClipShape = createClipShape(coordSys, false, seriesModel); // Update clipPath\n\n      lineGroup.setClipPath(coordSysClipShape); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isSymbolIgnore,\n        clipShape: coordSysClipShape\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  _getSymbolIgnoreFunc: function (data, coordSys) {\n    var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis\n\n    if (categoryAxis && categoryAxis.isLabelIgnored) {\n      return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n    }\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/LineView.js\n// module id = 1278\n// module chunks = 2 3 4","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will\n  // cut part of the symbol element shape.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 1279\n// module chunks = 2 3 4","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 1280\n// module chunks = 2 3 4","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  if (smoothMonotone == null) {\n    if (isMono(points, 'x')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n    } else if (isMono(points, 'y')) {\n      return drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n    } else {\n      return drawNonMono.apply(this, arguments);\n    }\n  } else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n    return drawMono.apply(this, arguments);\n  } else {\n    return drawNonMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n\n\nfunction isMono(points, smoothMonotone) {\n  if (points.length <= 1) {\n    return true;\n  }\n\n  var dim = smoothMonotone === 'x' ? 0 : 1;\n  var last = points[0][dim];\n  var lastDiff = 0;\n\n  for (var i = 1; i < points.length; ++i) {\n    var diff = points[i][dim] - last;\n\n    if (!isNaN(diff) && !isNaN(lastDiff) && diff !== 0 && lastDiff !== 0 && diff >= 0 !== lastDiff >= 0) {\n      return false;\n    }\n\n    if (!isNaN(diff) && diff !== 0) {\n      lastDiff = diff;\n      last = points[i][dim];\n    }\n  }\n\n  return true;\n}\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/line/poly.js\n// module id = 1281\n// module chunks = 2 3 4","function _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/symbol.js\n// module id = 1282\n// module chunks = 2 3 4","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n\n      if (isDimensionStacked(data, dims[0], dims[1])) {\n        dims[0] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      if (isDimensionStacked(data, dims[1], dims[0])) {\n        dims[1] = data.getCalculationInfo('stackResultDimension');\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i, true);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i, true);\n            var y = tmpIn[1] = data.get(dims[1], i, true); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/layout/points.js\n// module id = 1283\n// module chunks = 2 3 4","var samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    }\n\n    return max;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    }\n\n    return min;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            seriesModel.setData(data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataSample.js\n// module id = 1284\n// module chunks = 2 3 4","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _model = require(\"../../util/model\");\n\nvar isNameSpecified = _model.isNameSpecified;\nvar LegendModel = echarts.extendComponentModel({\n  type: 'legend.plain',\n  dependencies: ['series'],\n  layoutMode: {\n    type: 'box',\n    // legend.width/height are maxWidth/maxHeight actually,\n    // whereas realy width/height is calculated by its content.\n    // (Setting {left: 10, right: 10} does not make sense).\n    // So consider the case:\n    // `setOption({legend: {left: 10});`\n    // then `setOption({legend: {right: 10});`\n    // The previous `left` should be cleared by setting `ignoreSize`.\n    ignoreSize: true\n  },\n  init: function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n    option.selected = option.selected || {};\n  },\n  mergeOption: function (option) {\n    LegendModel.superCall(this, 'mergeOption', option);\n  },\n  optionUpdated: function () {\n    this._updateData(this.ecModel);\n\n    var legendData = this._data; // If selectedMode is single, try to select one\n\n    if (legendData[0] && this.get('selectedMode') === 'single') {\n      var hasSelected = false; // If has any selected in option.selected\n\n      for (var i = 0; i < legendData.length; i++) {\n        var name = legendData[i].get('name');\n\n        if (this.isSelected(name)) {\n          // Force to unselect others\n          this.select(name);\n          hasSelected = true;\n          break;\n        }\n      } // Try select the first if selectedMode is single\n\n\n      !hasSelected && this.select(legendData[0].get('name'));\n    }\n  },\n  _updateData: function (ecModel) {\n    var potentialData = [];\n    var availableNames = [];\n    ecModel.eachRawSeries(function (seriesModel) {\n      var seriesName = seriesModel.name;\n      availableNames.push(seriesName);\n      var isPotential;\n\n      if (seriesModel.legendDataProvider) {\n        var data = seriesModel.legendDataProvider();\n        var names = data.mapArray(data.getName);\n\n        if (!ecModel.isSeriesFiltered(seriesModel)) {\n          availableNames = availableNames.concat(names);\n        }\n\n        if (names.length) {\n          potentialData = potentialData.concat(names);\n        } else {\n          isPotential = true;\n        }\n      } else {\n        isPotential = true;\n      }\n\n      if (isPotential && isNameSpecified(seriesModel)) {\n        potentialData.push(seriesModel.name);\n      }\n    });\n    /**\n     * @type {Array.<string>}\n     * @private\n     */\n\n    this._availableNames = availableNames; // If legend.data not specified in option, use availableNames as data,\n    // which is convinient for user preparing option.\n\n    var rawData = this.get('data') || potentialData;\n    var legendData = zrUtil.map(rawData, function (dataItem) {\n      // Can be string or number\n      if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n        dataItem = {\n          name: dataItem\n        };\n      }\n\n      return new Model(dataItem, this, this.ecModel);\n    }, this);\n    /**\n     * @type {Array.<module:echarts/model/Model>}\n     * @private\n     */\n\n    this._data = legendData;\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Model>}\n   */\n  getData: function () {\n    return this._data;\n  },\n\n  /**\n   * @param {string} name\n   */\n  select: function (name) {\n    var selected = this.option.selected;\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      var data = this._data;\n      zrUtil.each(data, function (dataItem) {\n        selected[dataItem.get('name')] = false;\n      });\n    }\n\n    selected[name] = true;\n  },\n\n  /**\n   * @param {string} name\n   */\n  unSelect: function (name) {\n    if (this.get('selectedMode') !== 'single') {\n      this.option.selected[name] = false;\n    }\n  },\n\n  /**\n   * @param {string} name\n   */\n  toggleSelected: function (name) {\n    var selected = this.option.selected; // Default is true\n\n    if (!selected.hasOwnProperty(name)) {\n      selected[name] = true;\n    }\n\n    this[selected[name] ? 'unSelect' : 'select'](name);\n  },\n\n  /**\n   * @param {string} name\n   */\n  isSelected: function (name) {\n    var selected = this.option.selected;\n    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;\n  },\n  defaultOption: {\n    // \n    zlevel: 0,\n    // \n    z: 4,\n    show: true,\n    // \n    // 'horizontal' | 'vertical'\n    orient: 'horizontal',\n    left: 'center',\n    // right: 'center',\n    top: 0,\n    // bottom: null,\n    // \n    // 'auto' | 'left' | 'right'\n    //  'auto',  x \n    align: 'auto',\n    backgroundColor: 'rgba(0,0,0,0)',\n    // \n    borderColor: '#ccc',\n    borderRadius: 0,\n    // px0\n    borderWidth: 0,\n    // px5\n    // css\n    padding: 5,\n    // itempx10\n    // \n    itemGap: 10,\n    // \n    itemWidth: 25,\n    // \n    itemHeight: 14,\n    // \n    inactiveColor: '#ccc',\n    textStyle: {\n      // \n      color: '#333'\n    },\n    // formatter: '',\n    // \n    selectedMode: true,\n    // LEGEND.SELECTED\n    // selected: null,\n    // legend.dataitem\n    // data: [],\n    // Tooltip \n    tooltip: {\n      show: false\n    }\n  }\n});\nvar _default = LegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendModel.js\n// module id = 1285\n// module chunks = 2 4","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _listComponent = require(\"../helper/listComponent\");\n\nvar makeBackground = _listComponent.makeBackground;\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar Group = graphic.Group;\n\nvar _default = echarts.extendComponentView({\n  type: 'legend.plain',\n  newlineDisabled: false,\n\n  /**\n   * @override\n   */\n  init: function () {\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n    this.group.add(this._contentGroup = new Group());\n    /**\n     * @private\n     * @type {module:zrender/Element}\n     */\n\n    this._backgroundEl;\n  },\n\n  /**\n   * @protected\n   */\n  getContentGroup: function () {\n    return this._contentGroup;\n  },\n\n  /**\n   * @override\n   */\n  render: function (legendModel, ecModel, api) {\n    this.resetInner();\n\n    if (!legendModel.get('show', true)) {\n      return;\n    }\n\n    var itemAlign = legendModel.get('align');\n\n    if (!itemAlign || itemAlign === 'auto') {\n      itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';\n    }\n\n    this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout.\n\n    var positionInfo = legendModel.getBoxLayoutParams();\n    var viewportSize = {\n      width: api.getWidth(),\n      height: api.getHeight()\n    };\n    var padding = legendModel.get('padding');\n    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`.\n\n    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({\n      width: mainRect.width,\n      height: mainRect.height\n    }, positionInfo), viewportSize, padding);\n    this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout.\n\n    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n  },\n\n  /**\n   * @protected\n   */\n  resetInner: function () {\n    this.getContentGroup().removeAll();\n    this._backgroundEl && this.group.remove(this._backgroundEl);\n  },\n\n  /**\n   * @protected\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var contentGroup = this.getContentGroup();\n    var legendDrawnMap = zrUtil.createHashMap();\n    var selectMode = legendModel.get('selectedMode');\n    each(legendModel.getData(), function (itemModel, dataIndex) {\n      var name = itemModel.get('name'); // Use empty string or \\n as a newline string\n\n      if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n        contentGroup.add(new Group({\n          newline: true\n        }));\n        return;\n      }\n\n      var seriesModel = ecModel.getSeriesByName(name)[0];\n\n      if (legendDrawnMap.get(name)) {\n        // Have been drawed\n        return;\n      } // Series legend\n\n\n      if (seriesModel) {\n        var data = seriesModel.getData();\n        var color = data.getVisual('color'); // If color is a callback function\n\n        if (typeof color === 'function') {\n          // Use the first data\n          color = color(seriesModel.getDataParams(0));\n        } // Using rect symbol defaultly\n\n\n        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n        var symbolType = data.getVisual('symbol');\n\n        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);\n\n        itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n        legendDrawnMap.set(name, true);\n      } else {\n        // Data legend of pie, funnel\n        ecModel.eachRawSeries(function (seriesModel) {\n          // In case multiple series has same data name\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel.legendDataProvider) {\n            var data = seriesModel.legendDataProvider();\n            var idx = data.indexOfName(name);\n\n            if (idx < 0) {\n              return;\n            }\n\n            var color = data.getItemVisual(idx, 'color');\n            var legendSymbolType = 'roundRect';\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);\n\n            itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name\n            .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n            legendDrawnMap.set(name, true);\n          }\n        }, this);\n      }\n    }, this);\n  },\n  _createItem: function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {\n    var itemWidth = legendModel.get('itemWidth');\n    var itemHeight = legendModel.get('itemHeight');\n    var inactiveColor = legendModel.get('inactiveColor');\n    var isSelected = legendModel.isSelected(name);\n    var itemGroup = new Group();\n    var textStyleModel = itemModel.getModel('textStyle');\n    var itemIcon = itemModel.get('icon');\n    var tooltipModel = itemModel.getModel('tooltip');\n    var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first\n\n    legendSymbolType = itemIcon || legendSymbolType;\n    itemGroup.add(createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, true)); // Compose symbols\n    // PENDING\n\n    if (!itemIcon && symbolType // At least show one symbol, can't be all none\n    && (symbolType !== legendSymbolType || symbolType == 'none')) {\n      var size = itemHeight * 0.8;\n\n      if (symbolType === 'none') {\n        symbolType = 'circle';\n      } // Put symbol in the center\n\n\n      itemGroup.add(createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor));\n    }\n\n    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n    var textAlign = itemAlign;\n    var formatter = legendModel.get('formatter');\n    var content = name;\n\n    if (typeof formatter === 'string' && formatter) {\n      content = formatter.replace('{name}', name != null ? name : '');\n    } else if (typeof formatter === 'function') {\n      content = formatter(name);\n    }\n\n    itemGroup.add(new graphic.Text({\n      style: graphic.setTextStyle({}, textStyleModel, {\n        text: content,\n        x: textX,\n        y: itemHeight / 2,\n        textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n        textAlign: textAlign,\n        textVerticalAlign: 'middle'\n      })\n    })); // Add a invisible rect to increase the area of mouse hover\n\n    var hitRect = new graphic.Rect({\n      shape: itemGroup.getBoundingRect(),\n      invisible: true,\n      tooltip: tooltipModel.get('show') ? zrUtil.extend({\n        content: name,\n        // Defaul formatter\n        formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n          return name;\n        },\n        formatterParams: {\n          componentType: 'legend',\n          legendIndex: legendModel.componentIndex,\n          name: name,\n          $vars: ['name']\n        }\n      }, tooltipModel.option) : null\n    });\n    itemGroup.add(hitRect);\n    itemGroup.eachChild(function (child) {\n      child.silent = true;\n    });\n    hitRect.silent = !selectMode;\n    this.getContentGroup().add(itemGroup);\n    graphic.setHoverStyle(itemGroup);\n    itemGroup.__legendDataIndex = dataIndex;\n    return itemGroup;\n  },\n\n  /**\n   * @protected\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup(); // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n    var contentRect = contentGroup.getBoundingRect();\n    contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n    return this.group.getBoundingRect();\n  }\n});\n\nfunction dispatchSelectAction(name, api) {\n  api.dispatchAction({\n    type: 'legendToggleSelect',\n    name: name\n  });\n}\n\nfunction dispatchHighlightAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'highlight',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nfunction dispatchDownplayAction(seriesModel, dataName, api) {\n  // If element hover will move to a hoverLayer.\n  var el = api.getZr().storage.getDisplayList()[0];\n\n  if (!(el && el.useHoverLayer)) {\n    seriesModel.get('legendHoverLink') && api.dispatchAction({\n      type: 'downplay',\n      seriesName: seriesModel.name,\n      name: dataName\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendView.js\n// module id = 1286\n// module chunks = 2 4","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nrequire(\"./pie/PieSeries\");\n\nrequire(\"./pie/PieView\");\n\nvar createDataSelectAction = require(\"../action/createDataSelectAction\");\n\nvar dataColor = require(\"../visual/dataColor\");\n\nvar pieLayout = require(\"./pie/pieLayout\");\n\nvar dataFilter = require(\"../processor/dataFilter\");\n\ncreateDataSelectAction('pie', [{\n  type: 'pieToggleSelect',\n  event: 'pieselectchanged',\n  method: 'toggleSelected'\n}, {\n  type: 'pieSelect',\n  event: 'pieselected',\n  method: 'select'\n}, {\n  type: 'pieUnSelect',\n  event: 'pieunselected',\n  method: 'unSelect'\n}]);\necharts.registerVisual(dataColor('pie'));\necharts.registerLayout(zrUtil.curry(pieLayout, 'pie'));\necharts.registerProcessor(dataFilter('pie'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie.js\n// module id = 1349\n// module chunks = 2 3","var echarts = require(\"../../echarts\");\n\nvar createListSimply = require(\"../helper/createListSimply\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _number = require(\"../../util/number\");\n\nvar getPercentWithPrecision = _number.getPercentWithPrecision;\n\nvar dataSelectableMixin = require(\"../../component/helper/selectableMixin\");\n\nvar _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawAttr = _dataProvider.retrieveRawAttr;\nvar PieSeries = echarts.extendSeriesModel({\n  type: 'series.pie',\n  // Overwrite\n  init: function (option) {\n    PieSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item\n    // Use a function instead of direct access because data reference may changed\n\n    this.legendDataProvider = function () {\n      return this.getRawData();\n    };\n\n    this.updateSelectedMap(this._createSelectableList());\n\n    this._defaultLabelLine(option);\n  },\n  // Overwrite\n  mergeOption: function (newOption) {\n    PieSeries.superCall(this, 'mergeOption', newOption);\n    this.updateSelectedMap(this._createSelectableList());\n  },\n  getInitialData: function (option, ecModel) {\n    return createListSimply(this, ['value']);\n  },\n  _createSelectableList: function () {\n    var data = this.getRawData();\n    var valueDim = data.mapDimension('value');\n    var targetList = [];\n\n    for (var i = 0, len = data.count(); i < len; i++) {\n      targetList.push({\n        name: data.getName(i),\n        value: data.get(valueDim, i),\n        selected: retrieveRawAttr(data, i, 'selected')\n      });\n    }\n\n    return targetList;\n  },\n  // Overwrite\n  getDataParams: function (dataIndex) {\n    var data = this.getData();\n    var params = PieSeries.superCall(this, 'getDataParams', dataIndex); // FIXME toFixed?\n\n    var valueList = [];\n    data.each(data.mapDimension('value'), function (value) {\n      valueList.push(value);\n    });\n    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n    params.$vars.push('percent');\n    return params;\n  },\n  _defaultLabelLine: function (option) {\n    // Extend labelLine emphasis\n    modelUtil.defaultEmphasis(option, 'labelLine', ['show']);\n    var labelLineNormalOpt = option.labelLine;\n    var labelLineEmphasisOpt = option.emphasis.labelLine; // Not show label line if `label.normal.show = false`\n\n    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // \n    center: ['50%', '50%'],\n    radius: [0, '75%'],\n    // \n    clockwise: true,\n    startAngle: 90,\n    // 0\n    minAngle: 0,\n    // \n    selectedOffset: 10,\n    // \n    hoverOffset: 10,\n    // If use strategy to avoid label overlapping\n    avoidLabelOverlap: true,\n    // singlemultiple\n    // selectedMode: false,\n    // 'radius' | 'area'\n    // roseType: null,\n    percentPrecision: 2,\n    // If still show when all data zero.\n    stillShowZeroSum: true,\n    // cursor: null,\n    label: {\n      // If rotate around circle\n      rotate: false,\n      show: true,\n      // 'outer', 'inside', 'center'\n      position: 'outer' // formatter: Tooltip.formatter\n      // TEXTSTYLE\n      // distance: positioninnerlabel()\n\n    },\n    // Enabled when label.normal.position is 'outer'\n    labelLine: {\n      show: true,\n      // \n      length: 15,\n      // \n      length2: 15,\n      smooth: false,\n      lineStyle: {\n        // color: ,\n        width: 1,\n        type: 'solid'\n      }\n    },\n    itemStyle: {\n      borderWidth: 1\n    },\n    // Animation type canbe expansion, scale\n    animationType: 'expansion',\n    animationEasing: 'cubicOut'\n  }\n});\nzrUtil.mixin(PieSeries, dataSelectableMixin);\nvar _default = PieSeries;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n// module id = 1350\n// module chunks = 2 3","var createDimensions = require(\"../../data/helper/createDimensions\");\n\nvar List = require(\"../../data/List\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar extend = _util.extend;\nvar isArray = _util.isArray;\n\n/**\n * [Usage]:\n * (1)\n * createListSimply(seriesModel, ['value']);\n * (2)\n * createListSimply(seriesModel, {\n *     coordDimensions: ['value'],\n *     dimensionsCount: 5\n * });\n *\n * @param {module:echarts/model/Series} seriesModel\n * @param {Object|Array.<string|Object>} opt opt or coordDimensions\n *        The options in opt, see `echarts/data/helper/createDimensions`\n * @param {Array.<string>} [nameList]\n * @return {module:echarts/data/List}\n */\nfunction _default(seriesModel, opt, nameList) {\n  opt = isArray(opt) && {\n    coordDimensions: opt\n  } || extend({}, opt);\n  var source = seriesModel.getSource();\n  var dimensionsInfo = createDimensions(source, opt);\n  var list = new List(dimensionsInfo, seriesModel);\n  list.initData(source, nameList);\n  return list;\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListSimply.js\n// module id = 1351\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n */\nvar _default = {\n  /**\n   * @param {Array.<Object>} targetList [{name, value, selected}, ...]\n   *        If targetList is an array, it should like [{name: ..., value: ...}, ...].\n   *        If targetList is a \"List\", it must have coordDim: 'value' dimension and name.\n   */\n  updateSelectedMap: function (targetList) {\n    this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];\n    this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n      targetMap.set(target.name, target);\n      return targetMap;\n    }, zrUtil.createHashMap());\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  // PENGING If selectedMode is null ?\n  select: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    var selectedMode = this.get('selectedMode');\n\n    if (selectedMode === 'single') {\n      this._selectTargetMap.each(function (target) {\n        target.selected = false;\n      });\n    }\n\n    target && (target.selected = true);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  unSelect: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name); // var selectedMode = this.get('selectedMode');\n    // selectedMode !== 'single' && target && (target.selected = false);\n\n    target && (target.selected = false);\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  toggleSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n\n    if (target != null) {\n      this[target.selected ? 'unSelect' : 'select'](name, id);\n      return target.selected;\n    }\n  },\n\n  /**\n   * Either name or id should be passed as input here.\n   * If both of them are defined, id is used.\n   *\n   * @param {string|undefined} name name of data\n   * @param {number|undefined} id dataIndex of data\n   */\n  isSelected: function (name, id) {\n    var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name);\n    return target && target.selected;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/selectableMixin.js\n// module id = 1352\n// module chunks = 2 3","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar ChartView = require(\"../../view/Chart\");\n\n/**\n * @param {module:echarts/model/Series} seriesModel\n * @param {boolean} hasAnimation\n * @inner\n */\nfunction updateDataSelected(uid, seriesModel, hasAnimation, api) {\n  var data = seriesModel.getData();\n  var dataIndex = this.dataIndex;\n  var name = data.getName(dataIndex);\n  var selectedOffset = seriesModel.get('selectedOffset');\n  api.dispatchAction({\n    type: 'pieToggleSelect',\n    from: uid,\n    name: name,\n    seriesId: seriesModel.id\n  });\n  data.each(function (idx) {\n    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);\n  });\n}\n/**\n * @param {module:zrender/graphic/Sector} el\n * @param {Object} layout\n * @param {boolean} isSelected\n * @param {number} selectedOffset\n * @param {boolean} hasAnimation\n * @inner\n */\n\n\nfunction toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n  var midAngle = (layout.startAngle + layout.endAngle) / 2;\n  var dx = Math.cos(midAngle);\n  var dy = Math.sin(midAngle);\n  var offset = isSelected ? selectedOffset : 0;\n  var position = [dx * offset, dy * offset];\n  hasAnimation // animateTo will stop revious animation like update transition\n  ? el.animate().when(200, {\n    position: position\n  }).start('bounceOut') : el.attr('position', position);\n}\n/**\n * Piece of pie including Sector, Label, LabelLine\n * @constructor\n * @extends {module:zrender/graphic/Group}\n */\n\n\nfunction PiePiece(data, idx) {\n  graphic.Group.call(this);\n  var sector = new graphic.Sector({\n    z2: 2\n  });\n  var polyline = new graphic.Polyline();\n  var text = new graphic.Text();\n  this.add(sector);\n  this.add(polyline);\n  this.add(text);\n  this.updateData(data, idx, true); // Hover to change label and labelLine\n\n  function onEmphasis() {\n    polyline.ignore = polyline.hoverIgnore;\n    text.ignore = text.hoverIgnore;\n  }\n\n  function onNormal() {\n    polyline.ignore = polyline.normalIgnore;\n    text.ignore = text.normalIgnore;\n  }\n\n  this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);\n}\n\nvar piePieceProto = PiePiece.prototype;\n\npiePieceProto.updateData = function (data, idx, firstCreate) {\n  var sector = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var sectorShape = zrUtil.extend({}, layout);\n  sectorShape.label = null;\n\n  if (firstCreate) {\n    sector.setShape(sectorShape);\n    var animationType = seriesModel.getShallow('animationType');\n\n    if (animationType === 'scale') {\n      sector.shape.r = layout.r0;\n      graphic.initProps(sector, {\n        shape: {\n          r: layout.r\n        }\n      }, seriesModel, idx);\n    } // Expansion\n    else {\n        sector.shape.endAngle = layout.startAngle;\n        graphic.updateProps(sector, {\n          shape: {\n            endAngle: layout.endAngle\n          }\n        }, seriesModel, idx);\n      }\n  } else {\n    graphic.updateProps(sector, {\n      shape: sectorShape\n    }, seriesModel, idx);\n  } // Update common style\n\n\n  var visualColor = data.getItemVisual(idx, 'color');\n  sector.useStyle(zrUtil.defaults({\n    lineJoin: 'bevel',\n    fill: visualColor\n  }, itemModel.getModel('itemStyle').getItemStyle()));\n  sector.hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && sector.attr('cursor', cursorStyle); // Toggle selected\n\n  toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(null, idx), seriesModel.get('selectedOffset'), seriesModel.get('animation'));\n\n  function onEmphasis() {\n    // Sector may has animation of updating data. Force to move to the last frame\n    // Or it may stopped on the wrong shape\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r + seriesModel.get('hoverOffset')\n      }\n    }, 300, 'elasticOut');\n  }\n\n  function onNormal() {\n    sector.stopAnimation(true);\n    sector.animateTo({\n      shape: {\n        r: layout.r\n      }\n    }, 300, 'elasticOut');\n  }\n\n  sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n  if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n\n  this._updateLabel(data, idx);\n\n  graphic.setHoverStyle(this);\n};\n\npiePieceProto._updateLabel = function (data, idx) {\n  var labelLine = this.childAt(1);\n  var labelText = this.childAt(2);\n  var seriesModel = data.hostModel;\n  var itemModel = data.getItemModel(idx);\n  var layout = data.getItemLayout(idx);\n  var labelLayout = layout.label;\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.updateProps(labelLine, {\n    shape: {\n      points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]\n    }\n  }, seriesModel, idx);\n  graphic.updateProps(labelText, {\n    style: {\n      x: labelLayout.x,\n      y: labelLayout.y\n    }\n  }, seriesModel, idx);\n  labelText.attr({\n    rotation: labelLayout.rotation,\n    origin: [labelLayout.x, labelLayout.y],\n    z2: 10\n  });\n  var labelModel = itemModel.getModel('label');\n  var labelHoverModel = itemModel.getModel('emphasis.label');\n  var labelLineModel = itemModel.getModel('labelLine');\n  var labelLineHoverModel = itemModel.getModel('emphasis.labelLine');\n  var visualColor = data.getItemVisual(idx, 'color');\n  graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {\n    labelFetcher: data.hostModel,\n    labelDataIndex: idx,\n    defaultText: data.getName(idx),\n    autoColor: visualColor,\n    useInsideStyle: !!labelLayout.inside\n  }, {\n    textAlign: labelLayout.textAlign,\n    textVerticalAlign: labelLayout.verticalAlign,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n  labelText.hoverIgnore = !labelHoverModel.get('show');\n  labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n  labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color\n\n  labelLine.setStyle({\n    stroke: visualColor,\n    opacity: data.getItemVisual(idx, 'opacity')\n  });\n  labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n  labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n  var smooth = labelLineModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.4;\n  }\n\n  labelLine.setShape({\n    smooth: smooth\n  });\n};\n\nzrUtil.inherits(PiePiece, graphic.Group); // Pie view\n\nvar PieView = ChartView.extend({\n  type: 'pie',\n  init: function () {\n    var sectorGroup = new graphic.Group();\n    this._sectorGroup = sectorGroup;\n  },\n  render: function (seriesModel, ecModel, api, payload) {\n    if (payload && payload.from === this.uid) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var group = this.group;\n    var hasAnimation = ecModel.get('animation');\n    var isFirstRender = !oldData;\n    var animationType = seriesModel.get('animationType');\n    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);\n    var selectedMode = seriesModel.get('selectedMode');\n    data.diff(oldData).add(function (idx) {\n      var piePiece = new PiePiece(data, idx); // Default expansion animation\n\n      if (isFirstRender && animationType !== 'scale') {\n        piePiece.eachChild(function (child) {\n          child.stopAnimation(true);\n        });\n      }\n\n      selectedMode && piePiece.on('click', onSectorClick);\n      data.setItemGraphicEl(idx, piePiece);\n      group.add(piePiece);\n    }).update(function (newIdx, oldIdx) {\n      var piePiece = oldData.getItemGraphicEl(oldIdx);\n      piePiece.updateData(data, newIdx);\n      piePiece.off('click');\n      selectedMode && piePiece.on('click', onSectorClick);\n      group.add(piePiece);\n      data.setItemGraphicEl(newIdx, piePiece);\n    }).remove(function (idx) {\n      var piePiece = oldData.getItemGraphicEl(idx);\n      group.remove(piePiece);\n    }).execute();\n\n    if (hasAnimation && isFirstRender && data.count() > 0 // Default expansion animation\n    && animationType !== 'scale') {\n      var shape = data.getItemLayout(0);\n      var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n      var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n      group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));\n    }\n\n    this._data = data;\n  },\n  dispose: function () {},\n  _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {\n    var clipPath = new graphic.Sector({\n      shape: {\n        cx: cx,\n        cy: cy,\n        r0: 0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: startAngle,\n        clockwise: clockwise\n      }\n    });\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n      }\n    }, seriesModel, cb);\n    return clipPath;\n  },\n\n  /**\n   * @implement\n   */\n  containPoint: function (point, seriesModel) {\n    var data = seriesModel.getData();\n    var itemLayout = data.getItemLayout(0);\n\n    if (itemLayout) {\n      var dx = point[0] - itemLayout.cx;\n      var dy = point[1] - itemLayout.cy;\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      return radius <= itemLayout.r && radius >= itemLayout.r0;\n    }\n  }\n});\nvar _default = PieView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieView.js\n// module id = 1353\n// module chunks = 2 3","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction _default(seriesType, actionInfos) {\n  zrUtil.each(actionInfos, function (actionInfo) {\n    actionInfo.update = 'updateView';\n    /**\n     * @payload\n     * @property {string} seriesName\n     * @property {string} name\n     */\n\n    echarts.registerAction(actionInfo, function (payload, ecModel) {\n      var selected = {};\n      ecModel.eachComponent({\n        mainType: 'series',\n        subType: seriesType,\n        query: payload\n      }, function (seriesModel) {\n        if (seriesModel[actionInfo.method]) {\n          seriesModel[actionInfo.method](payload.name, payload.dataIndex);\n        }\n\n        var data = seriesModel.getData(); // Create selected map\n\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          selected[name] = seriesModel.isSelected(name) || false;\n        });\n      });\n      return {\n        name: payload.name,\n        selected: selected\n      };\n    });\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/action/createDataSelectAction.js\n// module id = 1354\n// module chunks = 2 3","var _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\nfunction _default(seriesType) {\n  return {\n    getTargetSeries: function (ecModel) {\n      // Pie and funnel may use diferrent scope\n      var paletteScope = {};\n      var seiresModelMap = createHashMap();\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        seriesModel.__paletteScope = paletteScope;\n        seiresModelMap.set(seriesModel.uid, seriesModel);\n      });\n      return seiresModelMap;\n    },\n    reset: function (seriesModel, ecModel) {\n      var dataAll = seriesModel.getRawData();\n      var idxMap = {};\n      var data = seriesModel.getData();\n      data.each(function (idx) {\n        var rawIdx = data.getRawIndex(idx);\n        idxMap[rawIdx] = idx;\n      });\n      dataAll.each(function (rawIdx) {\n        var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\n        var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true);\n\n        if (!singleDataColor) {\n          // FIXME Performance\n          var itemModel = dataAll.getItemModel(rawIdx);\n          var color = itemModel.get('itemStyle.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + '', seriesModel.__paletteScope, dataAll.count()); // Legend may use the visual info in data before processed\n\n          dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered\n\n          if (filteredIdx != null) {\n            data.setItemVisual(filteredIdx, 'color', color);\n          }\n        } else {\n          // Set data all color for legend\n          dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n        }\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 1355\n// module chunks = 2 3","var _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar linearMap = _number.linearMap;\n\nvar labelLayout = require(\"./labelLayout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar PI2 = Math.PI * 2;\nvar RADIAN = Math.PI / 180;\n\nfunction _default(seriesType, ecModel, api, payload) {\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var center = seriesModel.get('center');\n    var radius = seriesModel.get('radius');\n\n    if (!zrUtil.isArray(radius)) {\n      radius = [0, radius];\n    }\n\n    if (!zrUtil.isArray(center)) {\n      center = [center, center];\n    }\n\n    var width = api.getWidth();\n    var height = api.getHeight();\n    var size = Math.min(width, height);\n    var cx = parsePercent(center[0], width);\n    var cy = parsePercent(center[1], height);\n    var r0 = parsePercent(radius[0], size / 2);\n    var r = parsePercent(radius[1], size / 2);\n    var startAngle = -seriesModel.get('startAngle') * RADIAN;\n    var minAngle = seriesModel.get('minAngle') * RADIAN;\n    var validDataCount = 0;\n    data.each(valueDim, function (value) {\n      !isNaN(value) && validDataCount++;\n    });\n    var sum = data.getSum(valueDim); // Sum may be 0\n\n    var unitRadian = Math.PI / (sum || validDataCount) * 2;\n    var clockwise = seriesModel.get('clockwise');\n    var roseType = seriesModel.get('roseType');\n    var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max]\n\n    var extent = data.getDataExtent(valueDim);\n    extent[0] = 0; // In the case some sector angle is smaller than minAngle\n\n    var restAngle = PI2;\n    var valueSumLargerThanMinAngle = 0;\n    var currentAngle = startAngle;\n    var dir = clockwise ? 1 : -1;\n    data.each(valueDim, function (value, idx) {\n      var angle;\n\n      if (isNaN(value)) {\n        data.setItemLayout(idx, {\n          angle: NaN,\n          startAngle: NaN,\n          endAngle: NaN,\n          clockwise: clockwise,\n          cx: cx,\n          cy: cy,\n          r0: r0,\n          r: roseType ? NaN : r\n        });\n        return;\n      } // FIXME  2.0  roseType  area \n\n\n      if (roseType !== 'area') {\n        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n      } else {\n        angle = PI2 / validDataCount;\n      }\n\n      if (angle < minAngle) {\n        angle = minAngle;\n        restAngle -= minAngle;\n      } else {\n        valueSumLargerThanMinAngle += value;\n      }\n\n      var endAngle = currentAngle + dir * angle;\n      data.setItemLayout(idx, {\n        angle: angle,\n        startAngle: currentAngle,\n        endAngle: endAngle,\n        clockwise: clockwise,\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: roseType ? linearMap(value, extent, [r0, r]) : r\n      });\n      currentAngle = endAngle;\n    }); // Some sector is constrained by minAngle\n    // Rest sectors needs recalculate angle\n\n    if (restAngle < PI2 && validDataCount) {\n      // Average the angle if rest angle is not enough after all angles is\n      // Constrained by minAngle\n      if (restAngle <= 1e-3) {\n        var angle = PI2 / validDataCount;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            layout.angle = angle;\n            layout.startAngle = startAngle + dir * idx * angle;\n            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n          }\n        });\n      } else {\n        unitRadian = restAngle / valueSumLargerThanMinAngle;\n        currentAngle = startAngle;\n        data.each(valueDim, function (value, idx) {\n          if (!isNaN(value)) {\n            var layout = data.getItemLayout(idx);\n            var angle = layout.angle === minAngle ? minAngle : value * unitRadian;\n            layout.startAngle = currentAngle;\n            layout.endAngle = currentAngle + dir * angle;\n            currentAngle += dir * angle;\n          }\n        });\n      }\n    }\n\n    labelLayout(seriesModel, r, width, height);\n  });\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n// module id = 1356\n// module chunks = 2 3","var textContain = require(\"zrender/lib/contain/text\");\n\n// FIXME emphasis label position is not same with normal label position\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n  list.sort(function (a, b) {\n    return a.y - b.y;\n  }); // \n\n  function shiftDown(start, end, delta, dir) {\n    for (var j = start; j < end; j++) {\n      list[j].y += delta;\n\n      if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {\n        shiftUp(j, delta / 2);\n        return;\n      }\n    }\n\n    shiftUp(end - 1, delta / 2);\n  } // \n\n\n  function shiftUp(end, delta) {\n    for (var j = end; j >= 0; j--) {\n      list[j].y -= delta;\n\n      if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {\n        break;\n      }\n    }\n  }\n\n  function changeX(list, isDownList, cx, cy, r, dir) {\n    var lastDeltaX = dir > 0 ? isDownList // \n    ? Number.MAX_VALUE // \n    : 0 // \n    : isDownList // \n    ? Number.MAX_VALUE // \n    : 0; // \n\n    for (var i = 0, l = list.length; i < l; i++) {\n      // Not change x for center label\n      if (list[i].position === 'center') {\n        continue;\n      }\n\n      var deltaY = Math.abs(list[i].y - cy);\n      var length = list[i].len;\n      var length2 = list[i].len2;\n      var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);\n\n      if (isDownList && deltaX >= lastDeltaX) {\n        // \n        deltaX = lastDeltaX - 10;\n      }\n\n      if (!isDownList && deltaX <= lastDeltaX) {\n        // \n        deltaX = lastDeltaX + 10;\n      }\n\n      list[i].x = cx + deltaX * dir;\n      lastDeltaX = deltaX;\n    }\n  }\n\n  var lastY = 0;\n  var delta;\n  var len = list.length;\n  var upList = [];\n  var downList = [];\n\n  for (var i = 0; i < len; i++) {\n    delta = list[i].y - lastY;\n\n    if (delta < 0) {\n      shiftDown(i, len, -delta, dir);\n    }\n\n    lastY = list[i].y + list[i].height;\n  }\n\n  if (viewHeight - lastY < 0) {\n    shiftUp(len - 1, lastY - viewHeight);\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].y >= cy) {\n      downList.push(list[i]);\n    } else {\n      upList.push(list[i]);\n    }\n  }\n\n  changeX(upList, false, cx, cy, r, dir);\n  changeX(downList, true, cx, cy, r, dir);\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n  var leftList = [];\n  var rightList = [];\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    if (labelLayoutList[i].x < cx) {\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var linePoints = labelLayoutList[i].linePoints;\n\n    if (linePoints) {\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (labelLayoutList[i].x < cx) {\n        linePoints[2][0] = labelLayoutList[i].x + 3;\n      } else {\n        linePoints[2][0] = labelLayoutList[i].x - 3;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n      linePoints[1][0] = linePoints[2][0] + dist;\n    }\n  }\n}\n\nfunction _default(seriesModel, r, viewWidth, viewHeight) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  data.each(function (idx) {\n    var layout = data.getItemLayout(idx);\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get('emphasis.label.position');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    var labelLineLen2 = labelLineModel.get('length2');\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = layout.cx;\n    cy = layout.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = layout.cx;\n      textY = layout.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n      var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n      textX = x1 + dx * 3;\n      textY = y1 + dy * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + dx * (labelLineLen + r - layout.r);\n        var y2 = y1 + dy * (labelLineLen + r - layout.r);\n        var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        textX = x3 + (dx < 0 ? -5 : 5);\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';\n    }\n\n    var font = labelModel.getFont();\n    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);\n    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');\n    hasLabelRotate = !!labelRotate;\n    layout.label = {\n      x: textX,\n      y: textY,\n      position: labelPosition,\n      height: textRect.height,\n      len: labelLineLen,\n      len2: labelLineLen2,\n      linePoints: linePoints,\n      textAlign: textAlign,\n      verticalAlign: 'middle',\n      rotation: labelRotate,\n      inside: isLabelInside\n    }; // Not layout the inside label\n\n    if (!isLabelInside) {\n      labelLayoutList.push(layout.label);\n    }\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n// module id = 1357\n// module chunks = 2 3","function _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    reset: function (seriesModel, ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      var data = seriesModel.getData();\n      data.filterSelf(function (idx) {\n        var name = data.getName(idx); // If in any legend component the status is not selected.\n\n        for (var i = 0; i < legendModels.length; i++) {\n          if (!legendModels[i].isSelected(name)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 1358\n// module chunks = 2 3","import React from 'react'\nimport {injectIntl} from \"react-intl\";\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/line'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport {connect} from \"react-redux\";\n\nexport class LineReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      lineId: 'line' + id\n    }\n  }\n\n  initLine(id) {\n    let {intl, keysData, data, format} = this.props;\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.lineChart.title.text='';\n    config.lineChart.xAxis.data = [];\n    config.lineChart.series[0].data = [];\n    if(data && data.length>0) {\n      data.map((val) => {\n\n        if (format && format[keysData[0]]) {\n          if (format.date) {\n            config.lineChart.xAxis.data.push(intl.formatDate(val[keysData[0]] * 1000));\n          }\n          else {\n            config.lineChart.xAxis.data.push(intl.formatTime(val[keysData[0]] * 1000));\n          }\n        }\n        else\n          config.lineChart.xAxis.data.push(val[keysData[0]]);\n\n\n        config.lineChart.series[0].data.push(val[keysData[1]]);\n      })\n    }\n    if(data && data.length===0){\n      config.lineChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.lineChart);\n\n  }\n\n  componentDidMount() {\n    this.initLine(this.state.lineId);\n  }\n\n  componentDidUpdate() {\n    this.initLine(this.state.lineId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.lineId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {}\n}\n\nconst mapDispatchToProps = {};\n\nexport default connect(mapStateToProps, mapDispatchToProps, null, {pure: false})(injectIntl(LineReact));\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/LineChart.js","var echarts = require(\"../echarts\");\n\nrequire(\"./legend/LegendModel\");\n\nrequire(\"./legend/legendAction\");\n\nrequire(\"./legend/LegendView\");\n\nvar legendFilter = require(\"./legend/legendFilter\");\n\nvar Component = require(\"../model/Component\");\n\n// Do not contain scrollable legend, for sake of file size.\n// Series Filter\necharts.registerProcessor(legendFilter);\nComponent.registerSubTypeDefaulter('legend', function () {\n  // Default 'plain' when no type specified.\n  return 'plain';\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend.js\n// module id = 1360\n// module chunks = 2 4","var echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nfunction legendSelectActionHandler(methodName, payload, ecModel) {\n  var selectedMap = {};\n  var isToggleSelect = methodName === 'toggleSelected';\n  var isSelected; // Update all legend components\n\n  ecModel.eachComponent('legend', function (legendModel) {\n    if (isToggleSelect && isSelected != null) {\n      // Force other legend has same selected status\n      // Or the first is toggled to true and other are toggled to false\n      // In the case one legend has some item unSelected in option. And if other legend\n      // doesn't has the item, they will assume it is selected.\n      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n    } else {\n      legendModel[methodName](payload.name);\n      isSelected = legendModel.isSelected(payload.name);\n    }\n\n    var legendData = legendModel.getData();\n    zrUtil.each(legendData, function (model) {\n      var name = model.get('name'); // Wrap element\n\n      if (name === '\\n' || name === '') {\n        return;\n      }\n\n      var isItemSelected = legendModel.isSelected(name);\n\n      if (selectedMap.hasOwnProperty(name)) {\n        // Unselected if any legend is unselected\n        selectedMap[name] = selectedMap[name] && isItemSelected;\n      } else {\n        selectedMap[name] = isItemSelected;\n      }\n    });\n  }); // Return the event explicitly\n\n  return {\n    name: payload.name,\n    selected: selectedMap\n  };\n}\n/**\n * @event legendToggleSelect\n * @type {Object}\n * @property {string} type 'legendToggleSelect'\n * @property {string} [from]\n * @property {string} name Series name or data item name\n */\n\n\necharts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));\n/**\n * @event legendSelect\n * @type {Object}\n * @property {string} type 'legendSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));\n/**\n * @event legendUnSelect\n * @type {Object}\n * @property {string} type 'legendUnSelect'\n * @property {string} name Series name or data item name\n */\n\necharts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendAction.js\n// module id = 1361\n// module chunks = 2 4","var _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\nvar layoutBox = _layout.box;\nvar positionElement = _layout.positionElement;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\n/**\n * Layout list like component.\n * It will box layout each items in group of component and then position the whole group in the viewport\n * @param {module:zrender/group/Group} group\n * @param {module:echarts/model/Component} componentModel\n * @param {module:echarts/ExtensionAPI}\n */\nfunction layout(group, componentModel, api) {\n  var boxLayoutParams = componentModel.getBoxLayoutParams();\n  var padding = componentModel.get('padding');\n  var viewportSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n  layoutBox(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n  positionElement(group, boxLayoutParams, viewportSize, padding);\n}\n\nfunction makeBackground(rect, componentModel) {\n  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));\n  var style = componentModel.getItemStyle(['color', 'opacity']);\n  style.fill = componentModel.get('backgroundColor');\n  var rect = new graphic.Rect({\n    shape: {\n      x: rect.x - padding[3],\n      y: rect.y - padding[0],\n      width: rect.width + padding[1] + padding[3],\n      height: rect.height + padding[0] + padding[2],\n      r: componentModel.get('borderRadius')\n    },\n    style: style,\n    silent: true,\n    z2: -1\n  }); // FIXME\n  // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n  // and background rect when setting like `left: 0`, `top: 0`.\n  // graphic.subPixelOptimizeRect(rect);\n\n  return rect;\n}\n\nexports.layout = layout;\nexports.makeBackground = makeBackground;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/listComponent.js\n// module id = 1362\n// module chunks = 2 4","function _default(ecModel) {\n  var legendModels = ecModel.findComponents({\n    mainType: 'legend'\n  });\n\n  if (legendModels && legendModels.length) {\n    ecModel.filterSeries(function (series) {\n      // If in any legend component the status is not selected.\n      // Because in legend series is assumed selected when it is not in the legend data.\n      for (var i = 0; i < legendModels.length; i++) {\n        if (!legendModels[i].isSelected(series.name)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendFilter.js\n// module id = 1363\n// module chunks = 2 4","var LegendModel = require(\"./LegendModel\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar mergeLayoutParam = _layout.mergeLayoutParam;\nvar getLayoutParams = _layout.getLayoutParams;\nvar ScrollableLegendModel = LegendModel.extend({\n  type: 'legend.scroll',\n\n  /**\n   * @param {number} scrollDataIndex\n   */\n  setScrollDataIndex: function (scrollDataIndex) {\n    this.option.scrollDataIndex = scrollDataIndex;\n  },\n  defaultOption: {\n    scrollDataIndex: 0,\n    pageButtonItemGap: 5,\n    pageButtonGap: null,\n    pageButtonPosition: 'end',\n    // 'start' or 'end'\n    pageFormatter: '{current}/{total}',\n    // If null/undefined, do not show page.\n    pageIcons: {\n      horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n      vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n    },\n    pageIconColor: '#2f4554',\n    pageIconInactiveColor: '#aaa',\n    pageIconSize: 15,\n    // Can be [10, 3], which represents [width, height]\n    pageTextStyle: {\n      color: '#333'\n    },\n    animationDurationUpdate: 800\n  },\n\n  /**\n   * @override\n   */\n  init: function (option, parentModel, ecModel, extraOpt) {\n    var inputPositionParams = getLayoutParams(option);\n    ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt);\n    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function (option, extraOpt) {\n    ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt);\n    mergeAndNormalizeLayoutParams(this, this.option, option);\n  },\n  getOrient: function () {\n    return this.get('orient') === 'vertical' ? {\n      index: 1,\n      name: 'vertical'\n    } : {\n      index: 0,\n      name: 'horizontal'\n    };\n  }\n}); // Do not `ignoreSize` to enable setting {left: 10, right: 10}.\n\nfunction mergeAndNormalizeLayoutParams(legendModel, target, raw) {\n  var orient = legendModel.getOrient();\n  var ignoreSize = [1, 1];\n  ignoreSize[orient.index] = 0;\n  mergeLayoutParam(target, raw, {\n    type: 'box',\n    ignoreSize: ignoreSize\n  });\n}\n\nvar _default = ScrollableLegendModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/ScrollableLegendModel.js\n// module id = 1364\n// module chunks = 2 4","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar layoutUtil = require(\"../../util/layout\");\n\nvar LegendView = require(\"./LegendView\");\n\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\nvar ScrollableLegendView = LegendView.extend({\n  type: 'legend.scroll',\n  newlineDisabled: true,\n  init: function () {\n    ScrollableLegendView.superCall(this, 'init');\n    /**\n     * @private\n     * @type {number} For `scroll`.\n     */\n\n    this._currentIndex = 0;\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n    /**\n     * @private\n     * @type {module:zrender/container/Group}\n     */\n\n\n    this.group.add(this._controllerGroup = new Group());\n    /**\n     *\n     * @private\n     */\n\n    this._showController;\n  },\n\n  /**\n   * @override\n   */\n  resetInner: function () {\n    ScrollableLegendView.superCall(this, 'resetInner');\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  },\n\n  /**\n   * @override\n   */\n  renderInner: function (itemAlign, legendModel, ecModel, api) {\n    var me = this; // Render content items.\n\n    ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api);\n    var controllerGroup = this._controllerGroup;\n    var pageIconSize = legendModel.get('pageIconSize', true);\n\n    if (!zrUtil.isArray(pageIconSize)) {\n      pageIconSize = [pageIconSize, pageIconSize];\n    }\n\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        textFill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        textVerticalAlign: 'middle',\n        textAlign: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSize[0] / 2,\n        y: -pageIconSize[1] / 2,\n        width: pageIconSize[0],\n        height: pageIconSize[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  },\n\n  /**\n   * @override\n   */\n  layoutInner: function (legendModel, itemAlign, maxSize) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx]; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh];\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n\n    contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0.\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.attr('position', contentPos);\n    containerGroup.attr('position', containerPos);\n    controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = this.group.getBoundingRect();\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as place holders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      position: pageInfo.contentPosition\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird efffect.\n    showController ? legendModel : false);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  },\n  _pageGo: function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  },\n  _updatePageInfoView: function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var canJump = pageInfo[name + 'DataIndex'] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({\n      current: current,\n      total: total\n    }));\n  },\n\n  /**\n   * @param {module:echarts/model/Model} legendModel\n   * @return {Object} {\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no next page.\n   *  pageNextDataIndex: number, null when no previous page.\n   * }\n   */\n  _getPageInfo: function (legendModel) {\n    // Align left or top by the current dataIndex.\n    var currDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var contentRect = contentGroup.getBoundingRect();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var xy = XY[orientIdx];\n    var contentPos = contentGroup.position.slice();\n    var pageIndex;\n    var pagePrevDataIndex;\n    var pageNextDataIndex;\n    var targetItemGroup;\n\n    if (this._showController) {\n      contentGroup.eachChild(function (child) {\n        if (child.__legendDataIndex === currDataIndex) {\n          targetItemGroup = child;\n        }\n      });\n    } else {\n      targetItemGroup = contentGroup.childAt(0);\n    }\n\n    var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0;\n\n    if (targetItemGroup) {\n      var itemRect = targetItemGroup.getBoundingRect();\n      var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy];\n      contentPos[orientIdx] = -itemLoc - contentRect[xy];\n      pageIndex = Math.floor(pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh]);\n      pageIndex = contentRect[wh] && pageCount ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1;\n      var winRect = {\n        x: 0,\n        y: 0\n      };\n      winRect[wh] = containerRectSize;\n      winRect[hw] = contentRect[hw];\n      winRect[xy] = -contentPos[orientIdx] - contentRect[xy];\n      var startIdx;\n      var children = contentGroup.children();\n      contentGroup.eachChild(function (child, index) {\n        var itemRect = getItemRect(child);\n\n        if (itemRect.intersect(winRect)) {\n          startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the\n          // current window is shown at the begining of next window.\n\n          pageNextDataIndex = child.__legendDataIndex;\n        } // If the last item is shown entirely, no next page.\n\n\n        if (index === children.length - 1 && itemRect[xy] + itemRect[wh] <= winRect[xy] + winRect[wh]) {\n          pageNextDataIndex = null;\n        }\n      }); // Always align based on the left/top most item, so the left/top most\n      // item in the previous window is needed to be found here.\n\n      if (startIdx != null) {\n        var startItem = children[startIdx];\n        var startRect = getItemRect(startItem);\n        winRect[xy] = startRect[xy] + startRect[wh] - winRect[wh]; // If the first item is shown entirely, no previous page.\n\n        if (startIdx <= 0 && startRect[xy] >= winRect[xy]) {\n          pagePrevDataIndex = null;\n        } else {\n          while (startIdx > 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) {\n            startIdx--;\n          }\n\n          pagePrevDataIndex = children[startIdx].__legendDataIndex;\n        }\n      }\n    }\n\n    return {\n      contentPosition: contentPos,\n      pageIndex: pageIndex,\n      pageCount: pageCount,\n      pagePrevDataIndex: pagePrevDataIndex,\n      pageNextDataIndex: pageNextDataIndex\n    };\n\n    function getItemRect(el) {\n      var itemRect = el.getBoundingRect().clone();\n      itemRect[xy] += el.position[orientIdx];\n      return itemRect;\n    }\n  }\n});\nvar _default = ScrollableLegendView;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/ScrollableLegendView.js\n// module id = 1365\n// module chunks = 2 4","var echarts = require(\"../../echarts\");\n\n/**\n * @event legendScroll\n * @type {Object}\n * @property {string} type 'legendScroll'\n * @property {string} scrollDataIndex\n */\necharts.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {\n  var scrollDataIndex = payload.scrollDataIndex;\n  scrollDataIndex != null && ecModel.eachComponent({\n    mainType: 'legend',\n    subType: 'scroll',\n    query: payload\n  }, function (legendModel) {\n    legendModel.setScrollDataIndex(scrollDataIndex);\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/scrollableLegendAction.js\n// module id = 1366\n// module chunks = 2 4","import React, {Component} from \"react\";\nimport {tu} from \"../../utils/i18n\";\nimport {Client} from \"../../services/api\";\nimport {ExternalLink} from \"../common/Links\";\nimport {FormattedNumber} from \"react-intl\";\nimport {TRXPrice} from \"../common/Price\";\n\nexport default class MarketOverview extends Component {\n  constructor() {\n    super();\n\n    this.state = {\n      markets: [],\n    }\n  }\n\n  componentDidMount() {\n    // this.load();\n  }\n\n  async load() {\n    let markets = await Client.getMarkets();\n\n    this.setState({\n      markets,\n    });\n  }\n\n  render() {\n\n    let {markets} = this.props;\n\n    function compare(property) {\n      return function (obj1, obj2) {\n\n        if (obj1[property] > obj2[property]) {\n          return 1;\n        } else if (obj1[property] < obj2[property]) {\n          return -1;\n        } else {\n          return 0;\n        }\n\n      }\n    }\n    markets = markets.sort(compare(\"rank\")).slice(0, 99);\n\n    return (\n        <div className=\"card\">\n          <table className=\"table table-hover bg-white m-0 table-striped\">\n            <thead className=\"thead-dark\">\n              <tr>\n                <th style={{width: 25}}>{tu(\"rank\")}</th>\n                <th>{tu(\"exchange\")}</th>\n                <th className=\"d-none d-sm-table-cell\" style={{width: 75}}>{tu(\"pair\")}</th>\n                <th className=\"d-none d-md-table-cell\" style={{width: 100}}>{tu(\"volume\")}</th>\n                <th className=\"d-none d-md-table-cell\" style={{width: 75}}>%</th>\n                <th className=\"text-right\" style={{width: 100}}>{tu(\"price\")}</th>\n              </tr>\n            </thead>\n            <tbody>\n            {\n              markets.map(market => (\n                <tr key={market.rank}>\n                  <th>\n                    {market.rank}\n                  </th>\n                  <td>\n                    <ExternalLink url={market.link}>{market.name}</ExternalLink>\n                  </td>\n                  <td className=\"d-none d-sm-table-cell\" style={{width: 75}}>\n                    <ExternalLink url={market.link}>{market.pair}</ExternalLink>\n                  </td>\n                  <td className=\"text-nowrap d-none d-md-table-cell\">\n                    <TRXPrice amount={market.volumeNative} />\n                  </td>\n                  <td className=\"text-nowrap d-none d-md-table-cell\">\n                    <FormattedNumber value={market.volumePercentage} maximumFractionDigits={2} />%\n                  </td>\n                  <td className=\"text-right\">\n                    $<FormattedNumber value={market.price} maximumFractionDigits={8} />\n                  </td>\n                </tr>\n              ))\n            }\n            </tbody>\n          </table>\n        </div>\n    )\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/markets/MarketOverview.js","import React from 'react'\nimport config from './chart.config.js'\n\nimport echarts from 'echarts/lib/echarts'\nimport 'echarts/lib/chart/pie'\nimport 'echarts/lib/component/title'\nimport 'echarts/lib/component/tooltip'\nimport 'echarts/lib/component/legend'\nimport 'echarts/lib/component/legend/ScrollableLegendModel.js'\nimport 'echarts/lib/component/legend/ScrollableLegendView.js'\nimport 'echarts/lib/component/legend/scrollableLegendAction.js'\n\nexport class RingPieReact extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let id = ('_' + Math.random()).replace('.', '_');\n    this.state = {\n      pieId: 'pie' + id\n    }\n  }\n\n  initPie(id) {\n    let {data} = this.props;\n\n    let myChart = echarts.getInstanceByDom(document.getElementById(id));\n    if (myChart === undefined) {\n      myChart = echarts.init(document.getElementById(id));\n    }\n    config.ringPieChart.series[0].data = [];\n    config.ringPieChart.series[1].data = [];\n    config.ringPieChart.legend.data = [];\n    config.ringPieChart.title.text=\"\";\n\n    function compare(property) {\n      return function (obj1, obj2) {\n\n        if (obj1[property] > obj2[property]) {\n          return 1;\n        } else if (obj1[property] < obj2[property]) {\n          return -1;\n        } else {\n          return 0;\n        }\n\n      }\n    }\n\n    if (data && data.length > 0) {\n      let sortObj = data.sort(compare(\"name\"));\n      let pairData = [];\n      let exchanges = []\n      let temp = [];\n      for (let index in sortObj) {\n        pairData.push({name: sortObj[index].pair, value: sortObj[index].volume});\n        if (temp.indexOf(sortObj[index].name) < 0) {\n          temp.push(sortObj[index].name)\n          exchanges.push({name: sortObj[index].name, value: 0, subCount: []});\n        }\n      }\n\n      for (let index in exchanges) {\n        for (let idx in sortObj) {\n          if (sortObj[idx].name === exchanges[index].name) {\n            exchanges[index].value = exchanges[index].value + sortObj[idx].volume;\n            exchanges[index].subCount.push({name: sortObj[idx].pair, value: sortObj[idx].volume});\n          }\n        }\n      }\n\n      exchanges.sort(compare(\"value\"));\n      let finalExchanges = exchanges.slice(exchanges.length - 10, exchanges.length);\n      let finalPairData = []\n      for (let index in finalExchanges) {\n        finalPairData.push(...finalExchanges[index].subCount);\n      }\n\n      config.ringPieChart.series[0].data = [];\n      config.ringPieChart.series[1].data = [];\n\n      config.ringPieChart.legend.data = temp;\n\n      config.ringPieChart.series[0].data = finalExchanges;\n      config.ringPieChart.series[1].data = finalPairData;\n\n    }\n    if(data && data.length===0){\n      config.ringPieChart.title.text=\"No data\";\n    }\n    myChart.setOption(config.ringPieChart);\n  }\n\n\n  componentDidMount() {\n    this.initPie(this.state.pieId);\n  }\n\n  componentDidUpdate() {\n    this.initPie(this.state.pieId);\n  }\n\n  render() {\n    return (\n        <div>\n          <div id={this.state.pieId} style={this.props.style}></div>\n        </div>\n    )\n  }\n}\n\nexport default RingPieReact\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/common/RingPieChart.js"],"sourceRoot":""}
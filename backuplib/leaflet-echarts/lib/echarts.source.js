(function(_global) {
    var require, define;
    (function() {
        var mods = {};

        define = function(id, deps, factory) {
            mods[id] = {
                id: id,
                deps: deps,
                factory: factory,
                defined: 0,
                exports: {},
                require: createRequire(id)
            };
        };

        require = createRequire('');

        function normalize(id, baseId) {
            if (!baseId) {
                return id;
            }

            if (id.indexOf('.') === 0) {
                var basePath = baseId.split('/');
                var namePath = id.split('/');
                var baseLen = basePath.length - 1;
                var nameLen = namePath.length;
                var cutBaseTerms = 0;
                var cutNameTerms = 0;

                pathLoop: for (var i = 0; i < nameLen; i++) {
                    switch (namePath[i]) {
                        case '..':
                            if (cutBaseTerms < baseLen) {
                                cutBaseTerms++;
                                cutNameTerms++;
                            } else {
                                break pathLoop;
                            }
                            break;
                        case '.':
                            cutNameTerms++;
                            break;
                        default:
                            break pathLoop;
                    }
                }

                basePath.length = baseLen - cutBaseTerms;
                namePath = namePath.slice(cutNameTerms);

                return basePath.concat(namePath).join('/');
            }

            return id;
        }

        function createRequire(baseId) {
            var cacheMods = {};

            function localRequire(id, callback) {
                if (typeof id === 'string') {
                    var exports = cacheMods[id];
                    if (!exports) {
                        exports = getModExports(normalize(id, baseId));
                        cacheMods[id] = exports;
                    }

                    return exports;
                } else if (id instanceof Array) {
                    callback = callback || function() {};
                    callback.apply(this, getModsExports(id, callback, baseId));
                }
            };

            return localRequire;
        }

        function getModsExports(ids, factory, baseId) {
            var es = [];
            var mod = mods[baseId];

            for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {
                var id = normalize(ids[i], baseId);
                var arg;
                switch (id) {
                    case 'require':
                        arg = (mod && mod.require) || require;
                        break;
                    case 'exports':
                        arg = mod.exports;
                        break;
                    case 'module':
                        arg = mod;
                        break;
                    default:
                        arg = getModExports(id);
                }
                es.push(arg);
            }

            return es;
        }

        function getModExports(id) {
            var mod = mods[id];
            if (!mod) {
                throw new Error('No ' + id);
            }

            if (!mod.defined) {
                var factory = mod.factory;
                var factoryReturn = factory.apply(
                    this,
                    getModsExports(mod.deps || [], factory, id)
                );
                if (typeof factoryReturn !== 'undefined') {
                    mod.exports = factoryReturn;
                }
                mod.defined = 1;
            }

            return mod.exports;
        }
    }());
    define('echarts/util/mapData/geoJson/ao_men_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "8200",
                "properties": {
                    "name": "澳门",
                    "cp": [113.5715, 22.1583],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@HQFMDIDGBI@E@EEKEGCEIGGEKEMGSEU@CBEDAJAP@F@LBT@JCHMPOdADCFADAB@LFLDFFP@DAB@@AF@D@B@@FBD@FADHBBHAD@FAJ@JEDCJI`gFIJW"],
                    "encodeOffsets": [
                        [116325, 22699]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/an_hui_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "3415",
                "properties": {
                    "name": "六安市",
                    "cp": [116.3123, 31.8329],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nJUXUV°UÑnU@mlLVaVln@@bn@VU@xlb@lLnKlVIJUVxnI@lVL@b°VX@bxnVVUnVVnU@kX@VwV@al¥UUnUWa@@wĸULU¥lKUa@aUI@alLVaU¯anWkUKm@XV@VaXlW@aU_UWVUI¯@ma¯W¯I@UU@WWU@U@@UU@VkV@@WUUm@UaU@lK@IUKL@KWmXUWaXI@@a@a@U@U@KV¥lwk°b²JVIVKlV@UXlaUl`UVLVVVUJU@Lnm@_VK@KUIW@J@Xk@WW@UmmXmWk@kK@aUUVmmkUwUmWL@WmU@UJmUULkKWakLWVkIlwULW@X°lUJ@°ULWVwmJ@bmb¯Vkm@@WkWm¯wL@lkXWmXym¯UImJUbkV@Vn¯@V@lUb@mk@maUxmlUbULWn@JLmKUkWKkwUKbmXWxkVUKmLkVV@JUUWL@xkJUUV@X@VVlUbVX@xk¤x¼xWxnnn@Þ¼JVb°aVn@mlnXUJlbVlkz@lUlXJmxVxXnWxXÈWlU@UxU@VX@xUL@UÆmLnV@lWXk@@JlbXblnlJ"],
                    "encodeOffsets": [
                        [118710, 33351]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3408",
                "properties": {
                    "name": "安庆市",
                    "cp": [116.7517, 30.5255],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n°znWXlW@kK°xXnl@Xn@l°Una@anIxXUVK@¯VIkW¯X@VKxklJXUlKXblLVKnVVIV@Xn@XKVnVxlnnUlmV@²óUkVlWbln@VVVIn@lw@WVIXblV@ÈxaUaVIVVnKVLKln@b²K@»U£ÑķġÝÅbKa@Im@Û@kWÓkkmKÅnóJUÅ£W@wĕ@wĉţ¯¯UkK±l¯U¥UÑkÝUķ»Ý¥¯JIUVbUl¯ÈV¼VJU¼Vb@bkLUl@VJ@bUXÇ@lkVmXmKkLVxVL@VkVVVlzWkbmLUUUbVbUVlÒnJlUnLllUL@bUVxlLXVÆ¦ÈVU¦WJ"],
                    "encodeOffsets": [
                        [118834, 31759]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3411",
                "properties": {
                    "name": "滁州市",
                    "cp": [118.1909, 32.536],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@`nnl@xK@X°KXVIXVlbXVWnXlL@È»LVan@VJêVVn@X@laÞbVayn@_xnWVXnWl@VnUVkI@lnXKVLVV@V@kW@LlVô@J@bVnnKnkVa@»lç@nwKmaUUUVÑ@nmWXalI@alVn@VwUaVU@nlaôJnUVVXlJaXXVK@UV@VWx@nXVWXVUlLUbVULVVnUVbUbVb@@aKÆnnKVK@U@UU@@a@V°¯ÈJVIlķ@aaUaVKU_@mkxUI@aUlyU@@wkKWmUbUnUVWbkJW_J@bn@Vm@@KULk@V@@bVbÅm@LW@UVVbkK@UkKWL@VULUKWIUJUbkK@_WVXUJka@XVa@ky@aVIUUW@@mUlLKWÑUKVan@UkVmmIXKaVaUwVU@UmykU¯@±UUL@WUIVUU@KkIWaaU@kUUaÇUó»mKk¯@y@kWK@bkI¯`mnl¯XWlkVUzUJlbUbVJl@nnm@VULV`XnWÆbmUUnJmUknJ¯km@yk@kUxL@VUbmnn¤lX@`z@JmaULUVl@Xn@xllkXWaaW@UVmUb@mVXWxXbWbUÒnVVnVVUL"],
                    "encodeOffsets": [
                        [120004, 33520]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3418",
                "properties": {
                    "name": "宣城市",
                    "cp": [118.8062, 30.6244],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Vb@XLJXxlIXxlVlV@I²¤nlUnVU@VULWVUJ@Lnb@lV@UnV@@VVVlLnbnJUVkUUVWn@@anUVnVJVIV@@nUJVbUb@VUbVK@bn@VbnIlxkllXVlXKWUXUlL°¤UVVb@bUlkXWxXz@IlaUlnUlJVInVÆJULVUnVK°@VnlVnxV@XLlK@wVL@KnUlJXUbnKVLXlUw@VWlLXKm@@a@VLnmlIVVnKn@kVaVlwk@@a@k@VIUa@maUa@wna@kmWUUmVUIVÇ@aKmakUJ@InmUUaVaklX@Vk@m@VU@wnK@alKVUkUkKbmUkm@U£WVk@@UÝbbaÇx@b@WVUa¯@wVwUUV@VwnK@KWaÅ@KIUyUI@WmXóUbWaKm@km@IUyIUaWKx@zUKUL@llVUnkLVVkJWX@VUKUVIkVWakb@VWb@n@JkXUlmL@xkL@`VxLUÈUJ@Vm@@bmIUlUL@VUVVbknm@mKUwKVÈ@J@LV±kkJUIl"],
                    "encodeOffsets": [
                        [120803, 31247]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3412",
                "properties": {
                    "name": "阜阳市",
                    "cp": [115.7629, 32.9919],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Vn@ak°a±@¥@UUI@aUmlwUUxb@¥XU@mmI@a@Kn@@_W@@WI@mUVVXUl@XaV@K@I@aLX@aVI°K@KVLUUwyXkK@kKÆbXnlK@k@aJlU@w@U@»@aXKWn_JXkVKn@°LlKXW@¯U@aUK@kmJUwVIUJkmLK@kka@wUVm@@am@UkUbkK@nmVÒ¯VUWVVmIULk@ma@kkK@nUbUamU`UUVUkKVkkW@@bkmnmUXVKXVL@VbUmbVXJ@nmKÅI@KWKUXVJUL@VUKUX@KUKWL@LUJmaXXm@kVVV@L@VUL@VlK@L@V@LUK@VUb@UUU@°@nVxU`Lkn@`@XVJ@XVmk@UKmV¯LVVn±Wm@Ub@JlLUl@VLk@lmVVn@bnV@V°IVaVJXI°K°V@XXVlVVUnKVlUbWXnV@bV`U@@m@@@nxmn@bXVlL@¤nbUl¦VVUnJVUVl@@bÞL"],
                    "encodeOffsets": [
                        [118418, 34392]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3413",
                "properties": {
                    "name": "宿州市",
                    "cp": [117.5208, 33.6841],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@UWU@bkW@aWU@aUIkWVlLXblVIUVV@mn@V_n@VaUK@I@UaanJVU@lVUVnnKVVlaUaI@wnKLnll@nVlk@wVKXkl@@bbUJ@VU@UUUyVk@aVUXwlWXXWU¹@aU@WUI@mlUnJ@Il@aXbV@VKl@XxVL@WIJlb@al@IUUm@@aVK@¥¯@mUķ¯bWk£Vm@akm@VaÅ@UVWa@UJWkJUbWbU@UlXk@amV@K¯nk@lU@Uxmz@bU`ÇbUbÅVm£U@Wwx@akLUK@UlakwUJWVkLmaUal@n_mVUnKVUUmÅXWa@kJmx@XUJ@bVLXxl@VVUVVUbkLWbU@@lUVVVVXK@XkJ@nU@@bV@VxUVlbU@xXLWn@UxVbVĊV@b@XV`mnkJ@kUKmbaU@VbnbÆx@XU@@`k@@bl@@bkL@WakXWaU@Vmkx@XWW@@wUUUbJU¯V@¯ÞU@WxXlL@bkb@lVlnbJW@kkU@mbkaWJIVlmz¯`UnU@mb@@`@bkVlnV@b@V@aVxn@VxKXnl@nbVKbVK@a_V@Vw@WLlwnK@UmIU@VW@UÈ@lKnalw@@V°@aUmlUUw@V@@UXK"],
                    "encodeOffsets": [
                        [119836, 35061]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3410",
                "properties": {
                    "name": "黄山市",
                    "cp": [118.0481, 29.9542],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lXnlWX@VUJVnUJVzXJVxkVJlI²lU@K@IUÇLVxnLn@lmUaVU@UVKVknJ@an@@UVIVÇKUw@_lK@wnKVklW@I@mXa@UlaXblUJVUVL@UXWlIUUlKVmkU@kVKVL@ywXLVbJVz@Jln@nLXbVaônW@la@UVWUa@@a@mk@WIk@VwUa¯¥m@UUVK@ImK@aX£kKÅVa_@±akXWWLnU@@a@¯mK@LJUWwUVVmbXX@lWLn`mzUJUbLk@makVWmkXambkKkna@ab@U@Unm@WV@VbUbUJWIk@@lmL@°UVUVmn@@kmWkb@x_m@@aU@b@JlUzlWxXn@b²@l`IVlUlL@VKnVbUl@VlIn@@bbVWUk@@bX@Valb@bnb°Vn@xVKlbVnV@VxL@ln@UXVVL"],
                    "encodeOffsets": [
                        [120747, 31095]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3414",
                "properties": {
                    "name": "巢湖市",
                    "cp": [117.7734, 31.4978],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VV@blL@XlWnnn@VXXl@@WIX@VJ@LxŎxln@bXJVblX@VVbUVn@VbUVlb@LnJVbVLVXLÒVLÒVbVIVylUXk°Wknm°_lJ@aXL@lz°@lnLô¼VÈVUUaVKU@WW@@UUa@knmVLlaV@a@kak±@UmwkKmkǉÝUUkL@mlIVmnÝWkkUÝ@KƑĉa@»mma@mX¤¯Uw@@UU@bU±±L@akmLUKmLUUUJVbbÇw@kUWaUJ@Xkxm@UJUUm@kakXUVl±ôU@kn"],
                    "encodeOffsets": [
                        [119847, 32007]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3416",
                "properties": {
                    "name": "亳州市",
                    "cp": [116.1914, 33.4698],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lU@Un@@anUlw@KVmUwlaX_lKna@KU@@kWKUU@ankWXK@@V²VVIÈU@al@VaÈamK@wU@klaUV@XVUU»WUUbkmUkVmk@aÈw@mWU@VkIkVWKUÑķXȭºU¯l@kkLWmÅaL@lLWlzVxVUK@L¯LUJ@bWK@b@JLU@Wbk@WVUUV@nJ@XX@@`m@@L@bnJ@nWV@¦awVVkxVn@bVJ@V¦@²¯blb@mUU@¼¦XbUV`@nnxUxWLkUkVWKkV@XV@@VVL@VX@lVV@L@blL@`L@xXKVL@VnU@lwnU@ml@XnV@@UVW°LnalUI@aUK@aa@UkXW@I@mWL@UXK@UVW@U@@kWn@@V@XblaVxL@bVKXbIlJ"],
                    "encodeOffsets": [
                        [119183, 34594]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3417",
                "properties": {
                    "name": "池州市",
                    "cp": [117.3889, 30.2014],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@V°°ĊŤ@xĖ@xXÆ¤VôIÆmnLllXÔ@lÜn@@JbLÆaĢÞĸ°VVUUKVanK@UV@VLVVnln@xnklxXamk@WV@Xa@naVkKlk@mkUWwkJWwIWK@UaUwWIUyVIUmVI@UXWmkkWKUUVWm@@kKw@UUUmkaULwm@¯Uma@akaUbW@@a@VlUXa@am@kJ@UVkUamL@UkKVUkJk_±@a@WmXwÇkkaVaUa±wV@VkwnyUaW@UU¯amLk@m@kmmU¯K@L@lUX¯WlkXVbbVUL@J@LVKnlJXnlb@`nXlalV@bnL@Vnb¼@lXbWlkLK@zUJmIUxUVUVmX", "@@llUL@VlxL@a@UwXa¯@"],
                    "encodeOffsets": [
                        [119543, 30781],
                        [120061, 31152]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3401",
                "properties": {
                    "name": "合肥市",
                    "cp": [117.29, 32.0581],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@LxVĊLÞkVlVVXaWaXwWnU@anVVUX@bXblWkk@wWmk@VUVKnb@Iy@_kWm£nmVa@UKwlVl@zn@°lIlmnVIVmnVaXÅWmU_VK@Unmmk@UIVakaaUÑUKÑWKUUKUamI@KkaVUUam@VUUa@UkWUaWI@akmōwwUL@`mn@KVIUVUUUKVk_VkbW@VkUULUJ±I¯alkxU¦@L@V@V@b@b@WJXbWVXn@LKVL@JkLV@Vbn@VV@XU@UlV@@VV@V@XXV@@VJ°°Xnb°@JUVVXV`@bkXWUbU@Wn@VLXlm°bVUbkK@bVJ@bVbkLV¦KķV@x@XbmVVVk¦"],
                    "encodeOffsets": [
                        [119678, 33323]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3403",
                "properties": {
                    "name": "蚌埠市",
                    "cp": [117.4109, 33.1073],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VÒXLlUlJ@UXV@nÇx@bnlUVllnVaXVV¼UVWU@V²wVV@Vl@VnwlI@XbÆWVnUVmLUVnm`k@VbnblKXUVIlxkb@VVLlK@bwXxV@n¤ÆUVaÈaV_@anyVwV@kl@°m@LnUbl@WVkV@XaaVIXlIV@XbVUÆ@XKWwUkmW@_UmnIlJXkWKXmV@w@_XV@Kl@kU@KlX@@UUUUKWLm@klJVUUmk@mXUWmXw`m@zUbÝakbW@m@UUéUIm@UbKÇ¼@kKWXmWUkaWUJWU¯L@WLwk@mm@_ÅlUVkmWUnV@VWLUbbƑĬ¯l"],
                    "encodeOffsets": [
                        [119543, 33722]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3402",
                "properties": {
                    "name": "芜湖市",
                    "cp": [118.3557, 31.0858],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@bVaV@XllLXU°lL@V@VUnVl¯IkVUVU@@b@lUXUWmbn@¼bƒĊLÞ@lVXlmÞUnkJ@nlKVVÞXklWVaVI@aUKn»lL@Kn@XXwlm@mn°@V@WywXlWVk@aUaVU¯£kKWVXVWLUkkWlkkwmJUam@@aULVa@UVaUaVI@m@UUJUIUmmV@bm@UXVVUlVmImakKUU@UU@VmU@@kma@KVIXUVK@UVmUkVm±£@JkU@nlkLUlmb@WbU@@XnlWb"],
                    "encodeOffsets": [
                        [120814, 31585]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3406",
                "properties": {
                    "name": "淮北市",
                    "cp": [116.6968, 33.6896],
                    "childNum": 3
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@lnnK@¦n@@VV@@VV@nIVV@VW²a@b@bVnUVVV@Vz@l@°UVIVaVV@x@XX@WlwUnV@XblWb@XlK@a@k@al@@_V@@WÅwmaUaV@bnaVL@llInmU_@W@aUUĉUaVwm@XWK@wVkaVUUwU@@aV@@mlI@WLWUUUVU@kV@XalKVaUVUUUk@WwUK@aVI@WUk@@UUU±xkb@lV@xnLÇbUbk@@bÇVUJ±U@U@WLXml@bVVXL@lV@@LmbkLW`kbVxUn@LkxmV@bm@@VkV"],
                        ["@@VVVkV@¥@UV@U@VUUJkWakKUlXVJ@bXV@blX@aXV@V"]
                    ],
                    "encodeOffsets": [
                        [
                            [119183, 34594]
                        ],
                        [
                            [119836, 35061]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3404",
                "properties": {
                    "name": "淮南市",
                    "cp": [116.7847, 32.7722],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°kƒīaVaXK@UUVmnXUlVÆkVKUUUmmUÑkUUÝlĉKUwKbU@UxW@@lmVUUVmUUmwaWkL¯K@mULWlIm`XWL@b@¼@V@xkVI@b@l@lkV°Ȯ¹ĸW"],
                    "encodeOffsets": [
                        [119543, 33722]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3405",
                "properties": {
                    "name": "马鞍山市",
                    "cp": [118.6304, 31.5363],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ǊnllLnxV@laXLVKmaaXbVIbVKVVVIVyn@n_W@@UnJlUVVXlLnaUWlV@VVIXW@_W@XK@K@UVUUwVamÑXmmwwKUnUKçU@JU¯@m@nknWxWm@@LkKm¼VL@bUJUbkXWl"],
                    "encodeOffsets": [
                        [121219, 32288]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3407",
                "properties": {
                    "name": "铜陵市",
                    "cp": [117.9382, 30.9375],
                    "childNum": 3
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ÒV¤@¼V²@aVV@@x°V£nW@nbnaVXVW@k@aV@VUUl°JUkVm@U@UkK¯WVkKWkU@Ubakwmlwm@kUmUUKU@@VmLUbVLUV¯U"],
                        ["@@LllUL@VlxL@a@UwXamK"]
                    ],
                    "encodeOffsets": [
                        [
                            [120522, 31529]
                        ],
                        [
                            [120094, 31146]
                        ]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/bei_jing_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "110228",
                "properties": {
                    "name": "密云县",
                    "cp": [117.0923, 40.5121],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@vIHZDZQtDLNMXIbHRCXXITbJ@H`LGPRDDJNCLHTOCWFGvGBUJMKGFO^IHWXITQCIY^AXGfRDXF`DJOLB~G\\DZIHHpErUVMhHb]\\MBVF@FTP`@zTbD\\@~M\\K`H^EVODWICAakAQXoIcCOCIgGYNWFWNGGKKGaJEGMEIKYJUT_J_Go@_SyQaSFMEGTcYOQLIIi@EKAUPCV[EEXQCW|aMUMAaYCYNIDGGACIMGGSKDQGaF_C[GaB@GOIiOKAYLmI@CN]F[SWWAcKKI@HMUimEKbeYQYISNUOcBKPIFBNgvDPGZYFSf]CMSIWGEUFgDIQ[MeDMJS@RR@LphFPCHaBAJKF@J]IBJO@HlO@@RKAMPJHCNDJTHFP@ZGNANBRFH@J_fM^ONJNF\\VTDJHDON@XRND\\XRCPVETCLBVKDFJINHRGPRV@\\CLJN@VbXbLVT"],
                    "encodeOffsets": [
                        [119561, 41684]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110116",
                "properties": {
                    "name": "怀柔区",
                    "cp": [116.6377, 40.6219],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@JHTVHXCHPfnDJGHNDJSB[JSBGVSAOH@PMPuDEHHXZN@PHF@ZLJ@LHVYJA\\OFWP]BMtMBSRGV[JeVAPQVIFENMD¡@^NV\\JH@NNL@NM\\kTQ\\I^FNIpBHGTBFFAZQfKDIXQTLXFXNNVMVHRGpCFLlRLEVBBH`IVO\\G`RDPAXLXBXORHZEHTDLLN@VGTMrQNFPeASKG@GMOAKBYMK@GTUHUXSHMVDNMOUEOZMJML@^KRACMZEZMRQLUHE@OFENPR@DI\\ChMHIDG\\GJMDWHCKGMDCIQCHO_K@GaIJSWWQDaGWJMNCKRsCYGYuJUSaKaW@UIMDK@[QUHOGQJMEILCAUDKFSOUQD[WMCQ@WPMGCCIUSE[IMPMN]`e@IEGAQBMHM@YEOSGCIDMIGNOLB@QP@GkP@AI^J@ILEBIbADGEOog@KQQWSekWQQUOFKZLF@PUNmIaHIUeBCTSHENcJa@_IWSaGu`GLSBKJQFOXGDXVQVOBIHcDSJWBEFGTMH[^mLaXcHiKElTRKtFXZ`MHMPCNRDxZB\\ICIHK@KHbIVFZ@BPnGTGbDXRDJaZKRiGEFSFEJhjFNZFjn"],
                    "encodeOffsets": [
                        [119314, 41552]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110111",
                "properties": {
                    "name": "房山区",
                    "cp": [115.8453, 39.7163],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@h@bl@HRJDZ``TA\\VVD^H`\\pF\\J`JGv@ZO\\GPSTEjPTR`FnEbDTDHEhLFMTK@ETSPULKEI@OVISKSJACEQNQbVIXGDIN@dMB[IIBcN]ZHNLP@XOWCFWCNRHTpATD@^NVNLED@Rh@jCEF}E[OOHUEW]W@QGGDIQSH_MmFmCUT_K]i@MHCMWFCFE{BMHMPOHKS]CFNGBELDH_@BcAKOACESAOBELaXAROB@FODMEDWJAG[aE@UM@DImEWJMC@OeCA{aE[@{L@MINUCQXKfUJORCHqJBF@TCXWNQX]M[EAJO@@KMBQJIC]EWMCCUBEBFHKDOTMBGNGF]MWDBRDdMDQVyE@LPVHDCP@JVVMTG~HNSH[CmRUvHPHBbA\\PTNRC\\YNJPRARPJDDR"],
                    "encodeOffsets": [
                        [118343, 40770]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110229",
                "properties": {
                    "name": "延庆县",
                    "cp": [116.1543, 40.5286],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@^AXOPEB[ZIGU@KKI@YGE@OYMGWFGvCNO@OPGTBHUTA\\ITACIGMIHmCOeDGGWSUIGimYEEMgiFITEFEjHLQbYCIWQaCSHmHAOY@UEaJG@LGLDJ[JAwYQCDMNONGY_EWLsSQFkMO[NWAIGaIYL@HMBOKiOQDWEUDMQSF_QIUBWdg@[NaAKQ@M]OQ@WhgLUMMFYQDIRCEUZOOCIOJ[KIUMKL@HIDKVEBM`HJAJSJUdBLGNEdMBMO[BYEWJSNKNaD]PE\\SjOT_RQVEZPpNQXfNA~lNG`@PNLp¼RFLfbdKbATUh@FSNWjGFZVLFHVA~X¨PPROfFJbNJPLFbENJPrEFNPFRHDDJdENJLVEPBJTVTHGHFRFH@PXP\\ORQHW\\BjWFDERLPPBbB\\E`B\\D\\L`@F]FCnJ^AZL"],
                    "encodeOffsets": [
                        [119262, 41751]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110109",
                "properties": {
                    "name": "门头沟区",
                    "cp": [115.8, 39.9957],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@V@XMnGPY²JQNEhH\\AZMPDVTTDZCPiJkHSHCjIdFtEHITCNITQEKUAMCEIKCECABYESKFWAKBEIIHABGDCKCAIHMHALKEI\\CFIBILIJQZS]BBEECS@E@@C]COKI@CABAAEEDMGCH]A[M@CJWHJaUMRFRBDTITLUJ@PFJKLOVST@FSLENgKGFSCaCmF_ESQiOSFOT[HYPu@IH_[IoE_[]GUC[USB__CYQI@Gakg@qZeHQNMNV\\FVLPgJAFJPRLCH[XcPELUT[JiV_EELFTADBXRTRLJC@fHXHHbPd`fR@NfT`@TLplHMpCEJHJBVLF@JTVnG^KXDXHNVGRLRXFJVdDHSNWLGfEzA"],
                    "encodeOffsets": [
                        [118635, 41113]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110114",
                "properties": {
                    "name": "昌平区",
                    "cp": [116.1777, 40.2134],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VNLJI\\JPPDYPFVQDCJZRNEVNhKXgR@^P@NLRbB\\Mh@XcVARJE`RTCNFVXRCjPPLNA@GZKbJJHXB\\MNPjLdGbWnK\\]NGHSFEXATIdCJGPARUWUHCPWRELITAHKv_E@iYCaW_BQ\\Y@QIO@QDCIGZCEMWGFMFAFgHEDOCSqKCCFGAMKEAC@ODGCGs@WH@KQA@EE@CE@GEA@EH@GGUEEJEAYD@JM@@DAA@FHD@FTJEHUC@JUBKCKG@G[CIIQReAYhO@OXGDO@@FF@IHJFCPEBACBIAAKDOABXARHPNEHGbQAAKQFGIAM[C@WHKaGiCEGOAHUKCIokSCUSOCYN[BgGMFIR±OZmHWNU@ShbbXDHVXXGJ^lZ@PZ\\Nb@\\FHJAD"],
                    "encodeOffsets": [
                        [118750, 41232]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110115",
                "properties": {
                    "name": "大兴区",
                    "cp": [116.4716, 39.6352],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@F\\E~DFN@BDFEpHFCHBBEGCDCJBHUDSBB@ELCPbF@B\\J@BJVAFJ\\ADKTCBGECFMT@BMN@@FH@DaNBEnvB@FPBATK@FHEFIAKFBFL@@PKBFJHC@FXBRAFCDMPDTOL@JIVFDHH@DDH@BGRFCDLD@N^@@CNA@KNOAEBCECFEGCFGMGFIPMOEJOLBADBBHGG@GCHIECY@INC@DMGS\\AIOZAAEYA@GT@KKMBEETCGMVINFxA@MJADB@FlA@HJA@NND@DFA@DVAZBBOFKH_JA@K^GBC@EFEG@gAENMXKJigC@IbSJMqGOP£RGSMGE@kbQFDPEFiBSGGSBK]I{CDWCIDOic[C_G@SuSO@EWKCO@MNY@\\uZOPENQD[LKESSKGBKEG@EJGAGHoH¥CqhifeJkX_XFFGHFNEDFPENKHM^IFIVL^S`DVEnNnG`RTCJHH@R^XFXGVPP"],
                    "encodeOffsets": [
                        [119042, 40704]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110113",
                "properties": {
                    "name": "顺义区",
                    "cp": [116.7242, 40.1619],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@EhEBENXHFNYDJHCD@RJP@R[ZARX`DbjZF@bHXT`Jb@dIFMTGDSfAJVbGnJVM@OKELYPERVXRflXTT@NIfC\\NJRhCVEHFJXNT^DTeZEHYCOhuAMJELOdAVPTMOWBWNMNEJgl]@WGUFIC[T{EEDEHGCIGMI@SECUQI[D{A{GQESPUH]CsiMCmHUeoHENcAaDGCMDGMQCACCBaCGLMAHB@DIEQLOAAEEJ@CW@CDINGAAGKQOCgV@LG@BEGDKNeREFBNCFIDOPKD[@YRW@GFWDAFE@EHDDrLDTCPGF", "@@KrJEH[\\B@FF@CHFBHUNAJKADGECBCMAG^E@EbI@BEGP"],
                    "encodeOffsets": [
                        [119283, 41084],
                        [119377, 41046]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110117",
                "properties": {
                    "name": "平谷区",
                    "cp": [117.1706, 40.2052],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ZJZRafFLjnVGNJ@LLBdXX\\T^EDMJ@nZKLBjPPJ@HbA\\H`DbERHLCFK^BZaFWXQLAGMHa\\OLO@SBIpBdCLVQfElO@GSAKEDQTC@GEBKG@ORIJBDAPDFA@CaOq@GGQAAEJK@KMUGAAGEAa@MGMBGCGSIIW@WSUCMDOJeWOM@IUF{WMWaDIMgIoRoCOKeEOEAG_I[cg@wLIFENQFDVTFJ@HNDJGHCFFFS|D\\EJHV@Xk^IhMFMNAXPX"],
                    "encodeOffsets": [
                        [119748, 41190]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110112",
                "properties": {
                    "name": "通州区",
                    "cp": [116.7297, 39.8131],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@FDAJTGDNDCTDDEDBBE@DT@@EHCDGJ@EIZ@@FDBR@ATFBBVFFE@@HNA\\VE@CLIFNJFNJBCP]A@LJFA@HJEDD\\C@DBCHLAEPF@@DH@APHAERDF\\GIxDTM@CFLBBFJ@CNUPMHECGDBF]BMFPDLRBHHBJMDCX@@DFIBFPBRKJF@CGANBHKbDDABDRDHNNCHDbCdBFMpGHiOYMefKJMC}HWAUNW\\NNBNAkNU|]HMTMN@MZBLFFF@RIRUTBMFIEGaAGGAOIIUGTSFcYKS@MSLYPKRUBU]EWDOI]CKGASgW@MTWKIMCS@uMAKKADMECGAKVUTSDy@IjWLMNBF@hHEF@FAD]H@LIBG`ELAPYAUB@CEB@CMC@MIB@GkB@ECAIB@NwBMEUJHNSDFFNALLS@@HZBBFYBJP[BHTCND@JMZ@FDGJHDH@GHAABCKAIPPFONEJNHEHHDEFFDADBFMP@L"],
                    "encodeOffsets": [
                        [119329, 40782]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110105",
                "properties": {
                    "name": "朝阳区",
                    "cp": [116.4977, 39.949],
                    "childNum": 2
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@bFGHBHFBFIVFHHG@@FFB@HDFF@@FRB@LXGt@DHCH@PBDLFBNF@BEXCHEX@ZQ\\@LCPOJCDEAMFEfQLMHCAFH@@KhUNE^AAEHCFDNGVODMI@AEKADEN@CSJw[HCEFQGBBOG@@CE@FOKBDGCAD@C[FCGIB@IE@K^BDOIAEMMIJEDKF@[UMB@GF@EEAUEABSQ@CA@EY@FJI@CHGD@FS@@CAFCACFSCCDCMSHBIECMB@D]@@MKCDCQEAHG@CCG@CGUEIJK@SPOCCNEDQBDNDB@DJCDLFCBBALJB@BVGPBKVO@KHCCCD@FE@BNA@FNCTDDJA@FGB@NBDW@CL@hT@@ZHHQDDDAFSAANBC@HG@EFS@@DE@@PCB@Ue@CADNJB@FCBWA@LI^ix@FIHrH"],
                        ["@@HUNAJKADGECBCMAG^E@EbI@BEGPKrJEH[\\B@FF@CHFB"]
                    ],
                    "encodeOffsets": [
                        [
                            [119169, 40992]
                        ],
                        [
                            [119398, 41063]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110108",
                "properties": {
                    "name": "海淀区",
                    "cp": [116.2202, 40.0239],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@plDJVLGPBFHjDbHGL@X\\DBNHJREBLRBHaFGMGOBQAWPBLCBBAJBDFADOIEJGE@@EP@HCPWP@ZgfBRQJJ\\D@HLHLDVA@IVDFGSI@EGC@EBB@CN@@IZCAGHGaEqGJG@EjwJ]@K@GSA@e_I@NE@CA@Kg@KC@ENCFAKQAW@WIMK@V@I@@F@^EDFB@HcIaDYCBRRDCHD@EFLN@FE@CJUPEJOJMTBPEDIFCMIAKNOGMRFJNDVBFLSRMJSDGJsFcEiJGDGTIlOjYD"],
                    "encodeOffsets": [
                        [118834, 41050]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110106",
                "properties": {
                    "name": "丰台区",
                    "cp": [116.2683, 39.8309],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@hMN@NFTQCFRCBJFA@HJ@@HJ@HJ\\FTACD@@UNLXJX@@MA@@IECAQlDFEHBDI~D@GXCFMVDFCH@@NF@ANJC@FnAB@AMF@@EDCDDLGP@LUOAUH@AIABKAAEDCKID@CCACMWA@EGDEILA@OK@AELEJBFEEGL@BSOA@EuAFmMACbG@@EM@ANS@ENFDAHSDCL[BEIUBAII@A[E@OaKD@FAACTGVIACDHDAFGAEDoGEFACM@ig@@QFCMKMU@]SCoBGSMQDEXXDWPO@MKYGM^AdJJA\\cNB\\G^DNHFCBFABDBJ@PL^D@DF@T@FDAF^A"],
                    "encodeOffsets": [
                        [118958, 40846]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110107",
                "properties": {
                    "name": "石景山区",
                    "cp": [116.1887, 39.9346],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@NQPHLMJBDNJEFCAONSPIFIVODIF@@EKMFEC@DGQCAQZDbCdJ@GEAFC@]@EJ@DCSB[EGII@@GI@@GEBAIQDDESRMEM@gNYTIRKJAJEJ[DFJKLGBGNBJLDCDAHGBJJAFBLEXTLZFBAFDLD"],
                    "encodeOffsets": [
                        [118940, 40953]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110102",
                "properties": {
                    "name": "西城区",
                    "cp": [116.3631, 39.9353],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XBDA@EIACM@IJAD]BC@SFABISAD]H@@OAEDQEW@BLEMD@FLDh@@LDBF@@M`J@fTB@H"],
                    "encodeOffsets": [
                        [119175, 40932]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110101",
                "properties": {
                    "name": "东城区",
                    "cp": [116.418, 39.9367],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@DBf@@VDA@OF@@CT@FEH@@GADBMTBBECCRCGG@YS@@gDK@AC@PG@C^TBAJEB@TADC^IB@J"],
                    "encodeOffsets": [
                        [119182, 40921]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110104",
                "properties": {
                    "name": "宣武区",
                    "cp": [116.3603, 39.8852],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@RBX@RFFCBFU@aK@WA}CCJGAEFkCBRFD@JB@@N"],
                    "encodeOffsets": [
                        [119118, 40855]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "110103",
                "properties": {
                    "name": "崇文区",
                    "cp": [116.4166, 39.8811],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XBL@@bEVD@BX@AC@MHA@EIBCCDSEMmB@EIDBME@@MG@EDUCENWD@H"],
                    "encodeOffsets": [
                        [119175, 40829]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/component/dataRange', ['require', './base', 'zrender/shape/Text', 'zrender/shape/Rectangle', '../util/shape/HandlePolygon', '../config', 'zrender/tool/util', 'zrender/tool/event', 'zrender/tool/area', 'zrender/tool/color', '../component'], function(require) {
        var Base = require('./base');

        // 图形依赖
        var TextShape = require('zrender/shape/Text');
        var RectangleShape = require('zrender/shape/Rectangle');
        var HandlePolygonShape = require('../util/shape/HandlePolygon');

        var ecConfig = require('../config');
        // 值域
        ecConfig.dataRange = {
            zlevel: 0, // 一级层叠
            z: 4, // 二级层叠
            show: true,
            orient: 'vertical', // 布局方式，默认为垂直布局，可选为：
            // 'horizontal' ¦ 'vertical'
            x: 'left', // 水平安放位置，默认为全图左对齐，可选为：
            // 'center' ¦ 'left' ¦ 'right'
            // ¦ {number}（x坐标，单位px）
            y: 'bottom', // 垂直安放位置，默认为全图底部，可选为：
            // 'top' ¦ 'bottom' ¦ 'center'
            // ¦ {number}（y坐标，单位px）
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc', // 值域边框颜色
            borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框）
            padding: 5, // 值域内边距，单位px，默认各方向内边距为5，
            // 接受数组分别设定上右下左边距，同css
            itemGap: 10, // 各个item之间的间隔，单位px，默认为10，
            // 横向布局时为水平间隔，纵向布局时为纵向间隔
            itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10
            itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10
            // min: null,              // 最小值，如果没有指定splitList，则必须指定min和max
            // max: null,              // 最大值，如果没有指定splitList，则必须指定min和max
            precision: 0, // 小数精度，默认为0，无小数点
            splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变
            splitList: null, // 用于用户自定义不等距分割。如果定义了splitList，则splitNumber无效。
            // splitList为Array.<Object>，其中每个Object形如：
            // {
            //   start: 10,          本项的数据范围起点（>=），如果不设置表示负无穷。
            //                       如果想本项只对应一个值，那么start和end设同样的数就可以了。
            //   end: 90             本项的数据范围终点（<=），如果不设置表示正无穷。
            //   label: '10 to 30',  本项的显示标签，缺省则自动生成label。
            //   color: '#333'       本项的显示颜色，缺省则自动计算color。
            // }
            calculable: false, // 是否值域漫游，启用后无视splitNumber和splitList，线性渐变
            selectedMode: true, // 选择模式，默认开启值域开关
            hoverLink: true,
            realtime: true,
            color: ['#006edd', '#e0ffff'], //颜色
            // formatter: null,
            // text:['高','低'],         // 文本，默认为数值文本
            textStyle: {
                color: '#333' // 值域文字颜色
            }
        };

        var zrUtil = require('zrender/tool/util');
        var zrEvent = require('zrender/tool/event');
        var zrArea = require('zrender/tool/area');
        var zrColor = require('zrender/tool/color');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         * @param {Object=} selected 用于状态保持
         */
        function DataRange(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            self._ondrift = function(dx, dy) {
                return self.__ondrift(this, dx, dy);
            };
            self._ondragend = function() {
                return self.__ondragend();
            };
            self._dataRangeSelected = function(param) {
                return self.__dataRangeSelected(param);
            };
            self._dispatchHoverLink = function(param) {
                return self.__dispatchHoverLink(param);
            };
            self._onhoverlink = function(params) {
                return self.__onhoverlink(params);
            };
            this._selectedMap = {};
            this._range = {};

            this.refresh(option);

            messageCenter.bind(ecConfig.EVENT.HOVER, this._onhoverlink);
        }

        DataRange.prototype = {
            type: ecConfig.COMPONENT_TYPE_DATARANGE,
            _textGap: 10, // 非值文字间隔
            _buildShape: function() {
                // 值域元素组的位置参数，通过计算所得x, y, width, height
                this._itemGroupLocation = this._getItemGroupLocation();
                this._buildBackground();
                if (this._isContinuity()) {
                    this._buildGradient();
                } else {
                    this._buildItem();
                }

                if (this.dataRangeOption.show) {
                    for (var i = 0, l = this.shapeList.length; i < l; i++) {
                        this.zr.addShape(this.shapeList[i]);
                    }
                }

                this._syncShapeFromRange();
            },

            /**
             * 构建图例型的值域元素
             */
            _buildItem: function() {
                var data = this._valueTextList;
                var dataLength = data.length;
                var itemName;
                var itemShape;
                var textShape;
                var font = this.getFont(this.dataRangeOption.textStyle);

                var lastX = this._itemGroupLocation.x;
                var lastY = this._itemGroupLocation.y;
                var itemWidth = this.dataRangeOption.itemWidth;
                var itemHeight = this.dataRangeOption.itemHeight;
                var itemGap = this.dataRangeOption.itemGap;
                var textHeight = zrArea.getTextHeight('国', font);
                var color;

                if (this.dataRangeOption.orient == 'vertical' && this.dataRangeOption.x == 'right') {
                    lastX = this._itemGroupLocation.x + this._itemGroupLocation.width - itemWidth;
                }
                var needValueText = true;
                if (this.dataRangeOption.text) {
                    needValueText = false;
                    // 第一个文字
                    if (this.dataRangeOption.text[0]) {
                        textShape = this._getTextShape(
                            lastX, lastY, this.dataRangeOption.text[0]
                        );
                        if (this.dataRangeOption.orient == 'horizontal') {
                            lastX += zrArea.getTextWidth(
                                this.dataRangeOption.text[0],
                                font
                            ) + this._textGap;
                        } else {
                            lastY += textHeight + this._textGap;
                            textShape.style.y += textHeight / 2 + this._textGap;
                            textShape.style.textBaseline = 'bottom';
                        }
                        this.shapeList.push(new TextShape(textShape));
                    }
                }

                for (var i = 0; i < dataLength; i++) {
                    itemName = data[i];
                    color = this.getColorByIndex(i);
                    // 图形
                    itemShape = this._getItemShape(
                        lastX, lastY,
                        itemWidth, itemHeight, (this._selectedMap[i] ? color : '#ccc')
                    );
                    itemShape._idx = i;
                    itemShape.onmousemove = this._dispatchHoverLink;
                    if (this.dataRangeOption.selectedMode) {
                        itemShape.clickable = true;
                        itemShape.onclick = this._dataRangeSelected;
                    }
                    this.shapeList.push(new RectangleShape(itemShape));

                    if (needValueText) {
                        // 文字
                        textShape = {
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase(),
                            style: {
                                x: lastX + itemWidth + 5,
                                y: lastY,
                                color: this._selectedMap[i] ? this.dataRangeOption.textStyle.color : '#ccc',
                                text: data[i],
                                textFont: font,
                                textBaseline: 'top'
                            },
                            highlightStyle: {
                                brushType: 'fill'
                            }
                        };
                        if (this.dataRangeOption.orient == 'vertical' && this.dataRangeOption.x == 'right') {
                            textShape.style.x -= (itemWidth + 10);
                            textShape.style.textAlign = 'right';
                        }
                        textShape._idx = i;
                        textShape.onmousemove = this._dispatchHoverLink;
                        if (this.dataRangeOption.selectedMode) {
                            textShape.clickable = true;
                            textShape.onclick = this._dataRangeSelected;
                        }
                        this.shapeList.push(new TextShape(textShape));
                    }

                    if (this.dataRangeOption.orient == 'horizontal') {
                        lastX += itemWidth + (needValueText ? 5 : 0) + (needValueText ? zrArea.getTextWidth(itemName, font) : 0) + itemGap;
                    } else {
                        lastY += itemHeight + itemGap;
                    }
                }

                if (!needValueText && this.dataRangeOption.text[1]) {
                    if (this.dataRangeOption.orient == 'horizontal') {
                        lastX = lastX - itemGap + this._textGap;
                    } else {
                        lastY = lastY - itemGap + this._textGap;
                    }
                    // 最后一个文字
                    textShape = this._getTextShape(
                        lastX, lastY, this.dataRangeOption.text[1]
                    );

                    if (this.dataRangeOption.orient != 'horizontal') {
                        textShape.style.y -= 5;
                        textShape.style.textBaseline = 'top';
                    }

                    this.shapeList.push(new TextShape(textShape));
                }
            },

            /**
             * 构建渐变型的值域元素
             */
            _buildGradient: function() {
                var itemShape;
                var textShape;
                var font = this.getFont(this.dataRangeOption.textStyle);

                var lastX = this._itemGroupLocation.x;
                var lastY = this._itemGroupLocation.y;
                var itemWidth = this.dataRangeOption.itemWidth;
                var itemHeight = this.dataRangeOption.itemHeight;
                var textHeight = zrArea.getTextHeight('国', font);
                var mSize = 10;


                var needValueText = true;
                if (this.dataRangeOption.text) {
                    needValueText = false;
                    // 第一个文字
                    if (this.dataRangeOption.text[0]) {
                        textShape = this._getTextShape(
                            lastX, lastY, this.dataRangeOption.text[0]
                        );
                        if (this.dataRangeOption.orient == 'horizontal') {
                            lastX += zrArea.getTextWidth(
                                this.dataRangeOption.text[0],
                                font
                            ) + this._textGap;
                        } else {
                            lastY += textHeight + this._textGap;
                            textShape.style.y += textHeight / 2 + this._textGap;
                            textShape.style.textBaseline = 'bottom';
                        }
                        this.shapeList.push(new TextShape(textShape));
                    }
                }

                var zrColor = require('zrender/tool/color');
                var per = 1 / (this.dataRangeOption.color.length - 1);
                var colorList = [];
                for (var i = 0, l = this.dataRangeOption.color.length; i < l; i++) {
                    colorList.push([i * per, this.dataRangeOption.color[i]]);
                }
                if (this.dataRangeOption.orient == 'horizontal') {
                    itemShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        style: {
                            x: lastX,
                            y: lastY,
                            width: itemWidth * mSize,
                            height: itemHeight,
                            color: zrColor.getLinearGradient(
                                lastX, lastY, lastX + itemWidth * mSize, lastY,
                                colorList
                            )
                        },
                        hoverable: false
                    };
                    lastX += itemWidth * mSize + this._textGap;
                } else {
                    itemShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        style: {
                            x: lastX,
                            y: lastY,
                            width: itemWidth,
                            height: itemHeight * mSize,
                            color: zrColor.getLinearGradient(
                                lastX, lastY, lastX, lastY + itemHeight * mSize,
                                colorList
                            )
                        },
                        hoverable: false
                    };
                    lastY += itemHeight * mSize + this._textGap;
                }
                this.shapeList.push(new RectangleShape(itemShape));
                // 可计算元素的位置缓存
                this._calculableLocation = itemShape.style;
                if (this.dataRangeOption.calculable) {
                    this._buildFiller();
                    this._bulidMask();
                    this._bulidHandle();
                }
                this._buildIndicator();

                if (!needValueText && this.dataRangeOption.text[1]) {
                    // 最后一个文字
                    textShape = this._getTextShape(
                        lastX, lastY, this.dataRangeOption.text[1]
                    );

                    this.shapeList.push(new TextShape(textShape));
                }
            },

            /**
             * 构建指示器
             */
            _buildIndicator: function() {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                var size = 5;
                var pointList;
                var textPosition;
                if (this.dataRangeOption.orient == 'horizontal') {
                    // 水平
                    if (this.dataRangeOption.y != 'bottom') {
                        // 手柄统统在下方
                        pointList = [
                            [x, y + height],
                            [x - size, y + height + size],
                            [x + size, y + height + size]
                        ];
                        textPosition = 'bottom';
                    } else {
                        // 手柄在上方
                        pointList = [
                            [x, y],
                            [x - size, y - size],
                            [x + size, y - size]
                        ];
                        textPosition = 'top';
                    }
                } else {
                    // 垂直
                    if (this.dataRangeOption.x != 'right') {
                        // 手柄统统在右侧
                        pointList = [
                            [x + width, y],
                            [x + width + size, y - size],
                            [x + width + size, y + size]
                        ];
                        textPosition = 'right';
                    } else {
                        // 手柄在左侧
                        pointList = [
                            [x, y],
                            [x - size, y - size],
                            [x - size, y + size]
                        ];
                        textPosition = 'left';
                    }
                }
                this._indicatorShape = {
                    style: {
                        pointList: pointList,
                        color: '#fff',
                        __rect: {
                            x: Math.min(pointList[0][0], pointList[1][0]),
                            y: Math.min(pointList[0][1], pointList[1][1]),
                            width: size * (this.dataRangeOption.orient == 'horizontal' ? 2 : 1),
                            height: size * (this.dataRangeOption.orient == 'horizontal' ? 1 : 2)
                        }
                    },
                    highlightStyle: {
                        brushType: 'fill',
                        textPosition: textPosition,
                        textColor: this.dataRangeOption.textStyle.color
                    },
                    hoverable: false
                };
                this._indicatorShape = new HandlePolygonShape(this._indicatorShape);
            },

            /**
             * 构建填充物
             */
            _buildFiller: function() {
                this._fillerShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    style: {
                        x: this._calculableLocation.x,
                        y: this._calculableLocation.y,
                        width: this._calculableLocation.width,
                        height: this._calculableLocation.height,
                        color: 'rgba(255,255,255,0)'
                    },
                    highlightStyle: {
                        strokeColor: 'rgba(255,255,255,0.5)',
                        lineWidth: 1
                    },
                    draggable: true,
                    ondrift: this._ondrift,
                    ondragend: this._ondragend,
                    onmousemove: this._dispatchHoverLink,
                    _type: 'filler'
                };
                this._fillerShape = new RectangleShape(this._fillerShape);
                this.shapeList.push(this._fillerShape);
            },

            /**
             * 构建拖拽手柄
             */
            _bulidHandle: function() {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                var font = this.getFont(this.dataRangeOption.textStyle);
                var textHeight = zrArea.getTextHeight('国', font);
                var textWidth = Math.max(
                    zrArea.getTextWidth(this._textFormat(this.dataRangeOption.max), font),
                    zrArea.getTextWidth(this._textFormat(this.dataRangeOption.min), font)
                ) + 2;

                var pointListStart;
                var textXStart;
                var textYStart;
                var coverRectStart;
                var pointListEnd;
                var textXEnd;
                var textYEnd;
                var coverRectEnd;
                if (this.dataRangeOption.orient == 'horizontal') {
                    // 水平
                    if (this.dataRangeOption.y != 'bottom') {
                        // 手柄统统在下方
                        pointListStart = [
                            [x, y],
                            [x, y + height + textHeight],
                            [x - textHeight, y + height + textHeight],
                            [x - 1, y + height],
                            [x - 1, y]

                        ];
                        textXStart = x - textWidth / 2 - textHeight;
                        textYStart = y + height + textHeight / 2 + 2;
                        coverRectStart = {
                            x: x - textWidth - textHeight,
                            y: y + height,
                            width: textWidth + textHeight,
                            height: textHeight
                        };

                        pointListEnd = [
                            [x + width, y],
                            [x + width, y + height + textHeight],
                            [x + width + textHeight, y + height + textHeight],
                            [x + width + 1, y + height],
                            [x + width + 1, y]
                        ];
                        textXEnd = x + width + textWidth / 2 + textHeight;
                        textYEnd = textYStart;
                        coverRectEnd = {
                            x: x + width,
                            y: y + height,
                            width: textWidth + textHeight,
                            height: textHeight
                        };
                    } else {
                        // 手柄在上方
                        pointListStart = [
                            [x, y + height],
                            [x, y - textHeight],
                            [x - textHeight, y - textHeight],
                            [x - 1, y],
                            [x - 1, y + height]

                        ];
                        textXStart = x - textWidth / 2 - textHeight;
                        textYStart = y - textHeight / 2 - 2;
                        coverRectStart = {
                            x: x - textWidth - textHeight,
                            y: y - textHeight,
                            width: textWidth + textHeight,
                            height: textHeight
                        };

                        pointListEnd = [
                            [x + width, y + height],
                            [x + width, y - textHeight],
                            [x + width + textHeight, y - textHeight],
                            [x + width + 1, y],
                            [x + width + 1, y + height]
                        ];
                        textXEnd = x + width + textWidth / 2 + textHeight;
                        textYEnd = textYStart;
                        coverRectEnd = {
                            x: x + width,
                            y: y - textHeight,
                            width: textWidth + textHeight,
                            height: textHeight
                        };
                    }
                } else {
                    textWidth += textHeight;
                    // 垂直
                    if (this.dataRangeOption.x != 'right') {
                        // 手柄统统在右侧
                        pointListStart = [
                            [x, y],
                            [x + width + textHeight, y],
                            [x + width + textHeight, y - textHeight],
                            [x + width, y - 1],
                            [x, y - 1]
                        ];
                        textXStart = x + width + textWidth / 2 + textHeight / 2;
                        textYStart = y - textHeight / 2;
                        coverRectStart = {
                            x: x + width,
                            y: y - textHeight,
                            width: textWidth + textHeight,
                            height: textHeight
                        };

                        pointListEnd = [
                            [x, y + height],
                            [x + width + textHeight, y + height],
                            [x + width + textHeight, y + textHeight + height],
                            [x + width, y + 1 + height],
                            [x, y + height + 1]
                        ];
                        textXEnd = textXStart;
                        textYEnd = y + height + textHeight / 2;
                        coverRectEnd = {
                            x: x + width,
                            y: y + height,
                            width: textWidth + textHeight,
                            height: textHeight
                        };
                    } else {
                        // 手柄在左侧
                        pointListStart = [
                            [x + width, y],
                            [x - textHeight, y],
                            [x - textHeight, y - textHeight],
                            [x, y - 1],
                            [x + width, y - 1]
                        ];
                        textXStart = x - textWidth / 2 - textHeight / 2;
                        textYStart = y - textHeight / 2;
                        coverRectStart = {
                            x: x - textWidth - textHeight,
                            y: y - textHeight,
                            width: textWidth + textHeight,
                            height: textHeight
                        };

                        pointListEnd = [
                            [x + width, y + height],
                            [x - textHeight, y + height],
                            [x - textHeight, y + textHeight + height],
                            [x, y + 1 + height],
                            [x + width, y + height + 1]
                        ];
                        textXEnd = textXStart;
                        textYEnd = y + height + textHeight / 2;
                        coverRectEnd = {
                            x: x - textWidth - textHeight,
                            y: y + height,
                            width: textWidth + textHeight,
                            height: textHeight
                        };
                    }
                }

                this._startShape = {
                    style: {
                        pointList: pointListStart,
                        text: this._textFormat(this.dataRangeOption.max),
                        textX: textXStart,
                        textY: textYStart,
                        textFont: font,
                        color: this.getColor(this.dataRangeOption.max),
                        rect: coverRectStart,
                        x: pointListStart[0][0],
                        y: pointListStart[0][1],
                        _x: pointListStart[0][0], // 拖拽区域控制缓存
                        _y: pointListStart[0][1]
                    }
                };
                this._startShape.highlightStyle = {
                    strokeColor: this._startShape.style.color,
                    lineWidth: 1
                };

                this._endShape = {
                    style: {
                        pointList: pointListEnd,
                        text: this._textFormat(this.dataRangeOption.min),
                        textX: textXEnd,
                        textY: textYEnd,
                        textFont: font,
                        color: this.getColor(this.dataRangeOption.min),
                        rect: coverRectEnd,
                        x: pointListEnd[0][0],
                        y: pointListEnd[0][1],
                        _x: pointListEnd[0][0], // 拖拽区域控制缓存
                        _y: pointListEnd[0][1]
                    }
                };
                this._endShape.highlightStyle = {
                    strokeColor: this._endShape.style.color,
                    lineWidth: 1
                };

                // 统一参数
                this._startShape.zlevel = this._endShape.zlevel = this.getZlevelBase();
                this._startShape.z = this._endShape.z = this.getZBase() + 1;
                this._startShape.draggable = this._endShape.draggable = true;
                this._startShape.ondrift = this._endShape.ondrift = this._ondrift;
                this._startShape.ondragend = this._endShape.ondragend = this._ondragend;

                this._startShape.style.textColor = this._endShape.style.textColor = this.dataRangeOption.textStyle.color;
                this._startShape.style.textAlign = this._endShape.style.textAlign = 'center';
                this._startShape.style.textPosition = this._endShape.style.textPosition = 'specific';
                this._startShape.style.textBaseline = this._endShape.style.textBaseline = 'middle';
                // for ondrif计算统一
                this._startShape.style.width = this._endShape.style.width = 0;
                this._startShape.style.height = this._endShape.style.height = 0;
                this._startShape.style.textPosition = this._endShape.style.textPosition = 'specific';

                this._startShape = new HandlePolygonShape(this._startShape);
                this._endShape = new HandlePolygonShape(this._endShape);
                this.shapeList.push(this._startShape);
                this.shapeList.push(this._endShape);
            },

            _bulidMask: function() {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;
                this._startMask = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    style: {
                        x: x,
                        y: y,
                        width: this.dataRangeOption.orient == 'horizontal' ? 0 : width,
                        height: this.dataRangeOption.orient == 'horizontal' ? height : 0,
                        color: '#ccc'
                    },
                    hoverable: false
                };
                this._endMask = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    style: {
                        x: this.dataRangeOption.orient == 'horizontal' ? x + width : x,
                        y: this.dataRangeOption.orient == 'horizontal' ? y : y + height,
                        width: this.dataRangeOption.orient == 'horizontal' ? 0 : width,
                        height: this.dataRangeOption.orient == 'horizontal' ? height : 0,
                        color: '#ccc'
                    },
                    hoverable: false
                };
                this._startMask = new RectangleShape(this._startMask);
                this._endMask = new RectangleShape(this._endMask);
                this.shapeList.push(this._startMask);
                this.shapeList.push(this._endMask);
            },

            _buildBackground: function() {
                var padding = this.reformCssArray(this.dataRangeOption.padding);

                this.shapeList.push(new RectangleShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this._itemGroupLocation.x - padding[3],
                        y: this._itemGroupLocation.y - padding[0],
                        width: this._itemGroupLocation.width + padding[3] + padding[1],
                        height: this._itemGroupLocation.height + padding[0] + padding[2],
                        brushType: this.dataRangeOption.borderWidth === 0 ? 'fill' : 'both',
                        color: this.dataRangeOption.backgroundColor,
                        strokeColor: this.dataRangeOption.borderColor,
                        lineWidth: this.dataRangeOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算值域实体的位置坐标
             */
            _getItemGroupLocation: function() {
                var data = this._valueTextList;
                var dataLength = data.length;
                var itemGap = this.dataRangeOption.itemGap;
                var itemWidth = this.dataRangeOption.itemWidth;
                var itemHeight = this.dataRangeOption.itemHeight;
                var totalWidth = 0;
                var totalHeight = 0;
                var font = this.getFont(this.dataRangeOption.textStyle);
                var textHeight = zrArea.getTextHeight('国', font);
                var mSize = 10;

                if (this.dataRangeOption.orient == 'horizontal') {
                    // 水平布局，计算总宽度
                    if (this.dataRangeOption.text || this._isContinuity()) {
                        // 指定文字或线性渐变
                        totalWidth =
                            (this._isContinuity() ? (itemWidth * mSize + itemGap) : dataLength * (itemWidth + itemGap)) + (this.dataRangeOption.text && typeof this.dataRangeOption.text[0] != 'undefined' ? (zrArea.getTextWidth(
                                this.dataRangeOption.text[0],
                                font
                            ) + this._textGap) : 0) + (this.dataRangeOption.text && typeof this.dataRangeOption.text[1] != 'undefined' ? (zrArea.getTextWidth(
                                this.dataRangeOption.text[1],
                                font
                            ) + this._textGap) : 0);
                    } else {
                        // 值标签
                        itemWidth += 5;
                        for (var i = 0; i < dataLength; i++) {
                            totalWidth += itemWidth + zrArea.getTextWidth(
                                data[i],
                                font
                            ) + itemGap;
                        }
                    }
                    totalWidth -= itemGap; // 减去最后一个的itemGap
                    totalHeight = Math.max(textHeight, itemHeight);
                } else {
                    // 垂直布局，计算总高度
                    var maxWidth;
                    if (this.dataRangeOption.text || this._isContinuity()) {
                        // 指定文字或线性渐变
                        totalHeight =
                            (this._isContinuity() ? (itemHeight * mSize + itemGap) : dataLength * (itemHeight + itemGap)) + (this.dataRangeOption.text && typeof this.dataRangeOption.text[0] != 'undefined' ? (this._textGap + textHeight) : 0) + (this.dataRangeOption.text && typeof this.dataRangeOption.text[1] != 'undefined' ? (this._textGap + textHeight) : 0);

                        maxWidth = Math.max(
                            zrArea.getTextWidth(
                                (this.dataRangeOption.text && this.dataRangeOption.text[0]) || '',
                                font
                            ),
                            zrArea.getTextWidth(
                                (this.dataRangeOption.text && this.dataRangeOption.text[1]) || '',
                                font
                            )
                        );
                        totalWidth = Math.max(itemWidth, maxWidth);
                    } else {
                        totalHeight = (itemHeight + itemGap) * dataLength;
                        // 值标签
                        itemWidth += 5;
                        maxWidth = 0;
                        for (var i = 0; i < dataLength; i++) {
                            maxWidth = Math.max(
                                maxWidth,
                                zrArea.getTextWidth(
                                    data[i],
                                    font
                                )
                            );
                        }
                        totalWidth = itemWidth + maxWidth;
                    }
                    totalHeight -= itemGap; // 减去最后一个的itemGap;
                }

                var padding = this.reformCssArray(this.dataRangeOption.padding);
                var x;
                var zrWidth = this.zr.getWidth();
                switch (this.dataRangeOption.x) {
                    case 'center':
                        x = Math.floor((zrWidth - totalWidth) / 2);
                        break;
                    case 'left':
                        x = padding[3] + this.dataRangeOption.borderWidth;
                        break;
                    case 'right':
                        x = zrWidth - totalWidth - padding[1] - this.dataRangeOption.borderWidth;
                        break;
                    default:
                        x = this.parsePercent(this.dataRangeOption.x, zrWidth);
                        x = isNaN(x) ? 0 : x;
                        break;
                }

                var y;
                var zrHeight = this.zr.getHeight();
                switch (this.dataRangeOption.y) {
                    case 'top':
                        y = padding[0] + this.dataRangeOption.borderWidth;
                        break;
                    case 'bottom':
                        y = zrHeight - totalHeight - padding[2] - this.dataRangeOption.borderWidth;
                        break;
                    case 'center':
                        y = Math.floor((zrHeight - totalHeight) / 2);
                        break;
                    default:
                        y = this.parsePercent(this.dataRangeOption.y, zrHeight);
                        y = isNaN(y) ? 0 : y;
                        break;
                }

                if (this.dataRangeOption.calculable) {
                    // 留出手柄控件
                    var handlerWidth = Math.max(
                        zrArea.getTextWidth(this.dataRangeOption.max, font),
                        zrArea.getTextWidth(this.dataRangeOption.min, font)
                    ) + textHeight;
                    if (this.dataRangeOption.orient == 'horizontal') {
                        if (x < handlerWidth) {
                            x = handlerWidth;
                        }
                        if (x + totalWidth + handlerWidth > zrWidth) {
                            x -= handlerWidth;
                        }
                    } else {
                        if (y < textHeight) {
                            y = textHeight;
                        }
                        if (y + totalHeight + textHeight > zrHeight) {
                            y -= textHeight;
                        }
                    }
                }

                return {
                    x: x,
                    y: y,
                    width: totalWidth,
                    height: totalHeight
                };
            },

            // 指定文本
            _getTextShape: function(x, y, text) {
                return {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: (this.dataRangeOption.orient == 'horizontal' ? x : this._itemGroupLocation.x + this._itemGroupLocation.width / 2),
                        y: (this.dataRangeOption.orient == 'horizontal' ? this._itemGroupLocation.y + this._itemGroupLocation.height / 2 : y),
                        color: this.dataRangeOption.textStyle.color,
                        text: text,
                        textFont: this.getFont(this.dataRangeOption.textStyle),
                        textBaseline: (this.dataRangeOption.orient == 'horizontal' ? 'middle' : 'top'),
                        textAlign: (this.dataRangeOption.orient == 'horizontal' ? 'left' : 'center')
                    },
                    hoverable: false
                };
            },

            // 色尺legend item shape
            _getItemShape: function(x, y, width, height, color) {
                return {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: x,
                        y: y + 1,
                        width: width,
                        height: height - 2,
                        color: color
                    },
                    highlightStyle: {
                        strokeColor: color,
                        lineWidth: 1
                    }
                };
            },

            /**
             * 拖拽范围控制
             */
            __ondrift: function(shape, dx, dy) {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                if (this.dataRangeOption.orient == 'horizontal') {
                    if (shape.style.x + dx <= x) {
                        shape.style.x = x;
                    } else if (shape.style.x + dx + shape.style.width >= x + width) {
                        shape.style.x = x + width - shape.style.width;
                    } else {
                        shape.style.x += dx;
                    }
                } else {
                    if (shape.style.y + dy <= y) {
                        shape.style.y = y;
                    } else if (shape.style.y + dy + shape.style.height >= y + height) {
                        shape.style.y = y + height - shape.style.height;
                    } else {
                        shape.style.y += dy;
                    }
                }

                if (shape._type == 'filler') {
                    this._syncHandleShape();
                } else {
                    this._syncFillerShape(shape);
                }

                if (this.dataRangeOption.realtime) {
                    this._dispatchDataRange();
                }

                return true;
            },

            __ondragend: function() {
                this.isDragend = true;
            },

            /**
             * 数据项被拖拽出去
             */
            ondragend: function(param, status) {
                if (!this.isDragend || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }

                // 别status = {}赋值啊！！
                status.dragOut = true;
                status.dragIn = true;

                if (!this.dataRangeOption.realtime) {
                    this._dispatchDataRange();
                }

                status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍
                // 处理完拖拽事件后复位
                this.isDragend = false;

                return;
            },

            // 外部传入range （calculable为true时有意义）
            _syncShapeFromRange: function() {
                var range = this.dataRangeOption.range || {};
                var optRangeStart = range.start;
                var optRangeEnd = range.end;
                if (optRangeEnd < optRangeStart) {
                    optRangeStart = [optRangeEnd, optRangeEnd = optRangeStart][0]; // 反转
                }

                // 内部使用的_range和option的range的start、end的定义是相反的。
                // 为了支持myChart.setOption(option, true); option中的设置优先。
                this._range.end = optRangeStart != null ? optRangeStart : (this._range.end != null ? this._range.end : 0);
                this._range.start = optRangeEnd != null ? optRangeEnd : (this._range.start != null ? this._range.start : 100);

                if (this._range.start != 100 || this._range.end !== 0) {
                    // 非默认满值同步一下图形
                    if (this.dataRangeOption.orient == 'horizontal') {
                        // 横向
                        var width = this._fillerShape.style.width;
                        this._fillerShape.style.x +=
                            width * (100 - this._range.start) / 100;
                        this._fillerShape.style.width =
                            width * (this._range.start - this._range.end) / 100;
                    } else {
                        // 纵向
                        var height = this._fillerShape.style.height;
                        this._fillerShape.style.y +=
                            height * (100 - this._range.start) / 100;
                        this._fillerShape.style.height =
                            height * (this._range.start - this._range.end) / 100;
                    }
                    this.zr.modShape(this._fillerShape.id);
                    this._syncHandleShape();
                }
            },

            _syncHandleShape: function() {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                if (this.dataRangeOption.orient == 'horizontal') {
                    this._startShape.style.x = this._fillerShape.style.x;
                    this._startMask.style.width = this._startShape.style.x - x;

                    this._endShape.style.x = this._fillerShape.style.x + this._fillerShape.style.width;
                    this._endMask.style.x = this._endShape.style.x;
                    this._endMask.style.width = x + width - this._endShape.style.x;

                    this._range.start = Math.ceil(
                        100 - (this._startShape.style.x - x) / width * 100
                    );
                    this._range.end = Math.floor(
                        100 - (this._endShape.style.x - x) / width * 100
                    );
                } else {
                    this._startShape.style.y = this._fillerShape.style.y;
                    this._startMask.style.height = this._startShape.style.y - y;

                    this._endShape.style.y = this._fillerShape.style.y + this._fillerShape.style.height;
                    this._endMask.style.y = this._endShape.style.y;
                    this._endMask.style.height = y + height - this._endShape.style.y;

                    this._range.start = Math.ceil(
                        100 - (this._startShape.style.y - y) / height * 100
                    );
                    this._range.end = Math.floor(
                        100 - (this._endShape.style.y - y) / height * 100
                    );
                }

                this._syncShape();
            },

            _syncFillerShape: function(e) {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                var a;
                var b;
                if (this.dataRangeOption.orient == 'horizontal') {
                    a = this._startShape.style.x;
                    b = this._endShape.style.x;
                    if (e.id == this._startShape.id && a >= b) {
                        // _startShape触发
                        b = a;
                        this._endShape.style.x = a;
                    } else if (e.id == this._endShape.id && a >= b) {
                        // _endShape触发
                        a = b;
                        this._startShape.style.x = a;
                    }
                    this._fillerShape.style.x = a;
                    this._fillerShape.style.width = b - a;
                    this._startMask.style.width = a - x;
                    this._endMask.style.x = b;
                    this._endMask.style.width = x + width - b;

                    this._range.start = Math.ceil(100 - (a - x) / width * 100);
                    this._range.end = Math.floor(100 - (b - x) / width * 100);
                } else {
                    a = this._startShape.style.y;
                    b = this._endShape.style.y;
                    if (e.id == this._startShape.id && a >= b) {
                        // _startShape触发
                        b = a;
                        this._endShape.style.y = a;
                    } else if (e.id == this._endShape.id && a >= b) {
                        // _endShape触发
                        a = b;
                        this._startShape.style.y = a;
                    }
                    this._fillerShape.style.y = a;
                    this._fillerShape.style.height = b - a;
                    this._startMask.style.height = a - y;
                    this._endMask.style.y = b;
                    this._endMask.style.height = y + height - b;

                    this._range.start = Math.ceil(100 - (a - y) / height * 100);
                    this._range.end = Math.floor(100 - (b - y) / height * 100);
                }

                this._syncShape();
            },

            _syncShape: function() {
                this._startShape.position = [
                    this._startShape.style.x - this._startShape.style._x,
                    this._startShape.style.y - this._startShape.style._y
                ];

                this._startShape.style.text = this._textFormat(
                    this._gap * this._range.start + this.dataRangeOption.min
                );

                this._startShape.style.color = this._startShape.highlightStyle.strokeColor = this.getColor(
                    this._gap * this._range.start + this.dataRangeOption.min
                );

                this._endShape.position = [
                    this._endShape.style.x - this._endShape.style._x,
                    this._endShape.style.y - this._endShape.style._y
                ];

                this._endShape.style.text = this._textFormat(
                    this._gap * this._range.end + this.dataRangeOption.min
                );

                this._endShape.style.color = this._endShape.highlightStyle.strokeColor = this.getColor(
                    this._gap * this._range.end + this.dataRangeOption.min
                );

                this.zr.modShape(this._startShape.id);
                this.zr.modShape(this._endShape.id);
                this.zr.modShape(this._startMask.id);
                this.zr.modShape(this._endMask.id);
                this.zr.modShape(this._fillerShape.id);
                this.zr.refreshNextFrame();
            },

            _dispatchDataRange: function() {
                this.messageCenter.dispatch(
                    ecConfig.EVENT.DATA_RANGE,
                    null, {
                        range: {
                            start: this._range.end,
                            end: this._range.start
                        }
                    },
                    this.myChart
                );
            },


            __dataRangeSelected: function(param) {
                if (this.dataRangeOption.selectedMode === 'single') {
                    for (var k in this._selectedMap) {
                        this._selectedMap[k] = false;
                    }
                }
                var idx = param.target._idx;
                this._selectedMap[idx] = !this._selectedMap[idx];

                var valueMax;
                var valueMin;
                if (this._useCustomizedSplit()) {
                    valueMax = this._splitList[idx].max;
                    valueMin = this._splitList[idx].min;
                } else {
                    valueMax = (this._colorList.length - idx) * this._gap + this.dataRangeOption.min;
                    valueMin = valueMax - this._gap;
                }

                this.messageCenter.dispatch(
                    ecConfig.EVENT.DATA_RANGE_SELECTED,
                    param.event, {
                        selected: this._selectedMap,
                        target: idx,
                        valueMax: valueMax,
                        valueMin: valueMin
                    },
                    this.myChart
                );

                this.messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this.myChart);
            },

            /**
             * 产生hover link事件
             */
            __dispatchHoverLink: function(param) {
                var valueMin;
                var valueMax;
                if (this.dataRangeOption.calculable) {
                    var totalValue = this.dataRangeOption.max - this.dataRangeOption.min;
                    var curValue;
                    if (this.dataRangeOption.orient == 'horizontal') {
                        curValue = (1 - (zrEvent.getX(param.event) - this._calculableLocation.x) / this._calculableLocation.width) * totalValue;
                    } else {
                        curValue = (1 - (zrEvent.getY(param.event) - this._calculableLocation.y) / this._calculableLocation.height) * totalValue;
                    }
                    valueMin = curValue - totalValue * 0.05;
                    valueMax = curValue + totalValue * 0.05;
                } else if (this._useCustomizedSplit()) {
                    var idx = param.target._idx;
                    valueMax = this._splitList[idx].max;
                    valueMin = this._splitList[idx].min;
                } else {
                    var idx = param.target._idx;
                    valueMax = (this._colorList.length - idx) * this._gap + this.dataRangeOption.min;
                    valueMin = valueMax - this._gap;
                }

                this.messageCenter.dispatch(
                    ecConfig.EVENT.DATA_RANGE_HOVERLINK,
                    param.event, {
                        valueMin: valueMin,
                        valueMax: valueMax
                    },
                    this.myChart
                );

                // console.log(param,curValue);
            },

            __onhoverlink: function(param) {
                if (this.dataRangeOption.show && this.dataRangeOption.hoverLink && this._indicatorShape && param && param.seriesIndex != null && param.dataIndex != null) {
                    var curValue = param.value;
                    if (curValue === '' || isNaN(curValue)) {
                        return;
                    }
                    if (curValue < this.dataRangeOption.min) {
                        curValue = this.dataRangeOption.min;
                    } else if (curValue > this.dataRangeOption.max) {
                        curValue = this.dataRangeOption.max;
                    }

                    if (this.dataRangeOption.orient == 'horizontal') {
                        this._indicatorShape.position = [
                            (this.dataRangeOption.max - curValue) / (this.dataRangeOption.max - this.dataRangeOption.min) * this._calculableLocation.width,
                            0
                        ];
                    } else {
                        this._indicatorShape.position = [
                            0, (this.dataRangeOption.max - curValue) / (this.dataRangeOption.max - this.dataRangeOption.min) * this._calculableLocation.height
                        ];
                    }
                    this._indicatorShape.style.text = this._textFormat(param.value);
                    this._indicatorShape.style.color = this.getColor(curValue);
                    this.zr.addHoverShape(this._indicatorShape);
                }
            },

            _textFormat: function(valueStart, valueEnd) {
                var dataRangeOption = this.dataRangeOption;
                if (valueStart !== -Number.MAX_VALUE) {
                    valueStart = (+valueStart).toFixed(dataRangeOption.precision);
                }
                if (valueEnd != null && valueEnd !== Number.MAX_VALUE) {
                    valueEnd = (+valueEnd).toFixed(dataRangeOption.precision);
                }
                if (dataRangeOption.formatter) {
                    if (typeof dataRangeOption.formatter == 'string') {
                        return dataRangeOption.formatter
                            .replace('{value}', valueStart === -Number.MAX_VALUE ? 'min' : valueStart)
                            .replace('{value2}', valueEnd === Number.MAX_VALUE ? 'max' : valueEnd);
                    } else if (typeof dataRangeOption.formatter == 'function') {
                        return dataRangeOption.formatter.call(
                            this.myChart, valueStart, valueEnd
                        );
                    }
                }

                if (valueEnd == null) {
                    return valueStart;
                } else {
                    if (valueStart === -Number.MAX_VALUE) {
                        return '< ' + valueEnd;
                    } else if (valueEnd === Number.MAX_VALUE) {
                        return '> ' + valueStart;
                    } else {
                        return valueStart + ' - ' + valueEnd;
                    }
                }
            },

            _isContinuity: function() {
                var dataRangeOption = this.dataRangeOption;
                return !(
                    dataRangeOption.splitList ? dataRangeOption.splitList.length > 0 : dataRangeOption.splitNumber > 0
                ) || dataRangeOption.calculable;
            },

            _useCustomizedSplit: function() {
                var dataRangeOption = this.dataRangeOption;
                return dataRangeOption.splitList && dataRangeOption.splitList.length > 0;
            },

            _buildColorList: function(splitNumber) {
                this._colorList = zrColor.getGradientColors(
                    this.dataRangeOption.color,
                    Math.max(
                        (splitNumber - this.dataRangeOption.color.length) / (this.dataRangeOption.color.length - 1),
                        0
                    ) + 1
                );

                if (this._colorList.length > splitNumber) {
                    var len = this._colorList.length;
                    var newColorList = [this._colorList[0]];
                    var step = len / (splitNumber - 1);
                    for (var i = 1; i < splitNumber - 1; i++) {
                        newColorList.push(this._colorList[Math.floor(i * step)]);
                    }
                    newColorList.push(this._colorList[len - 1]);
                    this._colorList = newColorList;
                }

                if (this._useCustomizedSplit()) {
                    var splitList = this._splitList;
                    for (var i = 0, len = splitList.length; i < len; i++) {
                        if (splitList[i].color) {
                            this._colorList[i] = splitList[i].color;
                        }
                    }
                }
                // console.log(this._colorList.length)
            },

            _buildGap: function(splitNumber) {
                if (!this._useCustomizedSplit()) {
                    var precision = this.dataRangeOption.precision;
                    this._gap = (this.dataRangeOption.max - this.dataRangeOption.min) / splitNumber;
                    while (this._gap.toFixed(precision) - 0 != this._gap && precision < 5) {
                        // 精度自适应
                        precision++;
                    }
                    this.dataRangeOption.precision = precision;

                    this._gap = (
                        (this.dataRangeOption.max - this.dataRangeOption.min) / splitNumber
                    ).toFixed(precision) - 0;
                }
            },

            _buildDataList: function(splitNumber) {
                var valueTextList = this._valueTextList = [];
                var dataRangeOption = this.dataRangeOption;
                var useCustomizedSplit = this._useCustomizedSplit();

                for (var i = 0; i < splitNumber; i++) {
                    this._selectedMap[i] = true;
                    var text = '';

                    if (useCustomizedSplit) {
                        var splitListItem = this._splitList[splitNumber - 1 - i];

                        if (splitListItem.label != null) {
                            text = splitListItem.label;
                        } else if (splitListItem.single != null) {
                            text = this._textFormat(splitListItem.single);
                        } else {
                            text = this._textFormat(splitListItem.min, splitListItem.max);
                        }
                    } else {
                        text = this._textFormat(
                            i * this._gap + dataRangeOption.min, (i + 1) * this._gap + dataRangeOption.min
                        );
                    }
                    valueTextList.unshift(text);
                }
            },

            _buildSplitList: function() {
                if (!this._useCustomizedSplit()) {
                    return;
                }
                var splitList = this.dataRangeOption.splitList;
                var splitRangeList = this._splitList = [];

                for (var i = 0, len = splitList.length; i < len; i++) {
                    var splitListItem = splitList[i];
                    if (!splitListItem || (splitListItem.start == null && splitListItem.end == null)) {
                        throw new Error('Empty item exists in splitList!');
                    }

                    var reformedItem = {
                        label: splitListItem.label,
                        color: splitListItem.color
                    };
                    reformedItem.min = splitListItem.start;
                    reformedItem.max = splitListItem.end;

                    if (reformedItem.min > reformedItem.max) { // Need to be exchanged
                        reformedItem.min = [reformedItem.max, reformedItem.max = reformedItem.min][0];
                    }
                    if (reformedItem.min === reformedItem.max) {
                        reformedItem.single = reformedItem.max; // Coresponding to single value
                    }
                    if (reformedItem.min == null) {
                        reformedItem.min = -Number.MAX_VALUE;
                    }
                    if (reformedItem.max == null) {
                        reformedItem.max = Number.MAX_VALUE;
                    }

                    splitRangeList.push(reformedItem);
                }
            },

            /**
             * 刷新
             */
            refresh: function(newOption) {
                if (newOption) {
                    this.option = newOption;
                    this.option.dataRange = this.reformOption(this.option.dataRange);
                    var dataRangeOption = this.dataRangeOption = this.option.dataRange;

                    if (!this._useCustomizedSplit() && (dataRangeOption.min == null || dataRangeOption.max == null)) {
                        throw new Error('option.dataRange.min or option.dataRange.max has not been defined.');
                    }

                    if (!this.myChart.canvasSupported) {
                        // 不支持Canvas的强制关闭实时动画
                        dataRangeOption.realtime = false;
                    }

                    var splitNumber = this._isContinuity() ? 100 : (this._useCustomizedSplit() ? dataRangeOption.splitList.length : dataRangeOption.splitNumber);

                    this._buildSplitList();
                    this._buildColorList(splitNumber);
                    this._buildGap(splitNumber);
                    this._buildDataList(splitNumber);
                }

                this.clear();
                this._buildShape();
            },

            getColor: function(value) {
                if (isNaN(value)) {
                    return null;
                }
                var idx;

                if (!this._useCustomizedSplit()) {
                    if (this.dataRangeOption.min == this.dataRangeOption.max) {
                        return this._colorList[0];
                    }

                    if (value < this.dataRangeOption.min) {
                        value = this.dataRangeOption.min;
                    } else if (value > this.dataRangeOption.max) {
                        value = this.dataRangeOption.max;
                    }

                    if (this.dataRangeOption.calculable) {
                        if (value - (this._gap * this._range.start + this.dataRangeOption.min) > 0.00005 || value - (this._gap * this._range.end + this.dataRangeOption.min) < -0.00005) {
                            return null;
                        }
                    }

                    idx = this._colorList.length - Math.ceil(
                        (value - this.dataRangeOption.min) / (this.dataRangeOption.max - this.dataRangeOption.min) * this._colorList.length
                    );
                    if (idx == this._colorList.length) {
                        idx--;
                    }
                } else {
                    var splitRangeList = this._splitList;
                    for (var i = 0, len = splitRangeList.length; i < len; i++) {
                        if (splitRangeList[i].min <= value && splitRangeList[i].max >= value) {
                            idx = i;
                            break;
                        }
                    }
                }

                //console.log(value, idx,this._colorList[idx])
                if (this._selectedMap[idx]) {
                    return this._colorList[idx];
                } else {
                    return null;
                }
            },

            getColorByIndex: function(idx) {
                if (idx >= this._colorList.length) {
                    idx = this._colorList.length - 1;
                } else if (idx < 0) {
                    idx = 0;
                }
                return this._colorList[idx];
            },

            /**
             * 释放后实例不可用
             */
            onbeforDispose: function() {
                this.messageCenter.unbind(ecConfig.EVENT.HOVER, this._onhoverlink);
            }
        };

        zrUtil.inherits(DataRange, Base);

        require('../component').define('dataRange', DataRange);

        return DataRange;
    });
    define('echarts/echarts', ['require', './config', 'zrender/tool/util', 'zrender/tool/event', 'zrender/tool/env', 'zrender', 'zrender/config', './chart/island', './component/toolbox', './component', './component/title', './component/tooltip', './component/legend', './util/ecData', './chart', 'zrender/tool/color', './component/timeline', 'zrender/shape/Image', 'zrender/loadingEffect/Bar', 'zrender/loadingEffect/Bubble', 'zrender/loadingEffect/DynamicLine', 'zrender/loadingEffect/Ring', 'zrender/loadingEffect/Spin', 'zrender/loadingEffect/Whirling', './theme/macarons', './theme/infographic'], function(require) {
        var ecConfig = require('./config');
        var zrUtil = require('zrender/tool/util');
        var zrEvent = require('zrender/tool/event');

        var self = {};

        var _canvasSupported = require('zrender/tool/env').canvasSupported;
        var _idBase = new Date() - 0;
        var _instances = {}; // ECharts实例map索引
        var DOM_ATTRIBUTE_KEY = '_echarts_instance_';

        self.version = '2.2.6';
        self.dependencies = {
            zrender: '2.1.1'
        };
        /**
         * 入口方法
         */
        self.init = function(dom, theme) {
            var zrender = require('zrender');
            if ((zrender.version.replace('.', '') - 0) < (self.dependencies.zrender.replace('.', '') - 0)) {
                console.error(
                    'ZRender ' + zrender.version + ' is too old for ECharts ' + self.version + '. Current version need ZRender ' + self.dependencies.zrender + '+'
                );
            }

            dom = dom instanceof Array ? dom[0] : dom;

            // dom与echarts实例映射索引
            var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
            if (!key) {
                key = _idBase++;
                dom.setAttribute(DOM_ATTRIBUTE_KEY, key);
            }

            if (_instances[key]) {
                // 同一个dom上多次init，自动释放已有实例
                _instances[key].dispose();
            }
            _instances[key] = new Echarts(dom);
            _instances[key].id = key;
            _instances[key].canvasSupported = _canvasSupported;
            _instances[key].setTheme(theme);

            return _instances[key];
        };

        /**
         * 通过id获得ECharts实例，id可在实例化后读取
         */
        self.getInstanceById = function(key) {
            return _instances[key];
        };

        /**
         * 消息中心
         */
        function MessageCenter() {
            zrEvent.Dispatcher.call(this);
        }
        zrUtil.merge(MessageCenter.prototype, zrEvent.Dispatcher.prototype, true);

        /**
         * 基于zrender实现Echarts接口层
         * @param {HtmlElement} dom 必要
         */
        function Echarts(dom) {
            // Fxxk IE11 for breaking initialization without a warrant;
            // Just set something to let it be!
            // by kener 2015-01-09
            dom.innerHTML = '';
            this._themeConfig = {}; // zrUtil.clone(ecConfig);

            this.dom = dom;
            // this._zr;
            // this._option;                    // curOption clone
            // this._optionRestore;             // for restore;
            // this._island;
            // this._toolbox;
            // this._timeline;
            // this._refreshInside;             // 内部刷新标志位

            this._connected = false;
            this._status = { // 用于图表间通信
                dragIn: false,
                dragOut: false,
                needRefresh: false
            };
            this._curEventType = false; // 破循环信号灯
            this._chartList = []; // 图表实例

            this._messageCenter = new MessageCenter();

            this._messageCenterOutSide = new MessageCenter(); // Echarts层的外部消息中心，做Echarts层的消息转发

            // resize方法经常被绑定到window.resize上，闭包一个this
            this.resize = this.resize();

            // 初始化::构造函数
            this._init();
        }

        /**
         * ZRender EVENT
         *
         * @inner
         * @const
         * @type {Object}
         */
        var ZR_EVENT = require('zrender/config').EVENT;

        /**
         * 要绑定监听的zrender事件列表
         *
         * @const
         * @inner
         * @type {Array}
         */
        var ZR_EVENT_LISTENS = [
            'CLICK', 'DBLCLICK', 'MOUSEOVER', 'MOUSEOUT',
            'DRAGSTART', 'DRAGEND', 'DRAGENTER', 'DRAGOVER', 'DRAGLEAVE', 'DROP'
        ];

        /**
         * 对echarts的实例中的chartList属性成员，逐个进行方法调用，遍历顺序为逆序
         * 由于在事件触发的默认行为处理中，多次用到相同逻辑，所以抽象了该方法
         * 由于所有的调用场景里，最多只有两个参数，基于性能和体积考虑，这里就不使用call或者apply了
         *
         * @inner
         * @param {ECharts} ecInstance ECharts实例
         * @param {string} methodName 要调用的方法名
         * @param {*} arg0 调用参数1
         * @param {*} arg1 调用参数2
         * @param {*} arg2 调用参数3
         */
        function callChartListMethodReverse(ecInstance, methodName, arg0, arg1, arg2) {
            var chartList = ecInstance._chartList;
            var len = chartList.length;

            while (len--) {
                var chart = chartList[len];
                if (typeof chart[methodName] === 'function') {
                    chart[methodName](arg0, arg1, arg2);
                }
            }
        }

        Echarts.prototype = {
            /**
             * 初始化::构造函数
             */
            _init: function() {
                var self = this;
                var _zr = require('zrender').init(this.dom);
                this._zr = _zr;

                // wrap: n,e,d,t for name event data this
                this._messageCenter.dispatch = function(type, event, eventPackage, that) {
                    eventPackage = eventPackage || {};
                    eventPackage.type = type;
                    eventPackage.event = event;

                    self._messageCenter.dispatchWithContext(type, eventPackage, that);
                    self._messageCenterOutSide.dispatchWithContext(type, eventPackage, that);

                    // 如下注掉的代码，@see: https://github.com/ecomfe/echarts-discuss/issues/3
                    // if (type != 'HOVER' && type != 'MOUSEOUT') {    // 频繁事件直接抛出
                    //     setTimeout(function(){
                    //         self._messageCenterOutSide.dispatchWithContext(
                    //             type, eventPackage, that
                    //         );
                    //     },50);
                    // }
                    // else {
                    //     self._messageCenterOutSide.dispatchWithContext(
                    //         type, eventPackage, that
                    //     );
                    // }
                };

                this._onevent = function(param) {
                    return self.__onevent(param);
                };
                for (var e in ecConfig.EVENT) {
                    if (e != 'CLICK' && e != 'DBLCLICK' && e != 'HOVER' && e != 'MOUSEOUT' && e != 'MAP_ROAM') {
                        this._messageCenter.bind(ecConfig.EVENT[e], this._onevent, this);
                    }
                }


                var eventBehaviors = {};
                this._onzrevent = function(param) {
                    return self[eventBehaviors[param.type]](param);
                };

                // 挂载关心的事件
                for (var i = 0, len = ZR_EVENT_LISTENS.length; i < len; i++) {
                    var eventName = ZR_EVENT_LISTENS[i];
                    var eventValue = ZR_EVENT[eventName];
                    eventBehaviors[eventValue] = '_on' + eventName.toLowerCase();
                    _zr.on(eventValue, this._onzrevent);
                }

                this.chart = {}; // 图表索引
                this.component = {}; // 组件索引

                // 内置图表
                // 孤岛
                var Island = require('./chart/island');
                this._island = new Island(this._themeConfig, this._messageCenter, _zr, {}, this);
                this.chart.island = this._island;

                // 内置通用组件
                // 工具箱
                var Toolbox = require('./component/toolbox');
                this._toolbox = new Toolbox(this._themeConfig, this._messageCenter, _zr, {}, this);
                this.component.toolbox = this._toolbox;

                var componentLibrary = require('./component');
                componentLibrary.define('title', require('./component/title'));
                componentLibrary.define('tooltip', require('./component/tooltip'));
                componentLibrary.define('legend', require('./component/legend'));

                if (_zr.getWidth() === 0 || _zr.getHeight() === 0) {
                    console.error('Dom’s width & height should be ready before init.');
                }
            },

            /**
             * ECharts事件处理中心
             */
            __onevent: function(param) {
                param.__echartsId = param.__echartsId || this.id;

                // 来自其他联动图表的事件
                var fromMyself = (param.__echartsId === this.id);

                if (!this._curEventType) {
                    this._curEventType = param.type;
                }

                switch (param.type) {
                    case ecConfig.EVENT.LEGEND_SELECTED:
                        this._onlegendSelected(param);
                        break;
                    case ecConfig.EVENT.DATA_ZOOM:
                        if (!fromMyself) {
                            var dz = this.component.dataZoom;
                            if (dz) {
                                dz.silence(true);
                                dz.absoluteZoom(param.zoom);
                                dz.silence(false);
                            }
                        }
                        this._ondataZoom(param);
                        break;
                    case ecConfig.EVENT.DATA_RANGE:
                        fromMyself && this._ondataRange(param);
                        break;
                    case ecConfig.EVENT.MAGIC_TYPE_CHANGED:
                        if (!fromMyself) {
                            var tb = this.component.toolbox;
                            if (tb) {
                                tb.silence(true);
                                tb.setMagicType(param.magicType);
                                tb.silence(false);
                            }
                        }
                        this._onmagicTypeChanged(param);
                        break;
                    case ecConfig.EVENT.DATA_VIEW_CHANGED:
                        fromMyself && this._ondataViewChanged(param);
                        break;
                    case ecConfig.EVENT.TOOLTIP_HOVER:
                        fromMyself && this._tooltipHover(param);
                        break;
                    case ecConfig.EVENT.RESTORE:
                        this._onrestore();
                        break;
                    case ecConfig.EVENT.REFRESH:
                        fromMyself && this._onrefresh(param);
                        break;
                        // 鼠标同步
                    case ecConfig.EVENT.TOOLTIP_IN_GRID:
                    case ecConfig.EVENT.TOOLTIP_OUT_GRID:
                        if (!fromMyself) {
                            // 只处理来自外部的鼠标同步
                            var grid = this.component.grid;
                            if (grid) {
                                this._zr.trigger(
                                    'mousemove', {
                                        connectTrigger: true,
                                        zrenderX: grid.getX() + param.x * grid.getWidth(),
                                        zrenderY: grid.getY() + param.y * grid.getHeight()
                                    }
                                );
                            }
                        } else if (this._connected) {
                            // 来自自己，并且存在多图联动，空间坐标映射修改参数分发
                            var grid = this.component.grid;
                            if (grid) {
                                param.x = (param.event.zrenderX - grid.getX()) / grid.getWidth();
                                param.y = (param.event.zrenderY - grid.getY()) / grid.getHeight();
                            }
                        }
                        break;
                        /*
                        case ecConfig.EVENT.RESIZE :
                        case ecConfig.EVENT.DATA_CHANGED :
                        case ecConfig.EVENT.PIE_SELECTED :
                        case ecConfig.EVENT.MAP_SELECTED :
                            break;
                        */
                }

                // 多图联动，只做自己的一级事件分发，避免级联事件循环
                if (this._connected && fromMyself && this._curEventType === param.type) {
                    for (var c in this._connected) {
                        this._connected[c].connectedEventHandler(param);
                    }
                    // 分发完毕后复位
                    this._curEventType = null;
                }

                if (!fromMyself || (!this._connected && fromMyself)) { // 处理了完联动事件复位
                    this._curEventType = null;
                }
            },

            /**
             * 点击事件，响应zrender事件，包装后分发到Echarts层
             */
            _onclick: function(param) {
                callChartListMethodReverse(this, 'onclick', param);

                if (param.target) {
                    var ecData = this._eventPackage(param.target);
                    if (ecData && ecData.seriesIndex != null) {
                        this._messageCenter.dispatch(
                            ecConfig.EVENT.CLICK,
                            param.event,
                            ecData,
                            this
                        );
                    }
                }
            },

            /**
             * 双击事件，响应zrender事件，包装后分发到Echarts层
             */
            _ondblclick: function(param) {
                callChartListMethodReverse(this, 'ondblclick', param);

                if (param.target) {
                    var ecData = this._eventPackage(param.target);
                    if (ecData && ecData.seriesIndex != null) {
                        this._messageCenter.dispatch(
                            ecConfig.EVENT.DBLCLICK,
                            param.event,
                            ecData,
                            this
                        );
                    }
                }
            },

            /**
             * 鼠标移入事件，响应zrender事件，包装后分发到Echarts层
             */
            _onmouseover: function(param) {
                if (param.target) {
                    var ecData = this._eventPackage(param.target);
                    if (ecData && ecData.seriesIndex != null) {
                        this._messageCenter.dispatch(
                            ecConfig.EVENT.HOVER,
                            param.event,
                            ecData,
                            this
                        );
                    }
                }
            },

            /**
             * 鼠标移出事件，响应zrender事件，包装后分发到Echarts层
             */
            _onmouseout: function(param) {
                if (param.target) {
                    var ecData = this._eventPackage(param.target);
                    if (ecData && ecData.seriesIndex != null) {
                        this._messageCenter.dispatch(
                            ecConfig.EVENT.MOUSEOUT,
                            param.event,
                            ecData,
                            this
                        );
                    }
                }
            },

            /**
             * dragstart回调，可计算特性实现
             */
            _ondragstart: function(param) {
                // 复位用于图表间通信拖拽标识
                this._status = {
                    dragIn: false,
                    dragOut: false,
                    needRefresh: false
                };

                callChartListMethodReverse(this, 'ondragstart', param);
            },

            /**
             * dragging回调，可计算特性实现
             */
            _ondragenter: function(param) {
                callChartListMethodReverse(this, 'ondragenter', param);
            },

            /**
             * dragstart回调，可计算特性实现
             */
            _ondragover: function(param) {
                callChartListMethodReverse(this, 'ondragover', param);
            },

            /**
             * dragstart回调，可计算特性实现
             */
            _ondragleave: function(param) {
                callChartListMethodReverse(this, 'ondragleave', param);
            },

            /**
             * dragstart回调，可计算特性实现
             */
            _ondrop: function(param) {
                callChartListMethodReverse(this, 'ondrop', param, this._status);
                this._island.ondrop(param, this._status);
            },

            /**
             * dragdone回调 ，可计算特性实现
             */
            _ondragend: function(param) {
                callChartListMethodReverse(this, 'ondragend', param, this._status);

                this._timeline && this._timeline.ondragend(param, this._status);
                this._island.ondragend(param, this._status);

                // 发生过重计算
                if (this._status.needRefresh) {
                    this._syncBackupData(this._option);

                    var messageCenter = this._messageCenter;
                    messageCenter.dispatch(
                        ecConfig.EVENT.DATA_CHANGED,
                        param.event,
                        this._eventPackage(param.target),
                        this
                    );
                    messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
                }
            },

            /**
             * 图例选择响应
             */
            _onlegendSelected: function(param) {
                // 用于图表间通信
                this._status.needRefresh = false;
                callChartListMethodReverse(this, 'onlegendSelected', param, this._status);

                if (this._status.needRefresh) {
                    this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
                }
            },

            /**
             * 数据区域缩放响应
             */
            _ondataZoom: function(param) {
                // 用于图表间通信
                this._status.needRefresh = false;
                callChartListMethodReverse(this, 'ondataZoom', param, this._status);

                if (this._status.needRefresh) {
                    this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
                }
            },

            /**
             * 值域漫游响应
             */
            _ondataRange: function(param) {
                this._clearEffect();
                // 用于图表间通信
                this._status.needRefresh = false;
                callChartListMethodReverse(this, 'ondataRange', param, this._status);

                // 没有相互影响，直接刷新即可
                if (this._status.needRefresh) {
                    this._zr.refreshNextFrame();
                }
            },

            /**
             * 动态类型切换响应
             */
            _onmagicTypeChanged: function() {
                this._clearEffect();
                this._render(this._toolbox.getMagicOption());
            },

            /**
             * 数据视图修改响应
             */
            _ondataViewChanged: function(param) {
                this._syncBackupData(param.option);
                this._messageCenter.dispatch(
                    ecConfig.EVENT.DATA_CHANGED,
                    null,
                    param,
                    this
                );
                this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            },

            /**
             * tooltip与图表间通信
             */
            _tooltipHover: function(param) {
                var tipShape = [];
                callChartListMethodReverse(this, 'ontooltipHover', param, tipShape);
            },

            /**
             * 还原
             */
            _onrestore: function() {
                this.restore();
            },

            /**
             * 刷新
             */
            _onrefresh: function(param) {
                this._refreshInside = true;
                this.refresh(param);
                this._refreshInside = false;
            },

            /**
             * 数据修改后的反向同步dataZoom持有的备份数据
             */
            _syncBackupData: function(curOption) {
                this.component.dataZoom && this.component.dataZoom.syncBackupData(curOption);
            },

            /**
             * 打包Echarts层的事件附件
             */
            _eventPackage: function(target) {
                if (target) {
                    var ecData = require('./util/ecData');

                    var seriesIndex = ecData.get(target, 'seriesIndex');
                    var dataIndex = ecData.get(target, 'dataIndex');

                    dataIndex = seriesIndex != -1 && this.component.dataZoom ? this.component.dataZoom.getRealDataIndex(
                        seriesIndex,
                        dataIndex
                    ) : dataIndex;
                    return {
                        seriesIndex: seriesIndex,
                        seriesName: (ecData.get(target, 'series') || {}).name,
                        dataIndex: dataIndex,
                        data: ecData.get(target, 'data'),
                        name: ecData.get(target, 'name'),
                        value: ecData.get(target, 'value'),
                        special: ecData.get(target, 'special')
                    };
                }
                return;
            },

            _noDataCheck: function(magicOption) {
                var series = magicOption.series;

                for (var i = 0, l = series.length; i < l; i++) {
                    if (series[i].type == ecConfig.CHART_TYPE_MAP || (series[i].data && series[i].data.length > 0) || (series[i].markPoint && series[i].markPoint.data && series[i].markPoint.data.length > 0) || (series[i].markLine && series[i].markLine.data && series[i].markLine.data.length > 0) || (series[i].nodes && series[i].nodes.length > 0) || (series[i].links && series[i].links.length > 0) || (series[i].matrix && series[i].matrix.length > 0) || (series[i].eventList && series[i].eventList.length > 0)) {
                        return false; // 存在任意数据则为非空数据
                    }
                }
                var loadOption = (this._option && this._option.noDataLoadingOption) || this._themeConfig.noDataLoadingOption || ecConfig.noDataLoadingOption || {
                    text: (this._option && this._option.noDataText) || this._themeConfig.noDataText || ecConfig.noDataText,
                    effect: (this._option && this._option.noDataEffect) || this._themeConfig.noDataEffect || ecConfig.noDataEffect
                };
                // 空数据
                this.clear();
                this.showLoading(loadOption);
                return true;
            },

            /**
             * 图表渲染
             */
            _render: function(magicOption) {
                this._mergeGlobalConifg(magicOption);

                if (this._noDataCheck(magicOption)) {
                    return;
                }

                var bgColor = magicOption.backgroundColor;
                if (bgColor) {
                    if (!_canvasSupported && bgColor.indexOf('rgba') != -1) {
                        // IE6~8对RGBA的处理，filter会带来其他颜色的影响
                        var cList = bgColor.split(',');
                        this.dom.style.filter = 'alpha(opacity=' +
                            cList[3].substring(0, cList[3].lastIndexOf(')')) * 100 + ')';
                        cList.length = 3;
                        cList[0] = cList[0].replace('a', '');
                        this.dom.style.backgroundColor = cList.join(',') + ')';
                    } else {
                        this.dom.style.backgroundColor = bgColor;
                    }
                }

                this._zr.clearAnimation();
                this._chartList = [];

                var chartLibrary = require('./chart');
                var componentLibrary = require('./component');

                if (magicOption.xAxis || magicOption.yAxis) {
                    magicOption.grid = magicOption.grid || {};
                    magicOption.dataZoom = magicOption.dataZoom || {};
                }

                var componentList = [
                    'title', 'legend', 'tooltip', 'dataRange', 'roamController',
                    'grid', 'dataZoom', 'xAxis', 'yAxis', 'polar'
                ];

                var ComponentClass;
                var componentType;
                var component;
                for (var i = 0, l = componentList.length; i < l; i++) {
                    componentType = componentList[i];
                    component = this.component[componentType];

                    if (magicOption[componentType]) {
                        if (component) {
                            component.refresh && component.refresh(magicOption);
                        } else {
                            ComponentClass = componentLibrary.get(
                                /^[xy]Axis$/.test(componentType) ? 'axis' : componentType
                            );
                            component = new ComponentClass(
                                this._themeConfig, this._messageCenter, this._zr,
                                magicOption, this, componentType
                            );
                            this.component[componentType] = component;
                        }
                        this._chartList.push(component);
                    } else if (component) {
                        component.dispose();
                        this.component[componentType] = null;
                        delete this.component[componentType];
                    }
                }

                var ChartClass;
                var chartType;
                var chart;
                var chartMap = {}; // 记录已经初始化的图表
                for (var i = 0, l = magicOption.series.length; i < l; i++) {
                    chartType = magicOption.series[i].type;
                    if (!chartType) {
                        console.error('series[' + i + '] chart type has not been defined.');
                        continue;
                    }

                    if (!chartMap[chartType]) {
                        chartMap[chartType] = true;
                        ChartClass = chartLibrary.get(chartType);
                        if (ChartClass) {
                            if (this.chart[chartType]) {
                                chart = this.chart[chartType];
                                chart.refresh(magicOption);
                            } else {
                                chart = new ChartClass(
                                    this._themeConfig, this._messageCenter, this._zr,
                                    magicOption, this
                                );
                            }
                            this._chartList.push(chart);
                            this.chart[chartType] = chart;
                        } else {
                            console.error(chartType + ' has not been required.');
                        }
                    }
                }

                // 已有实例但新option不带这类图表的实例释放
                for (chartType in this.chart) {
                    if (chartType != ecConfig.CHART_TYPE_ISLAND && !chartMap[chartType]) {
                        this.chart[chartType].dispose();
                        this.chart[chartType] = null;
                        delete this.chart[chartType];
                    }
                }

                this.component.grid && this.component.grid.refixAxisShape(this.component);

                this._island.refresh(magicOption);
                this._toolbox.refresh(magicOption);

                magicOption.animation && !magicOption.renderAsImage ? this._zr.refresh() : this._zr.render();

                var imgId = 'IMG' + this.id;
                var img = document.getElementById(imgId);
                if (magicOption.renderAsImage && _canvasSupported) {
                    // IE8- 不支持图片渲染形式
                    if (img) {
                        // 已经渲染过则更新显示
                        img.src = this.getDataURL(magicOption.renderAsImage);
                    } else {
                        // 没有渲染过插入img dom
                        img = this.getImage(magicOption.renderAsImage);
                        img.id = imgId;
                        img.style.position = 'absolute';
                        img.style.left = 0;
                        img.style.top = 0;
                        this.dom.firstChild.appendChild(img);
                    }
                    this.un();
                    this._zr.un();
                    this._disposeChartList();
                    this._zr.clear();
                } else if (img) {
                    // 删除可能存在的img
                    img.parentNode.removeChild(img);
                }
                img = null;

                this._option = magicOption;
            },

            /**
             * 还原
             */
            restore: function() {
                this._clearEffect();
                this._option = zrUtil.clone(this._optionRestore);
                this._disposeChartList();
                this._island.clear();
                this._toolbox.reset(this._option, true);
                this._render(this._option);
            },

            /**
             * 刷新
             * @param {Object=} param，可选参数，用于附带option，内部同步用，外部不建议带入数据修改，无法同步
             */
            refresh: function(param) {
                this._clearEffect();
                param = param || {};
                var magicOption = param.option;

                // 外部调用的refresh且有option带入
                if (!this._refreshInside && magicOption) {
                    // 做简单的差异合并去同步内部持有的数据克隆，不建议带入数据
                    // 开启数据区域缩放、拖拽重计算、数据视图可编辑模式情况下，当用户产生了数据变化后无法同步
                    // 如有带入option存在数据变化，请重新setOption
                    magicOption = this.getOption();
                    zrUtil.merge(magicOption, param.option, true);
                    zrUtil.merge(this._optionRestore, param.option, true);
                    this._toolbox.reset(magicOption);
                }

                this._island.refresh(magicOption);
                this._toolbox.refresh(magicOption);

                // 停止动画
                this._zr.clearAnimation();
                // 先来后到，安顺序刷新各种图表，图表内部refresh优化检查magicOption，无需更新则不更新~
                for (var i = 0, l = this._chartList.length; i < l; i++) {
                    this._chartList[i].refresh && this._chartList[i].refresh(magicOption);
                }
                this.component.grid && this.component.grid.refixAxisShape(this.component);
                this._zr.refresh();
            },

            /**
             * 释放图表实例
             */
            _disposeChartList: function() {
                this._clearEffect();

                // 停止动画
                this._zr.clearAnimation();

                var len = this._chartList.length;
                while (len--) {
                    var chart = this._chartList[len];

                    if (chart) {
                        var chartType = chart.type;
                        this.chart[chartType] && delete this.chart[chartType];
                        this.component[chartType] && delete this.component[chartType];
                        chart.dispose && chart.dispose();
                    }
                }

                this._chartList = [];
            },

            /**
             * 非图表全局属性merge~~
             */
            _mergeGlobalConifg: function(magicOption) {
                var mergeList = [
                    // 背景颜色
                    'backgroundColor',

                    // 拖拽重计算相关
                    'calculable', 'calculableColor', 'calculableHolderColor',

                    // 孤岛显示连接符
                    'nameConnector', 'valueConnector',

                    // 动画相关
                    'animation', 'animationThreshold',
                    'animationDuration', 'animationDurationUpdate',
                    'animationEasing', 'addDataAnimation',

                    // 默认标志图形类型列表
                    'symbolList',

                    // 降低图表内元素拖拽敏感度，单位ms，不建议外部干预
                    'DRAG_ENABLE_TIME'
                ];

                var len = mergeList.length;
                while (len--) {
                    var mergeItem = mergeList[len];
                    if (magicOption[mergeItem] == null) {
                        magicOption[mergeItem] = this._themeConfig[mergeItem] != null ? this._themeConfig[mergeItem] : ecConfig[mergeItem];
                    }
                }

                // 数值系列的颜色列表，不传则采用内置颜色，可配数组，借用zrender实例注入，会有冲突风险，先这样
                var themeColor = magicOption.color;
                if (!(themeColor && themeColor.length)) {
                    themeColor = this._themeConfig.color || ecConfig.color;
                }

                this._zr.getColor = function(idx) {
                    var zrColor = require('zrender/tool/color');
                    return zrColor.getColor(idx, themeColor);
                };

                if (!_canvasSupported) {
                    // 不支持Canvas的强制关闭动画
                    magicOption.animation = false;
                    magicOption.addDataAnimation = false;
                }
            },

            /**
             * 万能接口，配置图表实例任何可配置选项，多次调用时option选项做merge处理
             * @param {Object} option
             * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
             *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并
             */
            setOption: function(option, notMerge) {
                if (!option.timeline) {
                    return this._setOption(option, notMerge);
                } else {
                    return this._setTimelineOption(option);
                }
            },

            /**
             * 万能接口，配置图表实例任何可配置选项，多次调用时option选项做merge处理
             * @param {Object} option
             * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
             *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并
             * @param {boolean=} 默认false。keepTimeLine 表示从timeline组件调用而来，
             *                   表示当前行为是timeline的数据切换，保持timeline，
             *                   反之销毁timeline。 详见Issue #1601
             */
            _setOption: function(option, notMerge, keepTimeLine) {
                if (!notMerge && this._option) {
                    this._option = zrUtil.merge(
                        this.getOption(),
                        zrUtil.clone(option),
                        true
                    );
                } else {
                    this._option = zrUtil.clone(option);
                    !keepTimeLine && this._timeline && this._timeline.dispose();
                }

                this._optionRestore = zrUtil.clone(this._option);

                if (!this._option.series || this._option.series.length === 0) {
                    this._zr.clear();
                    return;
                }

                if (this.component.dataZoom // 存在dataZoom控件
                    && (this._option.dataZoom // 并且新option也存在
                        || (this._option.toolbox && this._option.toolbox.feature && this._option.toolbox.feature.dataZoom && this._option.toolbox.feature.dataZoom.show)
                    )
                ) {
                    // dataZoom同步数据
                    this.component.dataZoom.syncOption(this._option);
                }
                this._toolbox.reset(this._option);
                this._render(this._option);
                return this;
            },

            /**
             * 返回内部持有的当前显示option克隆
             */
            getOption: function() {
                var magicOption = zrUtil.clone(this._option);

                var self = this;

                function restoreOption(prop) {
                    var restoreSource = self._optionRestore[prop];

                    if (restoreSource) {
                        if (restoreSource instanceof Array) {
                            var len = restoreSource.length;
                            while (len--) {
                                magicOption[prop][len].data = zrUtil.clone(
                                    restoreSource[len].data
                                );
                            }
                        } else {
                            magicOption[prop].data = zrUtil.clone(restoreSource.data);
                        }
                    }
                }

                // 横轴数据还原
                restoreOption('xAxis');

                // 纵轴数据还原
                restoreOption('yAxis');

                // 系列数据还原
                restoreOption('series');

                return magicOption;
            },

            /**
             * 数据设置快捷接口
             * @param {Array} series
             * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
             *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并。
             */
            setSeries: function(series, notMerge) {
                if (!notMerge) {
                    this.setOption({
                        series: series
                    });
                } else {
                    this._option.series = series;
                    this.setOption(this._option, notMerge);
                }
                return this;
            },

            /**
             * 返回内部持有的当前显示series克隆
             */
            getSeries: function() {
                return this.getOption().series;
            },

            /**
             * timelineOption接口，配置图表实例任何可配置选项
             * @param {Object} option
             */
            _setTimelineOption: function(option) {
                this._timeline && this._timeline.dispose();
                var Timeline = require('./component/timeline');
                var timeline = new Timeline(
                    this._themeConfig, this._messageCenter, this._zr, option, this
                );
                this._timeline = timeline;
                this.component.timeline = this._timeline;

                return this;
            },

            /**
             * 动态数据添加
             * 形参为单组数据参数，多组时为数据，内容同[seriesIdx, data, isShift, additionData]
             * @param {number} seriesIdx 系列索引
             * @param {number | Object} data 增加数据
             * @param {boolean=} isHead 是否队头加入，默认，不指定或false时为队尾插入
             * @param {boolean=} dataGrow 是否增长数据队列长度，默认，不指定或false时移出目标数组对位数据
             * @param {string=} additionData 是否增加类目轴(饼图为图例)数据，附加操作同isHead和dataGrow
             */
            addData: function(seriesIdx, data, isHead, dataGrow, additionData) {
                var params = seriesIdx instanceof Array ? seriesIdx : [
                    [seriesIdx, data, isHead, dataGrow, additionData]
                ];

                //this._optionRestore 和 magicOption 都要同步
                var magicOption = this.getOption();
                var optionRestore = this._optionRestore;
                var self = this;
                for (var i = 0, l = params.length; i < l; i++) {
                    seriesIdx = params[i][0];
                    data = params[i][1];
                    isHead = params[i][2];
                    dataGrow = params[i][3];
                    additionData = params[i][4];

                    var seriesItem = optionRestore.series[seriesIdx];
                    var inMethod = isHead ? 'unshift' : 'push';
                    var outMethod = isHead ? 'pop' : 'shift';
                    if (seriesItem) {
                        var seriesItemData = seriesItem.data;
                        var mSeriesItemData = magicOption.series[seriesIdx].data;

                        seriesItemData[inMethod](data);
                        mSeriesItemData[inMethod](data);
                        if (!dataGrow) {
                            seriesItemData[outMethod]();
                            data = mSeriesItemData[outMethod]();
                        }

                        if (additionData != null) {
                            var legend;
                            var legendData;

                            if (seriesItem.type === ecConfig.CHART_TYPE_PIE && (legend = optionRestore.legend) && (legendData = legend.data)) {
                                var mLegendData = magicOption.legend.data;
                                legendData[inMethod](additionData);
                                mLegendData[inMethod](additionData);

                                if (!dataGrow) {
                                    var legendDataIdx = zrUtil.indexOf(legendData, data.name);
                                    legendDataIdx != -1 && legendData.splice(legendDataIdx, 1);

                                    legendDataIdx = zrUtil.indexOf(mLegendData, data.name);
                                    legendDataIdx != -1 && mLegendData.splice(legendDataIdx, 1);
                                }
                            } else if (optionRestore.xAxis != null && optionRestore.yAxis != null) {
                                // x轴类目
                                var axisData;
                                var mAxisData;
                                var axisIdx = seriesItem.xAxisIndex || 0;

                                if (optionRestore.xAxis[axisIdx].type == null || optionRestore.xAxis[axisIdx].type === 'category') {
                                    axisData = optionRestore.xAxis[axisIdx].data;
                                    mAxisData = magicOption.xAxis[axisIdx].data;

                                    axisData[inMethod](additionData);
                                    mAxisData[inMethod](additionData);
                                    if (!dataGrow) {
                                        axisData[outMethod]();
                                        mAxisData[outMethod]();
                                    }
                                }

                                // y轴类目
                                axisIdx = seriesItem.yAxisIndex || 0;
                                if (optionRestore.yAxis[axisIdx].type === 'category') {
                                    axisData = optionRestore.yAxis[axisIdx].data;
                                    mAxisData = magicOption.yAxis[axisIdx].data;

                                    axisData[inMethod](additionData);
                                    mAxisData[inMethod](additionData);
                                    if (!dataGrow) {
                                        axisData[outMethod]();
                                        mAxisData[outMethod]();
                                    }
                                }
                            }
                        }

                        // 同步图表内状态，动画需要
                        this._option.series[seriesIdx].data = magicOption.series[seriesIdx].data;
                    }
                }

                this._zr.clearAnimation();
                var chartList = this._chartList;
                var chartAnimationCount = 0;
                var chartAnimationDone = function() {
                    chartAnimationCount--;
                    if (chartAnimationCount === 0) {
                        animationDone();
                    }
                };
                for (var i = 0, l = chartList.length; i < l; i++) {
                    if (magicOption.addDataAnimation && chartList[i].addDataAnimation) {
                        chartAnimationCount++;
                        chartList[i].addDataAnimation(params, chartAnimationDone);
                    }
                }

                // dataZoom同步数据
                this.component.dataZoom && this.component.dataZoom.syncOption(magicOption);

                this._option = magicOption;

                function animationDone() {
                    if (!self._zr) {
                        return; // 已经被释放
                    }
                    self._zr.clearAnimation();
                    for (var i = 0, l = chartList.length; i < l; i++) {
                        // 有addData动画就去掉过渡动画
                        chartList[i].motionlessOnce =
                            magicOption.addDataAnimation && chartList[i].addDataAnimation;
                    }
                    self._messageCenter.dispatch(
                        ecConfig.EVENT.REFRESH,
                        null, {
                            option: magicOption
                        },
                        self
                    );
                }

                if (!magicOption.addDataAnimation) {
                    setTimeout(animationDone, 0);
                }
                return this;
            },

            /**
             * 动态[标注 | 标线]添加
             * @param {number} seriesIdx 系列索引
             * @param {Object} markData [标注 | 标线]对象，支持多个
             */
            addMarkPoint: function(seriesIdx, markData) {
                return this._addMark(seriesIdx, markData, 'markPoint');
            },

            addMarkLine: function(seriesIdx, markData) {
                return this._addMark(seriesIdx, markData, 'markLine');
            },

            _addMark: function(seriesIdx, markData, markType) {
                var series = this._option.series;
                var seriesItem;

                if (series && (seriesItem = series[seriesIdx])) {
                    var seriesR = this._optionRestore.series;
                    var seriesRItem = seriesR[seriesIdx];
                    var markOpt = seriesItem[markType];
                    var markOptR = seriesRItem[markType];

                    markOpt = seriesItem[markType] = markOpt || {
                        data: []
                    };
                    markOptR = seriesRItem[markType] = markOptR || {
                        data: []
                    };

                    for (var key in markData) {
                        if (key === 'data') {
                            // 数据concat
                            markOpt.data = markOpt.data.concat(markData.data);
                            markOptR.data = markOptR.data.concat(markData.data);
                        } else if (typeof markData[key] != 'object' || markOpt[key] == null) {
                            // 简单类型或新值直接赋值
                            markOpt[key] = markOptR[key] = markData[key];
                        } else {
                            // 非数据的复杂对象merge
                            zrUtil.merge(markOpt[key], markData[key], true);
                            zrUtil.merge(markOptR[key], markData[key], true);
                        }
                    }

                    var chart = this.chart[seriesItem.type];
                    chart && chart.addMark(seriesIdx, markData, markType);
                }

                return this;
            },

            /**
             * 动态[标注 | 标线]删除
             * @param {number} seriesIdx 系列索引
             * @param {string} markName [标注 | 标线]名称
             */
            delMarkPoint: function(seriesIdx, markName) {
                return this._delMark(seriesIdx, markName, 'markPoint');
            },

            delMarkLine: function(seriesIdx, markName) {
                return this._delMark(seriesIdx, markName, 'markLine');
            },

            _delMark: function(seriesIdx, markName, markType) {
                var series = this._option.series;
                var seriesItem;
                var mark;
                var dataArray;

                if (!(
                        series && (seriesItem = series[seriesIdx]) && (mark = seriesItem[markType]) && (dataArray = mark.data)
                    )) {
                    return this;
                }

                markName = markName.split(' > ');
                var targetIndex = -1;

                for (var i = 0, l = dataArray.length; i < l; i++) {
                    var dataItem = dataArray[i];
                    if (dataItem instanceof Array) {
                        if (dataItem[0].name === markName[0] && dataItem[1].name === markName[1]) {
                            targetIndex = i;
                            break;
                        }
                    } else if (dataItem.name === markName[0]) {
                        targetIndex = i;
                        break;
                    }
                }

                if (targetIndex > -1) {
                    dataArray.splice(targetIndex, 1);
                    this._optionRestore.series[seriesIdx][markType].data.splice(targetIndex, 1);

                    var chart = this.chart[seriesItem.type];
                    chart && chart.delMark(seriesIdx, markName.join(' > '), markType);
                }

                return this;
            },

            /**
             * 获取当前dom
             */
            getDom: function() {
                return this.dom;
            },

            /**
             * 获取当前zrender实例，可用于添加额为的shape和深度控制
             */
            getZrender: function() {
                return this._zr;
            },

            /**
             * 获取Base64图片dataURL
             * @param {string} imgType 图片类型，支持png|jpeg，默认为png
             * @return imgDataURL
             */
            getDataURL: function(imgType) {
                if (!_canvasSupported) {
                    return '';
                }

                if (this._chartList.length === 0) {
                    // 渲染为图片
                    var imgId = 'IMG' + this.id;
                    var img = document.getElementById(imgId);
                    if (img) {
                        return img.src;
                    }
                }

                // 清除可能存在的tooltip元素
                var tooltip = this.component.tooltip;
                tooltip && tooltip.hideTip();

                switch (imgType) {
                    case 'jpeg':
                        break;
                    default:
                        imgType = 'png';
                }

                var bgColor = this._option.backgroundColor;
                if (bgColor && bgColor.replace(' ', '') === 'rgba(0,0,0,0)') {
                    bgColor = '#fff';
                }

                return this._zr.toDataURL('image/' + imgType, bgColor);
            },

            /**
             * 获取img
             * @param {string} imgType 图片类型，支持png|jpeg，默认为png
             * @return img dom
             */
            getImage: function(imgType) {
                var title = this._optionRestore.title;
                var imgDom = document.createElement('img');
                imgDom.src = this.getDataURL(imgType);
                imgDom.title = (title && title.text) || 'ECharts';
                return imgDom;
            },

            /**
             * 获取多图联动的Base64图片dataURL
             * @param {string} imgType 图片类型，支持png|jpeg，默认为png
             * @return imgDataURL
             */
            getConnectedDataURL: function(imgType) {
                if (!this.isConnected()) {
                    return this.getDataURL(imgType);
                }

                var tempDom = this.dom;
                var imgList = {
                    'self': {
                        img: this.getDataURL(imgType),
                        left: tempDom.offsetLeft,
                        top: tempDom.offsetTop,
                        right: tempDom.offsetLeft + tempDom.offsetWidth,
                        bottom: tempDom.offsetTop + tempDom.offsetHeight
                    }
                };

                var minLeft = imgList.self.left;
                var minTop = imgList.self.top;
                var maxRight = imgList.self.right;
                var maxBottom = imgList.self.bottom;

                for (var c in this._connected) {
                    tempDom = this._connected[c].getDom();
                    imgList[c] = {
                        img: this._connected[c].getDataURL(imgType),
                        left: tempDom.offsetLeft,
                        top: tempDom.offsetTop,
                        right: tempDom.offsetLeft + tempDom.offsetWidth,
                        bottom: tempDom.offsetTop + tempDom.offsetHeight
                    };

                    minLeft = Math.min(minLeft, imgList[c].left);
                    minTop = Math.min(minTop, imgList[c].top);
                    maxRight = Math.max(maxRight, imgList[c].right);
                    maxBottom = Math.max(maxBottom, imgList[c].bottom);
                }

                var zrDom = document.createElement('div');
                zrDom.style.position = 'absolute';
                zrDom.style.left = '-4000px';
                zrDom.style.width = (maxRight - minLeft) + 'px';
                zrDom.style.height = (maxBottom - minTop) + 'px';
                document.body.appendChild(zrDom);

                var zrImg = require('zrender').init(zrDom);

                var ImageShape = require('zrender/shape/Image');
                for (var c in imgList) {
                    zrImg.addShape(new ImageShape({
                        style: {
                            x: imgList[c].left - minLeft,
                            y: imgList[c].top - minTop,
                            image: imgList[c].img
                        }
                    }));
                }

                zrImg.render();
                var bgColor = this._option.backgroundColor;
                if (bgColor && bgColor.replace(/ /g, '') === 'rgba(0,0,0,0)') {
                    bgColor = '#fff';
                }

                var image = zrImg.toDataURL('image/png', bgColor);

                setTimeout(function() {
                    zrImg.dispose();
                    zrDom.parentNode.removeChild(zrDom);
                    zrDom = null;
                }, 100);

                return image;
            },

            /**
             * 获取多图联动的img
             * @param {string} imgType 图片类型，支持png|jpeg，默认为png
             * @return img dom
             */
            getConnectedImage: function(imgType) {
                var title = this._optionRestore.title;
                var imgDom = document.createElement('img');
                imgDom.src = this.getConnectedDataURL(imgType);
                imgDom.title = (title && title.text) || 'ECharts';
                return imgDom;
            },

            /**
             * 外部接口绑定事件
             * @param {Object} eventName 事件名称
             * @param {Object} eventListener 事件响应函数
             */
            on: function(eventName, eventListener) {
                this._messageCenterOutSide.bind(eventName, eventListener, this);
                return this;
            },

            /**
             * 外部接口解除事件绑定
             * @param {Object} eventName 事件名称
             * @param {Object} eventListener 事件响应函数
             */
            un: function(eventName, eventListener) {
                this._messageCenterOutSide.unbind(eventName, eventListener);
                return this;
            },

            /**
             * 多图联动
             * @param connectTarget{ECharts | Array <ECharts>} connectTarget 联动目标
             */
            connect: function(connectTarget) {
                if (!connectTarget) {
                    return this;
                }

                if (!this._connected) {
                    this._connected = {};
                }

                if (connectTarget instanceof Array) {
                    for (var i = 0, l = connectTarget.length; i < l; i++) {
                        this._connected[connectTarget[i].id] = connectTarget[i];
                    }
                } else {
                    this._connected[connectTarget.id] = connectTarget;
                }

                return this;
            },

            /**
             * 解除多图联动
             * @param connectTarget{ECharts | Array <ECharts>} connectTarget 解除联动目标
             */
            disConnect: function(connectTarget) {
                if (!connectTarget || !this._connected) {
                    return this;
                }

                if (connectTarget instanceof Array) {
                    for (var i = 0, l = connectTarget.length; i < l; i++) {
                        delete this._connected[connectTarget[i].id];
                    }
                } else {
                    delete this._connected[connectTarget.id];
                }

                for (var k in this._connected) {
                    return k, this; // 非空
                }

                // 空，转为标志位
                this._connected = false;
                return this;
            },

            /**
             * 联动事件响应
             */
            connectedEventHandler: function(param) {
                if (param.__echartsId != this.id) {
                    // 来自其他联动图表的事件
                    this._onevent(param);
                }
            },

            /**
             * 是否存在多图联动
             */
            isConnected: function() {
                return !!this._connected;
            },

            /**
             * 显示loading过渡
             * @param {Object} loadingOption
             */
            showLoading: function(loadingOption) {
                var effectList = {
                    bar: require('zrender/loadingEffect/Bar'),
                    bubble: require('zrender/loadingEffect/Bubble'),
                    dynamicLine: require('zrender/loadingEffect/DynamicLine'),
                    ring: require('zrender/loadingEffect/Ring'),
                    spin: require('zrender/loadingEffect/Spin'),
                    whirling: require('zrender/loadingEffect/Whirling')
                };
                this._toolbox.hideDataView();

                loadingOption = loadingOption || {};

                var textStyle = loadingOption.textStyle || {};
                loadingOption.textStyle = textStyle;

                var finalTextStyle = zrUtil.merge(
                    zrUtil.merge(
                        zrUtil.clone(textStyle),
                        this._themeConfig.textStyle
                    ),
                    ecConfig.textStyle
                );

                textStyle.textFont = finalTextStyle.fontStyle + ' ' + finalTextStyle.fontWeight + ' ' + finalTextStyle.fontSize + 'px ' + finalTextStyle.fontFamily;

                textStyle.text = loadingOption.text || (this._option && this._option.loadingText) || this._themeConfig.loadingText || ecConfig.loadingText;

                if (loadingOption.x != null) {
                    textStyle.x = loadingOption.x;
                }
                if (loadingOption.y != null) {
                    textStyle.y = loadingOption.y;
                }

                loadingOption.effectOption = loadingOption.effectOption || {};
                loadingOption.effectOption.textStyle = textStyle;

                var Effect = loadingOption.effect;
                if (typeof Effect === 'string' || Effect == null) {
                    Effect = effectList[
                        loadingOption.effect || (this._option && this._option.loadingEffect) || this._themeConfig.loadingEffect || ecConfig.loadingEffect
                    ] || effectList.spin;
                }
                this._zr.showLoading(new Effect(loadingOption.effectOption));
                return this;
            },

            /**
             * 隐藏loading过渡
             */
            hideLoading: function() {
                this._zr.hideLoading();
                return this;
            },

            /**
             * 主题设置
             */
            setTheme: function(theme) {
                if (theme) {
                    if (typeof theme === 'string') {
                        // 默认主题
                        switch (theme) {
                            case 'macarons':
                                theme = require('./theme/macarons');
                                break;
                            case 'infographic':
                                theme = require('./theme/infographic');
                                break;
                            default:
                                theme = {}; // require('./theme/default');
                        }
                    } else {
                        theme = theme || {};
                    }

                    // // 复位默认配置
                    // // this._themeConfig会被别的对象引用持有
                    // // 所以不能改成this._themeConfig = {};
                    // for (var key in this._themeConfig) {
                    //     delete this._themeConfig[key];
                    // }
                    // for (var key in ecConfig) {
                    //     this._themeConfig[key] = zrUtil.clone(ecConfig[key]);
                    // }

                    // // 颜色数组随theme，不merge
                    // theme.color && (this._themeConfig.color = []);

                    // // 默认标志图形类型列表，不merge
                    // theme.symbolList && (this._themeConfig.symbolList = []);

                    // // 应用新主题
                    // zrUtil.merge(this._themeConfig, zrUtil.clone(theme), true);
                    this._themeConfig = theme;
                }

                if (!_canvasSupported) { // IE8-
                    var textStyle = this._themeConfig.textStyle;
                    textStyle && textStyle.fontFamily && textStyle.fontFamily2 && (textStyle.fontFamily = textStyle.fontFamily2);

                    textStyle = ecConfig.textStyle;
                    textStyle.fontFamily = textStyle.fontFamily2;
                }

                this._timeline && this._timeline.setTheme(true);
                this._optionRestore && this.restore();
            },

            /**
             * 视图区域大小变化更新，不默认绑定，供使用方按需调用
             */
            resize: function() {
                var self = this;
                return function() {
                    self._clearEffect();
                    self._zr.resize();
                    if (self._option && self._option.renderAsImage && _canvasSupported) {
                        // 渲染为图片重走render模式
                        self._render(self._option);
                        return self;
                    }
                    // 停止动画
                    self._zr.clearAnimation();
                    self._island.resize();
                    self._toolbox.resize();
                    self._timeline && self._timeline.resize();
                    // 先来后到，不能仅刷新自己，也不能在上一个循环中刷新，如坐标系数据改变会影响其他图表的大小
                    // 所以安顺序刷新各种图表，图表内部refresh优化无需更新则不更新~
                    for (var i = 0, l = self._chartList.length; i < l; i++) {
                        self._chartList[i].resize && self._chartList[i].resize();
                    }
                    self.component.grid && self.component.grid.refixAxisShape(self.component);
                    self._zr.refresh();
                    self._messageCenter.dispatch(ecConfig.EVENT.RESIZE, null, null, self);
                    return self;
                };
            },

            _clearEffect: function() {
                this._zr.modLayer(ecConfig.EFFECT_ZLEVEL, {
                    motionBlur: false
                });
                this._zr.painter.clearLayer(ecConfig.EFFECT_ZLEVEL);
            },

            /**
             * 清除已渲染内容 ，clear后echarts实例可用
             */
            clear: function() {
                this._disposeChartList();
                this._zr.clear();
                this._option = {};
                this._optionRestore = {};
                this.dom.style.backgroundColor = null;
                return this;
            },

            /**
             * 释放，dispose后echarts实例不可用
             */
            dispose: function() {
                var key = this.dom.getAttribute(DOM_ATTRIBUTE_KEY);
                key && delete _instances[key];

                this._island.dispose();
                this._toolbox.dispose();
                this._timeline && this._timeline.dispose();
                this._messageCenter.unbind();
                this.clear();
                this._zr.dispose();
                this._zr = null;
            }
        };

        return self;
    });
    define('echarts/chart/map', ['require', './base', 'zrender/shape/Text', 'zrender/shape/Path', 'zrender/shape/Circle', 'zrender/shape/Rectangle', 'zrender/shape/Line', 'zrender/shape/Polygon', 'zrender/shape/Ellipse', 'zrender/shape/Image', '../component/dataRange', '../component/roamController', '../layer/heatmap', '../config', '../util/ecData', 'zrender/tool/util', 'zrender/config', 'zrender/tool/event', '../util/mapData/params', '../util/mapData/textFixed', '../util/mapData/geoCoord', '../util/projection/svg', '../util/projection/normal', '../chart'], function(require) {
        var ChartBase = require('./base');

        // 图形依赖
        var TextShape = require('zrender/shape/Text');
        var PathShape = require('zrender/shape/Path');
        var CircleShape = require('zrender/shape/Circle');
        var RectangleShape = require('zrender/shape/Rectangle');
        var LineShape = require('zrender/shape/Line');
        var PolygonShape = require('zrender/shape/Polygon');
        var EllipseShape = require('zrender/shape/Ellipse');
        var ZrImage = require('zrender/shape/Image');
        // 组件依赖
        require('../component/dataRange');
        require('../component/roamController');
        var HeatmapLayer = require('../layer/heatmap');

        var ecConfig = require('../config');
        // 地图默认参数
        ecConfig.map = {
            zlevel: 0, // 一级层叠
            z: 2, // 二级层叠
            mapType: 'china', // 各省的mapType暂时都用中文
            //mapLocation: {
            // x: 'center' | 'left' | 'right' | 'x%' | {number},
            // y: 'center' | 'top' | 'bottom' | 'x%' | {number}
            // width    // 自适应
            // height   // 自适应
            //},
            // mapValueCalculation: 'sum',  // 数值合并方式，默认加和，可选为：
            // 'sum' | 'average' | 'max' | 'min'
            // mapValuePrecision: 0,           // 地图数值计算结果小数精度
            showLegendSymbol: true, // 显示图例颜色标识（系列标识的小圆点），存在legend时生效
            // selectedMode: false,         // 选择模式，默认关闭，可选single，multiple
            dataRangeHoverLink: true,
            hoverable: true,
            clickable: true,
            // roam: false,                 // 是否开启缩放及漫游模式
            // scaleLimit: null,
            itemStyle: {
                normal: {
                    // color: 各异,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 1,
                    areaStyle: {
                        color: '#ccc'
                    },
                    label: {
                        show: false,
                        textStyle: {
                            color: 'rgb(139,69,19)'
                        }
                    }
                },
                emphasis: { // 也是选中样式
                    // color: 各异,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 1,
                    areaStyle: {
                        color: 'rgba(255,215,0,0.8)'
                    },
                    label: {
                        show: false,
                        textStyle: {
                            color: 'rgb(100,0,0)'
                        }
                    }
                }
            }
        };

        var ecData = require('../util/ecData');
        var zrUtil = require('zrender/tool/util');
        var zrConfig = require('zrender/config');
        var zrEvent = require('zrender/tool/event');

        var _mapParams = require('../util/mapData/params').params;
        var _textFixed = require('../util/mapData/textFixed');
        var _geoCoord = require('../util/mapData/geoCoord');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} series 数据
         * @param {Object} component 组件
         */
        function Map(ecTheme, messageCenter, zr, option, myChart) {
            // 图表基类
            ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            self._onmousewheel = function(params) {
                return self.__onmousewheel(params);
            };
            self._onmousedown = function(params) {
                return self.__onmousedown(params);
            };
            self._onmousemove = function(params) {
                return self.__onmousemove(params);
            };
            self._onmouseup = function(params) {
                return self.__onmouseup(params);
            };
            self._onroamcontroller = function(params) {
                return self.__onroamcontroller(params);
            };
            self._ondrhoverlink = function(params) {
                return self.__ondrhoverlink(params);
            };

            this._isAlive = true; // 活着标记
            this._selectedMode = {}; // 选择模式
            this._activeMapType = {}; // 当前活跃的地图类型
            this._clickable = {}; // 悬浮高亮模式，索引到图表
            this._hoverable = {}; // 悬浮高亮模式，索引到图表
            this._showLegendSymbol = {}; // 显示图例颜色标识
            this._selected = {}; // 地图选择状态
            this._mapTypeMap = {}; // 图例类型索引
            this._mapDataMap = {}; // 根据地图类型索引bbox,transform,path
            this._nameMap = {}; // 个性化地名
            this._specialArea = {}; // 特殊
            this._refreshDelayTicket; // 滚轮缩放时让refresh飞一会
            this._mapDataRequireCounter; // 异步回调计数器
            this._markAnimation = false;
            this._hoverLinkMap = {};

            // 漫游相关信息
            this._roamMap = {};
            this._scaleLimitMap = {};
            this._mx;
            this._my;
            this._mousedown;
            this._justMove; // 避免移动响应点击
            this._curMapType; // 当前移动的地图类型

            this.refresh(option);

            this.zr.on(zrConfig.EVENT.MOUSEWHEEL, this._onmousewheel);
            this.zr.on(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
            messageCenter.bind(ecConfig.EVENT.ROAMCONTROLLER, this._onroamcontroller);
            messageCenter.bind(ecConfig.EVENT.DATA_RANGE_HOVERLINK, this._ondrhoverlink);
        }

        Map.prototype = {
            type: ecConfig.CHART_TYPE_MAP,
            /**
             * 绘制图形
             */
            _buildShape: function() {
                var series = this.series;
                this.selectedMap = {}; // 系列
                this._activeMapType = {}; // 当前活跃的地图类型

                var legend = this.component.legend;
                var seriesName;
                var valueData = {};
                var mapType;
                var data;
                var name;
                var mapSeries = {};
                var mapValuePrecision = {};
                var valueCalculation = {};
                for (var i = 0, l = series.length; i < l; i++) {
                    if (series[i].type == ecConfig.CHART_TYPE_MAP) { // map
                        series[i] = this.reformOption(series[i]);
                        mapType = series[i].mapType;
                        mapSeries[mapType] = mapSeries[mapType] || {};
                        mapSeries[mapType][i] = true;
                        mapValuePrecision[mapType] = mapValuePrecision[mapType] || series[i].mapValuePrecision;
                        this._scaleLimitMap[mapType] = this._scaleLimitMap[mapType] || {};
                        series[i].scaleLimit && zrUtil.merge(this._scaleLimitMap[mapType], series[i].scaleLimit, true);

                        this._roamMap[mapType] = series[i].roam || this._roamMap[mapType];

                        if (this._hoverLinkMap[mapType] == null || this._hoverLinkMap[mapType]) {
                            // false 1票否决
                            this._hoverLinkMap[mapType] = series[i].dataRangeHoverLink;
                        }

                        this._nameMap[mapType] = this._nameMap[mapType] || {};
                        series[i].nameMap && zrUtil.merge(this._nameMap[mapType], series[i].nameMap, true);
                        this._activeMapType[mapType] = true;

                        if (series[i].textFixed) {
                            zrUtil.merge(
                                _textFixed, series[i].textFixed, true
                            );
                        }
                        if (series[i].geoCoord) {
                            zrUtil.merge(
                                _geoCoord, series[i].geoCoord, true
                            );
                        }

                        this._selectedMode[mapType] = this._selectedMode[mapType] || series[i].selectedMode;
                        if (this._hoverable[mapType] == null || this._hoverable[mapType]) {
                            // false 1票否决
                            this._hoverable[mapType] = series[i].hoverable;
                        }
                        if (this._clickable[mapType] == null || this._clickable[mapType]) {
                            // false 1票否决
                            this._clickable[mapType] = series[i].clickable;
                        }
                        if (this._showLegendSymbol[mapType] == null || this._showLegendSymbol[mapType]) {
                            // false 1票否决
                            this._showLegendSymbol[mapType] = series[i].showLegendSymbol;
                        }

                        valueCalculation[mapType] = valueCalculation[mapType] || series[i].mapValueCalculation;

                        seriesName = series[i].name;
                        this.selectedMap[seriesName] = legend ? legend.isSelected(seriesName) : true;
                        if (this.selectedMap[seriesName]) {
                            valueData[mapType] = valueData[mapType] || {};
                            data = series[i].data;
                            for (var j = 0, k = data.length; j < k; j++) {
                                name = this._nameChange(mapType, data[j].name);
                                valueData[mapType][name] = valueData[mapType][name] || {
                                    seriesIndex: [],
                                    valueMap: {},
                                    precision: 0
                                };
                                for (var key in data[j]) {
                                    if (key != 'value') {
                                        valueData[mapType][name][key] =
                                            data[j][key];
                                    } else if (!isNaN(data[j].value)) {
                                        // value
                                        valueData[mapType][name].value == null && (valueData[mapType][name].value = 0);

                                        valueData[mapType][name].precision =
                                            Math.max(
                                                this.getPrecision(+data[j].value),
                                                valueData[mapType][name].precision
                                            );

                                        valueData[mapType][name].value += (+data[j].value);
                                        valueData[mapType][name].valueMap[i] = +data[j].value;
                                    }
                                }
                                //索引有该区域的系列样式
                                valueData[mapType][name].seriesIndex.push(i);
                            }
                        }
                    }
                }

                this._mapDataRequireCounter = 0;
                for (var mt in valueData) {
                    this._mapDataRequireCounter++;
                }
                //清空
                this._clearSelected();
                if (this._mapDataRequireCounter === 0) {
                    this.clear();
                    this.zr && this.zr.delShape(this.lastShapeList);
                    this.lastShapeList = [];
                }
                for (var mt in valueData) {
                    for (var k in valueData[mt]) {
                        if (valueCalculation[mt] == 'average') {
                            valueData[mt][k].value /= valueData[mt][k].seriesIndex.length;
                        }
                        var value = valueData[mt][k].value;
                        if (value != null) {
                            valueData[mt][k].value = value.toFixed(
                                mapValuePrecision[mt] == null ? valueData[mt][k].precision : mapValuePrecision[mt]
                            ) - 0;
                        }
                    }

                    this._mapDataMap[mt] = this._mapDataMap[mt] || {};

                    if (this._mapDataMap[mt].mapData) {
                        // 已经缓存了则直接用
                        this._mapDataCallback(mt, valueData[mt], mapSeries[mt])(
                            this._mapDataMap[mt].mapData
                        );
                    } else if (_mapParams[mt.replace(/\|.*/, '')].getGeoJson) {
                        // 特殊区域
                        this._specialArea[mt] =
                            _mapParams[mt.replace(/\|.*/, '')].specialArea || this._specialArea[mt];
                        _mapParams[mt.replace(/\|.*/, '')].getGeoJson(
                            this._mapDataCallback(mt, valueData[mt], mapSeries[mt])
                        );
                    }
                }
            },

            /**
             * @param {string} mt mapType
             * @parma {Object} vd valueData
             * @param {Object} ms mapSeries
             */
            _mapDataCallback: function(mt, vd, ms) {
                var self = this;
                return function(md) {
                    if (!self._isAlive || self._activeMapType[mt] == null) {
                        // 异步地图数据回调时有可能实例已经被释放
                        return;
                    }
                    // 缓存这份数据
                    if (mt.indexOf('|') != -1) {
                        // 子地图，加工一份新的mapData
                        md = self._getSubMapData(mt, md);
                    }
                    self._mapDataMap[mt].mapData = md;

                    if (md.firstChild) {
                        self._mapDataMap[mt].rate = 1;
                        self._mapDataMap[mt].projection = require('../util/projection/svg');
                    } else {
                        self._mapDataMap[mt].rate = 0.75;
                        self._mapDataMap[mt].projection = require('../util/projection/normal');
                    }

                    self._buildMap(
                        mt, // 类型
                        self._getProjectionData(mt, md, ms), // 地图数据
                        vd, // 用户数据
                        ms // 系列
                    );
                    self._buildMark(mt, ms);
                    if (--self._mapDataRequireCounter <= 0) {
                        self.addShapeList();
                        self.zr.refreshNextFrame();
                    }

                    self._buildHeatmap(mt);
                };
            },

            _clearSelected: function() {
                for (var k in this._selected) {
                    if (!this._activeMapType[this._mapTypeMap[k]]) {
                        delete this._selected[k];
                        delete this._mapTypeMap[k];
                    }
                }
            },

            _getSubMapData: function(mapType, mapData) {
                var subType = mapType.replace(/^.*\|/, '');
                var features = mapData.features;
                for (var i = 0, l = features.length; i < l; i++) {
                    if (features[i].properties && features[i].properties.name == subType) {
                        features = features[i];
                        if (subType == 'United States of America' && features.geometry.coordinates.length > 1 // 未被简化
                        ) {
                            features = {
                                geometry: {
                                    coordinates: features.geometry
                                        .coordinates.slice(5, 6),
                                    type: features.geometry.type
                                },
                                id: features.id,
                                properties: features.properties,
                                type: features.type
                            };
                        }
                        break;
                    }
                }
                return {
                    'type': 'FeatureCollection',
                    'features': [
                        features
                    ]
                };
            },

            /**
             * 按需加载相关地图
             */
            _getProjectionData: function(mapType, mapData, mapSeries) {
                var normalProjection = this._mapDataMap[mapType].projection;
                var province = [];

                // bbox永远不变
                var bbox = this._mapDataMap[mapType].bbox || normalProjection.getBbox(
                    mapData, this._specialArea[mapType]
                );
                //console.log(bbox)

                var transform;
                //console.log(1111,transform)
                if (!this._mapDataMap[mapType].hasRoam) {
                    // 第一次或者发生了resize，需要判断
                    transform = this._getTransform(
                        bbox,
                        mapSeries,
                        this._mapDataMap[mapType].rate
                    );
                } else {
                    //经过用户漫游不再响应resize
                    transform = this._mapDataMap[mapType].transform;
                }
                //console.log(bbox,transform)
                var lastTransform = this._mapDataMap[mapType].lastTransform || {
                    scale: {}
                };

                var pathArray;
                if (transform.left != lastTransform.left || transform.top != lastTransform.top || transform.scale.x != lastTransform.scale.x || transform.scale.y != lastTransform.scale.y) {
                    // 发生过变化，需要重新生成pathArray
                    // 一般投射
                    //console.log(transform)
                    pathArray = normalProjection.geoJson2Path(
                        mapData, transform, this._specialArea[mapType]
                    );
                    lastTransform = zrUtil.clone(transform);
                } else {
                    transform = this._mapDataMap[mapType].transform;
                    pathArray = this._mapDataMap[mapType].pathArray;
                }

                this._mapDataMap[mapType].bbox = bbox;
                this._mapDataMap[mapType].transform = transform;
                this._mapDataMap[mapType].lastTransform = lastTransform;
                this._mapDataMap[mapType].pathArray = pathArray;

                //console.log(pathArray)
                var position = [transform.left, transform.top];
                for (var i = 0, l = pathArray.length; i < l; i++) {
                    /* for test
                    console.log(
                        mapData.features[i].properties.cp, // 经纬度度
                        pathArray[i].cp                    // 平面坐标
                    );
                    console.log(
                        this.pos2geo(mapType, pathArray[i].cp),  // 平面坐标转经纬度
                        this.geo2pos(mapType, mapData.features[i].properties.cp)
                    )
                    */
                    province.push(this._getSingleProvince(
                        mapType, pathArray[i], position
                    ));
                }

                if (this._specialArea[mapType]) {
                    for (var area in this._specialArea[mapType]) {
                        province.push(this._getSpecialProjectionData(
                            mapType, mapData,
                            area, this._specialArea[mapType][area],
                            position
                        ));
                    }

                }

                // 中国地图加入南海诸岛
                if (mapType == 'china') {
                    var leftTop = this.geo2pos(
                        mapType,
                        _geoCoord['南海诸岛'] || _mapParams['南海诸岛'].textCoord
                    );
                    // scale.x : width  = 10.51 : 64
                    var scale = transform.scale.x / 10.5;
                    var textPosition = [
                        32 * scale + leftTop[0],
                        83 * scale + leftTop[1]
                    ];
                    if (_textFixed['南海诸岛']) {
                        textPosition[0] += _textFixed['南海诸岛'][0];
                        textPosition[1] += _textFixed['南海诸岛'][1];
                    }
                    province.push({
                        name: this._nameChange(mapType, '南海诸岛'),
                        path: _mapParams['南海诸岛'].getPath(leftTop, scale),
                        position: position,
                        textX: textPosition[0],
                        textY: textPosition[1]
                    });

                }
                //console.log(JSON.stringify(province));
                //console.log(JSON.stringify(this._mapDataMap[mapType].transform));
                return province;
            },

            /**
             * 特殊地区投射数据
             */
            _getSpecialProjectionData: function(mapType, mapData, areaName, mapSize, position) {
                //console.log('_getSpecialProjectionData--------------')
                // 构造单独的geoJson地图数据
                mapData = this._getSubMapData('x|' + areaName, mapData);

                // bbox
                var normalProjection = require('../util/projection/normal');
                var bbox = normalProjection.getBbox(mapData);
                //console.log('bbox', bbox)

                // transform
                var leftTop = this.geo2pos(
                    mapType, [mapSize.left, mapSize.top]
                );
                var rightBottom = this.geo2pos(
                    mapType, [mapSize.left + mapSize.width, mapSize.top + mapSize.height]
                );
                //console.log('leftright' , leftTop, rightBottom);
                var width = Math.abs(rightBottom[0] - leftTop[0]);
                var height = Math.abs(rightBottom[1] - leftTop[1]);
                var mapWidth = bbox.width;
                var mapHeight = bbox.height;
                //var minScale;
                var xScale = (width / 0.75) / mapWidth;
                var yScale = height / mapHeight;
                if (xScale > yScale) {
                    xScale = yScale * 0.75;
                    width = mapWidth * xScale;
                } else {
                    yScale = xScale;
                    xScale = yScale * 0.75;
                    height = mapHeight * yScale;
                }
                var transform = {
                    OffsetLeft: leftTop[0],
                    OffsetTop: leftTop[1],
                    //width: width,
                    //height: height,
                    scale: {
                        x: xScale,
                        y: yScale
                    }
                };

                //console.log('**',areaName, transform)
                var pathArray = normalProjection.geoJson2Path(
                    mapData, transform
                );

                //console.log(pathArray)
                return this._getSingleProvince(
                    mapType, pathArray[0], position
                );
            },

            _getSingleProvince: function(mapType, path, position) {
                var textPosition;
                var name = path.properties.name;
                var textFixed = _textFixed[name] || [0, 0];
                if (_geoCoord[name]) {
                    // 经纬度直接定位不加textFixed
                    textPosition = this.geo2pos(
                        mapType,
                        _geoCoord[name]
                    );
                } else if (path.cp) {
                    textPosition = [
                        path.cp[0] + textFixed[0],
                        path.cp[1] + textFixed[1]
                    ];
                } else {
                    var bbox = this._mapDataMap[mapType].bbox;
                    textPosition = this.geo2pos(
                        mapType, [bbox.left + bbox.width / 2, bbox.top + bbox.height / 2]
                    );
                    textPosition[0] += textFixed[0];
                    textPosition[1] += textFixed[1];
                }

                //console.log(textPosition)
                path.name = this._nameChange(mapType, name);
                path.position = position;
                path.textX = textPosition[0];
                path.textY = textPosition[1];
                return path;
            },

            /**
             * 获取缩放
             */
            _getTransform: function(bbox, mapSeries, rate) {
                var series = this.series;
                var mapLocation;
                var x;
                var cusX;
                var y;
                var cusY;
                var width;
                var height;
                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();
                //上下左右留空
                var padding = Math.round(Math.min(zrWidth, zrHeight) * 0.02);
                for (var key in mapSeries) {
                    mapLocation = series[key].mapLocation || {};
                    cusX = mapLocation.x || cusX;
                    cusY = mapLocation.y || cusY;
                    width = mapLocation.width || width;
                    height = mapLocation.height || height;
                }

                //x = isNaN(cusX) ? padding : cusX;
                x = this.parsePercent(cusX, zrWidth);
                x = isNaN(x) ? padding : x;
                //y = isNaN(cusY) ? padding : cusY;
                y = this.parsePercent(cusY, zrHeight);
                y = isNaN(y) ? padding : y;

                width = width == null ? (zrWidth - x - 2 * padding) : (this.parsePercent(width, zrWidth));
                height = height == null ? (zrHeight - y - 2 * padding) : (this.parsePercent(height, zrHeight));

                var mapWidth = bbox.width;
                var mapHeight = bbox.height;
                //var minScale;
                var xScale = (width / rate) / mapWidth;
                var yScale = height / mapHeight;
                if (xScale > yScale) {
                    //minScale = yScale;
                    xScale = yScale * rate;
                    width = mapWidth * xScale;
                } else {
                    //minScale = xScale;
                    yScale = xScale;
                    xScale = yScale * rate;
                    height = mapHeight * yScale;
                }
                //console.log(minScale)
                //width = mapWidth * minScale;
                //height = mapHeight * minScale;

                if (isNaN(cusX)) {
                    cusX = cusX || 'center';
                    switch (cusX + '') {
                        case 'center':
                            x = Math.floor((zrWidth - width) / 2);
                            break;
                        case 'right':
                            x = zrWidth - width;
                            break;
                            //case 'left' :
                            //x = padding;
                    }
                }
                //console.log(cusX,x,zrWidth,width,'kener')
                if (isNaN(cusY)) {
                    cusY = cusY || 'center';
                    switch (cusY + '') {
                        case 'center':
                            y = Math.floor((zrHeight - height) / 2);
                            break;
                        case 'bottom':
                            y = zrHeight - height;
                            break;
                            //case 'top' :
                            //y = padding;
                    }
                }
                //console.log(x,y,width,height)
                return {
                    left: x,
                    top: y,
                    width: width,
                    height: height,
                    //scale : minScale * 50,  // wtf 50
                    baseScale: 1,
                    scale: {
                        x: xScale,
                        y: yScale
                    }
                    //translate : [x + width / 2, y + height / 2]
                };
            },

            /**
             * 构建地图
             * @param {Object} mapData 图形数据
             * @param {Object} valueData 用户数据
             */
            _buildMap: function(mapType, mapData, valueData, mapSeries) {
                var series = this.series;
                var legend = this.component.legend;
                var dataRange = this.component.dataRange;
                var seriesName;
                var name;
                var data;
                var value;
                var queryTarget;

                var color;
                var font;
                var style;
                var highlightStyle;

                var shape;
                var textShape;
                for (var i = 0, l = mapData.length; i < l; i++) {
                    style = zrUtil.clone(mapData[i]);
                    highlightStyle = {
                        name: style.name,
                        path: style.path,
                        position: zrUtil.clone(style.position)
                    };
                    name = style.name;
                    data = valueData[name]; // 多系列合并后的数据
                    if (data) {
                        queryTarget = [data]; // level 3
                        seriesName = '';
                        for (var j = 0, k = data.seriesIndex.length; j < k; j++) {
                            var serie = series[data.seriesIndex[j]];
                            // level 2
                            queryTarget.push(serie);
                            seriesName += serie.name + ' ';
                            if (legend && this._showLegendSymbol[mapType] && legend.hasColor(serie.name)) {
                                this.shapeList.push(new CircleShape({
                                    zlevel: serie.zlevel,
                                    z: serie.z + 1,
                                    position: zrUtil.clone(style.position),
                                    _mapType: mapType,
                                    /*
                                    _geo : this.pos2geo(
                                               mapType, [style.textX + 3 + j * 7, style.textY - 10]
                                           ),
                                           */
                                    style: {
                                        x: style.textX + 3 + j * 7,
                                        y: style.textY - 10,
                                        r: 3,
                                        color: legend.getColor(
                                            serie.name
                                        )
                                    },
                                    hoverable: false
                                }));
                            }
                        }
                        value = data.value;
                    } else {
                        data = {
                            name: name,
                            value: '-'
                        };
                        seriesName = '';
                        queryTarget = [];
                        for (var key in mapSeries) {
                            queryTarget.push(series[key]);
                        }
                        value = '-';
                    }
                    this.ecTheme.map && queryTarget.push(this.ecTheme.map); // level 1
                    queryTarget.push(ecConfig.map); // level 1

                    // 值域控件控制
                    color = (dataRange && !isNaN(value)) ? dataRange.getColor(value) : null;

                    // 常规设置
                    style.color = style.color || color || this.getItemStyleColor(
                        this.deepQuery(queryTarget, 'itemStyle.normal.color'),
                        data.seriesIndex, -1, data
                    ) || this.deepQuery(
                        queryTarget, 'itemStyle.normal.areaStyle.color'
                    );
                    style.strokeColor = style.strokeColor || this.deepQuery(queryTarget, 'itemStyle.normal.borderColor');
                    style.lineWidth = style.lineWidth || this.deepQuery(queryTarget, 'itemStyle.normal.borderWidth');

                    // 高亮
                    highlightStyle.color = this.getItemStyleColor(
                        this.deepQuery(queryTarget, 'itemStyle.emphasis.color'),
                        data.seriesIndex, -1, data
                    ) || this.deepQuery(
                        queryTarget, 'itemStyle.emphasis.areaStyle.color'
                    ) || style.color;
                    highlightStyle.strokeColor = this.deepQuery(
                        queryTarget, 'itemStyle.emphasis.borderColor'
                    ) || style.strokeColor;
                    highlightStyle.lineWidth = this.deepQuery(
                        queryTarget, 'itemStyle.emphasis.borderWidth'
                    ) || style.lineWidth;

                    style.brushType = highlightStyle.brushType = style.brushType || 'both';
                    style.lineJoin = highlightStyle.lineJoin = 'round';
                    style._name = highlightStyle._name = name;

                    font = this.deepQuery(queryTarget, 'itemStyle.normal.label.textStyle');
                    // 文字标签避免覆盖单独一个shape
                    textShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase() + 1,
                        //hoverable: this._hoverable[mapType],
                        //clickable: this._clickable[mapType],
                        position: zrUtil.clone(style.position),
                        _mapType: mapType,
                        _geo: this.pos2geo(
                            mapType, [style.textX, style.textY]
                        ),
                        style: {
                            brushType: 'fill',
                            x: style.textX,
                            y: style.textY,
                            text: this.getLabelText(name, value, queryTarget, 'normal'),
                            _name: name,
                            textAlign: 'center',
                            color: this.deepQuery(queryTarget, 'itemStyle.normal.label.show') ? this.deepQuery(
                                queryTarget,
                                'itemStyle.normal.label.textStyle.color'
                            ) : 'rgba(0,0,0,0)',
                            textFont: this.getFont(font)
                        }
                    };
                    textShape._style = zrUtil.clone(textShape.style);

                    textShape.highlightStyle = zrUtil.clone(textShape.style);
                    if (this.deepQuery(queryTarget, 'itemStyle.emphasis.label.show')) {
                        textShape.highlightStyle.text = this.getLabelText(
                            name, value, queryTarget, 'emphasis'
                        );
                        textShape.highlightStyle.color = this.deepQuery(
                            queryTarget,
                            'itemStyle.emphasis.label.textStyle.color'
                        ) || textShape.style.color;
                        font = this.deepQuery(
                            queryTarget,
                            'itemStyle.emphasis.label.textStyle'
                        ) || font;
                        textShape.highlightStyle.textFont = this.getFont(font);
                    } else {
                        textShape.highlightStyle.color = 'rgba(0,0,0,0)';
                    }

                    shape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        //hoverable: this._hoverable[mapType],
                        //clickable: this._clickable[mapType],
                        position: zrUtil.clone(style.position),
                        style: style,
                        highlightStyle: highlightStyle,
                        _style: zrUtil.clone(style),
                        _mapType: mapType
                    };
                    if (style.scale != null) {
                        shape.scale = zrUtil.clone(style.scale);
                    }

                    textShape = new TextShape(textShape);
                    switch (shape.style.shapeType) {
                        case 'rectangle':
                            shape = new RectangleShape(shape);
                            break;
                        case 'line':
                            shape = new LineShape(shape);
                            break;
                        case 'circle':
                            shape = new CircleShape(shape);
                            break;
                        case 'polygon':
                            shape = new PolygonShape(shape);
                            break;
                        case 'ellipse':
                            shape = new EllipseShape(shape);
                            break;
                        default:
                            shape = new PathShape(shape);
                            if (shape.buildPathArray) {
                                shape.style.pathArray = shape.buildPathArray(shape.style.path);
                            }
                            break;
                    }

                    if (this._selectedMode[mapType] &&
                        (this._selected[name] && data.selected !== false) || data.selected === true
                    ) {
                        textShape.style = textShape.highlightStyle;
                        shape.style = shape.highlightStyle;
                    }

                    textShape.clickable = shape.clickable =
                        this._clickable[mapType] && (data.clickable == null || data.clickable);

                    if (this._selectedMode[mapType]) {
                        this._selected[name] = this._selected[name] != null ? this._selected[name] : data.selected;
                        this._mapTypeMap[name] = mapType;

                        if (data.selectable == null || data.selectable) {
                            shape.clickable = textShape.clickable = true;
                            shape.onclick = textShape.onclick = this.shapeHandler.onclick;
                        }
                    }

                    if (this._hoverable[mapType] && (data.hoverable == null || data.hoverable)) {
                        textShape.hoverable = shape.hoverable = true;
                        shape.hoverConnect = textShape.id;
                        textShape.hoverConnect = shape.id;
                    } else {
                        textShape.hoverable = shape.hoverable = false;
                    }

                    // console.log(name,shape);
                    ecData.pack(
                        textShape, {
                            name: seriesName,
                            tooltip: this.deepQuery(queryTarget, 'tooltip')
                        },
                        0,
                        data, 0,
                        name
                    );
                    this.shapeList.push(textShape);

                    ecData.pack(
                        shape, {
                            name: seriesName,
                            tooltip: this.deepQuery(queryTarget, 'tooltip')
                        },
                        0,
                        data, 0,
                        name
                    );
                    this.shapeList.push(shape);
                }
                //console.log(this._selected);
            },

            // 添加标注
            _buildMark: function(mapType, mapSeries) {
                this._seriesIndexToMapType = this._seriesIndexToMapType || {};
                this.markAttachStyle = this.markAttachStyle || {};
                var position = [
                    this._mapDataMap[mapType].transform.left,
                    this._mapDataMap[mapType].transform.top
                ];
                if (mapType == 'none') {
                    position = [0, 0];
                }
                for (var sIdx in mapSeries) {
                    this._seriesIndexToMapType[sIdx] = mapType;
                    this.markAttachStyle[sIdx] = {
                        position: position,
                        _mapType: mapType
                    };
                    this.buildMark(sIdx);
                }
            },

            _buildHeatmap: function(mapType) {
                var series = this.series;
                for (var i = 0, l = series.length; i < l; i++) {
                    // render heatmap
                    if (series[i].heatmap) {
                        // convert geo position to screen position
                        var data = series[i].heatmap.data;
                        if (series[i].heatmap.needsTransform === false) {
                            // baidu map position, does not need transform
                            var geo = [];
                            for (var j = 0, len = data.length; j < len; ++j) {
                                geo.push([data[j][3], data[j][4], data[j][2]]);
                            }
                            var pos = [0, 0]
                        } else {
                            // other map
                            var geoData = series[i].heatmap._geoData;
                            // copy initial geo position
                            if (geoData === undefined) {
                                series[i].heatmap._geoData = [];
                                for (var j = 0, len = data.length; j < len; ++j) {
                                    series[i].heatmap._geoData[j] = data[j];
                                }
                                geoData = series[i].heatmap._geoData;
                            }

                            var len = data.length;
                            for (var id = 0; id < len; ++id) {
                                data[id] = this.geo2pos(mapType, [geoData[id][0], geoData[id][1]]);
                            }
                            var pos = [
                                this._mapDataMap[mapType].transform.left,
                                this._mapDataMap[mapType].transform.top
                            ]
                        }
                        var layer = new HeatmapLayer(series[i].heatmap);
                        var canvas = layer.getCanvas(data[0][3] ? geo : data,
                            this.zr.getWidth(), this.zr.getHeight())
                        var image = new ZrImage({
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase() + 1,
                            position: pos,
                            scale: [1, 1],
                            hoverable: false,
                            style: {
                                x: 0,
                                y: 0,
                                image: canvas,
                                width: canvas.width,
                                height: canvas.height
                            }
                        });
                        image.type = 'heatmap';
                        image._mapType = mapType;
                        this.shapeList.push(image);
                        this.zr.addShape(image);
                    }
                }
            },

            // 位置转换
            getMarkCoord: function(seriesIndex, mpData) {
                return (mpData.geoCoord || _geoCoord[mpData.name]) ? this.geo2pos(
                    this._seriesIndexToMapType[seriesIndex],
                    mpData.geoCoord || _geoCoord[mpData.name]
                ) : [0, 0];
            },

            getMarkGeo: function(mpData) {
                return mpData.geoCoord || _geoCoord[mpData.name];
            },

            _nameChange: function(mapType, name) {
                return this._nameMap[mapType][name] || name;
            },

            /**
             * 根据lable.format计算label text
             */
            getLabelText: function(name, value, queryTarget, status) {
                var formatter = this.deepQuery(
                    queryTarget,
                    'itemStyle.' + status + '.label.formatter'
                );
                if (formatter) {
                    if (typeof formatter == 'function') {
                        return formatter.call(
                            this.myChart,
                            name,
                            value
                        );
                    } else if (typeof formatter == 'string') {
                        formatter = formatter.replace('{a}', '{a0}')
                            .replace('{b}', '{b0}');
                        formatter = formatter.replace('{a0}', name)
                            .replace('{b0}', value);
                        return formatter;
                    }
                } else {
                    return name;
                }
            },

            _findMapTypeByPos: function(mx, my) {
                var transform;
                var left;
                var top;
                var width;
                var height;
                for (var mapType in this._mapDataMap) {
                    transform = this._mapDataMap[mapType].transform;
                    if (!transform || !this._roamMap[mapType] || !this._activeMapType[mapType]) {
                        continue;
                    }

                    left = transform.left;
                    top = transform.top;
                    width = transform.width;
                    height = transform.height;
                    if (mx >= left && mx <= (left + width) && my >= top && my <= (top + height)) {
                        return mapType;
                    }
                }
                return;
            },

            /**
             * 滚轮缩放
             */
            __onmousewheel: function(params) {
                if ((!this.shapeList) || (this.shapeList.length <= 0)) {
                    return;
                }

                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    var shape = this.shapeList[i];
                    // If any shape is still animating
                    if (shape.__animating) {
                        return;
                    }
                }

                var event = params.event;
                var mx = zrEvent.getX(event);
                var my = zrEvent.getY(event);
                var delta;
                var eventDelta = zrEvent.getDelta(event);
                //eventDelta = eventDelta > 0 ? (-1) : 1;
                var mapType;
                var mapTypeControl = params.mapTypeControl;
                if (!mapTypeControl) {
                    mapTypeControl = {};
                    mapType = this._findMapTypeByPos(mx, my);
                    if (mapType && this._roamMap[mapType] && this._roamMap[mapType] != 'move') {
                        mapTypeControl[mapType] = true;
                    }
                }

                function scalePolyline(shapeStyle, delta) {
                    for (var i = 0; i < shapeStyle.pointList.length; i++) {
                        var point = shapeStyle.pointList[i];
                        point[0] *= delta;
                        point[1] *= delta;
                    }
                    //If smoothness > 0
                    var controlPointList = shapeStyle.controlPointList;
                    if (controlPointList) {
                        for (var i = 0; i < controlPointList.length; i++) {
                            var point = controlPointList[i];
                            point[0] *= delta;
                            point[1] *= delta;
                        }
                    }
                }

                function scaleMarkline(shapeStyle, delta) {
                    shapeStyle.xStart *= delta;
                    shapeStyle.yStart *= delta;
                    shapeStyle.xEnd *= delta;
                    shapeStyle.yEnd *= delta;
                    if (shapeStyle.cpX1 != null) {
                        shapeStyle.cpX1 *= delta;
                        shapeStyle.cpY1 *= delta;
                    }
                }

                var haveScale = false;
                for (mapType in mapTypeControl) {
                    if (mapTypeControl[mapType]) {
                        haveScale = true;
                        var transform = this._mapDataMap[mapType].transform;
                        var left = transform.left;
                        var top = transform.top;
                        var width = transform.width;
                        var height = transform.height;
                        // 位置转经纬度
                        var geoAndPos = this.pos2geo(mapType, [mx - left, my - top]);
                        if (eventDelta > 0) {
                            delta = 1.2; // 放大
                            if (this._scaleLimitMap[mapType].max != null && transform.baseScale >= this._scaleLimitMap[mapType].max) {
                                continue; // 缩放限制
                            }
                        } else {
                            delta = 1 / 1.2; // 缩小
                            if (this._scaleLimitMap[mapType].min != null && transform.baseScale <= this._scaleLimitMap[mapType].min) {
                                continue; // 缩放限制
                            }
                        }

                        transform.baseScale *= delta;
                        transform.scale.x *= delta;
                        transform.scale.y *= delta;
                        transform.width = width * delta;
                        transform.height = height * delta;

                        this._mapDataMap[mapType].hasRoam = true;
                        this._mapDataMap[mapType].transform = transform;
                        // 经纬度转位置
                        geoAndPos = this.geo2pos(mapType, geoAndPos);
                        // 保持视觉中心
                        transform.left -= geoAndPos[0] - (mx - left);
                        transform.top -= geoAndPos[1] - (my - top);
                        this._mapDataMap[mapType].transform = transform;

                        this.clearEffectShape(true);
                        for (var i = 0, l = this.shapeList.length; i < l; i++) {
                            var shape = this.shapeList[i];
                            if (shape._mapType == mapType) {
                                var shapeType = shape.type;
                                var shapeStyle = shape.style;
                                shape.position[0] = transform.left;
                                shape.position[1] = transform.top;

                                switch (shapeType) {
                                    case 'path':
                                    case 'symbol':
                                    case 'circle':
                                    case 'rectangle':
                                    case 'polygon':
                                    case 'line':
                                    case 'ellipse':
                                    case 'heatmap':
                                        shape.scale[0] *= delta;
                                        shape.scale[1] *= delta;
                                        break;
                                    case 'mark-line':
                                        scaleMarkline(shapeStyle, delta);
                                        break;
                                    case 'polyline':
                                        scalePolyline(shapeStyle, delta);
                                        break;
                                    case 'shape-bundle':
                                        for (var j = 0; j < shapeStyle.shapeList.length; j++) {
                                            var subShape = shapeStyle.shapeList[j];
                                            if (subShape.type == 'mark-line') {
                                                scaleMarkline(subShape.style, delta);
                                            } else if (subShape.type == 'polyline') {
                                                scalePolyline(subShape.style, delta);
                                            }
                                        }
                                        break;
                                    case 'icon':
                                    case 'image':
                                        geoAndPos = this.geo2pos(mapType, shape._geo);
                                        shapeStyle.x = shapeStyle._x =
                                            geoAndPos[0] - shapeStyle.width / 2;
                                        shapeStyle.y = shapeStyle._y =
                                            geoAndPos[1] - shapeStyle.height / 2;
                                        break;
                                    default:
                                        geoAndPos = this.geo2pos(mapType, shape._geo);
                                        shapeStyle.x = geoAndPos[0];
                                        shapeStyle.y = geoAndPos[1];
                                        if (shapeType == 'text') {
                                            shape._style.x = shape.highlightStyle.x = geoAndPos[0];
                                            shape._style.y = shape.highlightStyle.y = geoAndPos[1];
                                        }
                                }

                                this.zr.modShape(shape.id);
                            }
                        }
                    }
                }
                if (haveScale) {
                    zrEvent.stop(event);
                    this.zr.refreshNextFrame();

                    var self = this;
                    clearTimeout(this._refreshDelayTicket);
                    this._refreshDelayTicket = setTimeout(
                        function() {
                            self && self.shapeList && self.animationEffect();
                        },
                        100
                    );

                    this.messageCenter.dispatch(
                        ecConfig.EVENT.MAP_ROAM,
                        params.event, {
                            type: 'scale'
                        },
                        this.myChart
                    );
                }
            },

            __onmousedown: function(params) {
                // edit by wandergis
                if (!(this.shapeList && this.shapeList instanceof Array)) {
                    return;
                }
                if (this.shapeList.length <= 0) {
                    return;
                }
                var target = params.target;
                if (target && target.draggable) {
                    return;
                }
                var event = params.event;
                var mx = zrEvent.getX(event);
                var my = zrEvent.getY(event);
                var mapType = this._findMapTypeByPos(mx, my);
                if (mapType && this._roamMap[mapType] && this._roamMap[mapType] != 'scale') {
                    this._mousedown = true;
                    this._mx = mx;
                    this._my = my;
                    this._curMapType = mapType;
                    this.zr.on(zrConfig.EVENT.MOUSEUP, this._onmouseup);
                    var self = this;
                    // setTimeout(function (){
                    //     self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                    // },100);
                }

            },

            __onmousemove: function(params) {
                if (!this._mousedown || !this._isAlive) {
                    return;
                }
                var event = params.event;
                var mx = zrEvent.getX(event);
                var my = zrEvent.getY(event);
                var transform = this._mapDataMap[this._curMapType].transform;
                transform.hasRoam = true;
                transform.left -= this._mx - mx;
                transform.top -= this._my - my;
                this._mx = mx;
                this._my = my;
                this._mapDataMap[this._curMapType].transform = transform;

                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    if (this.shapeList[i]._mapType == this._curMapType) {
                        this.shapeList[i].position[0] = transform.left;
                        this.shapeList[i].position[1] = transform.top;
                        this.zr.modShape(this.shapeList[i].id);
                    }
                }

                this.messageCenter.dispatch(
                    ecConfig.EVENT.MAP_ROAM,
                    params.event, {
                        type: 'move'
                    },
                    this.myChart
                );

                this.clearEffectShape(true);
                this.zr.refreshNextFrame();

                this._justMove = true;
                zrEvent.stop(event);
            },

            __onmouseup: function(params) {
                var event = params.event;
                this._mx = zrEvent.getX(event);
                this._my = zrEvent.getY(event);
                this._mousedown = false;
                var self = this;
                setTimeout(function() {
                    self._justMove && self.animationEffect();
                    self._justMove = false;
                    self.zr.un(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                    self.zr.un(zrConfig.EVENT.MOUSEUP, self._onmouseup);
                }, 120);
            },

            /**
             * 漫游组件事件响应
             */
            __onroamcontroller: function(params) {
                var event = params.event;
                event.zrenderX = this.zr.getWidth() / 2;
                event.zrenderY = this.zr.getHeight() / 2;
                var mapTypeControl = params.mapTypeControl;
                var top = 0;
                var left = 0;
                var step = params.step;

                switch (params.roamType) {
                    case 'scaleUp':
                        event.zrenderDelta = 1;
                        this.__onmousewheel({
                            event: event,
                            mapTypeControl: mapTypeControl
                        });
                        return;
                    case 'scaleDown':
                        event.zrenderDelta = -1;
                        this.__onmousewheel({
                            event: event,
                            mapTypeControl: mapTypeControl
                        });
                        return;
                    case 'up':
                        top = -step;
                        break;
                    case 'down':
                        top = step;
                        break;
                    case 'left':
                        left = -step;
                        break;
                    case 'right':
                        left = step;
                        break;
                }

                var transform;
                var curMapType;
                for (curMapType in mapTypeControl) {
                    if (!this._mapDataMap[curMapType] || !this._activeMapType[curMapType]) {
                        continue;
                    }
                    transform = this._mapDataMap[curMapType].transform;
                    transform.hasRoam = true;
                    transform.left -= left;
                    transform.top -= top;
                    this._mapDataMap[curMapType].transform = transform;
                }
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    curMapType = this.shapeList[i]._mapType;
                    if (!mapTypeControl[curMapType] || !this._activeMapType[curMapType]) {
                        continue;
                    }
                    transform = this._mapDataMap[curMapType].transform;
                    this.shapeList[i].position[0] = transform.left;
                    this.shapeList[i].position[1] = transform.top;
                    this.zr.modShape(this.shapeList[i].id);
                }

                this.messageCenter.dispatch(
                    ecConfig.EVENT.MAP_ROAM,
                    params.event, {
                        type: 'move'
                    },
                    this.myChart
                );

                this.clearEffectShape(true);
                this.zr.refreshNextFrame();

                clearTimeout(this.dircetionTimer);
                var self = this;
                this.dircetionTimer = setTimeout(function() {
                    self.animationEffect();
                }, 150);
            },

            /**
             * dataRange hoverlink 事件响应
             */
            __ondrhoverlink: function(param) {
                var curMapType;
                var value;
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    curMapType = this.shapeList[i]._mapType;
                    if (!this._hoverLinkMap[curMapType] || !this._activeMapType[curMapType]) {
                        continue;
                    }
                    value = ecData.get(this.shapeList[i], 'value');
                    if (value != null && value >= param.valueMin && value <= param.valueMax) {
                        this.zr.addHoverShape(this.shapeList[i]);
                    }
                }
            },

            /**
             * 点击响应
             */
            onclick: function(params) {
                if (!this.isClick || !params.target || this._justMove || params.target.type == 'icon') {
                    // 没有在当前实例上发生点击直接返回
                    return;
                }
                this.isClick = false;

                var target = params.target;
                var name = target.style._name;
                var len = this.shapeList.length;
                var mapType = target._mapType || '';

                if (this._selectedMode[mapType] == 'single') {
                    for (var p in this._selected) {
                        // 同一地图类型
                        if (this._selected[p] && this._mapTypeMap[p] == mapType) {
                            // 复位那些生效shape（包括文字）
                            for (var i = 0; i < len; i++) {
                                if (this.shapeList[i].style._name == p && this.shapeList[i]._mapType == mapType) {
                                    this.shapeList[i].style = this.shapeList[i]._style;
                                    this.zr.modShape(this.shapeList[i].id);
                                }
                            }
                            p != name && (this._selected[p] = false);
                        }
                    }
                }

                this._selected[name] = !this._selected[name];

                // 更新当前点击shape（包括文字）
                for (var i = 0; i < len; i++) {
                    if (this.shapeList[i].style._name == name && this.shapeList[i]._mapType == mapType) {
                        if (this._selected[name]) {
                            this.shapeList[i].style = this.shapeList[i].highlightStyle;
                        } else {
                            this.shapeList[i].style = this.shapeList[i]._style;
                        }
                        this.zr.modShape(this.shapeList[i].id);
                    }
                }
                this.messageCenter.dispatch(
                    ecConfig.EVENT.MAP_SELECTED,
                    params.event, {
                        selected: this._selected,
                        target: name
                    },
                    this.myChart
                );
                this.zr.refreshNextFrame();

                var self = this;
                setTimeout(function() {
                    self.zr.trigger(
                        zrConfig.EVENT.MOUSEMOVE,
                        params.event
                    );
                }, 100);
            },

            /**
             * 刷新
             */
            refresh: function(newOption) {
                if (newOption) {
                    this.option = newOption;
                    this.series = newOption.series;
                }

                if (this._mapDataRequireCounter > 0) {
                    this.clear();
                } else {
                    this.backupShapeList();
                }
                this._buildShape();
                this.zr.refreshHover();
            },

            /**
             * 值域响应
             * @param {Object} param
             * @param {Object} status
             */
            ondataRange: function(param, status) {
                if (this.component.dataRange) {
                    this.refresh();
                    status.needRefresh = true;
                }
                return;
            },

            /**
             * 平面坐标转经纬度
             */
            pos2geo: function(mapType, p) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                return this._mapDataMap[mapType].projection.pos2geo(
                    this._mapDataMap[mapType].transform, p
                );
            },

            /**
             * 公开接口 : 平面坐标转经纬度
             */
            getGeoByPos: function(mapType, p) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                var position = [
                    this._mapDataMap[mapType].transform.left,
                    this._mapDataMap[mapType].transform.top
                ];
                if (p instanceof Array) {
                    p[0] -= position[0];
                    p[1] -= position[1];
                } else {
                    p.x -= position[0];
                    p.y -= position[1];
                }
                return this.pos2geo(mapType, p);
            },

            /**
             * 经纬度转平面坐标
             * @param {Object} p
             */
            geo2pos: function(mapType, p) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                return this._mapDataMap[mapType].projection.geo2pos(
                    this._mapDataMap[mapType].transform, p
                );
            },

            /**
             * 公开接口 : 经纬度转平面坐标
             */
            getPosByGeo: function(mapType, p) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                var pos = this.geo2pos(mapType, p);
                pos[0] += this._mapDataMap[mapType].transform.left;
                pos[1] += this._mapDataMap[mapType].transform.top;
                return pos;
            },

            /**
             * 公开接口 : 地图参考坐标
             */
            getMapPosition: function(mapType) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                return [
                    this._mapDataMap[mapType].transform.left,
                    this._mapDataMap[mapType].transform.top
                ];
            },

            /*
            appendShape : function (mapType, shapeList) {
                shapeList = shapeList instanceof Array
                            ? shapeList : [shapeList];
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    if (typeof shapeList[i].zlevel == 'undefined') {
                        shapeList[i].zlevel = this.getZlevelBase();
                        shapeList[i].z = this.getZBase() + 1;
                    }
                    shapeList[i]._mapType = mapType;
                    this.shapeList.push(shapeList[i]);
                    this.zr.addShape(shapeList[i]);
                }
                this.zr.refresh();
            },
            */

            /**
             * 释放后实例不可用
             */
            onbeforDispose: function() {
                this._isAlive = false;
                this.zr.un(zrConfig.EVENT.MOUSEWHEEL, this._onmousewheel);
                this.zr.un(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
                this.messageCenter.unbind(
                    ecConfig.EVENT.ROAMCONTROLLER, this._onroamcontroller
                );
                this.messageCenter.unbind(
                    ecConfig.EVENT.DATA_RANGE_HOVERLINK, this._ondrhoverlink
                );
            }
        };

        zrUtil.inherits(Map, ChartBase);

        // 图表注册
        require('../chart').define('map', Map);

        return Map;
    });
    define('echarts/util/mapData/geoJson/china_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "xin_jiang",
                "properties": {
                    "name": "新疆",
                    "cp": [84.9023, 41.748],
                    "childNum": 18
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@ρȁôƧƦóəʵסʵóƪԫʵѵͩƧͩړυࡓɛʵ@ȃ@óᇑѵƨɝɚôóНѺͩɜ̏ԭʵôƧɞñ@υƩ݇ȂóƩƧ@ѵȂυƥŌਗ॥ɛóʵѵƧѹ݇̍ࢯəɞυρͩ̏óਙƨƧŋôōó̍ͩóʵןóŋړͪƧѶ@ɜԭԫƦɛȄ̍ɝȄöςƩȂ̏ñȀ̏ƩóóŎə@Ő̎@ɞȀɝŎôƨóנѵȄƧ@óŏɝóɜôŎ̍ͨςŎ@ƨóôƨɞ݈ʶóƨφó̎Ȁƨ̍ԮòѸԮמ@ѺȀ@ƪၬֆòȂñ̐òȂɜóƨ̒Ŏ̑߼@φρȀ@Ő๐ς̎Ƨφ@ɝφڔ೦Ԯǿࢰ@ƦŏԮƨƨȄƧ۬ɜʶڔŐɚɚóŐôƨ߼ôƧƧó̐ƥóŏѺǿƦȁφƧςƨƧ̒@ɜƥƦυ̐ɛƪͩƩəƪʷ̑ə@ȃƨʵנŋྸōਚԭԪ@ɝƨŋ̒օςʵôƧ"],
                    "encodeOffsets": [
                        [98730, 43786]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "xi_zang",
                "properties": {
                    "name": "西藏",
                    "cp": [88.7695, 31.6846],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôŌנôʶ̎ͪôóŎƨŌਚƧ̐ôςͪφɚɝࢰ݈̎ѺѶƨôʶ०ɜਘƦŋφѶȁ̍ôŏɚŋ@̑ə@ŏò̍ɜóƥôʷƧ̍φѹԪ̍ע@Ѹʷɜ@ôñנ@Ѷɛɞô̐ŏѶƨѸƧƥōƦôŏô@ƧôƩ̒ŋƨŌƦǿô̎ɜȁ̒óʶѶôôО̒ςƥɜНφσɛȁ̎υƨఱƧŏ@ʵƥ@ŌóóóͩƨƧóŋ̑õóɞóɝԩͪɝρôƧ̍ƧѹͨڑŎ̑ōóƧࢭͩ̏ѵɝóఱóóԪυô@̒ƥŌ̏Ƨ̑Ȅ݇ŎƧѵӏ@ɛõŏɛȄôӒƧŌѵǿɝƧŋԫ@̏ʴƥ@óǿ̑Ȁóǿ̍ςóóυô@ʶɛñρƦƩŐó̎óѵó̑ͪࢯОóɜןƧ̏ƥȄ߻̎̏̐ןŎɝɜöɞƩȀôöɛȀóͪ̐ƨƪ̍̎ȂƥԪυО@φɞôƪ"],
                    "encodeOffsets": [
                        [80911, 35146]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "nei_meng_gu",
                "properties": {
                    "name": "内蒙古",
                    "cp": [117.5977, 44.3408],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ኊȁ૊ö߼ƩɜɛנñԮɛѶóԮô@ȁѸóמ̎ගѺၬ@߼ʶԮӒ߼̎@ŐѹӒ̒Ԫƨöග̑ѶȄ̒ς।ѶɚöɞɜʴڔôôȂ̎ѺȀςƨƪóԪɜôɛОਕڔԭѵ̍ѹȂԫɛƥ̍Ȃóɜ̎ô@ʶ݊ੲࢮʵږͪנƨôȂƧ̐ͪ@ŐƦƨφԬѶɜôƦ@ŐƧôôƦəŐ̏@ŐڒѶԬô̐ʳԩНςōôŏɞ@ƨȂѶəóƧ̒ػ̎ó̐Őנóƨô̒@ƨɚɚ@עԫɛɛ@ȁυͩƥʳòևρ̑ࡗƧͪ༃ॣԮփ̎Ʀ@ôô@ôō@@ȁѵóƨ̍υȃóʵɛƨƥóυȂóəƪ̐ρƧͩɜԭڔȄ̎عƧȁ̐ŏó̍ɛƥƧ̑óρŐ@Ƨ̏ɝəɛ߻ͩ̍ͩɝО̍ƪƧóóӓƨóƧʳ݇@ɝςƪ@ʴƩƧƦôƨɛȄəƧŋυóͩѵ@ɝǿóŌן̍ɛóО̍̑̏ôȁ̍ŏòȁñóƦͩ@ǿə@ɛƧ̑ρȁυô̍օѹóȃə@ȂσʵѷƪòƩ̍ôó߻ۯôʳƧóõʵѵóѹɜ̍ȂѹôɛŌφֈƩͨρóυӑóޟఱ̑݇ͪóƪƨŌóȄڔԬƩςםñ̑ȃѵŐԭŏƨȁɛǿρôõɚɛóƧОə@ѹ̐ѵöԪͨôͪɛ̒ןŏƧƥóôƥƧɛŌôóɝó@̒݇Ӓ̒Ō@Ŏԭࢰ"],
                    "encodeOffsets": [
                        [99540, 43830]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "qing_hai",
                "properties": {
                    "name": "青海",
                    "cp": [96.2402, 35.4199],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƨ@ôƪ݈ȁƪ@φɝòóƨԮʶɛ̐ѹͪôОəóƧɞᇒѶ@ôږô@ǿѶƪȁςɜͩφςŋɞôѶɛƨŌɞ@ɚςŐñԪॢͩƨȂɞóƨŐ̎ŏעӏ̎óƧƦô̒ȁɜςͩ̒ɚɛƨôƨɝφɛóȁƨŋóóɚͩƨóóƩ@ƧəŋƦƩ̍@ƧƧôǿυ̑@ȁɞǿõŏρƥסɚƧóτԫɞôƧƦ@ñȃòñƥóυôôѹѵ@ŏ̏Ȅɝó@ȂəŌóəѹƦ@Ő̍Ōυ݈ԩŐƧóôƧ̑ôʵɞƧ̑ѵôƩɞƧ̑óНѵóôʵ̑ɛȂó̍ƥȀƧŋ̑Ōóƪ@ƨóóŐƥƦŎѷƨѵƧ̏Őɝóѵɜן@óòɛ@ѷʸס@ԩ̎υѺƨ̎óʸôƦɛñ̎@Őɚ@̒əŌóŐ̎"],
                    "encodeOffsets": [
                        [91890, 36945]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "si_chuan",
                "properties": {
                    "name": "四川",
                    "cp": [102.9199, 30.1904],
                    "childNum": 21
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôôŋó̑Ԯ̒ɛОמͪƨōöͫ߼ƥôȃƨóóñôƧóƧôōڔŏƨŐ@ŎôòƥѺŎ@ōɜóנôǿôƦôԮ̍ɜôɚƧñɛɚȁ̍Ƨɛևυ@óóôŋρԭɝ@Ƨʸ̍ŏυɜƧƧóƧƨȁρ̍ƨȃɚôʵφóô̑̏Ȃ̑ʵɜʵɞ@ƨʳסƩóŎəóɜƧôƩƧρóôôô@ŎƧƨƨƪѹó̍̍Ʃ@̏ѹНôޟ̍ƩóƪυɝɛəƨôŎɛȀ@Ȃ@ñɝʶ@Ōρנ̏õóɛͨƨȂѵОɛʵ@̏ƩŐó߼Ƨల̍φɜȂυτɛОρƦɝƨóƪ̒Ѷɝƨóʶ̒óƨƨôԪŏφ݇̎ŋ@ŏѺƥôɚɚŋ@ȁɞô̐ȃ@ŐѶóѺφóƦôñòòȄ"],
                    "encodeOffsets": [
                        [104220, 34336]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "hei_long_jiang",
                "properties": {
                    "name": "黑龙江",
                    "cp": [128.1445, 48.5156],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ᇔȂਚНƨŐѶŏöƥςŏñƧƦóƨȁ@óƨóȁφӑóóƨóǿ̎̑ôНɞó̑ɜə߼̎ǿ̒ôڒӑφ@Ƨȁ̎̏ƥƩ̎ρశôȂςƨφ@נɞ݈̑ƥƧɛƨʵƧȃƥ@Ƨƥ@ŏ̑ԩôɝρρóɛƧƩͩƧó߻ʸ̍ʷѹƥɞڕõ̍öɝυ̍ȂƧ̐̑ŏóƨñŋѹóóȁ̍̏Ԭõʸ̏ŏ@ǿ̍@ƧОυ@ñƨòȀƥŎ̑ŐѵóɛŌóȂԫōƧŎѹñ̍ʶóОן@Ƨ̎Ѷô@Ȃ@óŎó@@ó̍ƥԭք༄।ƨͩ̒ࡘςñֈƦʴφͪ@ȂɜɜסԬə@Ƨə̑@Ƨóןô̏ŏ̍ô̑ؼôƨѵɚƧȁɝ@óŐρŎԪО̏ʴ"],
                    "encodeOffsets": [
                        [124380, 54630]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "gan_su",
                "properties": {
                    "name": "甘肃",
                    "cp": [95.7129, 40.166],
                    "childNum": 14
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ڔôԮࢯ@ō̑ŋ݈ӑ@̑ɞôóôɜŋƦƨôóƨƦנŐɜ̑óͩԩͧѶõѺ̏ɚ@ƨНɜôöəςóɜȀƧȂԮŐѶŏ̒ȄמòƪρړԫôȃƧŋôƩ݈ͩɚ@@ǿɜ@φͩóŏɜӑƧōôǿ̎ôƥƪóõö@ôƨôƧƦôó̒ɜ@ɞŌõʶ̏Ő@ȀóôƨȂ@ʶע@@ƥ୾ӑó̑óŋôʵóɛړ@@ƩöóƩóρɛƨ̑@óʷƥƥ̎ɛƧôōƧǿôͩѵôɝȃɞȁõƧρóó@ōƧŏړŐóŎôƨóƨôòƧôóȄ߻ƦõͬƧŎםͩɜНԭ̑ô̒óŌóƥ@óƨɝσԬƨôעəςƦöŐɝȀ@Ȃφ̒óȀƨƨ̎@ƥƪɚŌ@ƨôƪƧôəͪôôƧŌôȂυɜƧɞƧóəɜ̑ρͪɛ̑Ȃóƨƥ̍ôסӐ̍ŐƧŏɝôƧȁॡͪòԩρŏ@əɝƧŋѵɜɝóρŌυɛͪρƩȂѵ@Ȁڕó@ȄɜʶφࡔڔƨͪѶͪԬʶôƩעʶɚʶƥôóƨςȂ"],
                    "encodeOffsets": [
                        [98730, 43740]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "yun_nan",
                "properties": {
                    "name": "云南",
                    "cp": [101.8652, 25.1807],
                    "childNum": 16
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôɞôɝ̒öôŌƧƨôͪôô@ŋƦ@ʶƨŐô߻ƪŏ@̐ɜʶѶНƧȁɜͧöô̐ςן@ŋɞʵ@ò@ȁɜǿóōɚƧɜφɞôƩ̎ƪóޠѺО@̐̎ƪô̎ѺƧƩƨƧ@ōóóôóςƪƨƨóôɛó̑ԭƥŌɛǿɝƨɛͩô@ǿƨȁѺŌɚɛ̍ןѶНɛƧôóƥȁƦͩôŎɞƨ̑ɜòôφ@ƨʵ@ɛѹōóȃəƨυǿóʵρƧƧŌƩɛ̏ȄñƧƧȀɝ̍ԩʶƧ̑υóŌƥʳɚӑóНƥô̑óӒѵʵѹƧӐןôƪφõŌƪ̒ԫŌƧؼƨƨסρȁƧƨȂóʶó@@ʴƨôôφ̎Ŏ@ȀƨƪɚƨóƨôôôςóޤƧŌƩŋƧԪ"],
                    "encodeOffsets": [
                        [100530, 28800]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "guang_xi",
                "properties": {
                    "name": "广西",
                    "cp": [108.2813, 23.6426],
                    "childNum": 14
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƦŋѺ̎ڔʵƨŐ@ƦמȄƪôóȂɜŌɚͩɜ@öóɜôôȂƦôɜȁ@ɞφóȄ̎ƨʶɞŋƨʴɚǿ̐̎Ԭ@ôñ@̏ƨρ۫ôɚƨƨНƪŐ̎ƥóƦʵƥŋ@ȃóƥƧ@@ŏɝǿôυƧȁѵɛ@əóŏ̑@@ə̍óƧó@ȁƩρóòНƥô@Ӓ̑@óŎ̍ƥσŎυ@̍ƨ@Ō̑ôóͪƨ̒óŌړ̏Ŏ@ŌôȄѺŎ@ɜƧʶυ@ñóɛƧ̒ɝóōƥͪ"],
                    "encodeOffsets": [
                        [107011, 25335]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "hu_nan",
                "properties": {
                    "name": "湖南",
                    "cp": [111.5332, 27.3779],
                    "childNum": 14
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@քɜОƨ@öŐמóƪôƩɚ̒Ő߼ȁςͩɜòƪɜȀòñɝòѺͪ@ŏƨŋóɝôǿƨɚȃóəƨȃѵͩó̍@ȃƨóóƥƨƧ@ʵƦóͩɜɛóñԭɛōυȂ̍ƧƦō@ɛƥɛȀ̑óʷóō̍ƩŏƧОəƧóς۬Ƨ@̐óòԫ@̏̍əȀƧʳɝŌóɞƧƨɜóŐƨò@ȄƧŌρŋóôԪОóʶ@̎óȄ"],
                    "encodeOffsets": [
                        [111870, 29161]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "shan_xi_1",
                "properties": {
                    "name": "陕西",
                    "cp": [109.5996, 35.6396],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ςôöƨɝȂɞȄѶóóͪƨȀóŎƨ̍ɜƦƦôʸ̒@ɜƧςƪôõô@ƪڔ@ôɜóʶôŌô̒୽Ӓ@Ʀ@Ѻ̎ɜѺɛѶôöʶôƨóʴ߼۰óô̎ñƪѸƩτʶ@ȁòŋəѹóǿ̑ʵ@ȁ̒ʷυփô݉ôН̏ط@ȁƨóô̏ƪõ@ʳ̐ʵ@ɝɛŋƩŌɛóןôƧŋ̒ó@ŏ̐ƥ@ŏυ@ƧƧôן̏@ƥȂѹɜəɛóԭ̎ƥóóóȀןɛô@ŎѹōñƦ"],
                    "encodeOffsets": [
                        [108001, 33705]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "guang_dong",
                "properties": {
                    "name": "广东",
                    "cp": [113.4668, 22.8076],
                    "childNum": 21
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@Ȃôôƨ̎@ɚ̒@ôŐ@ɚѶɜƨȂóφɞȀ@Őƨ@ôƦ@ȄƦŌƥʶƦôôŎôʸ̒ɜǿƦ@ɜƥŎ̎ƨφȁɜŎòƥԮŎƨōóŏɛƧɝəɞƧ߼ɜςȃñȄƦŎ̒ōôòƨəƨɚН@əƨ̏ƪʵυŌəɛóəԭŏəóŏѹρʵɝƦ̏ƥʳѶöō̑óóŋρȀυƧƥɛѹōƧôןɛŏѵ@óŋôʵɝƪԩõ@Ƨō̍@Ƨ@@ƦɝԮƪО@@", "@@X¯aWĀ@l"],
                    "encodeOffsets": [
                        [112411, 21916],
                        [116325, 22697]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ji_lin",
                "properties": {
                    "name": "吉林",
                    "cp": [126.4746, 43.5938],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@נ@ôН̎ʵѺòƨōԬŎôȁɜŋѶô̒ŏƦōñǿòƧφ@ƨН̎@@Ȁ̐Őöʷ̐ԫ̎ôȂѺôòŌôƧ̒Őƨ̏̎ȁφ@ŋƩͩםȃƨ@ȁ̑ʶ@Ōóôɛƥѹ̑συ݇@ɜρƧȃࢯƨôəȂɛōƩɛ̏υρóõƪʴυφ@ʶôŌóρք@ɜƧ@ɝǿƧͪρȀƩó̏ŐƨȂ̍غړȃɛԮƨͪ̏ςƩôɚφȁƦôɜƧôʶφȄ"],
                    "encodeOffsets": [
                        [126181, 47341]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "he_bei",
                "properties": {
                    "name": "河北",
                    "cp": [115.4004, 37.9688],
                    "childNum": 11
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@Ʃ̒̏ŌѺ̒ƩóȄƧŌƥͪòôñȂ̎ŐóȂ̒̐̎ôНɜנ̎ôŋɞȀѶ@ôͪφƨŌɚɜȃóƧƨƥƪ@ʳƩɞρ݈@υНφʵɜƦρƨƧ̍ɝóɛѹ̍ρŏ̑ôóƨ@ƧƦôƨɛ@ƥƨ@ȂƦ@@ôəŐƧʶƨŌυ̍̎ɛŋôōɝ@óƧ̍ƦʵѵʳôʵɜŏςôƪŋƨŌɚ@ôНƥƧ@ōѸɛ̐ô̎ʵѵНԭ@̍̍Ƨò@ȁɝ@əρυͩƪ̏ƩõƧŎƧōóॡȄɛʶɜȀ@ɞςѶƧƥςɛŐ@ɚɜɜ@Ŏôôςƪς"],
                        ["@@õə@Ƨɛ@ŐóƦφô"]
                    ],
                    "encodeOffsets": [
                        [
                            [117271, 40455]
                        ],
                        [
                            [120061, 41040]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "hu_bei",
                "properties": {
                    "name": "湖北",
                    "cp": [112.2363, 31.1572],
                    "childNum": 17
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ñȄυƦöŐƩóנƨƨφ@@Ő̏Ʀ@Ő̑ôƨŌנóɜôƪŋɜŌѶօڔə݈òɞōɜŎôӏƦóƨô̒óôȃƨó̎ŐôƧƪ@ƨȁςƧə̑̎Н@̍Ƨŏρôԭͩԫ̍ʵƧóȀôɞƧŌ@ŐѹͩñòɞñɛǿƩɛñρͪ߻Ȃ̑ŏƪəƩóםôõŏƧ@ɛНƥȄó̑ѺƧôφóƨƨƦƪóɜŐôóòôƨóφ̐ƨóƦ̎"],
                    "encodeOffsets": [
                        [112860, 31905]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "gui_zhou",
                "properties": {
                    "name": "贵州",
                    "cp": [106.6113, 26.9385],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɜȀƦŋԮô̒ɚôōעƪƧʴɝ@ɛʶ̒ʶ̐ȁƦóȂô@ôŏ@ōôƨʶѸô@ʶƨɞó@ōτöòυƨ@@əƨô@ɛ̒@Ʀɜôȃ@̍ôʵԩНôóςŌƨŋ@ȃƧñôŏƧɛƨôɝƧʵ̍ôȃυ@ɝɛȂƥóóȁɛóõôɛ@əͪɛŋôȁƩóםȃ@ƥƧŏړʶѹ̍ƥŌƦȂóôɜƨѵО̎נəɜѹŋƧȂ@ȀóɜͪɞƧ"],
                    "encodeOffsets": [
                        [106651, 27901]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "shan_dong",
                "properties": {
                    "name": "山东",
                    "cp": [118.7402, 36.4307],
                    "childNum": 17
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ʃ̐φͪɚςɞ@@Ȃƨñ̎̎Ԯ@ѶОƨƧڔ@φН̑ŋ@Ʃ̒ǿ̎@ƨɜԬςôʶ̐ʶöԫƨƧנƥɜŎôō̎@ôŏóρƧŏԫôóƧԩó@ƥɜƧԭóƨʵɛƨ߻ӑɜНԩóô̑óƧʳəóɛƧ@õȀƧ̍ȃɛŐóŏυО̍óɝƩԩ@ƧɚԫȄɚʶƨɞʶԪ̐ړɛƪ̒"],
                    "encodeOffsets": [
                        [118261, 37036]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "jiang_xi",
                "properties": {
                    "name": "江西",
                    "cp": [116.0156, 27.29],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƧȄôɚəȄ̎ʶԬԮͪςóƨŐƪτɞƦōƥƧ@ŏςôóŐôô̒ʷѶƪƩƩǿ@ō̒ɛôυ@Ƨȁѹɛəƨѹ̑ƨ̏óƥѵʷô̍ɛȁôŏɝǿƧԫƧôʳƥōòȃρȄ߻ɛɝƨɞɚɜƨôŐƧŎԭōñƦòԮɜôɛôͪƥ@ʶƧƨôƦƧô@Ȅô̎Ѷͪ"],
                    "encodeOffsets": [
                        [117000, 29025]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "he_nan",
                "properties": {
                    "name": "河南",
                    "cp": [113.4668, 33.8818],
                    "childNum": 17
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@φ̎ƪ̐ɞȄɚ@@Ȃעó̎ŌѺ̒ôֆॢȃôƨŎƨōƪöƩ̑ڔɜԩ̏ɝʵƧəʵԬȃƨəԪ@@Ƨ̒ŏô̍υȁƧɚ̍ôóŋ@ɝƧŋõ̑σ@ŏɜŋôɝ̒ƧɚôôطρóóɛƩ@óƨ̍ŏƧôóȄ̑ôƧóƥôóӐɛōɝŎ݇ñړɚѵֆ@ɞ̏ʶ@ʴƩöó̐"],
                    "encodeOffsets": [
                        [113040, 35416]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "liao_ning",
                "properties": {
                    "name": "辽宁",
                    "cp": [122.3438, 41.0889],
                    "childNum": 14
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƨʴƧôôӔƨô̎ƩɞН̎ͪ߼ͪɜɞɚ̐@ƨςŏ̒ôƦƨɜô̎ƪôςǿƨͩɞȀƨ@@ɛςփôóŋ@ʵφυƩʳö॥փρѹס@əɛ@ͩࢯ@ѹʵρƩʶφȀƧ݈̒۬óʸɝŎѵ@ԭԫןɛƧƨƥςɛυʶφО"],
                    "encodeOffsets": [
                        [122131, 42301]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "shan_xi_2",
                "properties": {
                    "name": "山西",
                    "cp": [112.4121, 37.6611],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɚѺñŌɚôȄѺ̎ֆφóςȂ̒ɜƨɚ@@Ȁƨŋôȃƪѹ̑̐ŋƪ̑Ʃρρóó@ōɛɛ@əɜŏƦρƨρѵ@ɝɛǿɜʵóօѹ̑̍ŋסô@ȁə@ɝȃ̏̍ƩυƧô@Ȃ̐ظóОó݊φք̑ʸ@Ȃ̒ʶôȀ"],
                    "encodeOffsets": [
                        [113581, 39645]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "an_hui",
                "properties": {
                    "name": "安徽",
                    "cp": [117.2461, 32.0361],
                    "childNum": 17
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ó̎̑Ő@ƨƪѶǿɜ̑φƦʵ̐ƧѵôóƪôôυςƨȂɞŏ@̍ԫôò̑ƥóȃѶͩƧƥôŏѺôŏƦ@ƥͩƧôȁυó@̑ƧɛѵʵƩƪѵ̑ʸóóôŏρó@ŐƦƨƥŎσɝƩ@̎̍Оɚ̒ρƨƧȂôɜςôóظəó̑ƨóɞɛŌ@Őτö̒ƨŌ@ɞôŌ̎óƨəφȂ"],
                    "encodeOffsets": [
                        [119431, 34741]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "fu_jian",
                "properties": {
                    "name": "福建",
                    "cp": [118.3008, 25.9277],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@̎óȁƨӑ̒̎ɚƨͩφŐƨɝ̎ŋóŏρ@ōƨòʳəóƨō̏õɛƧ@ƨѵƧōəŏóŋƧô̑ɝɛʳƥ@@óɛõ@Ƨ̑ƧóȁəƧ̑Ƨ̐@ɚəОƧƧɚóñ̑ŎóʴƨƨԬɞȀóŐɜȂó̎ѶʸôƦƧ̐Ѻ̒ɚƧѺɜƨȂ"],
                    "encodeOffsets": [
                        [121321, 28981]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "zhe_jiang",
                "properties": {
                    "name": "浙江",
                    "cp": [120.498, 29.0918],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ѷʶƨɜ@̒φôóȂƨƦͪ@̐Ѹ̍τȂ̒̑נŐמôƪƧôӑ̑@ƥρͩƨօ̏@@υɝó@ŋɛ@ôƩəóƧѵυó@ƩɜŋƧ@̍ŌƧɞυŏƧͪ̍ə̑ƧӒôȂ̍@óφ̑ɜ@ŎƪȀ"],
                    "encodeOffsets": [
                        [121051, 30105]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "jiang_su",
                "properties": {
                    "name": "江苏",
                    "cp": [120.0586, 32.915],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôɞ̎φНôŐɜŏ̎Ȅƨöǿƨ@ôɜɚƨʴ̒ôôó@Ƨ̎əԮȃԪૉöͩ̐ƧòʵφƧôʵ@óړɜóŏɜǿƧɝρσȁѷ̎̏ƥóŐѹóŐƨƦѵͪôȄƦñ̒Ԭó@̎ɝŐƧȁρóφƩóóôƨѶ̏ƥʶυɛ̒ѵȀ"],
                    "encodeOffsets": [
                        [119161, 35460]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "chong_qing",
                "properties": {
                    "name": "重庆",
                    "cp": [107.7539, 30.1904],
                    "childNum": 40
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@əȂòɜƨѺɛƦȁ̐@ƪõŏφƥòȃƥ̍Ƨôυ̏ƧôñóóôɛŏƩôƧƥôƧóυƨ̒ѹôƦȃ@փƥɛ̑@@ɜƧó@ɚƧ@ñφσõ@ŎɝôƧ@ʵѷóƧʵó@ŎóŐó@ôȁƥó̒υôóʶəƧȄς̎ƧȂôƨƨƨφɛ̎Őƨʷɞ@ςԮóŌôôφ@ɜֈ̎ƨ"],
                    "encodeOffsets": [
                        [111150, 32446]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ning_xia",
                "properties": {
                    "name": "宁夏",
                    "cp": [105.9961, 37.3096],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ల̒ôޠφӒςôƪͧυևɜŋѺó̎ȁ̍ɛ@ѹס@@ʵƧȁôó@ǿ̐ŏöʵɝŋɛ@ô̑ƥóóƨƧóôó@ƩôóƦ̍óȀƨŎɛӒôŐυͪɛ@@Ȁə@"],
                    "encodeOffsets": [
                        [106831, 38340]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "hai_nan",
                "properties": {
                    "name": "海南",
                    "cp": [109.9512, 19.2041],
                    "childNum": 18
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@φɜƦʶ̐ôφô̎@ƨŎö@τʵƦԩ۫õН̏óƥȃƧ@Ʃəםƨ̑Ʀ@ޤ"],
                    "encodeOffsets": [
                        [111240, 19846]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "tai_wan",
                "properties": {
                    "name": "台湾",
                    "cp": [121.0254, 23.5986],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôƩɝöƧɝѵəޣ̏ρƩԭóōóͪρɞƧОôԪ݈ଦѶɜ̒ɛ"],
                    "encodeOffsets": [
                        [124831, 25650]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "bei_jing",
                "properties": {
                    "name": "北京",
                    "cp": [116.4551, 40.2539],
                    "childNum": 19
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@óóóυóôƥ@ŏóóə@ƧŋƩŌρóɛŐóʶѶʴƥʶ̎ôƨɞ@óŎɜŌ̎̍φƧŋƨʵ"],
                    "encodeOffsets": [
                        [120241, 41176]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "tian_jin",
                "properties": {
                    "name": "天津",
                    "cp": [117.4219, 39.4189],
                    "childNum": 18
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôôɜ@ƨöɚôôôɚŏ@óƥ@@ȁƦƧɜ@óƧƨƥ@ƧóəН̏óѷɜ@ŎƦƨóО"],
                    "encodeOffsets": [
                        [119610, 40545]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "shang_hai",
                "properties": {
                    "name": "上海",
                    "cp": [121.4648, 31.2891],
                    "childNum": 19
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɞςƨɛȀôŐڔɛóυô̍ןŏ̑̒"],
                    "encodeOffsets": [
                        [123840, 31771]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "xiang_gang",
                "properties": {
                    "name": "香港",
                    "cp": [114.2578, 22.3242],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@óɛƩ@ρ@óôȀɚŎƨ@ö@@ōƨ@"],
                    "encodeOffsets": [
                        [117361, 22950]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ao_men",
                "properties": {
                    "name": "澳门",
                    "cp": [113.5547, 22.1484],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@X¯aWĀ@l"],
                    "encodeOffsets": [
                        [116325, 22697]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/chong_qing_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "500242",
                "properties": {
                    "name": "酉阳土家族苗族自治县",
                    "cp": [108.8196, 28.8666],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XJ°lJX@lbl@XbV@VLnJlxnbUU@IVK@lVIVwnJlU@n@J@L@Jn@l_nWVLVln@@blLmV@@xÔ`nxVÈLlxLVxVVV_U»VWn_m¥XwVmnX°lmUUVwÞaVk@a@mmIUa@mwk@m@@U¯a@UV@@K@ykkmwkV@kU@ÑVkKWLÅamaUm@kyU@WkU@UaIUaVaUUmUUa@aVLXKWa¯UUbmJXnWnX`l@@xkzWÆ@VLU¦x@b@JkIkJ@LmbUamJwm@óxnk@V@xVnUVmVUVUbVlUbkXW"],
                    "encodeOffsets": [
                        [110914, 29695]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500236",
                "properties": {
                    "name": "奉节县",
                    "cp": [109.3909, 30.9265],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WVXbUnK@x@b²kxmKkl¯_VV°VU@bnKVVV@@nk@nbn@°@VLČU@°WV@VnU@InKVl@nUbKnXWlknLlKUwnalLaVlUXmWk@UU@UWWIUyķ¹XaWW@XKUIVmU@W@UVU@KV@n»VkUkÇmUmVIUmULUbm@wUaKkkm¯ÑUL@bWVnx@VmxUI@klmkkK@aK@IlJ@I¯k@mak@mnkJVL@bV@UbW`UUUVI@VU@VVbUJVLUVVbUXVVxk¦VJUnVxnVVUJV@Ubl@@bXV@L"],
                    "encodeOffsets": [
                        [111781, 31658]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500238",
                "properties": {
                    "name": "巫溪县",
                    "cp": [109.3359, 31.4813],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nLWbXVLVUV@KIVl@b@lbUVnU@JÆU@V@n°KĢUl@VbÞKV@_VKXUU@KX@wlkkU@mWKUU@UôJ@XV@aVmÞIVaVL@»km@UkLU@aU@WWLUUUKkbwWa@KU@kaXmWLamVk@UmL@JmVUU@¯X@ċVUK¯@ÅnWKLkKULWK@UXK@wW@LkV@bVLlXn`¯xU°LnlV@n°Lnl"],
                    "encodeOffsets": [
                        [111488, 32361]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500234",
                "properties": {
                    "name": "开县",
                    "cp": [108.4131, 31.2561],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n@naIw@@VVKLVbVxnVÆUnanKWXamKmk¯K@mkUm¯KV°w@Wm@UIUUlKUU@a¯KWanwmUXamKkUWUnU@KkUwWKXaWLUWkImaUUUKka±k@l¯wwmbUkXm@UJkIWXXbmUJXUV@°KllVXV@xmbnV@blV@VU`UL@Va@bULlb°VXbÜ@V@bL@JxnLVb@lVb@V@@zbXWXKVLV@@bUVVL@blVna@ll@zl@@J"],
                    "encodeOffsets": [
                        [111150, 32434]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500243",
                "properties": {
                    "name": "彭水苗族土家族自治县",
                    "cp": [108.2043, 29.3994],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Jlb@nVV@bXb@ÆlLUl`nVKU¼VxkbWnlUxlXX@°°WnnJ@VUn@Jk°L@VlV@nUJx@bVVVz@VnLlaKnalVlIU¼@nV@@anKUwVal@UlJlI@akU@UWXKVI¯Uak@@KmkXWÜkXWykIWwXw@laXamkVUUym_XmlkkmmakwmIUKU@Wak@kaW@kI¯WIk¦VUUmaUV@XkVUV±aUb¯b¯¥m@@ImJ@mmL@kUKUkkJbV¦"],
                    "encodeOffsets": [
                        [110408, 29729]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500235",
                "properties": {
                    "name": "云阳县",
                    "cp": [108.8306, 31.0089],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lbLVVVnblJVXXKWbXLVxl@LmVXVVlnLWbnVmxXb°L@bVVkLVVVJn@@X_WmkUK@alUKX@@xWL@VXLVKlLKXLÆm@ma@ml@mU@UUmL@aVUU¯U°`lknLlw±@a@wmLVWaXU@KWU@ak@VaU@IUVmUUwVmUIl¥UwUVWUaVUUKVIUa@UUUUJUUmknl@@VWV@L¯aUbUlx@@b@VULUx@VUxVVU@bU@mxUU@mUVklkk@WxknlxK@amLKUK"],
                    "encodeOffsets": [
                        [111016, 31742]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500101",
                "properties": {
                    "name": "万州区",
                    "cp": [108.3911, 30.6958],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĸĊVInaWWXlJVIn@lWVnax°xkl@²LVLnK@bLkwlmXw@lllkUnVV@VnwV@@aVUUVw@UVwVK@U@a@kwVVa°b@KXU@U@mkÇÑamlkUVmn@VULUm@kUVkUawUWm@Uw¯mKUUmVUUULUKUW@XbWVkaWwkUUk@maUbmbVlk¦xUVUIWVUkJVVkL@UmJUUVU@lLUVUlx@@VbJUL¯¤@V"],
                    "encodeOffsets": [
                        [110464, 31551]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500229",
                "properties": {
                    "name": "城口县",
                    "cp": [108.7756, 31.9098],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VK@w¯L@m@UÅV@ImVUVka@@aUkJ@LUUVUKmLmbÅVmUUwUaKUL@U@xJmbm@nVJ@X@VkVnlLXx@b@bUVLU`UnbU@@mVVX@JX@VLVVklV`@bUL@VLVKn@U@UJkn@lmLmK@X@Jn@mbnÞWVXnJkKČÑÆ@VK@knaÜmXlUČW°kôÇÆ@a@yÞ_VmUnU@K"],
                    "encodeOffsets": [
                        [111893, 32513]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500116",
                "properties": {
                    "name": "江津区",
                    "cp": [106.2158, 28.9874],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@InWUUlU@LValX@°²lÒXxlK@Ul@@Un@UaVJ@I@W@UUUVUwVIUKUaUUVwn@Üx@XUlnnbJ@¥VklKUUlk@ynU@kVUUVWnI@¥V£VWVIUKU@UVa@n@Vm@@nlUaVkUwJ@blLkLW@XWmXkmmLn@m@U@UVm@UVUUlakUVaVkV@@wnaWUk@VwklmVIkUUxmJ@U@KIkx±V@IUm@K@IUKkbWKUbnm@bmVnbmb@xkxUJ@ULW`@bX@WVXL@V¯mk¯@UJ@VmLUaWnX@WJ@nkKkxW@UIV@@KkImmkK@UW@XaWIU@UIkbWbxXlLVbnV@bWlX@VxVLnl@nÆÞVÜ"],
                    "encodeOffsets": [
                        [108585, 30032]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500240",
                "properties": {
                    "name": "石柱土家族自治县",
                    "cp": [108.2813, 30.1025],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@kl@¼UbmVXJ@bV@nxVIVJULVVk@@LWbnJVU@bVbUJ@blLXnWV@mbnV@Vbn@VJVLnaVanbl@VlVXxlbXUWaX@VUUVwUUVm@I@WmI@amlLlK@alwnUV@kóVaÝk@UlbVK@VU»VUUVWU@U`ULkwm@@KmU@knK»VkJkUmbLkbmK@UUyUU@awm@@XXJ@VVLVVUbVnUJVX@Kk`WXXJWXUbmW@bkLUm`Xnb@JVL@LU@°VVXKVnUxVLUbmJ"],
                    "encodeOffsets": [
                        [110588, 30769]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500237",
                "properties": {
                    "name": "巫山县",
                    "cp": [109.8853, 31.1188],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@kVUbkKmbVxkLmKkllbV@@LXbxlaLVVVKXXV@@bVlKV@ln@¼°KXaU@Ulw°JXalIUaÝWXW@kVU@VUVWUUUamUw@aVamwn@VUUlLXWm£@wÇĉkKklmLUÒ¯Wn@ğ±kwmaWm¼U@@LUV@V@XVUnVJLW@XXWbĸºVzXJVXV@@VXlWn"],
                    "encodeOffsets": [
                        [112399, 31917]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500102",
                "properties": {
                    "name": "涪陵区",
                    "cp": [107.3364, 29.6796],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nèVblĖVVnL@xVn@nJ@LUVVX@lbUJV@@nn@VVVK@zV@nzVJVUlmX@@_VVVbnaVal@@knW@wnaVK@aVIJ@£kUVW@wXUVJam@Ik_X¥@WwkKkwmkUxnÅmm¥WV@Um@UlVL@JU@@X@UVkKVkKVkKkb@bmJVXUVVUbU@@`W_UV¯b"],
                    "encodeOffsets": [
                        [109508, 30207]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500230",
                "properties": {
                    "name": "丰都县",
                    "cp": [107.8418, 29.9048],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Þè@XUK@LlV@blbUJ@V@bnV@VVVXU@lbXal@VXnKV@maXUÞ@amk@aVKXVanb£°mnIVaUKVwUmWLUU¯V@@KUK@IaWmn_VlK@anXVaXWWIXWl_@LUWVIUmVaUUUK@UWI@Wn@VI@mkU@U¯Kl@ImVÅLwU¤óbUU@wWXkmm@LU@@VUIWVUL@JUnax@JnbUIWVx@UXlV@¤IUJ@bULmb@xmX@lk@UbmbUaUU@`W@kn"],
                    "encodeOffsets": [
                        [110048, 30713]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500232",
                "properties": {
                    "name": "武隆县",
                    "cp": [107.655, 29.35],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lwbVm@IVKXUVJ@UV@@KnnWlX@xVVôaV£xÆKnUVm@UmIXm¯¯@WkWVwmkXlaUwV»ULmk_VkK@ÅWa@aUU@mkaIb@n¼nm_@mmK@ULUVVmI@aUJ@XWJ@U`UIkm±kk@@lULmUmKUnVnlUVmI@VkVlxbkIVmLUxkKUXn¦ÆnmVwlnlxlLXx@W¦`"],
                    "encodeOffsets": [
                        [110262, 30291]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500119",
                "properties": {
                    "name": "南川区",
                    "cp": [107.1716, 29.1302],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VUbVJVUn@VLX@WVXVVI@VUVWxU@m@ĊX@@¼V°aVUX`@_V@VaUUVUWnI@alaLUlLUllLVU@@WV@@IUKVkn@@VlLVwnKUlJakwlU@UnJVUmkUVmXa@wVK@UUw@VVI@ak@alInwlKXUmaUW@wWLkKVak_ÇaUV@XbLVxUlWIk@UK@V@kU@VbUVUlVnLUV@lVXmxkV@L@V@Vk@WbUwmL@JUI@xVxkx"],
                    "encodeOffsets": [
                        [109463, 29830]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500241",
                "properties": {
                    "name": "秀山土家族苗族自治县",
                    "cp": [109.0173, 28.5205],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XlV@lzn@VnbÆbXKlLUÒV@@llUnxll@z@LU@@V°b@Vn@l@VÑUnK@UU@aUakVm@K¯wklmnnUl`nI@almkIUwmWVkUakkJmUUa@K@aU@@_m@@wUyVUUa@Um@awl@Wka±UkUykIWVb@bUVk@aU@UXUUIWakUWmUxUV@nUVWb@XXVVmXX@VbVLkVWx"],
                    "encodeOffsets": [
                        [111330, 29183]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500114",
                "properties": {
                    "name": "黔江区",
                    "cp": [108.7207, 29.4708],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VX@V@LV@VJUL@lVnnxlb@VXVXV@@W@UIVK@kUKna@£VWUaVUUalIVJVIUW_lm@bXKV@mn@JUUw@KnIVll@VanLVmUkVKXLVKUIVamw@UaU_lwKlwUWV_Ua@aUa@KUwm_Ó@wU@nkK@am@UkUKmXk`m@@I@K@I@mkVmIUxUJ@kUL@JVVlnklWnn`VzUVnlWbkb@WxXxlJXzWÛlWXnl@Ll@Vb°UJWLX@VlV@bkJ"],
                    "encodeOffsets": [
                        [111106, 30420]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500117",
                "properties": {
                    "name": "合川区",
                    "cp": [106.3257, 30.108],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XKVXlKVL@UnV@aValXXKU@WVwUaVU@IV@@aVWL@U@anVV@@bVK@UVL@bnJWL@VnUnb@@JnIlVl@@bXIWbn@UKVLVKXLlaV@VVnK@bVLmIV@KmknUUWVI@aVJ@_WU_VmUwU@KVak@am¯mJU_UJUkU@WkIV`UI@JV@LmmU@@mbUzÅ@VK@nUKbakb@UWK@bkVVbVÛ@@`Xk@W@n@lXL@bmb@VVJUn@JnUlnUlmX@`XLlbkJW@kzlb@`@b@b"],
                    "encodeOffsets": [
                        [108529, 31101]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500222",
                "properties": {
                    "name": "綦江县",
                    "cp": [106.6553, 28.8171],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@¦@XlVX@@UVKlVUX@lanVlUVbXWVXVVVUnKVUlwUwU@UJ@nmVkUVlwXam@VaUUUw@W@kk»mV@UmKkwVKVUU@@LUKVI@mV@XVWxnXVKUUUK@wWU@UUWnUlLXamUIam@wI@K@amImUUkI@makUkKWUUan@wamLVxk@UVmUUL@Vm@kV@I@ak@@bWVXJlLVbVL@@bn@@`Un@WbUKULWVXb@UVmbXWVb@bVmxUKUV@Un@V@V@nmnKlnnWWXX@lKkK@aIVxUlVbk@mn@@U@mbVUV@VLUJUXU¤"],
                    "encodeOffsets": [
                        [109137, 29779]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500233",
                "properties": {
                    "name": "忠县",
                    "cp": [107.8967, 30.3223],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VLÞĊU@W@¼V@lk@w²mlVUllVnI@VlKUUlIVXUVJVUwl¥UkUKUIm@aU@mUna@XUWmkK@aVIUa@aUVmIXa@Kl@UUVKUIUJmwU@@aWInUVa»k@@l¯n¤mabWUUL@bnl@bÝWVnbU@mLUWk@Wbka@WVUU@UmUmVkUULVlVUxl@L@VbÈÒlb"],
                    "encodeOffsets": [
                        [110239, 31146]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500228",
                "properties": {
                    "name": "梁平县",
                    "cp": [107.7429, 30.6519],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XLV@VV@b°°nnkb@bnJWVXblIUVxWnUJnVVLVUJlUnLVK@UnUVJ²nKVbVKla@aXlJkKlb@U°£KVIUa@@kwVVUkKV@VUkkUVk±n@xkl@U@»@XVÝĉUJnxWb@UXKkVUbUKWUkVmkkLU`b"],
                    "encodeOffsets": [
                        [109980, 31247]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500113",
                "properties": {
                    "name": "巴南区",
                    "cp": [106.7322, 29.4214],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nxnVlJlUXL¦@x@Vl@nKVVX@V_V@@KlVXU@lKlxXIl@ÈĊ@Vl@n_VJlnVlnb²VVVJVVmUUkĕUamçU@»W@@ĉnV@XwVU@UUJWUXUW@UKm@UVUIVaUUVmLUVUUUWWXUakVmUkbW@UVkUL@VW@kUW@mJUXVVU@lmV@zklVVkLUl@¦I"],
                    "encodeOffsets": [
                        [108990, 30061]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500223",
                "properties": {
                    "name": "潼南县",
                    "cp": [105.7764, 30.1135],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@a@a@_kalyX@lIkaWK@_nWVkkmmV@IVmUI@Una@aWK@k@mkbWaknmJUk@mk@@kUal@Ua@Wa@aXLlwUKlkk@KmI@VUJ@Lk@@VUUmL@amJU£kKUaWakLmU@bVVUbnbWV@xkL@bUbxUxVbXJVbUVWIUVU@kLWxkKWV@n¯VUbU@@VVX@VmaUL@VUK@VVbn@lVnI@@lnLULm@Ub@l@na@lK@XVVkJ@b@zl@@VnV@bVb@J@bnXV`lXXmVI@W@InbV@@aVKUblKVLUanLlmnLlK"],
                    "encodeOffsets": [
                        [108529, 31101]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500118",
                "properties": {
                    "name": "永川区",
                    "cp": [105.8643, 29.2566],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@bÜnWVLXlxVVxXxlVn@@bVblK@a@UnLVJV@@UnLVU@VXaVKVX@n`WUÿ@IUKlaUUUkWyUÛÅÝ@mmkUKUwW@Xk@amUUakKWwXaK@VVLklXVlkxVUL@bm@Vxn`IVxUVkLVUl@@lkXmmVUn@VV@Xb"],
                    "encodeOffsets": [
                        [108192, 30038]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500231",
                "properties": {
                    "name": "垫江县",
                    "cp": [107.4573, 30.2454],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ċ°¤nÒ¼aV_lKnllUXVVLValULVW@XamwVIUKkaÇÑa@U@KkVwkUUVKlVnU@aU@VIka@akU@KVL@WÝçUV@VmbÅ¯@LKnnJWVkxlL@VX@VxmnXVWxUb@bkn"],
                    "encodeOffsets": [
                        [109812, 30961]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500112",
                "properties": {
                    "name": "渝北区",
                    "cp": [106.7212, 29.8499],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@bVVXLa@lnbWn@L@XVlK@VVLUVlbkLUKVVVL@VnXVL@VV@UbVb@x@¦UxVb@bUJL@LVVxlK@nk@U@WUVLlKXV@VblU@UUKVU@wn@VJVanLlkX@VaVK¯@a@U@U@VaUKkUU±maUkm@UUkbm@@Vk@@JwU@Ub@I@JmwUL@a@@KkVÇLkWk@kUU@@xUVmKUnllUb"],
                    "encodeOffsets": [
                        [109013, 30381]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500115",
                "properties": {
                    "name": "长寿区",
                    "cp": [107.1606, 29.9762],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VVUbXlX¥l@XnVmlxUx@@blVnnôĀlm@aVaXwWUnmUwW@@UkKlwUXmImL@KÆ°na@UUImyU@@yULUUm@@mU@VIkaW@UUV@KI@mmUw@mKUnUUIlVLUb@@V@V@b°ULUbW@klmKUbUIm@@xUVVL"],
                    "encodeOffsets": [
                        [109429, 30747]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500225",
                "properties": {
                    "name": "大足县",
                    "cp": [105.7544, 29.6136],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XUmaVaUU@anVlKXbValU@aV@@IXK@@bV@VxVK@UXLlUJXa@_@@aVKÅWVkwWawUa@am@kUWLU@kWmX@ykI@W@UV@na@LlLV@UkwWUKmXX`mIVl@bXLWVkbkkx@`VXm@@J@U@UUKUxk@WbUIVl@VXLWJUkUlUImxXlmb@X@VUJUnVbW@UV@@VVX@bnW@LVxUnlJUV@n@VxVIn@l`UVVVL"],
                    "encodeOffsets": [
                        [108270, 30578]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500224",
                "properties": {
                    "name": "铜梁县",
                    "cp": [106.0291, 29.8059],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VblLV¤nI@bnKVV@Ul@@KVI@UnJ@LlklVLkxWK@bXb@Vbk@Vb@ll@@nVlnIlmXblaXl@W@_Ü@UUalU@aXL@VlabaVL@mUL@UUÇXUWX_WaU»m_@UWULWb@UUVmK@VU@UImK@V@bkLxXblxXUÆUL@b@@`WbIkVWK@VULUwU@@a@WL@JU@@bkVUb"],
                    "encodeOffsets": [
                        [108316, 30527]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500226",
                "properties": {
                    "name": "荣昌县",
                    "cp": [105.5127, 29.4708],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VI@U@WnaWknwVJVkVlIXWK@UUkVJXal@VwVL@V@V@In@UW@_wlllaXUWK@aUknJW_Û@aWaU@@UVmUUaUImJVnÅUmVUm`kUUVWLnVU@VVmXK@nxmULkxImJ@nU`@X@Vkn@`@nlV@nVJVaXVLnK@bVV@nV@lbXW@"],
                    "encodeOffsets": [
                        [108012, 30392]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500227",
                "properties": {
                    "name": "璧山县",
                    "cp": [106.2048, 29.5807],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XzVlVVkbVL@JVĀX¼VXbW`XWVÈVVVkV@@UXa@alK@IU@UKWUyUI@wVUUWVak@VUkW¹@WXI@yVIUK@kWwkÑ¯±W@kUb@KkVVVmXJ"],
                    "encodeOffsets": [
                        [108585, 30032]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500109",
                "properties": {
                    "name": "北碚区",
                    "cp": [106.5674, 29.8883],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XVLV@@JkL@bWb@VU@UlÆVya@nV@nn@KU@IVJU_lJXV@VlVIV`nIn°@blUbKVI@aUaVw@¥@wUaVaU@@UUKWm@UUKUUVLlKkaVUUK@UkLWU@@KXmma@kbWKUU@aUamLnÞ@VWLk@@Wm@ULU@@UKUVWI"],
                    "encodeOffsets": [
                        [108855, 30449]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500110",
                "properties": {
                    "name": "万盛区",
                    "cp": [106.908, 28.9325],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VIV@@wVJ@InKVxXal@@U@U@KlUnwUW@kVUKUmVkUa@I@KW@@bk@@mU@m@k@a@aIUxmJk@wULwkKmVVX@VXV@xVLVVULmWXwWUU@@nUJVL@KV@UVULlxnL@VnUl¼@l@XVxVVUbn@WbkxUlVnU@m"],
                    "encodeOffsets": [
                        [109452, 29779]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500107",
                "properties": {
                    "name": "九龙坡区",
                    "cp": [106.3586, 29.4049],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XKL@V@XbV@lW@UV@@VXIV@UVKlL@KnnJ@VV@VU@I@@mVUVWUUmL@V¯LUK@UV@UU@a@U@yU@WLUK@X@KUVmL@@aXI@w@ammVk@WÛwm@UxVVVbVLUJVxVUV@V@X@JUIVbm@@Vk@@VkL@lVLUJ@zWJ@X"],
                    "encodeOffsets": [
                        [108799, 30241]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500106",
                "properties": {
                    "name": "沙坪坝区",
                    "cp": [106.3696, 29.6191],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XºlUVl@UbVXUV@xVJVzXJVUL@VV@VKn@@Xl@XK@UmÝnKVbVakkVm@kUK@UmIm@LkKULVU@WJ@UU@@VkXU@Wa@@UKWL"],
                    "encodeOffsets": [
                        [108799, 30241]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500108",
                "properties": {
                    "name": "南岸区",
                    "cp": [106.6663, 29.5367],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VVJVL@bUVVnl`XIlwXJlw°nnlIXW@UÇĉk@WJkwkL@WVkU@LU@U`W@UXUV@n"],
                    "encodeOffsets": [
                        [109092, 30241]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500105",
                "properties": {
                    "name": "江北区",
                    "cp": [106.8311, 29.6191],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nLVU@wV@lV@XllÈKlU@L@@bVKnx@I@JVaV@x@Il@@Un@laVVn@mkUIm`k@WXJmk¯mkxWIkxWJk_UmVUUK@UU@@l"],
                    "encodeOffsets": [
                        [109013, 30319]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500104",
                "properties": {
                    "name": "大渡口区",
                    "cp": [106.4905, 29.4214],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@k@@U@w¥WKkVkImUmwa@b@xWJ@b@nKVU@L@WVLXKV@@z@V@bVVU@@VVL°K@U"],
                    "encodeOffsets": [
                        [109080, 30190]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500111",
                "properties": {
                    "name": "双桥区",
                    "cp": [105.7874, 29.4928],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WwUwU@kK@KmbU@@V@XlJ@znWlXV@XK"],
                    "encodeOffsets": [
                        [108372, 30235]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "500103",
                "properties": {
                    "name": "渝中区",
                    "cp": [106.5344, 29.5477],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VL@VV@VL@aUKIUU@@JUVU@"],
                    "encodeOffsets": [
                        [109036, 30257]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/fu_jian_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "3507",
                "properties": {
                    "name": "南平市",
                    "cp": [118.136, 27.2845],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@knyk@KU¥wV@nkWzUmk@@lKUa@aVI@UKUamKUUVaUI@X@UV@K±IUVVlUbUbUL@KWUXmWk@KkXmmkÅKUa@amUbkUkKWUnwUÇwVUUÝUKV£U@nKWwXLVKm¥@wUXkmWk@@wX@lU@yVImaXwV@knU@mbk@mlUXmU@mV@n@bnW@bUIWJImVUKWbUK@nkKaU@W_VUUmWmL@UU@bUWUL@V@bmVUz@`mUUVVbXL@VL@lmLUxmVamXkW@xWbUVbUxkU±@ÅUmmkLUbW@@`kLknVlV@lbXxlVUXVVUU@UbWkIWVUUUJkI@llbUxVL@VVUU°ULUmWXUV@VULWb@xm@UaVLVKUa@w@VbkmVambUUm@@VkK@@bxlxX@n¤@X@@lkLWV@nVkb@bWJXLWx@nkxmmbXn@VWVUn@VnJ@bVXl@VJXnWbX`lLUlJVI@@VXV@Vl@bn@@Æmn@VxXU@mVIlxVnIl@nVJaXI@mlU@aXkVm°klmnVV_na°@V@xÜ¦XKVnnUlVXbVKLXKV@naV@@VVl@@lXblXWnLlbVK²n@@VLUnlV@lXxô°V@UnaUUlKXLVUVVUbVVlUnJVX@VW@an@lb@nl@VU@anUVW@kaUm@InVVKVU@kUW@Uam@km@kVa@a@nwU@WlI@mVI@WXaW_n@nlkkW@U¥@kV@Uw@wU@@IXK¥VIn@nU@`@Xl@VVLnaWbVaUwnU@VIKlV"],
                    "encodeOffsets": [
                        [122119, 28086]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3504",
                "properties": {
                    "name": "三明市",
                    "cp": [117.5317, 26.3013],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lL@Un@VVnabnUla@Ux@VbULUKVbn@w@XaVK@UVUXWVnVKV¯VU@UUKVwka@klJVIVVXUlJXVaV@VUUVWkUWwkaU@UklmlK@_X@ValKnnÆV²@lVVwUaVXa@wlXnWbnUVwnK@kK@UWKUaVUnV@_VynU@a@UVKVXaV@@VnKnXVVUX`V@blL@mVLXaVLnUJXIVJ@amX@a@mnUV@nVWnkl@naV@ml@@KmKUam@UU@@UlKUVkUK@aVaUwVU¥UIkJ@wmI@mbkwkVW@UXKULU`IVKUa@LkkVmUU@WlULUWÅU@I@WWnU@@w@a@Uam_XyVIVWkk@mwVKXUV@nwVXkWÅU@aU¯KUnK@¯mULXVLnWVbVbUVm@Ub¯¼W@am`kbamLUUUaUXV`@x@XmJ@n@L@xkJUU@kU@mWm@kUUwUUVWl@VUkIy@kkaVUUmIWVXbWxU@kmVkK@nWVX¦WxU@@bkx@VU@Wk@kUbmJUUmkUW@_kKWK@knV¤kIUKWLUbV@Wbk@@VWL@VkI@lUXVxUVU@@mWIV@a¯nUaaUV@Jb@bÞ°VbU@XaUVmL@VXblnV°n@Vnx@VUUUlK@InJVb@Vlnn@VL@VWJUx@XlJUVVVl@LUUUJ@L@lUL°¦kVVnV@xVl@blLnlLVaXll@nVUn@xn@nml°X@lb"],
                    "encodeOffsets": [
                        [119858, 27754]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3508",
                "properties": {
                    "name": "龙岩市",
                    "cp": [116.8066, 25.2026],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@aI@VUbVb°m@bUXJ@nV@VUUwVW@klJ@UXK@Ul@Xa@UVaXKVLlJU£lm@XLlL@`VXnlVVnIVall@XV@@Ulw@aV@XwW¥XU@mlLnUlV@XwWaXUJVnUVlb@lzlJUVk@UXVVVxlVn@nXV@@lVVlI@w@K@mnI@W@wU_VWbVVVnKbla_nbX@°»Van@VUUaUamXUKWK@a@Uk@wWkXWW@wUUKw@_lywUkU@@U@kamVmXaUVUka@Wk@»UUUVKkbWUVUbk@mkxkKnIVUmW@kUKmXUmVaU@kU@m@KUWVkIWJ@U@UI@wUUUa@KW»nU@mVkUmm@XwWU@UUmL@w@mnVUU@aWak@@amxU@UxULWVXbVLU`mbUImVUbnV@@bVn@bnVWxLmyUbIUK@aVmakbVUXWUlKWbkV@WLUlk@@nbb@lkKmU@UIWJkw¯UUVVxm@@XkbWxXKlUzWJkUUL@bmKkV@@VUIUlWV@XK@VkbWx°xUb@LUbk@@VWb@LXJ@VWXU@@bUVVVVn@VVlLn@l@xk¦Vx@bVJXbn@JlnXxV@@nJ@X@V@lmxbUn@xVL@VVKlL@lnLVaVL@xkl@LxVl°XWVXVlJWnxlJ"],
                    "encodeOffsets": [
                        [119194, 26657]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3509",
                "properties": {
                    "name": "宁德市",
                    "cp": [119.6521, 26.9824],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@LVKVaVaUkVU²J@LVU@@WVJUbVVnLVbL@VUJ@bVbkL@l@VnyXmlU@xV¦L@lmz@lnL@bVVbVb@lnKVkVl¤@zXV@l@XJVLVKnXVKVnU@wUm@KU@UlVlw@U@U@UaUKlU@kXKlmXIWKXaVIVUVK@KU@@kJVUnLVJUL@VIVa@VnLKUnl`VbVV@Vbn@Vzn@lKnVlIVVKUalkXJl@XXVWVLVUUmVU@Unm£lK@Uk@WUXK@U@WVwVkĠkĢÇ°aUÅUwmaţɱUÇaw±V¹XalKôx@UVaÜʓͿVóbÅLJm¯Vk¦k@mamXkKUULakbk@mV@LkJWb@VkmXk@UVmaUV@amLUKUamI@KUaU@WbU@UUUUIWJUkm@wKkVJm@kxÇVUK@mUVUkmlkkVm@amwLVWU@UbVLkUb@VmK@XaVWU_VJnwV@@kUmWakx@kwWakIWxnbUJz@kVW@@x@XllnVW@xn¦ULWKXxmL@VU¤VLÞVVUÈxVmxXVlLlVanV@bbVLlÆnnlW@LXlWnXV"],
                    "encodeOffsets": [
                        [121816, 27816]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3501",
                "properties": {
                    "name": "福州市",
                    "cp": [119.4543, 25.9222],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lxna@nJ@xlIVJV¦UVxUb@bLVUlVkL@V@VVn@VbLn@LUlJXblx@lwXbVn@lU@mxUIV`UXWb@nLU@ValUKVaV@UXKnxbn@lUkllnUVnV@VLUÈlwn@UIlLxn@VlXIVJVVVV@XaV@Vb@LnJVbVLnK@bVUnbVUl@nWl@UXalI@KnUl@labVKVlLnWnbl@l¥°UnIÆKôa΀Ua@UUwÇWǓIUWUÅVkƨm@@£@KmLU¤ULˣJkUVǟUUķ@ĉVKUk@Ñ°wôÇç@īé@Åţ¥mīÛkm¼Å@VķVó°ō¦U°n@bVJXVVL@bUakLmx@xmxXzW`XbWnXV@bWLÛ@a@aXbWVkaÝwU@mlWKkLWWkLUKULW@kVmVUUÝUamV¤n@xUVUzkJV¦lJU"],
                    "encodeOffsets": [
                        [121253, 26511]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3506",
                "properties": {
                    "name": "漳州市",
                    "cp": [117.5757, 24.3732],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@bl@Xb@bVVUm@nx@nKVV@XVWxn@VnUl@nmVX¼@LVbVV@xVJV@@XIlJXUV@Ln@lVV@UbVnnWVL@lnXUVmJLlwnll@VaUXVlaLVUVV@¼Xl@lbUVVWbnnUlb@@VV@aVUmlUaUny@kU@Wkk@WaUVk@@ammk@@U@UlU@aUa@wl@mXLllnLU@anVnU@L@VVV@KlXnWVnVanUw@w@wmnÅ@waUam@UkmUl@@aa@U@¥kôKwÈ¯°w@ŻkwǕaKÑÛk@ĕōřċ£ĵUKW»kÅŻLU@Ulġw@¤VzVUbkKUbmLmlULU¼UxmbXl@bWVb@bUnVUVbULU@@VkbVL@`U@WX@XV@b°@b¯@¤@Xm@@b@`UVVUL"],
                    "encodeOffsets": [
                        [119712, 24953]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3505",
                "properties": {
                    "name": "泉州市",
                    "cp": [118.3228, 25.1147],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Vlxkz@`xLVV@xXXWXl@xl@V@bnV°@LVm°LVbV@ÆXWlUmxU@WVULnx@llUXUJWzn`Vb@@b@xV@mXX@@JÆVVXVKXkV@nVlUl@KVbULJV_VKLVWX@lUVkIU¥lIVyVU@wm£nUVWU@am@UmWw@UX@@amVUn@@aUUlUVanaWUXWmUnkK@VUlVVUUw@XLWWXma@knmbVbVXbVL@XJlInlLwmXów@çV»ÇçŋaķƧóƅóKġ°nÅUķƑUÇW@¯xÇ°öÆlVn@lla@Lb`@VXVVx@V@bULVJUkÇ@¼XUKk@mmULkaWbk@x@UkL@a@K@U@UmKmbU@kV@UmVUbUmmXkW@LUU@U@KmVmU@bVmKkkWKnk@@xVb@bkV@V@Vl@nn@bl@VUXbl@XlV@@lmzVVbknUVb"],
                    "encodeOffsets": [
                        [120398, 25797]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3503",
                "properties": {
                    "name": "莆田市",
                    "cp": [119.0918, 25.3455],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VbÞVVnUlUX@VKVLlKXXlKXLnkV@ÞxlbXUWab@bÜ@XK@aWUXmWaX_Wynw@wnwlKbV@aUKWUUI@amV¯Ŏ¥ô¯ĸUUÆ@n»¯aƿé@ţ¯nĉĬÝKóó@ÑU¼@èxWônxKmkkJWI@UKWaUUaamn@lnbWXXWK@VxUVkUV@ULmlnVWXXVmbUbkVVV@bm@UVn@bW@@VXxn@Vn@bVUX"],
                    "encodeOffsets": [
                        [121388, 26264]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3502",
                "properties": {
                    "name": "厦门市",
                    "cp": [118.1689, 24.6478],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@VlUV@nanL@V@V@L@blK@Vwl@XalbVKnnl@VLW»È@lVUIVK@a@UUwWUU@_aK@bkkm@UkõÅxóLl@¦@Vb@bk@VnVln@Vbb@xmÆn@x@xx"],
                    "encodeOffsets": [
                        [120747, 25465]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/gan_su_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "6209",
                "properties": {
                    "name": "酒泉市",
                    "cp": [96.2622, 40.4517],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÇnÅaĉ@U¯¥UŹ£WUýUU±JkkUwyÞIČxĊĕĊ¯¥ÆUkţUÅÓ±¼IUx¯UÒƑÝÅ°KÝnğ°ÅU@@Vn@þ¼¯WnŎ°XLWlnVnbWnVXxmbabóUlǕUUaIUmlU¥k¥ĉwkkÝɛa@¯U¯°mVkVnKlōÑÇÑU@klUġkUŻnUW@¯k»mWV£UKnUmUww@UIVaXwm»Èmmwn¯ċ¯LĉUJUalka±Va@Uk@ÛÑ¯WmnUaɝ¤Ûmn¯m±x@wóxÛLġÒUx¯VÈJUbózÝÇKĉ¯ōlÝUÅWl¯nťbÝ@¯ǩLġmV@Æ¯ĢkÆmĊkVťLɃmÝXó°@ĢbVóVÝ¦ɱ@ƧaġUVĠÇÈV¼UVţwmbJÇwˋaXmÇ¯KkkmbXm¼V¼ǬŚ²¤ôŰÆƴô̐ŤǪnɆӨ¼ɆLÆłUĊxŎƞȘǔˎǬǪnƨŮǬö°»ġÞÜÆĸÒĊǀbƾèôÈ@¼¯þŤĸƧ°VĀ¯b@lÈĊʠń̐ȘKǀֲॗţÿǕý@ʊǓƨóÆÑǖŃôw@΋ʈƆÅÈVVĊVóĊÅ@ÞƒĬV@Þī@°V@ĸĢ°XτƜĠ@ÈaÜ¥ŐƅnğóĕVġUůƿŋĕa±VUťÇğÑ"],
                    "encodeOffsets": [
                        [101892, 40821]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6207",
                "properties": {
                    "name": "张掖市",
                    "cp": [99.7998, 38.7433],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÈÒŎÒkmLUlU¯nV°@°ɜbÞĠaÈ»ĸlLVUÈ@Ċ@ýUm@@ÆVĠ¯ÞmLÆ¯ÞƒÑ°VVwJ²»ÆÔVlŤÅV¦ĉ°ĉĖċwÝJzVxll²IVVVþX¤źV°¦VĊ@ÆbÈmǔLĸĠ¯Ģaô¯ĸmÆÛUlÇĸk°XyĊUǔVǩnmV»a@ýnK°n@l¥@»żĊ¤mç@£ČU@mmVkÞUƐ±²¹°ĠwÅƑŃU¯V¯aÈŁÇ»ġn_°xŎKlxklx@Þw@Æm²bÇ²LlkWXať¯ĊaÑK±w@wUÅçV±Uk@@¯¯xU±±UU°ōxVxÅÔō°ó¯UÝ¦óbÝþ@ĉÈóUVUx@VUVÝwÅÈÇóVkk¯JÇkmmL@KÇx@bk@U°ķ²ó`mn¯°UwlÅkU`¦ɛôķz@ÅnÇ°U¼¯KmVk²J¼ƏÞķô¤UL@mnğ`ÇnUxÇ@ÛÿU@kŻ@x@móJkÅ¥VŹĉóÒĉlċ°ķUƽÜ@x"],
                    "encodeOffsets": [
                        [99720, 40090]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6230",
                "properties": {
                    "name": "甘南藏族自治州",
                    "cp": [102.9199, 34.6893],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÞnKlnwX¥WÝXkxÞUn°aĊVnUUKlÞĶWXnĠ¥ô»@nmVL@¤°VzJanU@aÆwna@kU¯yX_aĉbwéXkWwÅa¯V¥m¯UI@@mb°aÈçU¥@»knwɜƇ°I°ÑÈmVU¯Xa@wW@wV¯Č¥l¯Uwnm@kaUaóKkk@Çab@ÒWa¯IÇxÛam¼VUxÒl@zÝÒ¯bÝaĉVĉwÇWzJmJn²mÜ¯U¯ĉ@ġ¤Åb@²nml@@ULVxVU¼Ålmab@°l@WIU¯@m@ó@UzţyXÇUÇVUUVLkbWakVWmUbkkKUÆ»n°Knk@aUVmnk»l¯Ģlw@_kKVU@na@lUk@¯¥mV@kmbWb¯Åõa@mkU@kÇkU@`@óóbl¼Uxn¼lVÈx@blVkVVn`XÈġÈ@ÇK£ÝJmUUnUĖmlUmKUnVÅaUwUĉ`¯n¯wW¼nxV@bĉnkIċŘkXU±ÒxÈ@X°`lVIÈ¯ĊVVVan@VaUVażVmblkÈWWIXaalL@wVbV¦lL@lĠnÒUnkL@ÆÞkÞKbñþW¦ÛċVULUºkÈlŎUxÆxÞUUxÒx@XbL@lÆ@ÒlXVln@bm¼J@Ånx@bnĠmxVXmbÈè@Ċ£ČWw"],
                    "encodeOffsets": [
                        [105210, 36349]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6206",
                "properties": {
                    "name": "武威市",
                    "cp": [103.0188, 38.1061],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@±¯¥@klwU»ÞÝmwKm¯ç@kVÇUL¯lVUKġġm@a@U@X£°l°LŎÇ@aōVÝwÔKUÅWJ¯lm@ÛVWa@klĉUmaLUanak¯J±KkXóÜÅx²Ç@nUÒĊb°@ÆkLXÇÆ@xÝnxWxţ¯¤I@ÆnVVVlU²ÆèV@x²xLÒĉbŦ°WbXklÞ@l¤XĊ`wl@ĢÈŎm@bnVUb@ÈÆÛLèÇUÒÅ¦lĸ`°ĮʟÆǓbĉôϚĊÆĢnŤé΀ÑĸĀĊ¦@@l°l¦Ȯ¦ɆÞĊKŤĵĸů»mŁyġķŭ@Çɱȭ¯mƧUĊķnŁŻ»UaUƛɞÝƨů"],
                    "encodeOffsets": [
                        [106336, 38543]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6212",
                "properties": {
                    "name": "陇南市",
                    "cp": [105.304, 33.5632],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÈÞ@l`UmV¼@nnÆwVlnVVaLVÈ_ÿÞ@naxÆ@l_@VxnK@llLnxmÈŎJnbUxI°l@n¦lÈIlmX¥k°@kJk²é@klaUaVaU@@ÝnIWnmnxkºÞaV°V@nwKxôbÞ£VUbþLn»mVwIJ°@nb@°°IġUkÇKV@Å¯»lLnm£@anK@ÑÜn@»mL@£ykUUmbUÞÝ@kyÇbó»XUxWVzb±mÝbXawUamL¯»@wUKVwm¯ĵJ°ÅUWVkKVk°wÈVVÑlU¥kmVamknUw¯¯bċ¥ÅKkKkVċVk£kKVwÑa@kóyÛ¯ÇVkówXō¥Ç¼ów¯U±k@xIĉÒÅVmÈnÜ@n°bUbÝVUnnJ¯Į@m¦nVÜ@L°JXbÑ@aÈb@llôLVbb@lmnVxk°ċ¦U°@xX@xWb°UVÇn¯Ò¯Jɛƈmxl@¼"],
                    "encodeOffsets": [
                        [106527, 34943]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6210",
                "properties": {
                    "name": "庆阳市",
                    "cp": [107.5342, 36.2],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@kwĉ»VamV¯wIóVkl¯KmVō¯ÝWkL@bÝKō¦@@Lx@b@la@km@@l¯nm@UaÅ@óWUXm¥nw`@UUxķôÇ°ğ¦@VJ_nIVnalxkXJWn¯nVLxl¤nnVbklVX@xnxmV@bUK@nm@@xV°±aÅnkUWnUax@mn@¯LmUĀlU@lV@blLUblxklkIÇx¯°UXbaVUnV@°LUlnbX@`°nVmbnÆmVkLmK¦U@Xy@kl@U°K@¼XbW@bWnLVaVVz@xlVČ¥lbUxÞlVU@nÆWôn²VJlUƧLnmÜLXan@mw@wlUlV²mblwVÈlLÞ±@lVnUlxnkma@mkJ@kXVU@mn@¼VXUVlLnmVbôaVnWV»ÈUl°È¯ÆInÆU@kk»mKkÆġk¯@»mk¯@óÇlÇ@VykklUml¯Þ@w"],
                    "encodeOffsets": [
                        [111229, 36383]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6204",
                "properties": {
                    "name": "白银市",
                    "cp": [104.8645, 36.5076],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VKUÈl@è°nLnxÝÞV¼kx@l¦²°ĊóĠĊ»@ÈxaĊxlwÈVŤa@¯²aÇ£Jk£lnUÞ@°ô@ywl»lIX¥Ǫnw@ÑÞWlaÅlL@Uwĉakl@¯mwna°JV¯nUVÓÞÑm£²óWaUÇ@óÝUçV»ÈkkW@¯xV@XlK@wX@Vmm_@wÈÝKU¯ÇwVwÅK¯VkJXkWVaIm¯UkÇlVĀV°mxók@¼óWxĉÜU@UbzÛJÇk@ÆnVlÔ@kxô@ĬWL¯K@aÛImm@IUa@UÇêU¤VÒÇx¯ÒVlk@Wbĉ¦UbkWV_y¯Laók@b@nmbkx°"],
                    "encodeOffsets": [
                        [106077, 37885]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6211",
                "properties": {
                    "name": "定西市",
                    "cp": [104.5569, 35.0848],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@aV²wVJV_@LlanÅllŦçÜÓ_lnWaôkxUbmV@È°lènk°l¦`@nnL@ÈlÜIyVaV@ĊÛXwô@»lônwU¯ÿUÈkl°VnJUblXWIl°UV@aVVVmnL@lUUwmk£bV¥VUVwÛlaÇÝÞmk£LUy¯L@WlkKW_XaWmġU@akakXkmVwmŹVUbWónmwnWW£KÈnV¥¥Æ_klWbU¯V°aôbnaVwmaōInÇmwkK@kmLUw@`kÅ@wb@mÝĀÇ`UKUbmUUkÅxmm@»nUVk_Ý@Ç¦VÇè¯ban@@JV°nU¦°ÆbXxWlêxĊabW`zV°@lmbÅx@bmVbI`¦@ÒUVUI@ÆL@b¼@@lmxnL°ULÞğÞ°kLUL°xVnKVl@zX@"],
                    "encodeOffsets": [
                        [106122, 36794]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6205",
                "properties": {
                    "name": "天水市",
                    "cp": [105.6445, 34.6289],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@UyÈVVUnn@VU`UblzJnk@VbKU°lwW°nkVUÈl£°V@n¥VklkU±Unlw¯UkwmKUlmkUmnkym@Å@UmWÈU°l°anlJkUKlU¯Èm@kmWV»kkÝLUWUx±b@¯ma@¯IJUxnm¼KýaVUÝ¤óawLmxU@¯UbÝ¹lmwmnXmJ@ÞV@UbVbkbl@±êlIl¯@lW¦knÇJkm¥k@¯Jmbóa¯bUV°akXlÅ`¦U¦ÇmLX¤mXnxmôXaVźUnUxlnlWbl@bĢVnXWbX`lLXk@°KVzKl¤nÞÝÈkbÜ"],
                    "encodeOffsets": [
                        [108180, 35984]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6201",
                "properties": {
                    "name": "兰州市",
                    "cp": [103.5901, 36.3043],
                    "childNum": 5
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@lW²L°IlmbVbKnbĊVlk@XbÜU@kn°XIÆVLÓÞxŎUlôb°KzU`lXVaĊ¥Xal@kU°ÑÈwUÑV£ÈéV@VbJ@nnÜJ@bL°XK@īówl@kÓmUÅmK@m_k¥l¯mkçÇ¯@nUaVwólXbmk`ÛÔťèkkmÆkbK@U`UI±xUbWlXmbVbÅÒólkIWJk@zKŻ¼@xUxó¯LWb@ÅÒ±¦U`nbťĀUVbLU"],
                        ["@@¯lwna@mōÈ¯K¯kW¤@@V@bĢnĢVLU°k"]
                    ],
                    "encodeOffsets": [
                        [
                            [105188, 37649]
                        ],
                        [
                            [106077, 37885]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6208",
                "properties": {
                    "name": "平凉市",
                    "cp": [107.0728, 35.321],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÆLUxÈxV°LÇÞ@xn`Ü@X@nĊÆwnJmwUxaUkw@V@waVmlLXÝl@XVĢmV°@nl@UUUWK@wÿVI²Òlm@nÝĊýVV@nJ°Ułm@kV¼nKĢÈ¤ôKblnKllVk²aĠ¥È¯ĸóVw@V_xmn¦VWôXÆ@Vbn@°m@kn@@lb@ka@wK@@UlKVaWXW²¹lÓw@_°n@@_lKÅķW@mLUWn»Û@l_Ç`Ûmm°ÅbWb@VWbUUKÇÅaġlmkUġl»LlUm¦@¯U¤ÇkVUml¯Xx¯kVLUa@mlIkyVa_UV@mmUVUÇVzUxUVU¦a¤lnVxVk@mKUnUU@bU", "@@@ż@mlkġk"],
                    "encodeOffsets": [
                        [107877, 36338],
                        [108439, 36265]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6229",
                "properties": {
                    "name": "临夏回族自治州",
                    "cp": [103.2715, 35.5737],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@ż»Ly@lXIJlôkÆÑUanaWXkW@yk@ULmUw¯KVlK¯ĠÝÝVK¯mKnwk@@»@aK@ÅVJVU@Ñ¥_Uy¯@£UKmn@ó¼ğ¦WmĵXÝkVLmVĉU¯bmÝVwWlXÞW¦xkmmLÝ±U@VÞ@ÅÈW°XÜ¼ƨyUĮnWnXÝxUx°lVXJlôV"],
                    "encodeOffsets": [
                        [105548, 37075]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6203",
                "properties": {
                    "name": "金昌市",
                    "cp": [102.074, 38.5126],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĢÈ¼Çł°bU°VƒńÆǖŰnÆōĬǔaʠÅ¯ĭ_kķÆ¥VÑÈçÜKÅ@ÇVaUm@aōnġÇk@xĉ_Wk£@Ý±KÈ±aÅn@Ýx@kwlkwōL¯wm`"],
                    "encodeOffsets": [
                        [103849, 38970]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6202",
                "properties": {
                    "name": "嘉峪关市",
                    "cp": [98.1738, 39.8035],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@llĊx¦l¦kVVnJVbǖVkôVabnaWwUXmmamUXkWKō¯Xm°»ĉÇ@UVKķkÇ¼ğb"],
                    "encodeOffsets": [
                        [100182, 40664]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/guang_dong_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "4418",
                "properties": {
                    "name": "清远市",
                    "cp": [112.9175, 24.3292],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lÇ¯kÿaV¯VaÈU¥ÆÇIlxmnbUxlUôl°kWl@ôVwUanUl@xVkaX¥kU»a¯±@kka@UwmUkwJk±k@L@ÝWUwVÝxÇU¯ÇX@mÅ@@yĉ£VmUwȗ»ÇUnlUnWU¯`Uk@@x@bÇxX¼VV¯LĀkÝL¯@VĀ¯lnĊW¦kVÇôkUÇUK@ţU@aóÜUU»@¦k@VxKVbn@Æl@xbWnlUlxÈlVÈ°Æ@¼@xWxŎVK°¥nÆkŎ@ÈÑmK@¥k@ô@nôV"],
                    "encodeOffsets": [
                        [115707, 25527]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4402",
                "properties": {
                    "name": "韶关市",
                    "cp": [113.7964, 24.7028],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WXk±Ñ@UwmUwĉwlmn@Æwn£mkI¥ÇÅ@¥aón£nWWw£V`Þ@nVml@xô¼IV¥kUmkamUkVWwÛ»mó£UVÅKmn@x@kbmm¯aXkaVĉaUbÝ²lIlxnVVx@lb@l²°bV¼lW¦bUlwk@mVVbUxó@kX¯lókVkwVmankwJÅÈ¦ÇVUbU°blĀ°kÈ@x¦ÆÜ°@°¦óaVUôlUlbXl@nÜVnKlnIVÞ°W°U@bnm@¥IV²Ul°VnalzXyl_Vyƒ¦lLlx@ÞbKmknVWanwÑVwČº@n_ÞVaVÜIl@KÈVJ@a£È@@kmaV¯W@_a¯KmbkÇkLmw@Å¥"],
                    "encodeOffsets": [
                        [117147, 25549]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4408",
                "properties": {
                    "name": "湛江市",
                    "cp": [110.3577, 20.9894],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@kX@aUUċlkJk@wVJXUWk°W@nKnwlUl²blU@lIl@XbWxnm@lW@wwUJX¯VU°`ŎóˋkÝÝkÅ@ÇmğÈřmwaĵVxUÛ»°ĠǷnýmóX¥ɅĵҏÇ@°²ĊUĖ±ĮU¤Ç°Ā¯ɐnżUĊĊĬV@è@ÔÒU¼l¤nĠbêVĠ°ÈyzVaVnUÆLabVlwÆ@"],
                    "encodeOffsets": [
                        [113040, 22416]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4414",
                "properties": {
                    "name": "梅州市",
                    "cp": [116.1255, 24.1534],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nÔlW¼x¦@lVllLkèa@z¤Ė¼UxlnUKUbÝlU¼lb@VxVklJÈwV¯@ĠlÛĖnbkÆźÞUÈôklmL¥LWnKUkVa°Vx@IVV@x°bUkaa@mV@@ywLÑUwVUVUbÞVVann@XwÇÿ¯²aVamkXaÆ»@»nw@¥UXakbWa¯KUw@¥m@kwmLU»UUJ@kmU@UUWU@yanwmçÛl¯¯UmKUmwVkmÝXbW@XWÝbk¯@±w@»U@W¯Å@Ç¥UU@IUakJĀê°þXkam@_J°m@X"],
                    "encodeOffsets": [
                        [118125, 24419]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4416",
                "properties": {
                    "name": "河源市",
                    "cp": [114.917, 23.9722],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°VlmX¹laĢÒlm@V£@¦Ģklynn¼lW°zW°VbÈV@lÆbnnJkXVÆaÅW@UUw@kaV»ÞkVaVLkmVw»ĕ£@yblçkKkU@k¥wX»kmÓ@Wn¯I`@nlbWý¯éÿlI@XUmWUw@@UJUÇmKUV@xţk¯¯LWnUxK@Å±»Vwa¯@¤WX@Û¦@¤ÇIÈ¼WxX@WxwUnVbÅèmVa±²UWl@klÈ¤nôÜ¼XxlUnVlbVnlU¦Jó»@wnkmUÝ@U_¤XxmXm¤ôb@¦ÈÆ¦lJn"],
                    "encodeOffsets": [
                        [117057, 25167]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4412",
                "properties": {
                    "name": "肇庆市",
                    "cp": [112.1265, 23.5822],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@l@¥@V¼VôÛ@bV@ŤVLÈlVÈólUX¥mĉ°kÿU°@ÞKlÿ°KUUW»Èw@aw@@nm@w£kÓVUVnKk¥£Vam@nkKkbÆǫmakmLU¥UmÛwmVUmUJÇaUxÇIn`mb@Þ¯b@nJ@nlUVlVULW¯Û`Ç_¯`m¯IbĉWċzx±Jx¯ÆU_k@J@UmbXôlLn¦@¼ĊxlUXxUbLĠUnVĊwlUb@lWXm²@ÞWxXUnb"],
                    "encodeOffsets": [
                        [114627, 24818]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4413",
                "properties": {
                    "name": "惠州市",
                    "cp": [114.6204, 23.1647],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lbW°bnnla@@wnmÆLVUkÇl@XkV²±bnUÆçUaVmxXw@WXwÇ»ÈJ@£Ü¥@XW@£°bUx²¼@ÆLVwmX°K°Ťl@wVUnLÈVVIky±wkKU¯ÅkXġÑÛlwUwlm@mnKWaÅm¯óÇmğb¯alĉUwķbmb@lÞÒVnmĀŹ@VbVUnmakLm`@xĉkklVÔVJVnlVUnmJmaLUblzmkLaō@@zV¦UV²kJnÜU@VXUL@lJL@bÝ¤UnVb@xVnlK²Vx°VxlIlkVl²k¤@n"],
                    "encodeOffsets": [
                        [116776, 24492]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4409",
                "properties": {
                    "name": "茂名市",
                    "cp": [111.0059, 22.0221],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@LnÇlkKnkÆLUmÈxlUJló°n@ana@@X_@mÝóóU@aaU¯mL¯kV¯ÇVwkw@V±Ŏ£@@alw±Vk@mÅm¯ÿÅƧIÇ`ōô¯_UVW°IVx@xkX@mnwXWa@kkJ@kVa±kkVmxmL@¯XXlWVUI@xlIklVČV@blW@@nUxVblVxkôlxnynIÆ»Æ°aXwlKbVnXbL¤kLèVV¼²IlĠVXynz°KVx°@VlLlblK"],
                    "encodeOffsets": [
                        [113761, 23237]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4407",
                "properties": {
                    "name": "江门市",
                    "cp": [112.6318, 22.1484],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lUXx°JWnnÆXVWX@ºVLV¯nUVnbôxaXmWXIUb°xlKl¯KxXÞ°XÈ¥Ü@ĉÞUç»nóVmax¯UÅU¥Ý¯@ç@ș@çĉÅUmUç±ĉKÝxÝ_ÅJk¯»ó¯nmèkǀWx¼mnUÜġ°@¦@xLkÇaVnUxVVlnIlbnÆÆKX¦"],
                    "encodeOffsets": [
                        [114852, 22928]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4417",
                "properties": {
                    "name": "阳江市",
                    "cp": [111.8298, 22.0715],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°nKV°b@bôVÞô@nVlÒôÆUnlnn@lmkmVkaÈkÆÆk¥ÅÞ»ÆKXkW¥ÅLmÅkamJUkUVwUmÈblKw@@¥Ģ¯VÛnm»Xwlƿ@kbWaʵ@óLl¯ƽ@Ln°Æ@nUl²kxb@@ō¤U²@lxUxÈU°l"],
                    "encodeOffsets": [
                        [114053, 22782]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4453",
                "properties": {
                    "name": "云浮市",
                    "cp": [111.7859, 22.8516],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@VIl@`V°Åw²IwČyĊXa°Jn°_È`Ü_°XKVkUUVk@mmI@°a@Ýnam_ÈJVwlĉX@lUómaUmVU°UK¹@WXUWmÅXm¯IWwkVWlÅLÝ¼Æl¦ÅÅÇlbUllnknm@kmVmóÅkÑUW`@@bmb@¯mkôIkVÇwnVÅKmlLklmÈKVĊK°²`n¤nUbWlxVxLUx@°nXm`VklVxmnnx"],
                    "encodeOffsets": [
                        [114053, 23873]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4401",
                "properties": {
                    "name": "广州市",
                    "cp": [113.5107, 23.2196],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ș¼VxUnĊ¤@z@Æ@nÈW°ÈVwUÞVxÞX@Kl@ÞVaĊbU@ml£k±lUkkJw¯UUw±kLUm@waUVmÞ£@aKkI@KVUW@ÛVmlIU±VU¥@yğzƧÇƽĠřÅnī±m@²¯l°@nÝÆóUll@XnÝVU¦mVV°V¼Jnb@°mbn@²¯¯wVw@@nmxX¤¯L@VLUm@@l"],
                    "encodeOffsets": [
                        [115673, 24019]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4415",
                "properties": {
                    "name": "汕尾市",
                    "cp": [115.5762, 23.0438],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@@VxnXWV@bVJV@ÞÅU¥Ċx£UWUwÅUU¥WVUkĊÇnkV`°LVwnU@lbĊ¯Vnal@@çkUÝ¥ġaó¯ÅaÅLŻÆUýmy¯ó@ĉÆóȯwÆXbmL@nknVxkxÜĢÒWÆlV°Ll²xlz"],
                    "encodeOffsets": [
                        [118193, 23806]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4452",
                "properties": {
                    "name": "揭阳市",
                    "cp": [116.1255, 23.313],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VÈ¦Æ@X°V@@¼x²°@lÞaWXX@aÞWlnUxVnnL°V@kmĢl@ak@mlk°aX±nwm±²¯JV²@wW_maV»U@m¯ĉUÑJlabVnlĸLlƅÛÇ±wÝ@ĉxó@è@kmbUĉ°ka@mVxU¯KU_mlĉÈVlXUV¦ÆVxVVX¤ĉwV¦ÝÆ"],
                    "encodeOffsets": [
                        [118384, 24036]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4404",
                "properties": {
                    "name": "珠海市",
                    "cp": [113.7305, 22.1155],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@è@Þ°V¦VÆ°wnbUÆ»nçÆ@nxÜ¤²llU°VnÈJÞ°UôéķUklô£VVˌKÞV°£n¥£ȗÝy¯¯mÅkw¯bÇĔğ@Ýn¯ĊVğōŁŻķJ@Ț", "@@X¯kmèVbnJ"],
                    "encodeOffsets": [
                        [115774, 22602],
                        [116325, 22697]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4406",
                "properties": {
                    "name": "佛山市",
                    "cp": [112.8955, 23.1097],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÈbInVVnUÜxnVV¦nKlnbÅǬlalL@mnUb¤l¦LUmUVlÔ¤@xmnVl°_XVVmkVmÈ@kn@VUK@°KW£nw@m@Ux°x°@±mna@¯amIU»U¯nUV¥ÞUWmk@Vk¯UknÑWÝĊÛ@Ç¦W¯WÝwLk°kL¯wVaWJXWnbwkVW@kĊ"],
                    "encodeOffsets": [
                        [115088, 23316]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4451",
                "properties": {
                    "name": "潮州市",
                    "cp": [116.7847, 23.8293],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°Üknèmxbz@VVX@VnV@lIVVV¼nKlxn@@¦Vx°LXblaWbV°£¯W@nW@aUñVwW»@¥ŤÅUÝǓÝóV@ńÇkUVmIUwÅVWÇX¹@W¯bkl@nlb@kġn@l"],
                    "encodeOffsets": [
                        [119161, 24306]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4405",
                "properties": {
                    "name": "汕头市",
                    "cp": [117.1692, 23.3405],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@U±°I±n²mx²@WºXÈÆUVxJUnlVÈ@ŃôUǔÞVçn»VyĢÛVm@»kaÝUÇ¼óÛÈķKċ¥X¥Wwğk¯@wķKkUmabkIVÒ°Ċ@nVU¼bn`Xx"],
                    "encodeOffsets": [
                        [119251, 24059]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4403",
                "properties": {
                    "name": "深圳市",
                    "cp": [114.5435, 22.5439],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÞL@xbVVK°X°Kô¥Vw@anUèlkĊl@wn_lKnbVmUaUź@nÿUmÝÑ¯Ubk@ÆkxŻ@aÇXwJ¯LķÝUĕóĸóêWº@b²nmĬÆ"],
                    "encodeOffsets": [
                        [116404, 23265]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4419",
                "properties": {
                    "name": "东莞市",
                    "cp": [113.8953, 22.901],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ŏ@blKnykVaKnbnIVmUkUmUIUÓçmV@bUxó¦¯LW¯LUUa@wÝKğŚƾƨÈĠy"],
                    "encodeOffsets": [
                        [116573, 23670]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4420",
                "properties": {
                    "name": "中山市",
                    "cp": [113.4229, 22.478],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XÒlmV°ôÞÅ@m¯°k±@@aX¹¯VÝÇIUmV¯kk±Û£mw@ÅmèÅ¼mô¼èV"],
                    "encodeOffsets": [
                        [115887, 23209]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/guang_xi_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "4510",
                "properties": {
                    "name": "百色市",
                    "cp": [106.6003, 23.9227],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lklWXL@VIl@XnJn@VUUalk@mK@kny@UlU@a°UU@VmaU@Ua@UWw@n@KmLm@alkmnIm@an@VIUamWÅImwU@@a@KX@JVLUVmUaVkUa@m@@Ulmkk°UaVUlKXbVwVIkaVmUk@KVk@aaW¯m@w¥laX@KmakVmnUl@nxVKInU@yVaVIV@na°KlxX@@_lmXUV`VIVV@n@lbn@@WUkValK@²yl@VUV@@K°L@KU@@UVaXIVVV@naVkVa@K@UUK@UUaLWaw@m@K@UVV@mVUUVKnLmVLKbVK@UUIkmI@mUIVK@IUK@VkL@WU@mU@WmUk@I@VJk@WwX_@amK@UUWkIK@LVb@mVmakL@J@bU@Ux@xbmI@`Iwm@UbmKUaUWa¯UkJWV@XJUU¯LUmV@ma@kkamKwLUUmWVkkm@aVUUkVKnVVUmXK@UW@km@Ukkm@@W@UkUy@I@aUUmb¤U@kUmL@bmJU@Ua@wkLWWkL@U@VaU@LUakKWbkUWVkKkLVLUV@JVbz@V@VmUU@kVmK¯@VU_VWakVmIUKUaU@@bml@XU@@V@LmKUVmVUKKbkaUXKUL@x@V@l@mxU¦V@lL@V@Ln@@VV@nlKUaV@nLUbmJnL@VWLkbmV@@LWXLlxVVIVV@x@V²blUVmLVUK@kWWXUlV@Xl`LXl@@Vn@VnbV@lVUVUÈVb@@`UXU`l@@XUVm@k@xmVknUJVXUbmKULmbx@VlJ@LVbkKUbVLÇUUVUVmU@VaUkUKVUwmLkUUVVlbkaXmwKUVVU@@V±Uk@VWUUm»XamUbKk`U@UnWW_kKmbUVUVmnUV@nJVUlUbU@UV@n@JmI@VmbnVUXlx¯kKmnVV@L@VbkVUmm@Ub¯LmlUL@VWLkmkLmmn£WmnKU_mWbnbmx@U¦UJU@Xmlk¦@mnUUm@@Jn@lVÔVJnIVWI@aÆK@I@aVKIlÞnnl@nl`nbÆX²l@xV@llbVn²VVl@nnV@IlW@Un@@kVa°KnÈmVaVXUlaVÈUVlwôUlynIVaan@lVXbI@n¥la@K_n@bÆx@XnJVnKVz@`VXVU`@b¦UV@VIlxUnVKXÈbVllbVbnVn@"],
                    "encodeOffsets": [
                        [109126, 25684]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4512",
                "properties": {
                    "name": "河池市",
                    "cp": [107.8638, 24.5819],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lLVlbVV@nXVlI@JVXmnW°bIVV@ln@nalVUbnW@kVkÒlbVKn²°bUlV²@X@`nbaUI@°wlU@aXJVI@aVK@wUamIXm@XUV@@bV@VmImnUUwVaVKXUnVK@akVwV@nL@UV`n@@XlnIUJl@X¦V@aUIVm@anV@UwnL@VlbVL@KVVXUWwUUVUka@UVJnUlbnalbVVn@°LV`Þ@XVxV@@bVlUVVbXnWlXnml@XXWVXJmbUI@VllUVkn@@VWV@Vnb@VXUJVnn`lLVka»lVLnw@WV@lInw@WnU@U@mknUVóKwUmUXUU@@wVJVIl@XKVVVbVIJ@Un@lVLnmb@U@Ul@nU°VUVJnnVJV@@mVU@@wkUVwkKWkyUUkU@alkÈ@lJ@xIl@UUWVkUw@Kn@@kmaVUlUULÇUUKl@UUmL@aXU@mlUUwmKkUUVKVUaKUnK@U@Vl@XUWUKlwX@b@K@XkV@UwWJka@aUwmV@U@@U@wUm@»kLWVkIWXnmV@VkbmKLUbkVa@aa@@aVU@aVak£@±UkVU¯VUUJVUI@kxmUmWUbLw@K@aU@@aVU@Kma@aka@_VWkk@UWVUKULWKULU@KUnwVaUKxU@UmaLm@kVmVa@UkmI@@KmIkxU@@KU@mmakI@VLkmWkkJ_U@V@L@nxXbKVb@VVL@V@LUbUlmbU@UUWJUb@VV@@L¯K@LU@UVk@±z@kLUbVl@Xm@akm@U@UUJU_VWkn@`W@kw¯LmbU@UJUb@zmVJULmwk@mVUnlnb@LWkb¦@x°nXb@bUl@LVlUnlbUJUxWakLUVVb¯llkn@V@@nVbUlVbUnVUK@IW@L@bV@nxÆJnXVbUJm@@bnmJnkl@bnnK@Lm@Xx@VVbV@nb@UVV¯@bkV@Vmz@lnLl@kVbUVm@mI@WkJ@UWKkXkl"],
                    "encodeOffsets": [
                        [109126, 25684]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4503",
                "properties": {
                    "name": "桂林市",
                    "cp": [110.5554, 25.318],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nU@JX@`XLm¦Vb`lVXXW@VblČnVlanLnmVLK@_Va¥@kUa@VmVbaV@XVVzlVVK@knKVmX£VKLlbn@b@llL@xĊôXaV@°È@¤bnV@@Wl_VU@WnVamwwVbn@KVLX@VmVUxlV@nVV_nK@mI@Wn@@IUĊ@@wVWX@@I°VVm@wmU@m@IUVklkUmmkÅV@@aV@@Wn_UKla@kaVlVanb@k@@KlVn@@aV@nIWWUUaVU@kKmwU@UImKk@UU@w@W@k@UkW@mk_W@Ua@a@¯mV£@mUUam@kWakVama@UUm@nw@alaUmnUlVlIVLVyk£Vm@k@UUJkK@kmKUwKkWK@UXImyVwnI@mkUlkUKkUVmw@kkJWUÈm@_k@@aaW@UUJUwU@@IWKkmUUV@nVl@bVb@bUUXakw@WUkbkKbm@xUlkLm@@wmKUX@UaVWXVmU@@UUUxkmWXkKkUWaUaUbL@`UL@LV`UXmK@VmakLVbkLxUJUIVbUVVb¯KV@Xnl@lVXbmÒnV@L@VWKkVUIWJkIUamUUbm@UkU@JUbW@XWxUam@kbVVUnUJmUUV@bU@UUV@Vk@bmULV¦U@VU`VLUL@xVbn@UJ@nWJXXVVV@bkxVbUxL@x¦@UlXUVVlULV@@nUb@xlnJVnlVknUlVUbmU@bVx"],
                    "encodeOffsets": [
                        [112399, 26500]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4501",
                "properties": {
                    "name": "南宁市",
                    "cp": [108.479, 23.1152],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lKnbnU@Ua@KLlJVX@VnL@bW`Xxl@I@UJl@nV@XV@nXV@lK@UVL@JULVJ@nnJlVJ@VULaLUKnmKULVVU@nU`lIXllnK@UlJnb@nV@LV@lwnJ@L@nJl@VUbUn@lnKnbVV@wVLUbxVm@LVVKXLVKVLXU@VllUX@`lb@bnbL@UV@bV@@b@LxKVanXVUUmVUUUaVUkyUUaImK@mUUVUkKU_@W@UVVVIUWUVaVU@UUKn@k@al@ll@bnL@bVUVX@V@@bKnblmn@V_@aUalL@a@akK@kVKUKlwUUnV¥VmU_VWVIVaX@VaalÅK@LVJnalL@LnKwlVUwmX@VXlLUVnblaUmVUVwXU@Wm¯Va@ÞKnw@wmk»UVW²a@_mW@U@IyLVUUKW@@LX@VUV@@yVU@UV@nwUUmJka@IU@mVkaW@UwUX@`@kLWUk@mkUUm@kUUWkUkWxk@@VK@nV@UVaUUJmIkV@UamLUbkVmamLka@kmL¯WI@wJmwx@akU@aUKmbkaW_nW@_U@Wm@a@wkwUKmk@bkbw@mKUkkU@J@bW@kVWz@bVUaVUx@ULkJWbXVVX`@mJUVU@@Lk@WbU@UJlnXlmVx@Ln@b@KLXWJUUW@kaUVUbmV@nnV@n@lVLVmLXmXkV±@kxÅLUbJWIÅJ@ImXalkUamKkkL±aVwKUU@mÞnbWJXm@lbmKULWUUVkabnn@Vl@VVV@VbVbnLWLXJWxXLV@@VV"],
                    "encodeOffsets": [
                        [109958, 23806]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4502",
                "properties": {
                    "name": "柳州市",
                    "cp": [109.3799, 24.9774],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@wUaV@nVaUVklmkUUmmIk@waVm@U@VKUkVUkWV@¥@wKVwUalw@aUUUWWXI@mVIm@Ua@wVKUKV_UV@U¥VKnal@U@VU@VV@aVUnVVIVmUUlan@VbXwWX@Va@IlVVn@VanVVblJXIVJlUXL@U@KmUnÑWakU@mkJUI@mk@wUmmUV@JXaWIXWmaUIJkk@WnJ@aUak@kkJ@kUKU_@myUóWUkm¥kUmL@KUKm@k_UmVa@k@@UmU@mm_JWIUVUWLUlbVUJÇVUIVwKUVk@mU@n@lUL@Km@@l@LVzJmUU¤m@UbV²U`U@@¼Vn@x@V@@VnUVx@blbXIVxU@Wl@@LaW@kxLXVWVk@@U@VmLVLbUVULVVlnLVxkV@nWV@bnKVVk@VLVÈVKVVkUnb@lm@@LVxUlVX@VkJ@wkIÇ@kl@blVVVzXllLUxlV@x@UV@nU@UImmUIUV¯mVk@@V@VamnUKkm@@VIUJUaUUWLk@UJUI@xV@VVWVnxLUômVV@VkVVVUnV@UVkL@VVV@bVxla@bkXVJVn`nU@bb@bVL@VnJ@l@VaU@@_lW@UUU@Unlll@XLl@@UX@°bVWVanLlknVV@VVX@VVnUVLmbXJ@nllXX@`VXlmaXVWk@WkwJ@VL@JbnU@bn@@bVKUnVJVIVVVL²a@bV@@Vl@nUVakalmUL@VUL@Va@mXl@nK@UlKL@Vl@@nkllb@Vnn@nVV°lVInwlKXxlU°n@@I@UnVlakUJWkUK@anUWK@_ÞJ@U"],
                    "encodeOffsets": [
                        [112399, 26500]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4514",
                "properties": {
                    "name": "崇左市",
                    "cp": [107.3364, 22.4725],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@JVzl@V@Xn@ll@VlnX@@VWLnUVmUULVlUV@blnUlnXVVKxnLlb@lnbU@Vn°KVVI@WXUlI°VXbVVbnLVan@xJ@_nJa@wVwV@@a@IU@UU@WKXwWIXKmKUaa@UUUUk@@UmmalbVUXVVKnLa@knWXImanÝV@VLUx²blKlnLVbklWbn@JÆIXJIVaÆKlw²@lUnWWnKUUK@k@mmU@mnUVaVUb@lVXVXIWK@Lam@@KUwnWkkmVIV@Xal@@KV@VUnI@_UWWUkam@kkm@ka@mk@wkJWIUU@WXkWXkWWLUU@UakLWXV±VIVWUU@anUWaUK@IU@Vak@@UUKWa@m@ak@@wUkla@mUaUklakwV¯¯@WWUkLkKmakLUnV`UxWX@Jkn@bmlakkk@b@l¯bmbJb@VXnbVV@bJUkkKWVU@mÛVUUW@UVUJWXkVkKmUL@WW@UVl@XXKWXJ@XVlmbUxnnm@UlVnV@XVm¦VJb@mLkKÇbXblVkn@l@bWnX`V@@IVV@VV°n@@_naÆVVbUVVbUJnzlVUlXkV@Vlx@XVnxbKUK@b¯VVUVL"],
                    "encodeOffsets": [
                        [109227, 23440]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4513",
                "properties": {
                    "name": "来宾市",
                    "cp": [109.7095, 23.8403],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nVlw@VJUIVVUV°lU²V@l¤Ub@bUV@b@b@bUblVaKnLla@UnUWmXlJXUlKV@V_U±Van@V£nVIyU@K@kn@@LVK@k@mnVl@VULUxVJÈUVIUaVkXKVVUXJIn`@nnV@Vl@@UbVnl`n@VL@LnKlVn¦VlôXVnz@V`VL@llIll@Vbb@mIXl@lIVJnbWXXJWb@IUnVVn@xl@nVJI@WU°LUaVUUaVJVIwlKUalKnb@UnLVWU_@KVK@_KVa@VKU¯VLVKn@laaUkU@maVUJ@k@Um@XmbkyVaUIUU@KV@laVn@KXKWUkUk@aWUUVw@aXKmVaUUkmIlUU@wUaxUmmU¯U@WLUmVIUym@UVmUa@wmw@çm@aWLUJUIUamKmL@ax¯¥kU¥U@±kUVmKU_mJUbkKmLÅÇ_@WWUXUmaVUkKUWW@nVxkUxmL@KkKmbUI@KLkÆbUbW@UbUJUXV`UnU¦mVVkxVLUL@llL@b@bkKVb@bU`m@knmaL@a@@UWVUU@amK@akkk@@b@lmVL@VUVUbVVXUJUU@V@XV`lLUVVV@nnLJVbVlzUVVbVVnUVVU"],
                    "encodeOffsets": [
                        [111083, 24599]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4509",
                "properties": {
                    "name": "玉林市",
                    "cp": [110.2148, 22.3792],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VJUXVVXlWX@VxVnX@@`ULWUXÅbWK@mULUUmJ@n¯b@l@VULVxxXU`VXXJVIV@nm`@nUVXn@lWVn@b@Jn@nU@Lm`@Xn@WJ¦U@@VnLlV@@Xl`nIlJnkVLw@KVK@UaVL@bVKXlUUKVK@IVLa@U@WLUlVL@bU@@blb@VlbUxVbXUVJ@xVLUlV@VUbVLnKlXJ@Lb@an@VanL@`VLKV_UWl@U_a@WVInlVUUUVm@I@W@wVakIWm@U@XwlaVbnI@m»Va@aXaVLU»@aVa@kKkL@KmU@WzUK@wU@VWUUVUUKUa@mKmbUK@_nWVaUkVaUaVUVLXKVVUVmVI@UkKkLm`UkW@UwWW_UaU@WakXmK@xUXJkUUWUk@WlmJ@km@@aUKzmyVka@kkWVUU¯lmU@@wkkmV@Vk@mÅIUka@Ub@m@UUU`mUbWaWmbXXKWIXUWm@Å@y@UkIUJUUWLUWL@UkVUxW@kaWbKWnXxW¦nm`XLVlUbVbUxI@JmLUKUb@VW@@bkL@b@VlU@xk@L@lxXxWXX°V@VVVbUVV@UVVbULVnVJUb²baUb@VVVVInlV@VnXaVUlIVUb"],
                    "encodeOffsets": [
                        [112478, 22872]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4504",
                "properties": {
                    "name": "梧州市",
                    "cp": [110.9949, 23.5052],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VbXblVlLXWlnwVV@VV@UnWUXVb@VWXa@kVKUaVaVkUlyX@VaVmUwUaVU@UÈymI@aU°@nWV@VaVaw@IV@VmnLVK@kmmna@VbVI@aV@XbW`ULUVVx@VbUV@bl@VLXblJn¦lL°°@n@K@UlLnKa°LWbnJ¦UÒVUllLlVnKnbWnnV`w@@Xa±nl@XKV_WVkVa@kVyUa@wU£UW@UIVW@@awWaX_WKkVmUULmak@UJUI@±m»k@m»VyUImnmmwnkUmVaVIUn_mW@»Vk@VwkmmUXa@IaVmm@Wm_U@mIUWóLmUk@laXmmkUK@UmKULUUmWUL@VakU@Ub@b¼VUKWb@bUbn¼@mJUakbWx@@VXnlJUb@x@X@JUnVVUVmkUJ@XbV`k@VXU`LUK@_mKUbm@@b@U`@nlV@bUnbVbn@@`VbUbVV¯bm@@mJXb@bVnUllVXUlbUl@LU¦VVmkLVb@bl@V@XlK@V@nUJUz°mwmLmlXbWVU@UUUlIU@VVmV@@¦bXbWxXWlXVWL@LUmkbU@@LVVVJUblzna@WVn@@lIUVnbV@Vlbkbm@ULUKV°UL@"],
                    "encodeOffsets": [
                        [112973, 24863]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4511",
                "properties": {
                    "name": "贺州市",
                    "cp": [111.3135, 24.4006],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nL@xn@lKVkwn@alLlaXV@lxbVWV@aUa@aUk@mVUnVlXL@JV@VxVIVX@b@bl@@`ÇnXVlI@lxUnlVVLkllV@nmJUxnzWJ@VXLlLVxnL@lLlVI@V@lUnl¤UzK@Vl@LlLnb@VnVVU@kaKnxn@VkVJ@ÅUlakmWIUaVanm@_UK@UVWUa@klXamU@VmVIXW@lUVknVlKVLXVXW@b@VlnnVL@KXLKn@lb@UnW°@VaXWVb°aVa@I¯aUkUaVKVwaXk@aa@wkm@alanUVw@alK@Umkw@UaUmU@WXUaUK@UW@UaVWI@¥Xa@w@WWVXwU@mKUXUWVU@a¯kl@akU@UULmK¯VUVW@U_m`U@@xVbUz@lUbUlXU`WLk@m²Wb@@xU_mXmmamLkUkKVkUVÑ¥mIXa¯KbmLkK@V@Lm¯@¯kKm¥kIWaUKk@@aVUUa@UwVUKVX_WaU@@bUJUa@mbnn@lULmKUnU@@JxUbUbU@mX¯@V@bnJÇz@VUVVbVxUnUbW@kzVUlUbVbUL@lWb"],
                    "encodeOffsets": [
                        [113220, 24947]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4507",
                "properties": {
                    "name": "钦州市",
                    "cp": [109.0283, 22.0935],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@IlVVlnL@xlaal@nVLlx@x@bXnV@@`mXX`lbnaVL@blV@bwnxI@xXJ°nKl@lbnKnblUVanKVb@lUnJVIVUb@VU@mL@Ul@XwllVVXV@lVnlVnl@XVlK@@_VWVxX@lbUnV@@JlbnIlmnVV@UwVK@U@k°a@mnIVVVK@nXLÆaVWXVK@_W@Umw@UXWWkUUVWUIVaUkJUVWbUmU@mkUJUU@UVab±aVaUIUmVKUaVUU@VUUaUUU@W¯XWWww@k@Kl@wkV@U@alK@aX@@UmIUWUI@mmkXU`U_WJUnUJmUk@@amLU@UVW@UkU@@VbUWVUk@@wmKkUWLUWX@JmIlUkkKWKkLWU@UKWa@bU@@a@_UKWUUUmJmw@nV_@ġğKóLmbU¼VÆ@xUX@Um@wklVnUnlkaUV@lV²WVklWXXbWlkVkIm`UULUU@UWx@XU@@lWLU@kbUbV`UXllUV@bmb@LnKVbULmnVVIV`X@"],
                    "encodeOffsets": [
                        [110881, 22742]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4508",
                "properties": {
                    "name": "贵港市",
                    "cp": [109.9402, 23.3459],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n@VzUJnVK@XV°nVVnwVb@xVVknJlVVUbnWL@bUxVVXbl@lVXkWXwWaa@¥@nUUUV@JVkVVV@XUWanknKxn¯VyVI@m@UkL@W@Uk@aUalKnUUV¥@KVkkaWVkUVkUm@aWanI@n@°aUUVaUa@_m@UamaV@akU@mV_@a@KWIkmLUKaUVU@kVUK@wUIWVUaVwka@Uka@aV@@aUKVkK@X@VbKU@JULVLkVWUL@aUKb@VUL@LxUKmlkImJk_@WU@kmK@UV@¥XIm@@Wn_@KmVm@@I@aUmkXm@UWV@mn_@mUUJWIUWV_WwU@mUknVVmxU@@VUV@zU@UVW@K@X@VLUVKz@J@VnX@`±bUXV¼ln@xmxÝL@Ubn°@XWVUxUVVnkbWVXV@X`ÆÈKnlLVanIV`nLVUl²V@V¦l°¦wb@nKnLVbVJIVXK@bn@ènx@xVbUnV"],
                    "encodeOffsets": [
                        [112568, 24255]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4506",
                "properties": {
                    "name": "防城港市",
                    "cp": [108.0505, 21.9287],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XV@X°°UlxkbVlVb@nkbVl@xl@@b@nXbVL@Vl@UbV@@JVLXbmV@bVVUXUJU²WXlKVb@VVXKlXWlXXWV@VXJlI@xl@nlbn@lln@lbXalIVK@VwUVbU@aXylUX@@aW@U_UJmUnVKUamL@Kna@aVUkkVWU_ValaV@XK@kV@@WwVXV@VKVVn_lJlUXkWaXWlkXU±kU@VUlbkVmUmlk¯ÝW@mb@¦VxULmkJUU@ma¯wmkX@VóJ±bUVUXÝWklWXXlxUabIğÇ@U@mVUKkkm@UJm@XnWV@x"],
                    "encodeOffsets": [
                        [110070, 22174]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4505",
                "properties": {
                    "name": "北海市",
                    "cp": [109.314, 21.6211],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VaVLnK@IJVwUaVaUkWKn_mX¥WwXmLXalbU£UyVÅ@Ýwm@°lLÅUmkmwÛaƑLÝUUm@ȣÆV_Ó@£UUV¼U°W̄ÞVbXbôx@b@bmV@ÇUÝ@@ĢU`m@nxnIVVVXVL@`@bV@@aXbVL@XVlKXLlLVlknJ@IWVXXKlVnL@xl@UVVXa@UV@VlX@VUV@nK@bl@nVVIVmXIV`V_lWnn@VJVXnJ"],
                    "encodeOffsets": [
                        [112242, 22444]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/hai_nan_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "469003",
                "properties": {
                    "name": "儋州市",
                    "cp": [109.3291, 19.5653],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@à®¼jpnr``pRVHÊÌ¤Zt^JÖA[CâlTébQhRPOhMBcRSQiROE[FYdGNOEIH]MgEAMLLIAG_WMCSL@ED]PCLYC[ZIHgjSxJTMbHNEFCMEE_HSDFHSLECRNSFDRICHNADGPI\\RZGIJTIAHLDQOHG`GTNCOIC@eIGDWHIS[kiE[FMbECZS@KKS[FDWsCeRuU_DUQNOE[LKGUBM¨EDQP@HWHGDImXCog_~I_fGDG|QDUWKBC\\ore|}[KLsISBHVXHCN`lNdQLOnFJSXcUEJMCKSHOUMDIm_DI`kNDIGEYFM\\YPEEIPMSGLIKOVAU_EBGQ@CIk`WGGDUM_XcIOLCJphHT_NCISG_R@V]\\OjSGAQSAKF]@q^mGFKSW^cQUC[]T}SGD@^_aRUTO@OHAT"],
                    "encodeOffsets": [
                        [111506, 20018]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469005",
                "properties": {
                    "name": "文昌市",
                    "cp": [110.8905, 19.7823],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@hĲ¤Ī¯LQDaFßL[VQìwGF~Z^Ab[¹ZYöpFº lN®D´INQQk]U[GSU©S_­c}aoSiA£cÅ¡©EiQeU­qWoESKSSOmwćõWkàmJMAAMMCWHGoM]gA[FGZLZCTURFNBncVOXCdGB@TSbk\\gDOKMNKWQHIvXDJ\\VDTXPERHJMFNj@OwX@LOTGzL^GHN^@RPHPE^KTDhhtBjZL[Pg@MNGLEdHV[HbRb@JHEV_NKLBRTPZhERHJcH^HDRlZJOPGdDJPOpXTETaV[GOZXTARQTRLBLWDa^QAF`ENUPBP\\Eji`yºEvåà"],
                    "encodeOffsets": [
                        [113115, 20665]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469033",
                "properties": {
                    "name": "乐东黎族自治县",
                    "cp": [109.0283, 18.6301],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ªVLP`@PEdNRAHOPEAKHEVL`GZBJfvdTAXNNTZJFPrHHNpKTD\\ILHbEVd^JOHLh@NNBnHP`\\xH@NBRLJTlNv_^CTLd@bNDVFbxdFVUPBTKOGEOUO@OEBXQP[H_EI\\EbeYa@UO_JMEJ_IEDKJUGMDcNUd_FMTEJSGoZ]EIYGO[YWgEQ]a@WHEDQKUSDUGAbYBUpSCYNiWqOSQEoF[UcQISWWNMSDe_cLQ_UBiKQOOASQAWgS­ā]ZaSPÝZ]XMXS[^oVËNgNKlE RôEø"],
                    "encodeOffsets": [
                        [111263, 19164]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4602",
                "properties": {
                    "name": "三亚市",
                    "cp": [109.3716, 18.3698],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@®ĂhTBXTRPBRPjLVAR`dKf`TCNXMTXRJVdE\\FpTRrPjXZMTDVoZABaVHTCLVCRGF@X^bFRhZXP\\ZHHMA[^wBWXJlW¤EJ[bCTOFWWMm@ILMGWQ@DQ^QNWFSHEbF`OXNbOVNKTEPDTLTCCVTREfvfEHNbRAENH^RJXCFHNFRpVGHWISDOTMVCZeGamaLoLÛD¹¹ėgsia{OųETtlÉwr}jR±E{L}j]HąKÃT[P"],
                    "encodeOffsets": [
                        [111547, 18737]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469036",
                "properties": {
                    "name": "琼中黎族苗族自治县",
                    "cp": [109.8413, 19.0736],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@bRFnHNbHgN@NPEnbXP@bND`NT\\@\\QZb@`@J]V@XhDpWnCJGHGXO@CR§FANHVKLF\\MPVR`CvVfQtDPKpGHG@S`WJP~^dSTHWX\\RHTFACQTIAUPOU@MG__IaYSFQKNSbORHXCZeTFJgB`YBMNMFi~IVDV[tGJWXGDQRGF]JrALgESLSAYDGIaFeXQLS\\MKSLSQYJY}eKO[EHiGSaK[Yw[bmdURgEK^_kcSGEOHKIAS]aFSU@Y]IWFUTYlkP_CUOUEkmYbSQK@EMWUuAU\\M@EpK^_ZMDQ^OXwC_ZODBrERURGVVZ\\DTXcFWNIAWJWAYUUFYEWLQQaCIZeDM`cLKRGpanJZQd"],
                    "encodeOffsets": [
                        [112153, 19488]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469007",
                "properties": {
                    "name": "东方市",
                    "cp": [108.8498, 19.0414],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ºxJYZQIYXLl@dR\\WZEn]bA\\S~F`KXaDeTiNO^EEKWEDQXITBXaWaDQMUJOIaTWf@NJV@dSxGZFu_@WMKAU}AQ@MwG_[GOAmMMg@GKP]IUcaFKG[JSCoLGMqGEOYIMSWMSBucIeYA_HUKGFBLOFGPQBcMOF_@KO©UAtERadwZQ\\@ÊJÒgòUĪRlR°KĮVLJ"],
                    "encodeOffsets": [
                        [111208, 19833]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4601",
                "properties": {
                    "name": "海口市",
                    "cp": [110.3893, 19.8516],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ńZƂtĢ¬æßFuz¹j_Fi[AOVOFME_RBb]XCAKQKRSBQWSPY\\HbUFSWSPoIOcCOHIPkYCQ]GdGGIFQYgSOAQLK`MFUIGa@aQ\\GGUFcHKNMh@\\OYKAigsCgLSF]GOQO]@GM]HyKSHKPW@Pxi@EMINYREXWRQ@MQcFGWIAwXGRH\\yDI`KJIdOCGRNPNtd\\UTMbQYi@]JeYOWaL[EcICMUJqWGDNZEXGJWFEXNbZRELFV]XQbAZFrYVUBCLNFCHmJaMIDDHXHEhQNXZ_TARFHVB@DTQIRR@YHAJVnAbKFUEMLd\\c^ÍÞ"],
                    "encodeOffsets": [
                        [112711, 20572]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469006",
                "properties": {
                    "name": "万宁市",
                    "cp": [110.3137, 18.8388],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@^J@ZTVbET^JBGLFPTHld]`FLQhcVanx\\\\ZbLHTGj\\FLP~fIZRZPVTQFSVAFJE^NDLEE[~LjsxVTG\\NZZNGlLRRGLJTV@hPZANN^@T\\NEPPbDZXO`d^HSvcJDIV\\XZAJUFCLNP@PQ¤@[ïKLÑIÏ]ÇE±I{u­YśUćFcYUmsVeBSVgB[RO@aYYPO^]@UVaNeDShMLG\\EfFVE\\F`"],
                    "encodeOffsets": [
                        [112657, 19182]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469027",
                "properties": {
                    "name": "澄迈县",
                    "cp": [109.9937, 19.7314],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@T\\GJCXJH@fJDDPNCNJENN^NLHBNSx@DDYbBLLDRbjZTj@`XXTlG^Xr@PJLW\\WLTlWR@HDJTD@X_PO@STMDNTMVV@NLDM`M\\XM\\JNBH[PYZúYzŸ`Ċ\\ÎÝd]c[NKVFLEBaUmBIZGQ@JQSR@CUAEGBQ`SWYRMFgWGCGJCbNnIDGMEDKVAZUEqBYRa^WEUFKYQMaFWXEHIFWMYHCrXVIIiaK@aMCUYNSIISTwXALKH@XWXIEIJQCG[IEQDE_XSBaa[AIPW@]RS[FWS[CD]PEBYNGFSaSyJG]@ugEUDQlGHiBKHUIoNSKqHFaPMICK]UUHIPDJMuCA[SCPIDIOILGAEmU[POPBVSJDREBGS[QXWSGcT}]IO_X@TGHoHOLCX\\ELT@LYTDaFENF\\lj"],
                    "encodeOffsets": [
                        [112385, 19987]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469030",
                "properties": {
                    "name": "白沙黎族自治县",
                    "cp": [109.3703, 19.211],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@D\\RV]dTXELnHr]^@LETBBRTHPi^[@U`QTHDJ`MGSogDIPKdJ`WVNHCXHl_DJR@AH`FBVPUJLHKNTJOFFZON[ZEHFCJlMJ_Cn`CJVNGPLTNDFIdVTWEIPmRKMc_kDMWGGUTAtJLK~\\f{pqD[LAVXRCH{HC`eJ`}@W^U@I@_Ya[R[@MSC_aMO@aWFmMOM@haGGMEmaQ[@MESHaIQJQMckBIw[AOSKKAMPSDSLOAV_@@`KJRbKRDfMdHZERgAWVsDMTUHqOUr@VQXTT@TfgL^NH\\@heTCZaESNObHPHeZF\\X^ElM^F^"],
                    "encodeOffsets": [
                        [111665, 19890]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469002",
                "properties": {
                    "name": "琼海市",
                    "cp": [110.4208, 19.224],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@TP\\pATHTGlZDJGAQjE\\Rb@jVBDCN`JZ[NCNHNXbULPrP\\KNbMTLjJJRFP`pNLZz^FLRHjVPZ@hxVKbHBHMNNJFRlLzGPnNHhIrHHADcPWdUAmEMVQDSKYHY\\EhBN^HpXGNDBNNBnIßÅ_g{³So]Ã£@ORO@KMEDIVYB[WJUICudGTc]P_YWaCOOMFS[]@MMYBgOU@ISHKQQkKMHYY[MSHwUit}KF\\KFMCF]EIUBETSROUKTLT[NKTWREfJbCHBZKTFTKh"],
                    "encodeOffsets": [
                        [112763, 19595]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469031",
                "properties": {
                    "name": "昌江黎族自治县",
                    "cp": [109.0407, 19.2137],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@`ZĤd`òü BSPGP@VSbQ`@]HC~T^SE]N]FkW]E[fYGGOPaTMbFDYfS@g[MGK]he@SSSRW@UVqrPVGNStCXUhBFQGYNcCeLQQaLI@_`@EUwcEaCUaMc@SK]Du`MSkKI~BVNL@X`EvYwHcTU@MIe@SXJbIPNVCRXbWbSAWJCRXFFL]FMPSjCfWb_L}E[TaBm^YF[XcQk@WKZJYRIZw¹ "],
                    "encodeOffsets": [
                        [111208, 19833]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469028",
                "properties": {
                    "name": "临高县",
                    "cp": [109.6957, 19.8063],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@jD`hNd\\^dZädĒH´Op@ùZY\\OAGIMN[[W_NCNMKU@NUMSNCTSP@`O@WSCCI@GXQSkXKX[IK@OWqH]SkWW@_SiiYQaKCAKZaCCw@MTGAMKM]FMMIMDSM_HGHRPKCBGSJJIYH[QOJCHMBDGQJECMTDQKFGTCEGTF`NFEDMFaGSNwIiTGhYJD\\KZODC^@FTKND`XBHKJNKFBNhG^FJMPcHEZF\\QPRjQTAdgNOPgQaRSê"],
                    "encodeOffsets": [
                        [112122, 20431]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469034",
                "properties": {
                    "name": "陵水黎族自治县",
                    "cp": [109.9924, 18.5415],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@R]NC`YL]FoN@V[vBXVFNL@TRZalnVFVP`DlOZkVSXEE_F[EUFeH[NKTgfCbMVU^@P]ZObZP@\\QhATUfAtUasñiāEoI]eYǯ@aKmaeWuCºKÜKpnbHbYfUDSNCPJTRAHJTDJSfDNLHXC``VBNGTYCQDIXMDSP@xLNEFRNXBIpVNLXah@RgF@`qOML@LJNSPLbaHAh@Jdj"],
                    "encodeOffsets": [
                        [112409, 19261]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469026",
                "properties": {
                    "name": "屯昌县",
                    "cp": [110.0377, 19.362],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@\\OnVBFKHPJCJOJTDB\\vDINOCGJVVL^JDONEbrGTLpMVJLGjAHGRkVChF@vH^zIbTETMHAZOFC^\\DXT\\EffAP\\PdAV@UIYfS|S@YPICMeM@sC[_A]VQEwyHSMuNcAUlQJMVGMS@mVBZPFO\\CSFQK[LqDMACiUa@[QiFBRIHYCHkGSBS[oSOqBIE^QHCRWHIXsHU\\UC}JEjMNAN_ZAIhSEYfWDQGaPMTLERZTJb``NHV@"],
                    "encodeOffsets": [
                        [112513, 19852]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469025",
                "properties": {
                    "name": "定安县",
                    "cp": [110.3384, 19.4698],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@JjDNdJ\\FbKPXfZ^Ij@RZNaVSc[MsMOHQPDJcLIJ_zCG[HQxWJBHXdENRR@XQFWZQQGOFSWUCI[WCJuRGLXNMPLhCl[Ta@SqGgJMGOmyHkKEQMINMAGaGULgwY@UOGiKQ]EYyMKoO_QEIIKiNSMa[LqOKOaVMWMGMDY\\_IKrL\\ERT[DEPYOUA@nNTUHINkRBVMdNvGTxzRF^U`BD\\@tfNDNOJ@Z{TeTJZ@VUcB[OBOeeQT@^OXBJb\\AbWTF`RCJFH\\RDJIJFXW@WLGBKxWTSJJMTVZND@bbL"],
                    "encodeOffsets": [
                        [112903, 20139]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469035",
                "properties": {
                    "name": "保亭黎族苗族自治县",
                    "cp": [109.6284, 18.6108],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@FJp@fxpQ\\ApN\\GNPNBM`HLMrXLXj\\PEHnI@WUCEM\\GTc\\GZYHTPBHRCPTdH\\K\\@HXiBJILJJAVNTOZJNtFPC`YxDPWci@IBgbGKaTOIM@KNKrP@_hE@QbgKWUMJoWAQMFEKM@wTONCJWRCZDHSAM_UD_GWMKeCITSCGIQBGXUHQoMEEGWDQIG]FMQBMaFGueFeSQDUSDSKOCSFMLUaPWM_PaEGFETMX]RCRR@HXKN@JNnXXESPaDI\\£FkXWIAX]xB\\GN"],
                    "encodeOffsets": [
                        [112031, 19071]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "469001",
                "properties": {
                    "name": "五指山市",
                    "cp": [109.5282, 18.8299],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@TCNOLBTLBPx\\AJdlNRRIbJTGNF\\@RcIYbmHoLQdKN_fCJYbDRRXKZFVEZVXBXIJBXMdESW[CUYHUVQFQAqsEIMPYMSBUIIJKAIjGW[@[LGScDOGQOAGSYZ[HSd[HFNVD@XmJFG[OWiWKNqGKN_MAMO[HoM[BoRewo@Y^HpITSFENc`MVCdHNIVCLJFI`NFIP`@VZbaf[FFJG`O\\WRFA@PVPFPPH"],
                    "encodeOffsets": [
                        [111973, 19401]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/gui_zhou_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "5203",
                "properties": {
                    "name": "遵义市",
                    "cp": [106.908, 28.1744],
                    "childNum": 14
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@@UnUlJnwJU°VL@bnVUwlJ@XXVlU@klVUJknlUllL@bUJ@xULUlUblVkblbnwUXmla@wV@VK@L@UXaVKVLXWUVa@U@Im@@W@£UKUakKWIXU@al@@llUnL@W@Un@@VlUV@VIUanKl@Xb@lmxVb@b°bb@nlJVVnnJ@b@LV@ln@LmV@Vx@blnVKnlJXIlwJ@Òb@nlK@Un@UL@VVVVUUUVKl@VUVLJ@UVUUw@Wm@UVÈVlbUb@JLlX@@xLmk@@nlx@bUJUzVJ@@LVxUV@bWxnLnVVK@_K²xVbV@n¥@aVI@b@l@VaKnb@n`nmmýW@U_wV@VlVV@Vn@n@nI@Jn@°¦VaUU@mVVWVaUÅU@aVKnVbVUmmU@a@kUwm@aUUmUUJ¯lakUaXaWUUaVkkamkmUnVlULVlJ@XU@UJWUUwk@aU@WbkWL@U@WU@@XUKmV@aUVwUĕUJUamUUVUÑmnIVJ@kl@XalJVn@KVL¥@UWIXWmU@mVUKnUWLUKUaWUUKVU@U@anUny@UlUkK@w@a@aVU»UkVw@WmkJÅmUUVmwXalLXWWUnam@XkJ@UVU@U@W@@U@I@Wl@Ènlw@KXLWblVUkalKUUVVaV@@wnIlaUmkUKWU@KkUkLWaKUUWUn@VK@LnnWJUIVkUWVnV@V@@XK@VUIUJ@IWJkX@VVJIVkK@I@UVaUWk@m@wnUWKk@mxk@@lV@bxmb@x@VUmLkUJ@nVV@b@VkLVbU`¯Il@U_UW@UU@K¯wm@xL¯¥kI@bkb@Ua@m@kkW@XVbmV@kV@bWbUbV@¦xXlmVk@¦bkaWL@KUImK@wUK@VUIb@bmK@LÅy@akXW@kbWlXblL@ULUb`@UkUymX¯@mUJUUJL@Lm@@WX@lUVlXll@l@Èk°V°X@VU@UVll@XUJVXUVm@@VXLWlnV@Xk@mVULnxV@@bmkL@VWLUbU@UVm@b@ķ¥UnmJ@UUVkkJUlÔU`UIW@°kLUlUI@WVIU@mWKkXk@WU@bXW@J@xX@l@LVl@xLVxXX@xKnxVknbKVV@ULWlXU`@nUlX@llVXVUKlkUKlI@anKVLXKVaUIVWV_VK@VnLlU»VKVLm"],
                        ["@@@KlKkUUVVX"]
                    ],
                    "encodeOffsets": [
                        [
                            [108799, 29239]
                        ],
                        [
                            [110532, 27822]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5226",
                "properties": {
                    "name": "黔东南苗族侗族自治州",
                    "cp": [108.4241, 26.4166],
                    "childNum": 17
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@VV@XkV@bUbWJU¼Vb@Vnb@b@J@bL@LV@UVlUI@aKULVb@bkJmxlLVxknVJkxnKmnnL@bn`WIXlWLU@UxVbUVmKVXI@JVIVJ@UL@W@@UmUXUlVUVJXImm@KL@UVmVXVLXblKlV@LXVLlVVnkbmJ@xnXl@bXa@VanaÒLmVnIlÞ¦°k@b@@lVnJlUnVX_@lVlKVUUxVLVWVIXJUlnnWlI@KUaUUVKn@VaVXV@na@mw¯@mUkJUamI@lk@@am@@IUmVImUUw@anUVaUU@LU@WaWUXWWwV@VwnU@L@ynbl@@X@aJ@nW@@Vn@lVLlxnIl@@UWKUnIlJXIVllIVV¼XK@aVIV@@bn@VKXLVKVVVInwJ@UWI@mX@WKnI@KmUUVJUL@VKW@@k@aU@@W@InJWUXwWI@W@¯wkaVaUIl@nValIXWWI@UUm@anwWkXWWIUbk@UJmIUamKVUUUVVama¯VkIVVUlKnXVwX@@WVaUUVa@IlaVmknawkUU@U@mUVUVwl°LVbnJVU¯la@mX@@UWKXU@aV_V@@JlkU¯@VnK@km¯kU@WUW@mmU@kmlU@wkL@WUkL@VmLJ@b@V@bknUUVK@UVKUK@Uk@Wa@LUVVnUbmVk@@UU@@aV¯K@U@UU@WmUL@aU@WVw@IxXll@UXK@KXXVJna@wWa£naUKVm@UU@mUmalm@@XkVm@U@VLmWU@kkWxU@@bVV@VkXVlV@UUk@@mI@KUwm@UmVUUwU@lwkV@IUa@mUaVIVKVa@w@U@UJkb@n@bmJ@XmlVUxWXkJmUkUUVWxUlU@aULUmbU@@WXkmL@xUV@nUxÇm@XLWbnlnVnnUVUnVVz@lbUVVlULVb@V@nUJkwm@Ux@bWbUK@UULkaJbUU@U@lUK@XUJmnJ@bU@UwWax@zkJWnUJUUVVV@bXn@xVb@JLm@Xw@`@bkb@VmXUV¯L@mW@@n@V@L@KIW@@aaUx¯@Um@XbW@@LV@bnVWVkKUzlV@bÆa@lnI@VV@@LnVVKUaV_VJVbnU@bn@nX@yVIVxXKVLlUVaXU°J", "@@@KlKkUUVVX"],
                        ["@@UUVUkUmV@ln@VXVK@K"]
                    ],
                    "encodeOffsets": [
                        [
                            [110318, 27214],
                            [110532, 27822]
                        ],
                        [
                            [112219, 27394]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5224",
                "properties": {
                    "name": "毕节地区",
                    "cp": [105.1611, 27.0648],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@UkV@kW@Xn@@KKVIVVIn°@nWVzl@V_VaVK@kKWaXklaX@lW@bÆz@KnL@aaVJ@UVL@xnLVJ@LXKlba¥l@nUWkw¥U@VaXa@amLkUKm¯kmkIUaKUIWkKm@anw@mlwXImUk¯@a@amU`kkKWVkxmUUak_mJmw@wmXUW¯X_@WnI@aVwkWWýÅU@WLkUaUbVV@lUVVnm@kUmV¯kKLwmVUUaWVaaWw¯wÈ@VULUVUUK@nWJkIl@Umxnbm@kbUJa¯bUbVxmLUVaU@VUUWxkVVV@bUV@XWbnlUbbUJlbUV¯b@z`WbXnmbawUwVWUbUxmbU@Uam@VkVawVaUWI@mUKóz@lUlÅ@WIb@xXxml@XklULWKUmwUa¯KUXWJkaULmKkLWbkKUVImWa@kUaULW¯LK¯@kbL@bx@J@bmnnlUlzU`U@@Ub@mn¦°bUVx@bkVm¼mx@mkmVV@bkxVnaVV@bU@mL@b²`lIVV@lXLlbVxn@@bl@XllIVnbVn°°wlbXw@mVa°lVnU@mVLVbn@@b@@WVnUV@Xlxn`VznJVb@L@bV`V@UnwU@WUXKV@UUlmUUlaXalLmbIVbnJVIlVVaUUnWVXnVLk@nWnblnlb²xxVKVXlVXLVWLlUVJna@wVL¼@JVX@`@nnx@nWJU@Vx@XXKUblxU°LVKVVlL@KnbVUnJIlUnKl£VWxIlJ@nVÞUVVnbVX@V_°lnK", "@@@UmWUwkU@Um@@VkL@V@VVkV@nbVa@"],
                    "encodeOffsets": [
                        [108552, 28412],
                        [107213, 27445]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5227",
                "properties": {
                    "name": "黔南布依族苗族自治州",
                    "cp": [107.2485, 25.8398],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@V@IöalK@UV@@KUaVIVVLlaVbVWnX@@LnUlxl@naVLXVVaVUJ@lUUanWWI@VlV@Xbb@Vn@VmVVbk@kU@VV@XJ@zn`ULW@kK@_WVUK@LUb@Jlxn@nnWlU@@bx@XVVU@UbVb@n`VI@VVLUlUIUV@KmL@VV@XIV@@lVLVmXV@WLXLW@U`nkb@Vl@UL@VVVLllX@`lIXbJIXWLaVL@XXWĢb@bmK@L@°@VnxmxnK@xVn@VkL@VLakbl`VnnxVnUlV@@VVXV`@k°JV_UalK@U@aUU@mIlVnKV@U@wnaw@akU@l@nwl@XLmV@xnl@VXUb@V@JlLUJUI@UlWUnLVUUaVwV@XKWkXJm_@amKnmmLwlUIlmUwkKnwlI@aUaVKL@bVJkVUU@@KK@a@I@ama@UUaV»XIVa@alU@WUU¯IWVUbkVUKWLUwUJ@zmWm@@amVUaUIU`VbULmU@KU@@UmJ@kÅb@akUVylLXUmU@aU@KX@Wan@V°@Vwb@bX@J@LK@@U@mX@@n°KVUnW@Ula@a@_x@WnK@IUa@wWm@aUUUVVVIXmlI@ywXbVxV@@aInmVI@WVL@k@VVVaIlbVK@VVLXa@aVwn@lxVI@m@UUaVKUkVUka@UymUVVUmmUmmkXaWK@ÈnVw@mVU@wKlnXW@V@naVVKUk@KVIUW@mk@KXU@Um@@lVk@UVJna@UWaL@a@Xa@kmmVUUk@mkkamJImJUUmIm±aUUkambkamVUU@VlbUbVVxXWVUU@VUakU@UmUVU@mnUVVnUbVJ@bUW¥kLVamVkUaWJU_UVWKk@@nlUVVJUXm@Vm@UnVlmbnmJUbULU@@UUKWVIWxnJVb@xUL@bUJWIkxbkb@xVJbmU@kW±LkKUkVa@a¯am¥ULkalÑlKXUWXaVakImV@ka@UUJ¯aXmmbKWU@wUUaUaKmU@UXlWb¼WLUKUb°UlVbkbVL@VJ@nVlUbUXmJ@VX@lbUbU@@bWb@VnLVJ@bVVUzVL@lnL@bVVVULmKUkJkbm@xVb@VkKVnnV@b@WXUnVlVVXVJUXlVXbWV@VU@Ubk@@KWbUUmL@JnXV°XJ@_`UbkXVVlÆkb@VLXVV@V@kKXX@`V@@n"],
                    "encodeOffsets": [
                        [108912, 26905]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5222",
                "properties": {
                    "name": "铜仁地区",
                    "cp": [108.6218, 28.0096],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°a@aÈbVUlU@aVKnVVVUlyX¹lWVa@UVnUVU@m@mUl@mÞw@xnIVbna@KVIJ@kwV¥UXÇVkVW@kkKWU@aXUWmnIVa°VXbmL@VVbnVVVUbVbJVbVKXkVKVanU@aWnWUWa@Unk@mVIVK@wXxlLXbVJVlKbl@VI@maXalVVVbX@@aalnkx@b@Vb@Vnx@bVVUXn¤WXn@Vl@Vlzn@`@I@KUU@V£namVkXa@aVKnnU@anVlKa@UUU@amk@»kU¯@aVWnkWmkImU@akaVm@»VUV@UKnkW¯XWlkUKnIWa@nmlIXmWUnwUwWm@wULmaUJkIUaaWaklwkwmJmU@bkJ@XUJ¯W@XbWbUKUkWJUUVKnn@UmmXUWa@mU@@UI@WmXVykwm@kaULWwU@¯lKUUVU@mU@UkmaUbmV@bxVnVUJVn@Jn@@bl@@knJVblInV°@nx@mbU@UWUbm@ULVVVb@LkJmXkmVWIUJUXUKVwVUkLkU@W`UmkVmIU@k@@a¯lÝ¥kmJUnKÑmbUb@Wbak@mWU@UbUVVkLlbUVkXaWK@LkxÇmk@@X@J@V@@X@VUV@VIWln@mbXVWXkKWbnxVUnVÆInl@XUxVl¼UV@b@b@xlLkV@VmzmV@b@VUVVLXVVbVLXKmVVLU@nnVWXXJ@V¦UK@LUmkIWbk@@lUImJnVÒVUnVVbVIVĖUxV@bnUVL@WV@@X@VKlXXaV@@blVxXVVIV@@WkIUVKUkVmlnnbllUVbXVWbblVkb°VInVVV@bnVx@l@bnVVnUUamUL@bVVÆUbUXUn@VVUb"],
                    "encodeOffsets": [
                        [110667, 29785]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5223",
                "properties": {
                    "name": "黔西南布依族苗族自治州",
                    "cp": [105.5347, 25.3949],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VL@Vl@@IXW@kVUVbnW@XlKVVnUVlL@baVbb@xX°ÔUxV@kbm@VxkxWJV¦@ÈnVKxWXJmV@nÒ@xVbn@@blLk`VX@bla²JVUlnn@U±lw@wnw@mlwVIX@@m@klKnkaKnwmmXkÆVmU¥l@nb°n@aVwVmVIVnI@a¯@mU°l@@VnI@JV@UV@b@IUbVJmXöºzllUbVa@aXUl@U@llLnKVaUa@UmK@UwVbnKV@VwVK@UXV@Vbn@w@UWnX@a@mI@UUKlaUaVk¯VaVLXK»XaWk¯mkğwmW@mIVkwJUIÇVwUUkVKkm@UkmU@WÅwm£Vm¤¯IkJWa_lUbmJzÝJkUÇVU@bUÝnm¯LUb@`mL@VkL@VUmmk@UU±Umka@kU@ķymUkk@mmkÝmUaUakImV@V@VÅL¦JUXmJXWb@n°Æx¼nV@LlbUUbmL¯@ÞbV¤nbVx@bUVlblI@KVVUnVJUn@VlLUlmLUUUxmK@I@@VW@@bU@UJmUkLVVUl@b@V"],
                    "encodeOffsets": [
                        [107157, 25965]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5202",
                "properties": {
                    "name": "六盘水市",
                    "cp": [104.7546, 26.0925],
                    "childNum": 5
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ôyVL@nXJVUbxbUlU@nVbV@naVwaVUXVxxbnaWmXa_@y°aVUkaVIaVamkXa@WVU@aUUlUXwVV@UVbVUnKUwVa°abVIlan@manw@VklJXI@mLVVVUVK@UÇk@KUa@UkaVU@UVWV_XWVXVWlLXKlLXaÆKwVL@akKm@Uw@@XUVk@VUI@wWK@aUVI@UkK@mLW@kImJUÅVmkXUW@UJkx@nmx@xkxV²m@kmUV±Ikb@aUWl_kK@am@Ua@wÑ@mnUWIXwULm@ÇU¥XIlwUwn@laU@Vw¯ÓW@waUab@akKUmVUUkL@WmXUaUV@lWX@Jk@@UUKULmLUJmzkKmVX°VUnWKULL@mU@UnVJ@b@UV@X`m_@l@@bmbXJmnn@°wnn@VLX@V@nVl@nk@@bl@nn°WlXzW`XXVKnUlxVbUb@VXb@VxÈbVlnbmn@kVUL@mLUVVL"],
                        ["@@@@UmWUwkU@Um@@VkL@V@@V@VkV@nbVa"]
                    ],
                    "encodeOffsets": [
                        [
                            [107089, 27181]
                        ],
                        [
                            [107213, 27479]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5204",
                "properties": {
                    "name": "安顺市",
                    "cp": [105.9082, 25.9882],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lL@bUKxÅLWbkKWLkKUXUWWXU`UX@VUVlb@VVb@Ll°xXxbbXUVbVnUxKlL°nUlVn@UmVU@kUUVablVXKV@ÆXþlXUxnU@mVK@_@ml@UU@blU@KnLVyUw@@UmkWVw@UVK@VXzVK@nVVUUW@kVJnla@nKWkaWL@Uõb@JU@mU@@_WWL@lUU@WUUK@lakÅUUlWVa_@`WIU¯mW@InKVVXa@Ll@VaV@@UXUWakUVWUIUWUkUmVXW@@amUUmLl@UUawn@laIVlnLVKUUU@amK@kUKVyUU@aUImK@UXa@aV@VakaW@@UnIVWVaUkb@mWX@Vxm@UaU@W@VULUxU@mLaUx@VnL@VVbUbmLkK@kVk@WV@bUbVakkyõ¹nWUIVa@J@aVUU@@ImJ@Uk@¯V@n°@bmJUUJUnUxbm@¯mak@¦VUnÅWlnnmxLbmlkL@l@nWVnlÆUVnIlJ@XnK@lL@VJVU@bXL@xVJUl@VU@W@Vxn@"],
                    "encodeOffsets": [
                        [108237, 26792]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5201",
                "properties": {
                    "name": "贵阳市",
                    "cp": [106.6992, 26.7682],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nlLXVJLVblJn°lnLlVnKlU@nUUa@WlX@ln@Vb@la@alJ°¦Kwn@°xLVkUmmwUmk_labK@UlK@UUm@wLmnwmw@U@¯@KnL@aaġXWW@UKbKWXJIWakJ@_kWkKUU@UVKk@@UlamV_X@WKXK@WUUnUK@kU@WJU@@UnK@LVUVJVkUK@UUJm_@UaVaV@UU@Ww@aV@Xkmmm@kw@IVa@KVLXU@`lLX@VKm_@yI@WU@UlVl@UanU@Um@UaWaU@Uk@XJmXVbkV@IUVUbWUUKmbk@kwmV@K@mWUXUakbKUUUJVb@LU@@VkL@VXKlbXmL@kbmUI@lVXUVU@mULWy@UUL@VUxXnl@V@VxUzmK@LkVa@VVk@@n@`UL@nmV@bmJ@X`WX°WVn@xnxnIl`VbnVlwXUlLl_nV@b@bl°VnWJkx@nmx@b"],
                    "encodeOffsets": [
                        [108945, 27760]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/hei_long_jiang_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "2311",
                "properties": {
                    "name": "黑河市",
                    "cp": [127.1448, 49.2957],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VÈÞ@kxnX°VÈa°V@kôwbJVkXlVUx@lL@xkVV°VbxlVUnVxk@KkVbIl@°kVl@lÆnkll@@VVX@V²bUlVlVUVÇn@nkJlkVb@x²V@n°VUnlKUn`@n°bWLnVUblVUVVbknV`°kkl@@V°@nzJ@XxlWXb°n@bĠlbXbbVbJ@Vba@@lbUbVmn@lVmnIW@WbÞ@n@x°@ĢaƐéϚnlČ¯ĠŻÈwm@ôçUmm£Xy°UV@wÈ£Ǫ¯kõÝçUÑUķĢkVÑÆÞU°nŎ¥ČUĊx°m°¦żVƐx°Ç£@yUônÞÆ@Èĉ°Kô¦WkWUbÇ»@ÈĕWÇÈ£ŤU@n£ÆUUKVamanwÅmÝJ¯k@JIkaVaUUÇbkaÆÑkWmÝUÛÝ@wnU±@kkV¯KUkJ¼U¦Å@ówķaķůV¥Uaó@Åwm_kVwĉĉmmn_V»a@UVwķóU¦LǫéóXÇmōLǓÇķxÝkĉkmakbUĶ°@W¼@bÈÆ@ĖLl@°J¯mkl¯LÝ±LamJ@¼VƧUóUXċb¯ńVbkÆÝI@llxk°V²V@UxÞL@b@b`ÇzkókÝ¤@ğ¯WLĉÇLmmnċVkbUaL@¯bU°ğLÝÝ@"],
                    "encodeOffsets": [
                        [127744, 50102]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2327",
                "properties": {
                    "name": "大兴安岭地区",
                    "cp": [124.1016, 52.2345],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@kϙmƏêġb¯@@wmÝ@XV@Ill@bUxl¯VlVbV@ULVlUV_kxVVVÈÝJ@¯Ulm¯x@xóÒĉ¼m¯Wxţ@Uz¯WwnUwť@knW£óVUUwğyó¦WIVmmI@±kwÇ@@b@ĉ¼ó@¯wó@¯aó¼KÅaUwmWUwÅI@aKó@UaLaVÅwō¼UUÝl±I¤VxÇx@zkJmnnmbnzxll¯ČkJl°@kbmx@x@kêmVnWxôXxU°bWLóJnÇWĵV¦UUbbÆġKk¯VU±aXmċÑUwĉKġkVxkÇKkbIÛXWl¯bX¯KbĊÞVÆnĸ²lxU°n°òÈb¦xVb@¯Vx@¯VķÞČlĊ°KĸȘI°¤ČIôò»ƨnȰKǬ¦ôWŎÈƨwlnKVXmbX`lbwkVWXXL°aƾaĊ£n°@°¥ŎzÞ¥»alwôkƒJa@ĶK£bU°ĊxźVÈUĠ¥ƨVI@XU°x°Ln¥w°UmwXmÝV¥Ģ°@nU@mÆ£¯lKÜw@aÅU¥UaÝIkmV²nn@Ķ»@Uk¥VKÞ@ÞÛ@kVmĢa@_Jómǖ¯ÆwóÇa@alUwwĢřk@wÆWXUWXWam@_ƒ»ÇéXaĸwVa@ÝKkUWkXkKXxn@lĊV@¯m¯nřÆw¥"],
                    "encodeOffsets": [
                        [130084, 52206]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2301",
                "properties": {
                    "name": "哈尔滨市",
                    "cp": [127.9688, 45.368],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°`_JlU@@V¦°JUnLôlnŤ@@ÈaUÒVbkbl¤zk°ÇVÛô°IlVUVôUxÆU@bźĀº@¦b@l²UVl@°ÒĠxnXxÆVô¼Þ@Üx²KÞlVÑ°UȰôlwô@²ĸ°lanV@VŎUll@bÈnÜmwĢ@la@ÝÞb°UXblŎ²ÆkVI@nJnĠ°knÜbĢwna@akÞKƒĀaIVbU¥wĠwkôxnLċVçkaU±IUmnġW°WôĉalÞÅĵ¯@W¹XÝab¯a±X¯ºLaVmkLóbkaVUKVkkKV_@aÝykk±L@ÅU@yV_aU¥ówÇx@UkVn@lkÅlwWVwUkĉmkklW@abVwnWWwWL@UUÇLÇm@wJĉL¥@Ý_@a¯yUWw¯¯Uġx¯aÝXVmaU£ó±¯nwa¯óÅVXmanUlUXkWa@mkIğamIklÇUkĊzkKlUōĬl@nX°@llUxŹ²mKĉVWwk@UbUK@bmVmIVmwaWxXlWČmºÞÆbUxV@ĵńWÆĉLkWUbaWzkbĉ`U±LklōwUVÝ£UW`Uwk@mk¯VkaõVX@WbLK@XƧºWzxK@lmX@bkVVÆk¼Vbk@Vn"],
                    "encodeOffsets": [
                        [128712, 46604]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2302",
                "properties": {
                    "name": "齐齐哈尔市",
                    "cp": [124.541, 47.5818],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Þ@ÞĠKV¯a°@KVblaČUmnnKĊÈKX°Ġ@Þ£ôllÈy_@a@aKÝVwU@±¯Ulkw@kÞJlÅUa°ŃČaWVôƨVU@»nIb²KÞ°Klkn°¯I@kK@ĕÇÅ@aX»¯@VĵlaÿVamI@aÅÝउýĊȗJôȁÅkmƑÛ@kxġ@@laVk¯»īŹak¥Å¯JUaWU@@wa»KUkÆkUmUmwÛ±±UUbUUXwWwÆÝklkUanaWwnKlkal¯kaƽakÅxa¯@amb¯VlÇwÛĀV@xmêVÆVVaôVwÈx@ˌx¦VÞ¯VlmX@L@¯Ua¯LmV@°XċKV@UÈ@¥@wġIUkm¥Źw¦¯lmn@°kxVV@¦óamn¦l@nxlĉVómxnÒĉĀĊ¼þǔêÞ°ˌĠÞÒ°ĀɲĀƨźˤȤƨĊ°w@£nymwnkUUV¥ôÑVmkÆmUUVamVIkmôlxkXÞþbll@kVƆVxV@¼VÒ@UnnÞJ"],
                    "encodeOffsets": [
                        [127744, 50102]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2310",
                "properties": {
                    "name": "牡丹江市",
                    "cp": [129.7815, 44.7089],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@U`lLUlVLUlbaôlKnUbK°¹²W°baÞbknyUlUkamř²L@m°@lm²n`ôÅlKxÜKnxV@l@ÅXyW_k@wmŹĕmX»Ûl°ôÈ»ôô_WW@Ual»wU@@wUV@VXI@wĢ͑ÞȻaU_@mUkly@¯óV»XmWUXUWmnm¥nUUaWLk»Æ²IÇawÅaÝ°¯nUa±a@¦õÆğ@@ÅbxUÜnÇłlb¯¦ôó»m@±Uk@Wwa¯xUV°xXbÇÅUVK@¹KUaȯ@ōÝXallÛkalÇUǫÇÅÇakbÝƆ¯nl¯@¼VUx@x¯W¼Æ¯mĖĬ¯ČVkķÅmx°ô²V¤bUnÞW°bĢw°V°XxV°z@bÞ`@¦KĊI@xnÈÈKV@VXKxXmXUxab@kXllĊnVlUxXkxlÆkm@UVl@ÈwôxV¦bU`@zÆV@²KllÞz@b"],
                    "encodeOffsets": [
                        [132672, 46936]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2312",
                "properties": {
                    "name": "绥化市",
                    "cp": [126.7163, 46.8018],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ऊþÆÞ@bnJUbĀnblĊÞlĸwǔÈŎKÈnôWǬêKV¥ĸôUx@VbU¼m`nnĊĊxlUmkaVÿLw@°»UmbKmÝUwUmVknKUUl¯KUUÈnK@ĠkX±lX°L@¯¥@wV_mĵ¯WwL¯UkōÇVUlwVó±¯aVka°wVk°mÞ¯ŦřÆl²ŎkU@mUkb¯ķ±ó@kxȯó¯VUÒkÝ±LÛwÝ@ó»ÅUWwmğw¯Ñ@UkV±@ka@¥¹Źÿ@aÅVwóVVUkU¯JÜóÈUl¯yk£laUaVÑÇb@ţ@kmómKV¯IU¥@@kVI`@ô¼blUlbÈb@xÇKkĢɳaÅɆō@VK@z@@¥ÆKnÜ@@aÛUwwnUķ@_V°@klVnULVVÞbVl@°@nxn°LÅÆlVÈmU²@VmĠLxn¯xkWzJwnLmbXbW°Æ²@x@JVxLĀ²Æ°I¯ºÈ@ÒnÈ"],
                    "encodeOffsets": [
                        [128352, 48421]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2307",
                "properties": {
                    "name": "伊春市",
                    "cp": [129.1992, 47.9608],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@K¯kWW²ğl@mLÇVVLk°VVmLUlVnxVnÞLnaV¯¼@xKUĀlbn`nÆxô@VbU¦ĸŰĸbôxÆ@V¥»IVl°LUll@²mVx@ÞÜÞVnlXÅÒlbÈaVVUblbJ@I°lÞInÆmxnbUbVLÅVm¤@ţVÇ¤XÈÇĖ@È¼aXVÜaXbWnzŎařKôbUlw@¯naÆKnUU¯Üa@mkkVUĊmżÝǖK°L²lÆI@¯¥ĉƛVaÞk@ÝVaĠlnUVwóma@wĉ@aVxamX@a@UaÅLaVW_nWm£nWm_ÅV¯m@mó¤Ý¦¯ÅalmX£VWUÅwmÇ@@IVWUw@aI@k@wŎ»WÅVaKIka@¥lUkUlwÅwVyÈwWU@a¯U°mÇ@UçaVa¯mV»ÅwÝUlUkV@kmUkX£w°@@ÇaÝIamÛam¯lğmmI@JUl±ÅōkWa¯VÝa@Þkbġ@xÛnÇm@akkōVōl±kÅťŚÝ°¯nUl¯xlbU°b²ôUxkVÈUŎVl°KXxĶ°nU`@x°¦@"],
                    "encodeOffsets": [
                        [131637, 48556]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2308",
                "properties": {
                    "name": "佳木斯市",
                    "cp": [133.0005, 47.5763],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nbÞJb@È¯@xW¤Vln@lUVlkÞVÆxU¼°nUbbVèÈ@nIn@ĢmlUw°żVUn@lnL@VôbwĊlJķĸĢlwôwƨxVVUŦxLźÈ°`nnĠwŎJÞĶwôJ@¤XnÜĸln°¼È°lUbx@l@ÞÞÈm°lôwL°¼ĸ°Þ²nĠ@ôwÞ`ŤIVÒĠU@VJĸbÆ²@°ĊKJĶaĢȰ@ô¥°n¤bČU@VxmUw@aÝţÇķ@ĕķīU¯²@ÆmVÑô¯X¥ċç@ĉ»U¥ÝţKWVÅkUVÝŎUmÇÝx¯aķxÛUóL¯a±óōb¯ÑÅVÿ_Åķa@UK@wm@Van@UmmLVa@VImmXUWÝUÅKUwÝUUkVk@l¯XÅ_J¯kJmÅLa@¥U@¯Vz¯@`@¼mxƥŏKÛk@±laÛ@@Xm@@xƽ@WŎnˣĕÅ@@aÅ@@nÝbÇ¯@_UkUWkbwÝU@çWlw@anI¯lyX°m°VaÛm@mVwÞK°XlaXmm_@UkwÝK@VIXmV»I@a¯ğWbġaU_¯JU¯ġĉkō`±nÝÆkbóĊ¯XĢXmVn²JVlbUèČmKwlóğxxV¦UaJbƑÿÝLl@bmbġx"],
                    "encodeOffsets": [
                        [132615, 47740]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2303",
                "properties": {
                    "name": "鸡西市",
                    "cp": [132.7917, 45.7361],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@LKVVnkbVÈb²U°VnklVlaÈL@anU°ÜmXV`nôLèxlLXL²aVVmÈX@ķlnUÈl`È¹@Ť°U@xKnnVmlnnUllVnnaŎwlVÞÒ@n¦LV°lwVkLaÞlnÒ@xmLÞ¤Wn¼WÈLVVUxlÈôWVaU_VKKXUÆbnnôKbÞw°bÆWXamVwKUw¯WUkUlJUwVUa@@kmyzmĉw@kVwkW¯ÅKU_VmxU@aW@@kK@wa@K@@kVUaky°_Vmkna¯K@Lwġk@@IÇóXwVakmV@mwXUWanlĉ@ÇUwKóܛǊÛm°@wÅ@±b¯W¹WVwŹĕ¯kVmōb¯w@awmVUUbVIkaVwķxk¼b@VXXó`ó¼Çó¯kÜ¼WnźĖnxl@X`WzÆ"],
                    "encodeOffsets": [
                        [133921, 46716]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2305",
                "properties": {
                    "name": "双鸭山市",
                    "cp": [133.5938, 46.7523],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@UUwómÑÞÑUÝÝUkmmÅyV¯ī¥Uÿĉ¯mÇkaWbÅX¯aÝxaóLmmÅaWVLULV`UbXókÇVwUUÇKX»XmÝ£nK@wmÑkÝbKUlx¯kUKm¥@ÝÑkUōxmbUmkVkmmnkUmmL@w¯Vţ@Çºk_ÇmVk@ĸVxVÈ°lLkllUbōwnVW¼nlUx¯XmWUnÝ@xÝUó¼¯J@LVbkJWnkbW¯ÝLUxn@nÜb¯U¯nWkz°mJ@bkxX@èÞVxlaXlVV`°@ÈÞa@mÆ@@bÆ@ˤĖmXōƾ@@wn@@WÜ@kb@²ÜlŐLƦnw@»_°@y°UV@@¦bÆKnI°lIÆ`°W@kllUVÞVVxLÆÞVXWVnnUJ@UbnKVnm@Ubn@@xL@VbÆĸ`UĀÆÒ°Ŏa²ô°bôKÜVĸw°bÞwÈVnÞōVUÆlXU"],
                    "encodeOffsets": [
                        [137577, 48578]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2306",
                "properties": {
                    "name": "大庆市",
                    "cp": [124.7717, 46.4282],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@mÇ@ÑÇ°¹¯J±ÅÿKUwI@w@±ÅX¯WanamKxIylX°wmwğKUn±@nVÇUÅkÆ¯Kmmw@@¯UkÝaUUVKmUlk@¯U`ĸ@VmxVxÜ@bÛ@mÅL@¦@@yLUŎ@ÆɅɴblġÈL@wÇaakkVa»@ó¯_ÝJwÇaÅXnyU¯¥Å@wbÝaLmm@@VUlbğVm¯Xm_`¯_UxmLa¯b@maó¦Çk¤V@bóJknVxVXx±aLUbVxkLVlLWl@nX@VÅbWlÈnxbWÅbm@xbml°bXbWXVmnn`Lmnbmb@k@mwU@@¯Jlbk°lbkmLXxmbVbkllÅÞxXxVWVVa²VÜ²nxVVnÅlVlL¼b@xV@XVbIÆ°¦lźbĬ°¼Ulb@kĢ@lw@ƒÜlnȂÆóȘIĉ"],
                    "encodeOffsets": [
                        [128352, 48421]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2304",
                "properties": {
                    "name": "鹤岗市",
                    "cp": [130.4407, 47.7081],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Þ¥ô£nn@°ÆUn`mXn¤mX`UXbÆKVb@@bnWbwUbĊ@x@nbWVm_mm@ó»UmÅWXkĠ»²¯¯nķwŎ@ĊŎK°bĸUnÑKČ¦ĠÈbÆknJÆUĢV°IVƾwaVkÇ¯¯»mķkÛWm@£óIĵxÝōIğxmm¯_ÇŹKwťUVUƧwóxxġkĸķIkĉxóa@UmK@kVmUŻ¯Vxkġn@mmJ¯n°V@bXVÇxUzÆxkxlVkV@¦lbJLUbÆXō¼@xl@J@bVxXU@JÈ@nxVÆUXW¤knÆb°"],
                    "encodeOffsets": [
                        [132998, 49478]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2309",
                "properties": {
                    "name": "七台河市",
                    "cp": [131.2756, 45.9558],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@²mŎ_lĊĢV°°IV`ĢbaĠX°@bJU¼WnUJ@ÞLlxV@n`lIUa@K°Iô»ÞVwÞ@VmnX°WVwmkX»UmŎxVaklkkKÇ¯UUwÇWUnU±bKWKkwçóKmU_nW¯ÛmV@bÇKkbkUml¯U±VÇaUamlUULKk@U@mwÛLwkLóÆm_±nk¯@@n±KnŚlbkVVmzlWXº@Ķ°"],
                    "encodeOffsets": [
                        [133369, 47228]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/he_bei_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "1308",
                "properties": {
                    "name": "承德市",
                    "cp": [117.5757, 41.4075],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lLnlmxnIVVlUnb@VVxXJWL@LÞVnnVJ_@wkmKbxwXkWXXKlb²K@nVVVbL@WlU²lKVnUJVz@VVb@lÅ¼mVUVnbôaVX@°Ub@lWbX@b@bVb°x@VxÈLVlaÆ@Þb²k°@lVU@Xn@VWLXb@¤VXKVVVLnm°_ƨ¤@aUIVaalkX°kV@alwUVyU@kó°na°UVUUmUÆw@mkLVUWVIWLnn@xlVnKmyU@U°UXaV@U¥U@UÆ@aVUkWU¯aU@WLUV@bkbmKULmKkUVUkmVIUwlWV²Uml°U@WLUwVm@UUK@_KUUÜaXw@VKUU@mVIUUlmnIVVVbÈVlKnbVK@nI@nVnwVLVKKVnb@aUIVW@In°@lVnI@lWĢ@°UVL@b@VyUUa@w@WUnU@WÇ¯K@UkkJWaÛbmk@mVaÞU@amkW@mXUKkÿ£@akl@Um°UXwlaal@nmlXnW°znW@awV@akbĉ¥VmU@IVUJkUmWUKbmkUaKkUVU@KV@@klwWaU@kmXVènbmlUUKX¯JkbI@JmIUWU@Lml@XkJ@UkK@aVKwWaIWwmU@mU@J@UaċUaUUVkI±k@UU@UbVVm@UVKLlkIWaULUWXUJU@WbUb@lkXUxm@@JVn@J@bnb@Vkx@bLUÆnJaVXnKVVmzX°V@_lJXxWXK¯bÅamU@lUIbñJ@LÇKkIÇ`kxWL@@@bUVUb¯xWKkÅVlULW@n¦Ul@IlmUUUVm@kWnkKma¯XUKWmnwVwÝLmVUbUVWb@LnxmxVmbXx¦@nb@`V@kbLUmVUlkbVXkºmnm@@xk¦bĢÜl"],
                    "encodeOffsets": [
                        [118868, 42784]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1307",
                "properties": {
                    "name": "张家口市",
                    "cp": [115.1477, 40.8527],
                    "childNum": 15
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@kġÛal¥@wn@nml¹UWlaVknUVKla@U@_ma@¥WwnaUwnmw@KXaVUVaUnmWUk°lnUVUXWVwIWVóKUI@WXxUU@mma@kUKWLkw@yk@aVkUUċaUU@Wk@Unm@UVmLm±IUkJkW@aI@m@UVUla@VXVXmVwnkWKKU_k@m¥mX_JmnU@km@U@KmUVU@U@Umk@@LmW@Û£Wka@wk@aI@mmk@mUa@UmUIwW@aWUbU@kbÇ@kw@makVUkU@am@aU@mxkUbKUXU±KXVWLUK@wkU@V@WXUa@WbUxJI@¦VèVVX@±ê¯KUI`¯UULVx@V@UKIVkLmVkKm@nUJÝbkIUJVXVVxVbUVJUn°bVmlU°XnK@Ul@lVÈVUXx@W@VXVKÞbn@VnbVm`UxkW@UVkLKm¼@lUnUJVnVXV@Vm@@LVklIkl@VWlULWKUL@mJ@blbUVUlmzUJUxm@UUbċÜk@Ub@VLVV¦ôbVmUKUkU@m@VlVn¼WbUJ¯@@°nIllÈl@nXWlLkJ@bkxlxkxlXUlklJXL@bWn`@nÆXxlL@xl@XbLKlVlIXblVUbUJW@lX@VL@VVXJwn@WnL°KbVbl@VI@K@U@nmVmV@XUWI@aXm@VUUkWmn@lmUUk@mUmK@UnwVĉ@mU_V@XJôVVULVUn@llUnJl_n@ml@XlLlw²LVJUL@VmbVblVXmVnl@Ť¦nn@Ü@bl@@XV`Unb@VlLVb²JXn¥ÆÑ@¥Þ@"],
                    "encodeOffsets": [
                        [118868, 42784]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1306",
                "properties": {
                    "name": "保定市",
                    "cp": [115.0488, 39.0948],
                    "childNum": 23
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VbXW@@UlV@xVLXKWU²LVVWLalVnwV@@bn@bVVllUnb@lxÈ@laV@aXV@bXxJnV@VVb@nnl@nJ@bll@aU_VWUwVUkUmUkb±mVwU@VIUW@UWk@VU@ynLm@IV@bnKLVaVmnIlaXwV@@WVL°@@xnX@V`V@VbUVVLVKnwnL@ll@@_V@VVnaÆ@KVXÆ@n@wKmUWm@km@kÜKXU@ÑW±nIUwVKla@I°wU±kkmm¯m_JnawW@IVaUama@wUmU@mVw@aXk@mWa@£km@a_kVmUnWW@¯bkUmk@VÇm@@kUUKUU@UVUamVUaWIkb@xU@@amUkKVkam@@kVUkUWmKmUkLUb@xmJU@UImVÛVmnUwJU@VX@UWm@Ub°¦UmxklmX@`ULU@@UW@@xkn¯@makVUmxUb°lUbUbnUJUUVaLkbUUJUU@mUUUJka@xUIWJUnJ@Vz@kb@`@bln@lb@X@@@XlbnbVb@VJlInlbVw@UKl@lbnan@VbJôLnUzlV@lÈLVbVK@LVxVWXX`WxXzbV`UXV¤nx@bVlVnVlUL"],
                    "encodeOffsets": [
                        [117304, 40512]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1302",
                "properties": {
                    "name": "唐山市",
                    "cp": [118.4766, 39.6826],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@VVl@²lJUVVbČVVb@@InV@VnXxJXbxUL@bLl@VlI@WnkKV@VXnJ@IJla°IWLVVnkmaUçWVkôaÜ¯@nV°wnJlaV@VUnUUaW¯wXWWwna@£UaWKU¯¯@aVUkKUamUUn»anIVwUWlk@LlWVakU@K_lbÞU°@y°n@KÈkWWţ¥ĉōkġWUw¯£¯Çwţw@kK@k¥ÝwÅbÇ¤ÛťVlW°@ĸx@VVVULVLkl@V@X`Ub@Xm@UWbk@ÆVbnLWV@lnXUbl@X¯lmUVkKWLkK@_UK@U@UmmUxmVXLWVULkU@`W@ULUK@XlJXzV@@xml@VU@UX@Kk@WbUK@Xn`XmJnmkxUVbUVlVVxUbV@nKlLkVKÞbVKXI°KVmVUIUKULVxVJVLkV@V@UbU@WUU@UbUK@b@nV@VkLmb@b"],
                    "encodeOffsets": [
                        [120398, 41159]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1309",
                "properties": {
                    "name": "沧州市",
                    "cp": [116.8286, 38.2104],
                    "childNum": 15
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@ln@UÈl@Vnl°aX@mXnVlU`@bln@¤Xb@nWl@bUx@nnVV@xnbVbUb@JXxbmXa@kUVwlWkKôVm@wkkK@kl»ÈmVKXkla°@XVV@VI@ml@@Vn@VX@V@J@VxUzVV²blVk¦@Ġ@@»@VK@VÈLlK@XnJ@alIUlaVVb@n@aU@WUIV@mUn@mKXml@lL@LnWb@XV@@aVVbV@VVIVWÈbIÈ»ƒǟlWaVUÅUUm@kVUWVkaUwmaóUJUU¯ÑU¥mk¯UaKÅnÇyóXmWÛX¯aċbÛaJWÝU¯»aóóUm@IVVl@bLUJWLX@@xXUxl¤V@VnVUVXVbV@@@VVn°V@ţU¯VUmUWV@mUXabUKUwUaÇKnVk¦Wb@VnLmV@bkV@nxW`Å_UVV@bUklVX@VmlUx@VVL@xVWVL@VW@UUm@"],
                    "encodeOffsets": [
                        [118485, 39280]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1301",
                "properties": {
                    "name": "石家庄市",
                    "cp": [114.4995, 38.1006],
                    "childNum": 19
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@la@y@UImVXIVJw@lbIVVnV@VVIVVlaKbVUVVImVaaVk¯VanwVlUnb°@lm@wX@@VV@VK@_nWlknwV¯¥Van@VX@W@UVIVxnmÜUnUVJV@nI@wValKnV@kmU£na@mVk°KLVa@UU@UmknWWkXU@aWW@@km@UaU@@klK@UkaWaUnamm@Ua¯wWU@UkL@Un@xVlUXVJUbLmU@aUWUkmKkLUUm@mWXammkkWUm@@U¯JUUmkU¯@mKĉxÝwÝ¥LUómwkUUUWVkKmkKmLXlxVLVxXJ@nVJnz@VWL@`nX@x@kVUUmJmIXxJVnUV@UVV@LU`UXVVlXL@l@b@VmX@bxn°UbkKWLXlW@@bKmKULmakLUlmb@Xb@xmXU`Vb@`lLx@nWVXL@°WlXnlbKVKXVb@X@l_lJ@V@XnI"],
                    "encodeOffsets": [
                        [116562, 39691]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1305",
                "properties": {
                    "name": "邢台市",
                    "cp": [114.8071, 37.2821],
                    "childNum": 18
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nKlLnlLXUVVlVnxôVKÞ¦ÞxĊwnL°@lVnVV°I@Vn@VlXnlnbWnXn@VVlKnLVlVX@bnVKVaUIVWkU@wVm@¯@U¥VmU_°lKkw@LXVaU@wUUUKlUóW@UVUUl°KwlKU_naKVnlKkkWWa@IJVa@IlJnU@KVUUmVlaXUl@lm@kXWÝÑnk±k@wğ@@U@mKĉLmVJ@zmlnWLUÝJU_@@mJkXUVlbklÝ@Ýab¯@¯±JÅwġaUU@kU@mVI±bUKLWUXJkaLóKULWbUVkKmnk@@bmLUl@b@mnmJkUULabnmn@lVV@¦n@l@bznx@`Vz@bxnV@xllbnKVx"],
                    "encodeOffsets": [
                        [116764, 38346]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1304",
                "properties": {
                    "name": "邯郸市",
                    "cp": [114.4775, 36.535],
                    "childNum": 18
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@bVKlVnInm@@akVnK@al@nmlLVUXaVKôLKlbIVWXKVL²aJnU@lV@VVĢbÆx²I°°@aÞbÞ@lkkaVUlWnI@@V`ÞIVXKmnk@yInUĊKÇkUUamUUk@aU@Uk@WUwVkVJVkkw°a@mK@UX@VVLVW@wwVa@¯Xm@@lUIWaU@UWkXWmU@UwmUkKmn@lkV²VaULUVmJUUUwLma@UmkIUmLmVmx@bLUamKÅL@VmbkU¯KÝamzkJUb±VkbL@lU@WIkJzkKmKnUalWkkKW@@nkbk@WW¯XUVUJ@XlJ@X@XlWLkU`VUnaWaUV@UVIaUxUUmVK@I@W@ÇU@@U@b@nmKXmx@UxkVWUX@`VLlL@`zXÝb@b@VUVkIUJVz°KVlnLlKnLxlLVVUVlXUJ@nnI@mVUlbn@@m@bVnV"],
                    "encodeOffsets": [
                        [116528, 37885]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1303",
                "properties": {
                    "name": "秦皇岛市",
                    "cp": [119.2126, 40.0232],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lnV@Xbkx@lU@@LUVlVLVbnlaLXVVnlIVUJV@UnĊ¦lab@nJ°UmV@wn@VUJVI°bnWlXnWVLVK²bakklI@aUaVUwVUUalaVwnUVak¥X@WkLVÓmmUK@_lW@n_UK@alÅ@ğÅƑŃÝm@ÑţÇlL@¯mz¯@ÝVak`@LlVUbkXK@klVXUxJmbm¼VnVVblLUV@b°V°XLVb@¤mbXxWX°xXVbmVUVU@kbmI¯xmU@Û°óbUl"],
                    "encodeOffsets": [
                        [121411, 41254]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1311",
                "properties": {
                    "name": "衡水市",
                    "cp": [115.8838, 37.7161],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@KVlV@X°xb@VnnmbVXblb@VkL@lV@Vbn@@l@XX@bWVXlmXnlVV@@VUbK¯LUl@nmbV¤n@lLXnlVUV@ln@lbUlLnV@bV@@wlaXJVbnUVbVU@VVLVVn@VVX@@UKXUU@wUK@UwVnk@UUWlkV@aUVUÆ`X_w@mlU@anUmK@UXal¥UmÈLVbVxVLabVW@nXUVnV°UŤV@U¯Um@U@@UUaWVUmUUU@k£VwW@wW@XKIUa@wU@@al@UK@_mKXKbUU@aVKm@Xm±@kbÇakLğVaUw@a@mkUJk@ykw@£WX@lknk@WVkbUVnUVL@mVkI@JUbI@JXbXllkLUmLmbV`kLx¯LkVUV@VôXkVVLVV@xVUbW@KxlL¯kV`UnV¦°@"],
                    "encodeOffsets": [
                        [118024, 38549]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1310",
                "properties": {
                    "name": "廊坊市",
                    "cp": [116.521, 39.0509],
                    "childNum": 9
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@laU@UnL@VWbklWxnIVVV@XJlbUlXVbn@@KmV@@X°WVInJmn²@lmVbnL@amKV_kwlmX@@LVamaXaaVU@UnJVanLlUkaW@UaVakK@IlKUU@an@ln@alKUkIVa@a@klaUKUV@UkUV¯KVV@kUmU@@a¯ImJUU@VV@UL@U@@WXUWa@Ukwm@X@@w@al@@aVIUmVUUUVWUknK@I@l¥kU±aUUVyUw@@I@UUWm@@Uk@@nUJU@WU¯@kbWlULnÇk¼@llLl@xUnóLlkXUxV@lWbI`°nnnllV²¯x@JkbLUVxmJX²@ÒWVÛL@lln@XnnVL"],
                        ["@@@kX@Valaa@KWI@UXW@WanaUIW@UaUKķk_W@UVUKU@b@UamxVXnJUbWVXLVbn@W°kb@U@Wó¼mIU¼k`V@bVbl@lX@lUôVlUIV`lXVn@lUlVn@l@UVaIUWl£UmVWU@@UUKlUUUnVL@KUnLVWUa@U"]
                    ],
                    "encodeOffsets": [
                        [
                            [119037, 40467]
                        ],
                        [
                            [119970, 40776]
                        ]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/he_nan_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "4113",
                "properties": {
                    "name": "南阳市",
                    "cp": [112.4011, 33.0359],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lKl@nVV@bn@VVnmnLLXx@VLlKVUIXWÜ@Člbl@XUĊUlwnWLÞwm@ÞUVmnVl@nXJXLm@VnnJlaI@VkxVb@VlnJ@knKVn@°aVanal@XK°b@¯VJXIVK@al@nVk@nKab@XL@blVVKVLXK@VaVI°mVaX@V_@a@yUkVwVIVaJ°@anIlaV@nKnXÆm@wUUV±UUWUKnaWwXUWmÅ¯Vam@kakImUK»lan@VXXaW@@UlUUa@a@UlwUV@Xal@@anIVaUK@VXmwVmUmVLXl@nalLnal@nKlkV@@UnJUXnl@nVl¦V@@VnJ@nUVVVVIn@VaJÆn@@K@mka@kmWVaUI@a@k@@aUL@mmaVIUKUV@@IU@mUmmL@K@UUUU@mW@@nU@ğ»mVmbk@klW@UXnV@LJmlUnUJUUUW@UnkKxmLa@@@lUUbmUVWk@@nkUmam@UakJU_Vm@ÅlÇLUVmVUwULKU@k@UVUlU@@U@UaUUWaÅzJaWLklb@bmL@kKabWUV_@mV@b¯JmXUbUK¤ÇLUU@b@JkLWmkUWIkJ@VmX@JUbVXU`¯VV¯blK@LXKlUV@Um@@Uk@kxWkbL@KkbmL@UXmaU@@l@x@blX@xUJ@bULUlULÇ@@VnU`W@@nÛ¼U@@VmKUkm@VVX@@xÇ@bUbVb@VX@@xLUb@l¼XLlbUlVVUUb@n"],
                    "encodeOffsets": [
                        [113671, 34364]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4115",
                "properties": {
                    "name": "信阳市",
                    "cp": [114.8291, 32.0197],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VllInJlknJVkVU@mXlUÞ`VnVVU@U@y@nXlKVnJVkXKWaXIb@yVkVUkVwn@K@nW@kKlUXVVUlbnUV`n@V_V@llX@@Vb@bV@@nlVUb¯WLnbmb@nLnKbUbVWnLlaX@VVUX@Vln@`kL@ll@VXVJÈIVl@XÞJ°UnaLlylU@UXKlnn@lanLWWnbVI@KXKVL@LVWVL@UVKUIVWX@@XÆJ@In`@lJVI@aWÛnK@UlK@UU@VKnlmnXalUllLUbVVknJ@nV@Vm@al@@xnVlJVUU@w@ak@XW@_mWnUlŁUmVKV@VXwW»XWaUwnkWUkVUU@@@WlaUkkaIWVkm¯xmIUmLUVaUIó»m@mmwXk@amk¯¯l@wmkLmmU@UbkUWJ@XUbJ@b@l@znÆmK@Xk@Ub@lm@I@akmVKUUVUkU@U±JUbk@IWmkxa@UUVUWVkIUaW@UlLWn@VkJI@VkK@L@bmKkJmUUaUKWXk¼VxnJ@V@@VULV¼@@UkaUlWL@U@W@IkKmL@KULUWULWKUXUJmIbK²UWnWKUUkLUmUUam@UU@mUL@xkV@VV@bmV@Vk@mwkUVUx@mbXÇnVbUL¯WnUVLVb@xnlWnU@UVUVVUbVVlVkn@llVUXUWUXVbUJ@bmLUJnb@nVK@bl@@@bVJUbnX@lb"],
                    "encodeOffsets": [
                        [116551, 33385]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4103",
                "properties": {
                    "name": "洛阳市",
                    "cp": [112.0605, 34.3158],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VVUllLXl@LWn@J@bKUVmnL@`VblLnbV@b@JmL@LnV@VV@¯VJVnXL@nm@aÞ@ak@mImVbXLynLk°@°aVJnUV@UVVXk@WJ@VXLlUnJVnn°U@»°Uwl@bWmUXÆ@VLXU@m@Ua@Imkba@naWW@_@WXUV@@U²@K@I±U@¥kKWLóLla@£Um@kWKXU@mlLXUVKUU±J¯_@`UL¯Wmk@WakklUnVUVaU@KUU@mmK@_a@KX@VaUIm±kaVKVUkw@kaW@kbkL±UUaK@UUKVak£@UmmL@lIkmU@Ualw@UJkbmIUmn@WKImWk@mUUnÝV@nÝxKmXkxĉVWVk@kaċÛ@WXJUV@zmVWnbUbVbLlUnlUÒnWVVWnk@@Vm@kxm@Unl@Ll@@V@XnkJVV@nlVXxU@ln@a@VLnWĊ¦nx@lbVKXLl@ÞVLXJl@XXl`lIXVl@XlXUVKwV@lanxzUbVJ@VVX@b"],
                    "encodeOffsets": [
                        [114683, 35551]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4117",
                "properties": {
                    "name": "驻马店市",
                    "cp": [114.1589, 32.9041],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n@b°UÆXnVlnLÜ@VLm@n@na@Jm@k@lVVxXX@V`lLVXVV@VVÞLVV°²@labnxV@@bLmlm_VWnIWUna@lLbnV°VL@KVLVUVaVLXK@mÆXna@wVma@Xw@KlL@a@Va@wUkaWnIVla@Kn@Vn@VUl@nKVnJ@LnK@aVkVUUW@VakUVanI²XW@UUU°KnUVLl@XaVK@aU@KUI@W@_lm@KkLUKV_U@»@UVJ@XV@@mVL@K@U@Kk@VwUUm@kmWL@VkVkzKmb¯VÝI@WUkÇJUIUWk@@klK@_km@UVWUUW@kbmKUXaVamLmK@namaXK°VakU@mU@@aa@UW@kkU@U`m@U_mVkaUVWUkVL@lmX@Lm@UxVlUUl@zaWJXbWLUlmIUkLmW@@z@VUVUUmÝ_kVW@nUVUlmIklmIkJUkl@n@Lm@ÅIUbm@UJUUVU@mmI@UU@k¥mUk@WmVmI@VU@klmLk@mbkKmb@WkKUVnUnnxW@UVLUbmJ@bk@WbU@Vkx@V@bVbkV@V@XWbUWm@kb¼VLnlJlb"],
                    "encodeOffsets": [
                        [115920, 33863]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4116",
                "properties": {
                    "name": "周口市",
                    "cp": [114.873, 33.6951],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lnb@xlJ@UnLlKXUlJl_KnV@xVL@bkbVVUè@Wb@UbmkVmbXVJnUl@a°@@bLVblXxInmnLVwanJÆw²IlmnXVl°VVbÈaVb@lkn@VWnLlUVmÞUUklkVkUaVaVaUwK@kkaVWmw_l@nUVVb@baV@VV@zXJl@@kl@lk°WVnÆbnbUVJI@VKVm@kK@_kK@a@aU@@wW@@k@aUW@IUWVUnLlUlVXKVwmk@W@VWa¥@k@lnUIÇKUaU@UUVmIUVUk¥Vma@¯k@Wanwm@@n@@m@UIVkUVamUXWaVU_@mUVUImW@aUIĉK@VmIb@lU@@nJkU@KIUmmLk@UVm@Um@@LkbUmJXlbV@xUb@@bkK@LWx@bUn@xmbÅW@nWLUKUbUVKU@LUK¯mU@VV@xULUVL@bU`WUz¯aUamKUa@@xkX@x"],
                    "encodeOffsets": [
                        [116832, 34527]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4114",
                "properties": {
                    "name": "商丘市",
                    "cp": [115.741, 34.2828],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XVl@lLÈ@VkV@V»UanWX@VaÆÇô@ÈaVX@xVJXUÞUaVLĸbXKlV@m°Vn_nyXX»mUk¥lK@a_@yInaVKVa°_@WXI@@KVnIlbnaV@l@a@_w@lwUKmXa@UV@»Vw@kUKVUUm@w±VUXUKUwmJUU@km@@±mXkmUI@mmKUwkbWakLWaUIkJmX@l@@VUX@JWbX@VbULWblUVULknlV@bVJkmb¯KknWmk@@nmVkx@VmU¯KUnUL@JUIVmaÅaUm¯Xlkk@@lk@WI@yUUU@b@aUaUmVk@`nxUXlb@lLVxUbUbVbUllkVlÝVUnkVmKUXm@kl@nUx@xnxn@`VX@V²x@V@b@Wl@zU`VUVVbL@VbW@bkXllkLWV@V@VVÈwlV@@XK²LlbWnnÆL@VnJWn"],
                    "encodeOffsets": [
                        [118024, 35680]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4112",
                "properties": {
                    "name": "三门峡市",
                    "cp": [110.8301, 34.3158],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WKUmUI°U@@UmU@KnK@IaU@makKUa@_KnmVUL@a@IXm@KWkkKVkUU@aUW@UUIVaymwkbU@xLVUWWkk@WUkJk_WWk@WIUKÝk@WKULka@mwĉ¥mXUK@@bm@kVWwkU@mUUlIWm@@Uk@@KkVmn@lwn@@Ul@XmUXUmVÑkmkVKUaVamaUXn@ykLUK@WwKmKnUm@UmaU@mUk@kL@lxċxUnkVmnXxWb@`kzWJ@VLmVUnlmUL@lW@Ub@VXUb`VLUbUJ@nmnUlUUm@@bUJlnUU@lxkb@@XJUn@kb¯VVVmlXXlJlzn@VlkVW@bkKbmkUbVblXVxKÈnwÞlĊKlVnKlwX@lL@xlUnVn@l@lmX@ÆÈb°¼ÈwVJlx_°xalUÈxlUnbVxnL@lllbmn@nb@@VL@V@@VLJnIVVlKnV_"],
                    "encodeOffsets": [
                        [114661, 35911]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4107",
                "properties": {
                    "name": "新乡市",
                    "cp": [114.2029, 35.3595],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XVlLK°bUblbUbl@nX@WXVVKVk@@mb@UbnW`kLLV@VVLnKlVXIlV@@a@l£nWlkVa@°bnUlLVlnabnUVUXKlU@@lk@aI°y@ôkUU@wmônkWakmlUkVmkUlmUUm@nkUKWanamULXW@UVnUln`lblL°KXV@ĠJ@L°JUVwanK@UUImmkK@¯±Um@IVmUmmÅnWaUK¯aUkw@W±kVxUVwnÅJUIWaÝJóIbm`ÝbÅImJUI¯¥¯@mU¯UJmnUVóUkl±V@zXlbWVXL@bmmº@@XmJUXU°llk@nWJk@U@¦U`m¯Wx"],
                    "encodeOffsets": [
                        [116100, 36349]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4104",
                "properties": {
                    "name": "平顶山市",
                    "cp": [112.9724, 33.739],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@l¤UbVL@VLVb²VlKlaX@lb@lxUVULbln²VJUbW@@Lb@`nL@nVV@LVUbUVmkVllXbl@Xn°VK@_°`²IVVV@VUVJnInaWK@U@KLÆ@nmlXXWVUUw@klKVa@knyVkVanIJXUl@XbVUl@@aa@mXkbnK@UlK@UUUVaXaWmkUm¥nWmXaWakl@VmÞbKVL@aVI@mUwVm@KÅméULKVaUk@kUK@UWXI@VlKXU@VVnInVV@VLlK@UUkKU_@WWUwU@kln@@Imb@@mnUKÛ@mKUkWVXxmbVLXVVU²VV@xÅnmWmLU@kbmJ@b¯IUbJUUxVl@z@bU`W@Ub¯nUJUb@WLUKULkU@aWK@abmL@lmUk@@bULWJUI°@¯aWLk@mbUb¯b"],
                    "encodeOffsets": [
                        [114942, 34527]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4101",
                "properties": {
                    "name": "郑州市",
                    "cp": [113.4668, 34.6234],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@nWVUKÅ@WnVnIV@kÆwV@nn@lxÞlnôJzXJl@nalUČVll@²UlkôVVUnmI°VnV°@°¦VJnIÆJÞan_VmU@ama@kU¥kaUklw@UIV¥kVUI@mmUÅmUlwVU@amUJWbUakVVé¯Im`k@wVWmLkU¯XkWmLmx@UUbm@@xJ@LbW@UUVWUkVK@kaIUamKUkkmmLUkJUVWXkWmnÅ@KL@@VXLmbmJUIUVU@ULWVkK@nWVXL@lVn@¤bkôKXKlL@¦²V@JL±@@VU@WV@X@`XXmb@blan@Jb@V"],
                    "encodeOffsets": [
                        [115617, 35584]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4105",
                "properties": {
                    "name": "安阳市",
                    "cp": [114.5325, 36.0022],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°kVaV¥kVmUkWkWVkVKUwkkmKUU@awWWXWakKWkXmlaIVmX¥U@a@WnK@kVI¯@KğI@WU¯LkKak_kmmVU@VWXKnVmbXbVLmln@VVknlVUnVlklnXbmlmlXblnÈlWbn@@nK@VLbVV°VVzln@VxIbU@WLUa¯VUkWõ@¯kkmxk¼lXUlVbVLnlULmU@lLkVUlX@xW@¯mU@UmIUWL@aXakU¯anWk°@kkKmmUIWaambUkkKmV¯a@UblkmXk¤@@b@UbULWVnb@lUVVnmnVVUJ@bWXX@WJkL@blVU°UV@XlWnXUbW@UVkVVWbnLUJWLUK@Lnn@blVUnUblxVUVJXUa@UbLnUVV@mVIVVn@UbV@XbmbUV_lVXUWanJVI@WkI@WVIVU°WXXl@la@mX@lLXlkVbmXylIXJV@@kKla²UVaIVyÞb°LlVna@UÆKnLVbK@anwU"],
                    "encodeOffsets": [
                        [117676, 36917]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4102",
                "properties": {
                    "name": "开封市",
                    "cp": [114.5764, 34.6124],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lUVbXaInV@bUVxknVVÆnn@VJlUU¦VJ@kxVllb¦lV@nb@bVUnaôJÞIXbVJÆImxUVwU²l@XxVl°bVLXb`XklUnmVblL@lmx°LVK@UXIVaWlL@Uk°KkVaVUXmmI@UÅKmmXka±KL@W@kUÇxUU@@UXUlKkklW@aXa@UKUaVUUV_@yXk@@a@U±w@UUW@_mmw@wVwmUaÇbUa¯UUkmWkn±JÅxmIbUxmKmnJWwkUaK@a¯@bk@mVUIWLmwm@Ua@WJUb@LUl@UUmLUbWJ@VL@VmXWWzUJUê"],
                    "encodeOffsets": [
                        [116641, 35280]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4108",
                "properties": {
                    "name": "焦作市",
                    "cp": [112.8406, 35.1508],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@V@VL@x@bXWV@XklUWX@J@nI@KlLKUVaV@JlL@KUk@KÞLl²_@nWlLUVV@nLWVUJVn@anV@awÞUVLVxb@lW@lbXnVn@@¼L°mKVn@bnl@nVK@blbLWU@VWLXV@nlKn@lVVbXw°nV_@¥Vl@XI@mlkkV¯VWnI@W@n¹n@aWKXUaWk@yk@kċUkVmbk@WIyóImÝkkwm@mU@xÅlU@mJXak@x¯V@¼¯VmUmmIkVWK@UXIl@UWVUU@mVUI¯b¯@lmKzWKUanJ@nlbÝ@@b"],
                    "encodeOffsets": [
                        [114728, 35888]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4110",
                "properties": {
                    "name": "许昌市",
                    "cp": [113.6975, 34.0466],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lIVnKlnVlnLVbJlb@ULVlUXVVX@a@KI@wn@aVV@nwnKlXW°lVnKUXx@ln_°JVIXyXnW@UK@UXIVanKVV@Vk@KVaXI@Vbn@nxKnaUlnVa@Xa@VçUUla@aUK@wmULk`kIWVkLmK@V@XUln@JXV@nmbUóImUa±@@ÑóVUUk@UlKVU@akWVUUlUUaUK@UUKWbUkÅJ@XWa@XbmJ@nUJ@bUKLÝaUnk@lXbWbXnmn¦lVXnWbUbVV@VkL@VmLaWl@nb@bk@UVWak@WVImJUbUlmz@lUbkL@lVx"],
                    "encodeOffsets": [
                        [115797, 35089]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4109",
                "properties": {
                    "name": "濮阳市",
                    "cp": [115.1917, 35.799],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lLXbWXXx@bVVnLllVxULUlXXlVlUnlU¦Ub¯lnK@VbVb@XbVLKVxVVnIlaba¥lU@wnalLnVVlVLXnlWVXn@@lVI@WnU@mÅW¥aW_k@WwXy@km@wUm¦lUxVLV@UwJ°x@VX@Vb@`VX@VX@llIVbnJlIbVlJ@mÑ¯Lóa@KUakX@UK@wU@lWUUÝ¯ImW¯aLUKU@k»k@mwa@UnKWI@UU@akVWKk@a±bóUWKXUmkKUmLbUx@lmLX@@bVW¦UnJkbWnXl"],
                    "encodeOffsets": [
                        [117642, 36501]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4111",
                "properties": {
                    "name": "漯河市",
                    "cp": [113.8733, 33.6951],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@LUnVxnIWa@Xb@WÆIVlXaVL@VVLVbkVVUVlX@bUVkLVl@VVôU@Ò²@VbnôJVan@mWU@ImVk@WkI@wmak@wlW@w@VbnLVb°bVyXV_@aUKVVK@wUU@aK@kmbXVmJUX`knnK@aU@mwakb±@¯UUÝKUUU@WU@VkLUKU@mUmJUU@WVkL@UWJX@VVL@lVlUbLVKnêÆ"],
                    "encodeOffsets": [
                        [116348, 34431]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4106",
                "properties": {
                    "name": "鹤壁市",
                    "cp": [114.3787, 35.744],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ón@xVVól@¯zJ@bkl@@kVWLUVmVXbVJnnlLl¯@Xlm°bVlWb@bKVXnJ@VV°nX@@wWVklUK@knVVKmkUKUaVkWkl»nwl°lö@lXV°UVbXKV@aJw@UmkUy¯UUUaK@UL@mm@XaÇkkmWank"],
                    "encodeOffsets": [
                        [117158, 36338]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/jiang_su_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "3209",
                "properties": {
                    "name": "盐城市",
                    "cp": [120.2234, 33.5577],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n@°ĀÞ°@¦ULWKkx@bkLWb@lUlVXXJVbnUKmxXV@bm@@XLÞÜ¦XlVnmzVJ@n@²ÞôkÆÞaȰĉwnǉÜóéVÛnĊīČǉĉ@ō@KÞUlU@kklÇÈÑÑlġXɛ@UġaU@U_W@n@kaUL@VW@kKmkUV@bkbWW@bkzma@JWI@KUKUL@U¦`@XUJU@KmXw¯KXkmy@aUIWJXXmV@K¯UU@@bVL@¤VLXbV@@JVXVK@JVn@bkKmakVVXUVVVlI@`U@nzVVb@¤n@@UlKXLVVI@V@nV@V@ÈUx@óVōkÅWó@mU@bk@Ýwk@WbXxm@@J@zV@kVbVnLWVUXWUXUWLU@Wl°z@VkxU@UVWIxWJkbĬnW@@bUl"],
                    "encodeOffsets": [
                        [122344, 34504]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3203",
                "properties": {
                    "name": "徐州市",
                    "cp": [117.5208, 34.3268],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XKVX@WnIVx@K°Lnll@@I°KnVaU°x²mlx@VanU@ak@akmV@@w@Ua@aUwVwUw@w@UK@£kaĉlóIÇVk±@@kUKmVkIkxW@Ua¯UUm@UVI@WVIJV@@Um@UanaU@mI@J@XV@XaVlkXVaUUWLUyVIXmWak@XkJókJUL@KWkk@ULU@WalUIkJmImkVbV@lV°kXUKWKULUmb@VUlVnb@VV@IVKUUmU@ak@@bmV@xklUU@UKmV@nJVbkXKUamLUJ¯UUVmIbVVLl`@LLU`m@kXUVU@VlxUK@xkIWbUKx@VkVVnb¯@@U@xkmbkLÇKb@@XnJ@LmVkl@@XlUVkxakVVb@bVnUbU@@xVUVb@nIĊ`XVVôJ_K@xlU²KlkU@VaVVÈm@kVUVmnamUUaVXIVJ@ç@¥nkVLn@@XVK@VUX@JVUV@UnVJVLUJVLUVlnIbKnU@m°VanI@anVKVLanlKblKÞk@¦@¤@VKnLVKLKVzlWLX@VmV@VbnU°@UalkWXLVUKWkUUW@£Wa"],
                    "encodeOffsets": [
                        [121005, 35213]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3206",
                "properties": {
                    "name": "南通市",
                    "cp": [121.1023, 32.1625],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VJ@bnzWl°LxnW@LVVI@W_V¥@VKVL@LXJI@nbly@aXXla@aVUnllLX@@UVKlb@@mXV`V@bĢlkČÇÆȘ¯wnĕVĉVÿUƒUĠŦğlXÑVǵ@±ōLʵĖ¯lÇbÝÞ¯xk@Çkķén¯@ğġƴǫ@kVVlUbL@xULÇóLUl¤@nkVV°VLkxVb@laUXUKWĖklVX@¤UUkb"],
                    "encodeOffsets": [
                        [123087, 33385]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3208",
                "properties": {
                    "name": "淮安市",
                    "cp": [118.927, 33.4039],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nźUôÒɴèl¦nĖVkbmX@xVlVL@xUb@bUJVnUxlKVLÈxmzXV@lW@XVb@bÈVxnbVIXa°LaÆVVaXUlK@aXIÆVlXKVUlIXalK@alwXLVK@¥Ý¯¯ÿ@mVk@aX@mīlaXIwXJVUV@lw@U¯ybUaUġUÅaUKVknaġm@kUm@wÆIV±nLÆwÇnUUk@ƅÝU¯JÝI¯¦Ul@b@@VVL@l@LLÅmL@b@UaVaUWmLUKV¹KLWKX¥WI@mXk@UmaUVUU@VmL@WbkIUWUmVóIkbmm@UbVLUxmJkU@bkJWbnXU`WzKUÞÈlVbLmx@kè@Æ"],
                    "encodeOffsets": [
                        [121062, 33975]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3205",
                "properties": {
                    "name": "苏州市",
                    "cp": [120.6519, 31.3989],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôèĊVnX°¤²lxƒÈÜ@²x@J@b@X`nIUÆUUV@bl@VVnL@L@xJ@X@blJXnW@@`XbWkV@UbVxXUxkV@LóxVbUVW²VJĸklUǬ@ĢƳĠ°@mƒī°»ÈÇ¥ULUU±a@bU@¯U@KnImUVWUkmXUVU@lIVaUUVWKUbUkWKU¥n£WakJUkULK¯LKkVIn@VaUVUUUkVk@U@amUkJ@UUlwX¥W@@UkVmk@JUakL@kk¯ÝmJUn@nmVXlmbVVkn@UJ@±WUxV¯a¯KōbÅ¼ÇxUxUUlWL"],
                    "encodeOffsets": [
                        [122794, 31917]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3213",
                "properties": {
                    "name": "宿迁市",
                    "cp": [118.5535, 33.7775],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XbWnUJVzXKVVUbWklUWbU@@W@IJ@nVmbVbn@@V@UIUJ@XUJ@VVn°VVbX@lwlJnUVL@l²@lÈUôJĊklb@¤VL@@xVxUxVx@bVb@@xU@lnmnXmXLVmV@X@lxVnVJôLLXax@b@@KVL@bn@@m@@alLUUVaU¥nIV±I@mXI@aWWXU@LlUXWW_XWmaUwÇ@aaWUX@@kWUynÇwUKkLVwUmVI@aVa@wUKUk@wWnlaUmĕk¥ɳçóÑŹVmmzkVmm@a@Iók@@LWU@`WbXLWlkImJVn@`nXVbXmL@Vn@l@nUVl°Xx°U@LVĠ@z°@¦UV@Xn@VJmV"],
                    "encodeOffsets": [
                        [121005, 34560]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3207",
                "properties": {
                    "name": "连云港市",
                    "cp": [119.1248, 34.552],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@lzXxmÆV@@¦@l`XnlKXXmKnLlab@xmbm@kL@V@Vl@@VUXJXmb@@°Æ@èÈzlW°XĢJlÈ`lInbWV_@m@UUķnôw°ÆmnaVVÛVmĸ»Ģw±Ý@@mUInyUmWkÛ¥ÝK@Wn@@aWUnwVLmUaWIUWVk@kkJUVWLUkÅWJ@bkLWVUbÅUb¯KWbUJWXX`WXkV@KWVXX@bWJ@nJU²mJV¦UbVVkK@b@@nm@@aUK@L@@awWbKóKUIUmkwW@U@UnWKnmWn@bl@bmVUb@kw±n¯wVUb"],
                    "encodeOffsets": [
                        [121253, 35264]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3210",
                "properties": {
                    "name": "扬州市",
                    "cp": [119.4653, 32.8162],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VUXblVVVb@xV@kzV@lwVLUbVV@VU@VbUblb@nkĶ°IÞV@ƆVlmVÈÅxmKU²ÅJ@xVn@lĢnmbUlVLÆbĢVVbVaXk@VXKVVWXVWXUmKUaWaU@¥@£XWUUV@@ynam_VWkUVUna@ÆV@mnkWmXkWUW@k@@akkllWUI@UnKl¥I@VVma@a@I@U@a@anK@UmK@ÅVUnJlkI@aVwka@mVIUW@UWL@WÅbmIULkaUWUxkLUKWlXL@VImÅVUmĉLUól¯I±l@ÒUbVbUVVXUJUnVV@lnbl@"],
                    "encodeOffsets": [
                        [121928, 33244]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3201",
                "properties": {
                    "name": "南京市",
                    "cp": [118.8062, 31.9208],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@k@ma@kUUVmVIUWVUUaVa@Ñ²k°Jôk@Wmk¯KmX¯aUakKWU@XULXaV@@mUaVUUl@VmkaUXm@WUUna°IlmVmIUW@Uk@@aV@VVX@VI°»nmU@VKVan@m»UaU@U_@WlIUaaVaUala@¯n@kaUkUUWKU@mwkUUmmL@K@LmUUVKVÅImUJVkVVLèVLVU@WLV@nVÜULVUL@bW@XbWbkJUUVUxVXmVk@WUUkVmIV@nbnVWbJUkUULa@Jma@XkK@VVL@L@JLUVU@V¼nXlbm@kbUKmn@lVb@VXXVUV@b@LVbÆxXbl@@lV@UVV@XVK²VlI`UbVbUlVVn@WXn@@VUV@@KmbVLXÒLkKV@nX@VVUV@bnVllbmnbIWVXU@`lLlknVnmlLlbUmVInK°nUU@l@VU@Vn@@alI`VIXaVaVa"],
                    "encodeOffsets": [
                        [121928, 33244]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3212",
                "properties": {
                    "name": "泰州市",
                    "cp": [120.0586, 32.5525],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lUU@@y@In@WwXal@Þxl@@anVô@ÆXlŎôU@Vw@ÇUU@@m@UJUUWKkL@Vm@@£aUUmyV@@_kJUUVUUWlUnblL@aUmI@ULUW@IU@WaUK@£UK@aV@°V@LnUWWXIlaVV@£UWlkXĕVLVWb@kUalwUKU¯lU@mk£VôKÈVK@wKVaUkķlUI±ğ¥ÝUŹ¯ôm¦ĸ@XXK@VVXUJ@nlbUx@blJkmIUV@ÆnL@VmL@b@b@V@J@bnbU@UJk¦mL@VVJkXkll@b@@lXXVWlXnml@nÅU@mbUVlVUXn`mb@zU@VVWX@¤¦V@Xb"],
                    "encodeOffsets": [
                        [122592, 34015]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3202",
                "properties": {
                    "name": "无锡市",
                    "cp": [120.3442, 31.5527],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nLÒlxUVkLam@kVWUULUxVVVbUV@bVLUnnźÞVĠ¦XVUUaôw@KlUVwWUwVa@lUXWa@_X@WmkI@a@WI@w@KmKUUk@@aVUVVÅmJ_@W@a@I±wÛ@ƑÇkw±¯£mWĉUóçK¯VkUWK@XkV¯UWabmUaUUblln@b@xbXWX`@VxUblL@bn@Vb@`m@XbWnn@l¤n@xnVlUVLÆWkV@VbÞJ_nl@nKVU@aUU@mVk°WVLUV¯bVXbXlVn@VmL@xV@bl@nW@X@VVJ@²VJVU"],
                    "encodeOffsets": [
                        [123064, 32513]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3204",
                "properties": {
                    "name": "常州市",
                    "cp": [119.4543, 31.5582],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@LnxUbVVL@xnnWnn@VVXn@yImx°La¥n@VkKVwW@nXVJ@b@UVn@UnUV@Lb@`VLklVÞnÆ@VaXLlÈJmmVUK@aVUUaUUVwVKXVlUn@blKVUkwÑmKUVUI@±UI@U@WmX@k@aU@wnK@UUmWkaWU°aVUUK¯XUl@nVV@bUVmLk@m`ÝIUaU@lÅXUKkVmU@wmk£m@XmWan@@_Uam@@akKVaUw@W_XWa@w@akmm@mL@UJmnUK@@XnJWLkKUb@VxkWLaWVUImVULUK@L@lkLVVVllbm@@°kbVbUbbVbkJ@XV`V@Vbn¼"],
                    "encodeOffsets": [
                        [122097, 32389]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3211",
                "properties": {
                    "name": "镇江市",
                    "cp": [119.4763, 31.9702],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VĊKnVÆUnJ@UWKXkVLlKVwXVlbVKnJÆaķn¥°óÇIkWKUbÅ@mUÝlkUK@_a@KVUVm@mVU@@aUIW@mXUxLUlm@¦bK¯nwJzm@UW@UmmXmm@wKUUVamwKm@UbUL@Vmn¯¼JUW@UUU@@bl@@VVXJnnUk¯JmbVVXn@VWlbUnk@VVUVb@nU@WbKWV@XVlLVb°bnW°Lnl@X"],
                    "encodeOffsets": [
                        [122097, 32997]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/hu_nan_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "4312",
                "properties": {
                    "name": "怀化市",
                    "cp": [109.9512, 27.4438],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@n@b@XnJ@k°x@aVUnlUXnV@@VnJWUJVnIVV°UbVVVL@²LUVa°V@aV@nmUXblLXWVXVmVLVK@an_`@X@l°VlXXW`nX@Jmn@b@nV@Lm`bUbn@VUVl@nIVbUlV@LkJUnVV@xVblVUbU@zUKU@mx@xUnn@@WV@lbUb@nVWXXV@VIV@VUnJ@VUz@JWbXllI@VXVVL@Vn@Wlb@lXVlLaV@VJ@XX`kVwVl@bkbUlVXIlnLVamVwV@@nV@XaVJVbX@lwV@n@nV@VWnIVVUÆ@Xxa@IUUKmk@mVIXmWUVJnUVU@anaVwkU@UXa@W@m_@a¯@@K@UVbnK@blIlbXa@WW_n@VU@¯bmyUkUJÇÅ@WU@kWKÅwnm°KVkmankVWnXVWV@UwXkV@mUlLnaVaX@VUn@VnVK@xlnXWU@a@@klakVwmUaV@wmIÛ`m@mVUXmlIXVI@K@aU@UaV_UK@wkUmmUKWXmVkUL@mU_nK@aVU@Ukak»@U@ymU¯UUVKkam@nka@mwkLWb¯mka_VaVKUIUw@kKmU@WK@UnmaULkU@wUalWV¹U@@WUI@WU@_@W@U@mU@WbbUK@Um@@UmbUwWWkk@WUa@anUUwlWUwUU@wlJVUnnV@@mnI@mK@U@wa@wUm@_mVUUaVUk_kċUkVWL@mlU@kn¥W@UwUWV@VÝU@lXLWVUbVLXlVIlknmU@VUJk@@@kVmwmVkxU@@XmVUb@xnKVLl@VxUxkIU`@bWVXX@JWL@bkb¤@bmUUU¯Kkmb@VVUVVn@@Vb@`lnxmblUnbk@xUmV@bmWbUV@VJIl@nVUbK@nn@VbnJVIlJVkXJ@X@lmx@bnnWVXJWXU@UlU@mk@@llb°xIUbnJ@VWbXVmI@JVX@bk@bWL@JUXUK@U@U`n@@Xm@XVW@@nX@@`ImxU@@JUI@KLmK@UÅUUV@VW@¯kUU@UamVUUmJ@nxmLKkmJkwkKm_mKXU@aU@b@Wk@ma@zUJVUmbUlU@xnXlWlXXblK¤V@@nUVVLkVl@Xb@VVKnXKVx@znW@X@@lVK@X@JXbWbnn@JUamLVVXIVxnK@aWUX@x@VnI@WlI@anVIVxkl@lbXXxVVVJVInbV@@ln¦ml@XXVWbkJWb", "@@XLVKVXVKUa@UUUmV@l"],
                    "encodeOffsets": [
                        [112050, 28384],
                        [112174, 27394]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4311",
                "properties": {
                    "name": "永州市",
                    "cp": [111.709, 25.752],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lxUXVlXUVnlVĢJVbUXVJV@XUW¯VIUK@klW@Un@nl@V`XUVL@l@Vx@XXW`UnUbxUlVnUVlb@VnJUVVVInJlUVnwVklKnwLVJVV@nIV@nbVa@KVVVUUaKV_nVVJ@_VWnV@n¥lI@anl¥X_VKlwVlULUVVV@U@VXL@IUmn@VU@wmKXUWU@m²l@VIXWWkWUkWlkIVamUXamUnmWUU@@UnlK@XJl@kVUk@mWKXkl@@aVU@UVWUUVaIn`VUVLnw@U@K@U@w@UVmUU°K@UnV@bV@Xk@KVm@amkaU£VWUUmUUwm`UbULkaKXU@kVmU@aV_UWVIn@yXXK@klmVV_kWVUn@WUU@UmaU@wnwWanUmmXkam@UakLmK@bxUUUU@Km¥Va¯@kUaVUlmUU@mUUÇmUkUybbUaXUWWbÅLmL@VaL@WWXUKmmk@a@UUKXW¥kU@VUkxmVkUWbUJnVJ@nVJXzWxk@lVbUX@VVL@`mbUnUnVV¼k@Ulm@mwLb@lmLUK@UamWkK@£Ua@UkJkUmbVlkX@bWbUVnnUVl@bbVK@VX@lbV@nU¤x²Knblb@xVô@l@b@l@XWxnVl@VV@XLVlLUUXV`bXXmJU@@bm@UUkLW@UlUKWUUbwUmL@nklVVmVXXm@@bUKlÆnXkllVUVVL@nUbV@V@nnV@xUn¯U@JW@UX@xĉ@`m@@LV@b"],
                    "encodeOffsets": [
                        [113671, 26989]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4305",
                "properties": {
                    "name": "邵阳市",
                    "cp": [110.9619, 26.8121],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XIlJIVVK@n@VVVKnLVwVmnLVK@U@wJ@wVIÆ°X@ÜÈUÈxll@kn@VwVaXJWXn@@WVL@UUKVKV_U@@aVKx@UaV@lk@XylbUaV_Vnal@WU@aI@aV@@aVUl@XmUXWaXml@@kk@ma@V_UnUVUUWJUa@kkaWLUmk@@LUVWUkJWkK@¼UnWJIkV@b@JUIm@UlVm@Uw@a@kWXWKUknW@WUU@kmxUkVmIUJUUVmI@UkaUVUmVkwVaVmX_WW@Uw@@kUKWVU_k@mm@@VkX@lVLUJX°WVU@UIVWUaIUġmkVUkWUVWkwWXk`mI@¥kUVUUn±@mXkWknVUVmmU@@XVUk`@Xk@¥¯»mbĉó@mkU@kUKmX@UnmL@lULkKUWUU@bUaUn@Vb@l¦Ub@l@UKmnKUnlUVVbUVn@`Vn@xb@x@VL@nmJ@nU@mmUVkI@xVVVxkXVxmV@bbXVl@XlXVxna@Vn@@VVLaXaV@n@@V@X`V@@XVJ@XV@UºkXVb@xlVVKnbm@VXLV@nlL@VxJVULUb`lb°nXalKnx@lbmn@lbULVV°nV@z@Vl¼lb@VUV@bmLV`@nKlVnUXWVLnnlV@xVLU`VbV@"],
                    "encodeOffsets": [
                        [113535, 28322]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4310",
                "properties": {
                    "name": "郴州市",
                    "cp": [113.2361, 25.8673],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@²zVaVlnVl@nVkJl_XJlIVmnL@mV@VXn@lV@XzV@lyV¯²U@UlJ@XVKnVVIXl@UVLV`@n@JI@mlIKVLnUlVUVVLXaKVLl@nb@WXV°KUnVVL@xVJL@b@LUVVVUVXbmbVbn@@lUbm@x@XVVV@@@bkImx@Vm@Xbb@l°XU¤aLmnL@bl@@VUX@VxnVanLnW¥XKVwnUWXmVIUWÆLVxLw@wVmlU@¥XWUkwlÇn_UwWV@VU°wnUy@aVkVlnL@lVnw@VlJ@bXx@bVKnb@U@WVUl@@Vnbl@XLlK@aVLVKnxÞn@aLlmUaVUm@ÅknUmaUKmVk@mkk@UlWUkVm@w@kUU@WU¯¥@wÇ@aVIlUV@kUWU@UUm»@k@mKVkUKUwaUaUa@kkUWJkImaU@UK@maUzk`@zy@XmJkL@UUJmUkV@z@kkVmK@¦UbWL@a@UbmKmwUKXkVUUkmVkw@UUKmL@WUIWaJW_k@@WmI@mk@WkWULUUVKUUVm@Ub@nUÇ@U@wV@Ua@aL@akl@kUJwó@@L@V@`@J@xnnmV@bkJmUó@nJWUUmU@UV@LkWlnnmVXbmxxV@nbVV@XVm@UVlXU`Ukn@lWLWzm@UJVXU`@bVUn@lWVLlbVKVan_VxnVVVUXV¤bnl@bUn@LWlU@@amU@V¯LVVUn@V@x@V@L@VmxUKUVm_JUbVV"],
                    "encodeOffsets": [
                        [114930, 26747]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4307",
                "properties": {
                    "name": "常德市",
                    "cp": [111.4014, 29.2676],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lUmkUwUyV@VW@¯VaVmUU@KVUVUVLnaWnkUÓV_@mVU@Ýw@ka@kVmUmK@IkaUamKkXWaUW@WUk@@KVU@aU@L@J@XÇVUKVak_mWkLWakVUbmLUUmlUVKUU@kUWW@UImJ@xkLkKm@@X@óÝ@UUk@UKVULKXkWWbkaIUWU@mUk@WLaUJġ@@XÈÆVIlVnz°aV@Um@X`@XWbkakJ@amLaU@V@L°@@bn`@@XWb@VVlUxmb@bUVmVUIXVWnJU@nnlVLV@JbWzk`m@UVK²VxkLVl@Vn@V°xVKVkVVlUblx@bUÆ@@nVnUllkx@VW@@VkLWxUL@bÝ@kKkVõV@bkXVVUV@VkUkVLkVa@@¯xUxmX@JVb°WXkK@Vm@kVbbn¤xUXkJblxnXÆK²l_@Wnan@UL@bJnIlV@lU@@¯ô@lWȂIVKVmU@aXaV@lwVXn@@K@UVKUUnUbn@lWXlJnULKV@l@²a@UlK@aV@naVXWV_nKlL@KUm@a°U°@VXL@a@wWmXal@k@VLnV@@bl@VnX@mwVa²aVU@mk@"],
                    "encodeOffsets": [
                        [114976, 30201]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4331",
                "properties": {
                    "name": "湘西土家族苗族自治州",
                    "cp": [109.7864, 28.6743],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@KL@wnK±nnm@WUkÜÈn@n»@mVamkmUl@VnmmU@wUan¯VKLnVWlInyWUI@WWk@KXUn@mnUmU@WmkV@kXaaVaUmIk@kaX@Um@UKWU@UkJWkXa@IVy@UmIUVU@UJU@WXWmU@VakaU@@Xm@Vm@wnwV@VLyV@VakUUa@wUUVmlI@KUVkUamJk@VU@UmVaan_@KmU@@anm@ImWX_WWUk¯@k@W_m`@bULUKUnUWWXkKWaVmnU@@b¯UUbV±K@UKUUVa¯UUmJUVIXmI@UU@WmVmkUV@b¯w@lmI@W@a@m¯LXbmJVLklWL@V@XXmbVVU@@VU²Ul@VlX@b`XxzUmkUVÒl@bXLWxXVl@VbkLma@nmVmULVbmVUb@lnzmbUÒVl@°nLVlJkn@bmJk_VmmkblxÈx@LUbxVb@Vn@JmLVU@nV@¦VbnJ@lVVbkxbm@UxVLV@n`UnVVVkl°zxVb@VU@@ÆlXnWm¦nbVK@XVVUVVl@XKUV@nVL@WnIWXLVKVLlxUbVKXVWbn@@UnKVLVbJU@aVU°b"],
                    "encodeOffsets": [
                        [112354, 30325]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4304",
                "properties": {
                    "name": "衡阳市",
                    "cp": [112.4121, 26.7902],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lV@XV@mXVlXLWX@l@bVxn@UVkn@VJ@I@alUJXIVm@»LXllIXVVU@Kl@VnXKlb@lVbXIVVUmVVU`@nbl@@lXLVVVKVbnXWJ@VXbWxXbUlVK¦nLVVUVVbbK@ULnK@Un@VxlUV`UnnL@VVL@JV@VUnxnKVbV@@VIVUnJUVUl@nWXllIUaKVbÞLV¼²`V@VIUwlaVmXa@IWanK@U@mkVVUVaX@lnaVLÈ@¥@kkJUWJUaXkaUmwVXJ@_lWUU@¥n_KkamUK@amKnKbV£¯W@kaWan@@UnwlJ@a@@UUU@Wwn@Va@km@UanaWaUVUUVU@K@aKUI@wKUUVm¯LWUX@mak@UKLWbUKVUkUmVUKLkJ@nJ@I@mU_UK@VWkUJmUUL@WkI@V±VU°kzU@Wy@kUm@UWU@@nmKUnkJWIk`IUlmk@mUUkUb±yUX@VUV@bk@WlXL@nVlUlk@WI@kLm@VV@XVmnnVWbnVUblJXkVlXXlWXUJk@±@nXVWVnL@xUVm@Vn@JWK@UV@UUVUVKUkkxULW`k¦m@bkJm¦U@mUX@`UImUU`LVbUVUU@LUbmaU@mJU@UUIKmxkLUl"],
                    "encodeOffsets": [
                        [114222, 27484]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4306",
                "properties": {
                    "name": "岳阳市",
                    "cp": [113.2361, 29.1357],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@wUklmUUmU@@UVm@wUaV_mmUKmwkIkJmUUnm@@UUbUKUmÛamm¯xVLkbÇÆUVUzkVUlUUKWLX¦W@VUUUaKUbmLKm@akU@amVaUUVIVWkk@wk@@xmLlmÅwmbVlXlÝIWVkK@kkVL@VWKU@Ublnam@b@bnW`@XUJk@UUWKk@UKnn@xmLUVm@kbVbVnV@Vb@KnVLWXÆVĢ¦VblnUJWz@ÆVóUVbkVaÅx@¦lVUbVVknWKk@wKVUÅl@zkb@`m_mJ@xXmbVb@llV@n@llbXLUXalUlalVnwnLVKlVbX@@IV@blJ@bVL@VVVUXÈ¤VnkVÑXmlbnVKkÑÅ@UmaVç@±XUlIxlV@VaX¯lUVVUVJnV@°°n°Vxĸł°¦b²¦lJ@U@aUK@kUm@_m±VIXal@Kl@bV@KK@km@UmUUaK@_UJaXU@Xm_VmUk@WUk@kU@a@m@UaUUU@al@nyXXWWwkly@¯n@@bnV@k@mVIVlUUmlUJUwIbXVaUal@Kb@VKVkXVl@VkUU@ylUVVaVL"],
                    "encodeOffsets": [
                        [116888, 29526]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4309",
                "properties": {
                    "name": "益阳市",
                    "cp": [111.731, 28.3832],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÆxXL@lV@ĢVIbXKl@nVV@XVJlbXalXWLVKUVLl@VV@ôÞ@@Wn@lLlK@wnIVJX@VX@lVVULVnkVVnKValUXblKnXl`UbVLÈU@W@IKV@@bUV@L@lXV@VXXblWnLVblb@JnLVUn@llb@x@ÞUV@nU`VÔmlXmbUKUVUV@LVVUnUb@°UX@UVzVxnlVkVnlVnaW@wnIn`@_la@ykÆVULxl@XLlmUUVakU@¥ÆwblUUaôVU@ÅXyVImkUaġ¥ÅUWXKmU@La@UmUUUalan@VUnK@wmmL@VlXLVVl@VI@WX_m@a¯mKUkwW¥UK@_UWWLUVkUWL@WUIkVU@JwkLUUmJVI@WkXm@VmkKUIU@mmm_@VUV@kJċwUU@KUWkkW@IWW@km@klwkWVkkUV¯m@kWLU`mIkmkXm@@`@L@xUKWkU@VL@JUU@mbUKVa¯WVnL@`lXUVkU@xW@UbUWVU@UJ@lnU@mnÈmVa@bULwUb@@VkxmUUUVK@IUmk@akm@wmIkK@bVWXkm@wULUmm@UVW@UbmbkKVnU@WlxVU@UXmWUXmlnbUl¯Lmn"],
                    "encodeOffsets": [
                        [113378, 28981]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4301",
                "properties": {
                    "name": "长沙市",
                    "cp": [113.0823, 28.2568],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lVUllXkx@lln@XX@JlXXlV@LVVČxlI@VU@Un`nnV@VJlLUnn@lW@XUJnIVVlKx@IVlUVJ@XXKlVVUXKVX@`VLX¦lxVnL°an@bkmVaV@XL@UKlU@llLXUÞJWkUknaÆxnknK@w@l@xllUXUJVVUbn@blV@bnLnKVaLVbVVUX@W¥XKVLVVklUVyUVÈÅlaUK°wnnÜbnVVLaVV@n@VmnVlIlJna@Valkn@na@amwm@UXwK@aUUVUUaVawWK@kU@UaW@kKUU@kW¯XWan@kmmÅ@@I@U@KmLkaVUKkLWVUk@UVmU@am@kkk¥UVUKmaUb@UbI@aKkkWm@W¯K¯b@VmaULVxUXlVk@UxVJVbUb@xUL@ULWWLĕmxVVL@VbKUwaÅ²WwX@@WUWLU@VbkV@aU@@VUnmJ@VUn@VLUK@UmUIk@UÇmU@@UW@J@LbUmVI@aUmW@@bkXUx@lmLUbm@UbkJ@V@XmlUbkKm@ma@kUaVU@aUK@mImJUIkVUVUakbWwka@UWKkLUamKUXm`Å_UULmaU@@lUV@X"],
                    "encodeOffsets": [
                        [114582, 28694]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4302",
                "properties": {
                    "name": "株洲市",
                    "cp": [113.5327, 27.0319],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XUnwĖKXXVK@VK@wVaUaUIVwl@kUVWUwVKnb@U°a°LX@XnllL@bJVa@VanbVLUV@al@@UV¯ÅÇ@Ummkw@¯yVwnUVVVUkmWVnKVUa@WXkVKn@lUVUVVVXIlV°VnI@VlKnV@mwVm@LXKWkU¥wWw@k@mX@KX¯V@VUVa@VnKWkV@VUkm@aWa@wkUWwkmV£VÿXUVL@mVIXaò@nW@aU@@am@aUUUmXmWUk@nUW@_maVmwUkamaUL@awW@akI@UxUm@kmKUklU@bzVm¯xUVU@XVxm`kÈlxXVW@¦kVUn@xxKUwÅKVXUJWnXmVUxWL¦XmmKbmUUwW@UV@k@VLnlbLm`@¦VVkX@`WIUxVnlbWVbXIVlI@l¦Ç@UKmbkW@UbUVUl@n@VmLXb@JWbUnkbVxUJUxWXXlWL@V@V@XXJWxzUVVVVKnXW`@bkIUlnLVJUbUIWVXlWV@XklVbnn@xl"],
                    "encodeOffsets": [
                        [115774, 28587]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4308",
                "properties": {
                    "name": "张家界市",
                    "cp": [110.5115, 29.328],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@InWVw°w@@blUKlUlVU@VUUUlW@aöUlUlLÞ@@aVKXwlK@UX@@UlwkVkUm@m@ÅV@akwVaUkUUlUL¯w@UUm@UkKlw±UULVn@l_XyWwÅ@VUUmJUXU@@mmU@kxW@UaUIWbU@@mU@UxnUbmKkWJkUVal@aUkUxlW_@WUIU@bkKWUJVnUbbWblU@nl@XnVmV@nmWV@LXl@XJXVmzkJUXmKULm°Vb@xnVmnUk@VnnlUb@nm¼m@ÛÇVl@Xmnm²mL@xK@LUl@nULÆx@V@VXVWbXXl@nLlm@bVKXWL°bnU@VaVU@mVwJnwVK°zn@VVba@Ċ¼"],
                    "encodeOffsets": [
                        [113288, 30471]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4313",
                "properties": {
                    "name": "娄底市",
                    "cp": [111.6431, 27.7185],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lLnJ@xln@bnlV@JLVUVnVlw@U@VaxVK@abnUmÇnV@km@I@VUVVXVaX@@wlVVUkW@_mKXU°UbVLnaV@V@IUKV@XlVL@w@K@_n@lWlnnJV_XK@l°nU@WVU@kV@nbVKVl@nLlLXU@lmkw@nW@UKVa¯IVn@@aVUUKl@nXVKVn²aXblKnLlmVI@KUU@akLUaVaUXm@a@wVUVKnLnWlXln@@U@anUVm@UInm@IUK@UmKVmU_kVUwm@@VmLK@VLaUaVUUUmK¥ULkVWaXwWa@UXImWUaULUUWKk@WnXbWVWnk@UV@bU@@bJ@bV@XkmbUU`VbkaWz@klU@b@VwUL@bV@U`ULVL@VUK@Xm@XWWIUbUxm@@lkkÇwVÛÇW@¯ÅUJ@xIx@@VULmKUnUxmKULUUm@@ULUJkIWJ@b@LJUWkJWnUV@nnÜ_nJxU@VbnUxlkb@l@"],
                    "encodeOffsets": [
                        [113682, 28699]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4303",
                "properties": {
                    "name": "湘潭市",
                    "cp": [112.5439, 27.7075],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Æ`n_VWnLVblKXL@VlbXxlaVbUVlUVJnInJ@VL@bUVVb@lnbn@lLVank@W@UlIVan@VanK@kVwlW@aX@Vn@bUJVna@KIX@@VV@nVÈl@VJn@VVLK@UVm@UnIVm@UV@@blUUaV@XKV@XW@XxÆ±bVxLUa@UKWk@wmmUalk@WXUWkXUVJVaUImKVklJ@aX_mWULUUVUyXwWI@W@U@UXKWkXWVwU@±_U»ÝKUaLVbkJkWmXk@UVVmIUVJ@UU@UamLmwUVU@mnJ@VUnmV@b@Vm@kkWmXmKULUV@x@bWnVUbVblK@bVV@LUJknmKkLWa±bUmULmWk@VLUV@bm@U°JUbVLX@@mlxkn@WVKkmK@k"],
                    "encodeOffsets": [
                        [114683, 28576]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/jiang_xi_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "3607",
                "properties": {
                    "name": "赣州市",
                    "cp": [115.2795, 25.8124],
                    "childNum": 18
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@`l@Èbln@KVLl@V@bÈlnKXkVlVL@lJnb¦VKVVnXW@w°@VUmlnUV`UbVUV@xnKVI°KXKVkVL@al@XaLVlULWVVVL@bx@VXVmb@x@VVV@nn¤lb°b°KXXWbX`lbXxz@x`VIVUnKLxWXLVKVbVLVU@wnW°b@nalXmXVJn@U²mKkVlU@@xlnaVmlKn@JVLlnVl@XXÆèVlUX@xVLXVb°W@wnUWmXk@KLVwUmUkUKUw@wVaVK@k@WnkUKWkwlmXL@KVUlLVKXmWUL@aL@malaVk@aaanX@VVUblbJnXaVwn£K@UWmUk@UaWIV@bJW@KmmU@aUUUkmKkVKlUUnKVUlVaV£Å¥WUUK@UkUUw@m@mIkUUWLK¯Uw°¯@wUKUbKm@kkKUL@UUKV¥U@manw@k@U@Wm@@U@WwkmwWaUU@UUmV¯kw@@kmkKkUW@UK@ÅV@XWWkXa@Ul@Va@KVaUUU@aXwla@UkVWaXk@K@lmkUmV@Vmbk@»XI¥VUkVUVU@anKVUKUalU@wX@@a@K@ÝwL@UnÇlUIkJmn@bVVb@VmnkLV¯U@±lIWm@kaUI@aÇU@K@KUIkbWbJUIUyX¯UbU@méUUmUkWKxWIkJm@V¥U_UJUwmVkUU@@knwm@UmkWJkL@n@VW@@U@knm@kUml@xÅx@@XUJlb@VXJVxn@lbV@lULnV@VlnV@bWV@bXL@lVLVbV@blLn@VlK@xln@bX@laLVbnKUVVbKlXVVkxV@nnVUblV@@z°WWkbIkWL@LUJ@bUI@b`@UmI@mkK¯XWmUV¯@UUVUUam@@VULWUJIm`IUJKUkW@UxnWbnnmlXbmIUVmV@Vnb@VLUKWLnÒVVV@VUL@kJUV@bÈ@V°@XVV@l@xUz"],
                    "encodeOffsets": [
                        [116753, 26596]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3608",
                "properties": {
                    "name": "吉安市",
                    "cp": [114.884, 26.9659],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lxnb@V@bV@ln@nlIn@blVXKnk¼@VUKWL@bL@`UXU`@V¦XLĠ@lJ¦@nV@l°nn@mVXna@nbKn@lIV@VanJ@_lKVVnL@LK@Vn@VbUVanKlLnbnJVbnWVnVVanI@Vb@LbVKVanXVbVJVU@aXLllbôlÆ¼XxVLVK@Xn@xnVVVmb@LnVVKVXV@@mnaVXUVnVK@_UaUmwnKV_anKVL»K@¯ÝU@U@kWlUnlknKVnaUkma@UIUwl»Åw@VwV@nn@ÈXlKVmna@kVw@anm@n_WWk@mUkUK@ImkLUnbkm@wV@klUnLV±m@UInWkWmb@¯amX@xUVUKUaULWKXwKmLUVUJ_@wyWwkaW_XaWW¯L¯akam£@mUU@U@wnaWU@Uw@aUKUXUVKUkKWbk@@bUKUlWL¯LUJmLwU@UVaVU_VkmnUV¯@@xXmWUUUL¥makI@UKUkWlLkmÇ@aUk@UKL@kmÇak@_VlkL@`lbnlLVanLnbmVÆln@kJlbknmKUbÝmmwULUK@bkLWKULUUma@Kk@UV@L@llbVzxUxnl@bVLm@IVJXVlLV`@bn²@J@V@Xmbñ@WbUJ@bm@@LUĬU¦lV@xXb@blnUV"],
                    "encodeOffsets": [
                        [116652, 27608]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3611",
                "properties": {
                    "name": "上饶市",
                    "cp": [117.8613, 28.7292],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@VI°`nm¤²@bVJUVVXUl@Vmb@xV@XbmVV@lkLmbn`VbnU@VaUnbVllUXVa@w°VW@_VWLnVlbLVbnlKnVK@IUW@_@am@ÑUólK@U@WU@VwU@UI@aUUaX@kwmJV@yX@kan@mkwVmmI@aUU@aUUW@kVkV@@anK»XVWnIVUl`@_W@wlUV@UWKnUbn°InJlUV@VnIbWn@VklL@l@Vn²m@U`kI@bWJnV@°VXnJmXVmx@VVL@bkLmWULUmU@bWXb@llnX@xkxVVnVV@¤nLnVxnJVXX@bn`VIb@blmlLnaV@blWXnlUnbl@KVanUVmm_XK@kWWnaU@UnaWUXaXamUkKmXUWLX¯WakKmnUWwXa@KW_aXWW_@WnIVl@XULnWVknK@ImyUUÆbXKÛ@W@IÆUnVÝlkVK@mUIVwkUVaUm@aVIVyXIaÈwmmk@UnanVUmÅaó»lwW@kkUVmUK@WKLUmWULkamKLk@Wa@wk@UU@U@mbUIWVKUXWmkUmVmU@LkakKw@w@U¯UUn¯l@bmn@xkJWxkL@VkI@mkmJUI@V@b@VVxnbWlkÈkVLbkKmVL@V@²nxWkLUL@xlKVxbXmVnWJ@Þ°@nxUKUw±`UImVmnU@kalm@akwU@UUJmxU@@U@kU@Um@@KnVm@kKmkU@@WUnkLWxkVUwmKmLkUbmKUbV@xUnkJ@n±UxVXUWJ@LUblUnm@W@nknUJUVm@kXllknVbÆKVVb¼V@Ul"],
                    "encodeOffsets": [
                        [119194, 29751]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3604",
                "properties": {
                    "name": "九江市",
                    "cp": [115.4224, 29.3774],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WUkVUkmaVUb@mVUam_nalK@kUnUWaU@@wna@UVkUWVUUI@a±n£m¯_JU@ĉ¦Ul@UVKmmLlm@ğ¹m`Uk¯@@UVK¯@UUK@amkmKkVVUa@UkUKUaL@VVXUJ@n@WUbnVb¯V@LÅlÝIJÅkÝm@UaWUU@UmUXmmwVUUKWUX±mUam@kWzUaVmÇw@aÅLmKXUWKkL@W¯IwVwlkUJ@Um@ÛÈWKUxWkaUU@KkLVl@UKUX±KUb@nVVUbUVmaUlUL@aUL@@nUlWzX`@V@lx²@Vlb@bVÞ@°nl@UxVL@lUbVV@n²xVUVmnUÞbaJ@IV°xnbl@nbÆ@VwnK@VnXlK°xnUlVXV@Vl@L@lk@W_XK@KkWxUL@JnVx@aX@VVUaIXlmL@bVVX@VbnKa²XVWk°a@UnV¤nbmLmW@XbmJUbVLaÞKL@K@U@aVKlbV@nXlJxV@VnVÈÞKôbźĕČmV@Ċ²xÆIV@Þ¦ĸ¼ÞVlVÞnxln°JkLXWVUVUVwnJVI@yn@lXlaXmWI@w»ma@UmK@akKkXmW@_kaWakKWk@@K@IWkUa"],
                    "encodeOffsets": [
                        [119487, 30319]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3610",
                "properties": {
                    "name": "抚州市",
                    "cp": [116.4441, 27.4933],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°V°UnÜ@n@lnLlV@bV°LlnLllVzVVXlVV@@L@xX@WlXm@UVL@V@n°kVmVUnKlaXxVbnlU@lVVnaVI@aX@VJ@V@bb@Vb@X@lUL@@VlIVm@wUVanLalVnKnLVxlUXwlKVm@k@Una@mWIXKWUÛVk@a@UVWn@@kl@@WXlW@_Um@UVK@aLnalInWV@@xnI@¥Km@kKmnk@mlI¤laXbVblknV@UKXVlUXa@@Unw@±mU@ak_±a@UJUIVKW_Xa@aWUK@mmUVa@IXa@UWmannlmX¯WKXwVUVw@XUlK@klJXa@kkmm@Uww@¯W¯kw@WmbULaUUU@mVUUWmkUbKmkkK@akU¯¥Ulm@akU@m@KVIVV@KUkUVUkaUWbmIkaVaUU@mWbb@bUlkbb@nK@bKXVWnULkKUV@LWKknlxXVLml@X@lULUb@xVxVLVlVnUxK@LWlXnmV@x¯XaWUUK@wVWUkÅçm`@mn@bUx@lmbUnkLÇWm@mU@Ux@Æxk¼VxVJ@nbVlmbUmLklmkVlX@VV@°Þ"],
                    "encodeOffsets": [
                        [118508, 28396]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3609",
                "properties": {
                    "name": "宜春市",
                    "cp": [115.0159, 28.3228],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@VlbnK@b@JLlUnx±ĀXxÆWX@l@V@@blJ@nX@xUbVVUbVV@bVmnmJ@bmbm@klUbLmb@lVb@xUX@bVVVbV¤@LVVbXlVwLXÜÇn@@VIlVkUxx°J@XlKXLVWnLÆK@bÈxUnVbylXn@VbnW²XVLVVUnxWnnV@VVVXVbn@ÞÆlIÞJÆk@K°UUamVa@UUU»@wV@VkkUKUVW£U@UmW@@aXkVUnVlKVVUUkVmU@kWaUanUVVamIX¥W@@aUaUVW@_mW@UnIVVn@VbVm@bVL@anKVUkWKUXVIkx@nabVKb@nVJ_V@VwVUVVXUlUUaV@X@VblabnKlkVaXa¯@m@UKVUn@WXkW@@w@KU@UWkUUUykkmKk¯KU@akUmK@k@mmÛ¯V¯U@L¼UKmLbU`mLxVnVb@`LmUVUUWmb@nU@UWULmU@KnaUUmUwmJ¯IUJWIkVkaWVUIUlWaUIUVkKmbUIÒlVUnn@VlLUJ@bUX¯@aWVUKUXKUbm@UwKWa@a@VkUWn@Uak@mbXWJXbm@mLaWVk@wL@WmanU@knwWmkaWLKWUXaU@¥lUVVVbnw¥nKV»@aUk@a@UJ@kmLma@mbUWnm@ULÇº@LXnmxUm@UbkbW@@akLmWk@UXmJmUkV@VUXVlULmKUxkL@lmXnJ@Xl°Vnb@bU@WbKUX@VmKUX"],
                    "encodeOffsets": [
                        [116652, 28666]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3601",
                "properties": {
                    "name": "南昌市",
                    "cp": [116.0046, 28.6633],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@X@m@VIUW@UKVbLlV@VVbUlUnLnl@bVL@V°UL@V°@Vln_Ġºn@knKnLVU@VkĊ¥Vk@U»UaUÅLUalmkklWn@VUVIlm@mXn@VmkVa@KXIVUWVw²@m@U@VK@k@WUa@a@aU@IUW@@bUJmbUU@kkVmUaWwkbmLUVUnlWbUbklmLakbUaW@U@VbkVWVUUUVUx@U`UI@maULamb@lwJWUVXLlUVmL@bUK@aUnUam@UUmJ@VnX@`UXVVb@bX@W¦nJUbUmVVbXb@lVUnVlVUUkLmUUVWl@bX@VnV@X¤VUVLllUU@@x¼VV@V"],
                    "encodeOffsets": [
                        [118249, 29700]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3602",
                "properties": {
                    "name": "景德镇市",
                    "cp": [117.334, 29.3225],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VVX@VbmzxUlU@mbmL@V²xVbUVVblbX@VkVykValKVI@bn@n`lVWnX@lL@WKnVIVa@¯nK@alIXJVIVWUwn@nUnK@alI@a@anKm_aW@UWmIUwmmK@£UUmUUlwwW@km@kWaXaV@VnVKnXlK@aUK@UnwWUnmIUW@¯mUXI@alJV_n@m±@U@kkKUlm@XamJ@UVUkmI¯JmamVXL@VUkV@xX@`k_UVmJUXW¼mL@bU@UllX@VV@bVV@bnJUnlx@nmb@lW@zUnIlx@WbVV@bVJV@UxV@@X@VkLVôÒn@@b@`VX@J"],
                    "encodeOffsets": [
                        [119903, 30409]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3603",
                "properties": {
                    "name": "萍乡市",
                    "cp": [113.9282, 27.4823],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VWnL@UVWLXaV@@ama¯Uk@WmInW@klKVwnLVKUkVW@UlUnVnIVWl@nXlK@bX@laVan@VnwWm@KÈ¹VK¯m@kmU@¥kIğ@WKU¥@V_VW@_K@aXKVL@Ul»mWLkU@amkJm@kmU@@a@UmakwU@Xl@VXk`UIW¼kWWX@@lxV¦XlW@Ubn@mUkL@UmJ¯UkUWVUaUlm@UXWlnUJ@LmLUnXll@bUVUUmVUn@¦xlnn@VÆÈU°kbVVxllnL@VnVVUl@VanL"],
                    "encodeOffsets": [
                        [116652, 28666]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3606",
                "properties": {
                    "name": "鹰潭市",
                    "cp": [117.0813, 28.2349],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@XV@nlL@lUnm@Ln@@VlV@@VV@nwVI@VVlx@bknlbV@nmnUVJ_²VxVLw@m¯@ÝXImnUWaUwkL@wVKlKXmw@±@UKnUlLaKlUlÇXkmaUw@U@a@UUkwUJ@zWJw@WbkVWUL@VmUklUaWakb£kJ@nmlnlL@nL@¦mJ@wU@mXkJmbK@bUL@VVn@`kXW@Xk@@lm@UX@V@blÜUXVWLXJ@nmb@V@l"],
                    "encodeOffsets": [
                        [119599, 29025]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3605",
                "properties": {
                    "name": "新余市",
                    "cp": [114.95, 27.8174],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@m@@WULUKWwÅ»ókakkWK@bUVUIUamWUbULa@KUa@mJUbmUXUmUamImakKmLUbVUam@@UL@KKmUUkL@`mIUb@U@V@bVl@b¼UmL¦mxUaUUVk@¦VWbXVLXKlbXnmx@lmVnb@XKxl@XUbnKn@WaXIWnal@Vb@XmlV@U@bXbLVxn@VaLVWVLXUb°@VW@aVIkK@UmVmkUÑVJnalLVUVJXbVkVJXUlblUXJVI°JnI"],
                    "encodeOffsets": [
                        [118182, 28542]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/hu_bei_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "4228",
                "properties": {
                    "name": "恩施土家族苗族自治州",
                    "cp": [109.5007, 30.2563],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VKbX@lbUVnL°@VlVnUl@VUX@aVmaXlaUUU@wmaVUn@Vnmmk@mU@knaaU¥VamX_@WUmW@_kVaVKnLl@VVal@k¥@kUW@kUKVUlUVÑW@kÇaU»ValmkUVUVak@aV¯_@WUkmVUlU@aalI@akkVWUaWXUWwWVbÆ@lalIVK@Um@UUW@al²a¯UağÇm@bkk@w@@WaULmxIUb¯@U`UXJmL¯aKXWUL@aknmK@aWUXaWm@I@UÅmVU@aUV@bVI@WkUbXkm@VakwUKULWKXmJ@XUK@mL@KUwVaUI@KU@mmnmXka@»V@@UUaw¯yVk@UUVmmkÛÈU@mWUnmxmlUbV¦UlbWVUL@UUIUmÇKVVbUVVxknLUxV`VX@kJVVUXWaUVVlUnmKUbkI@WULmK@L@LVlLnmUIWV@akn`VXUJIVlUVVbUX@¤mbnLmm@UXk@mm@Uka¥@kV@@KkU@aUKWbkLWVkIVk@UbVlmX@bU@@mmL@bn`@Ln@llVLVk@XVVU@`VXU¼k`VULka@VllVIn¤VU@@blÜbkx@bkLkKn@bn@@b@JUnV`UnVbVKlVXUlbn@°Vx@@bnVbUllVn@VVK@UnW@UVUlnkVÈÞxVbVVIxVaÆ@@aka@UVaU@@ak@Wl@nbVIÆ@Jk@L@VlXnlla@VJnw@UmwXU@aVK°ÒnllnLlbxnKVaV@l¦²nVl@llLx@XVVĶ@nax@U@alXUVaLÈþV°XxWXkK@mLnlUb@bxnLVlVVkb@UJ@xWXX"],
                    "encodeOffsets": [
                        [112816, 32052]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4203",
                "properties": {
                    "name": "十堰市",
                    "cp": [110.5115, 32.3877],
                    "childNum": 9
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@@a@w@kV@nbVK@nUla@laÅl@nlVakwWX@WkLaVmwV@anK@UlIXmWkk@@mmLkWlwk@U_mKXwWK@U¯K@UU@VUakmkIyUUVUmanU@mlwk@_mWXaUWU@Ç@U@aUaVwUKUIVkK@UWIXmaV@k@Vm@UnwlUamk@V@ULUamxUJkU@I`WkkK¯XWak@@W@IUVLWJkXkaÇVUK@kUmbmUUUKbkKWUkI@kKÝ@@aUm»nI@mU@UnWV_@aUmWbkLUl¯b@akkk@WkkJm_k@UV±@J@bnU@@WÝIUJVbXL@nlJkx@Wn@VkJmbLmU`VbUL@xVn@XV@mVVnnJVbUx@VnVUbVVx@nbUK@b@bJm²VUlbXzVJVJVbn@@Xmb@V@bVJÈ@Vnkn@°aVVV@XKnalLVmUnnVKVlnLWlXXKlk°XWkLUVVV@nU@ml¯nmbk@W`Å@mbLWm¯UxnêVèk@mbVnUK@kKmXk@@JUIlÛLllnbVnlJ@LULnlÆaVLnV@nkVJ@lkô@²bÆm°wLWV@VXKVXI@W°ÆVKb°UJVIVV¦XKVL@lInaVÝnUl@@bX@nmVL@lVLlVLVUnbVW@xXnbU°¤V@a@kWKUUn@VlnL@UV@Ü»@mX@V_akaÞ@VK¯@kkW"],
                        ["@@mUkUUm@nllVKXXVK"]
                    ],
                    "encodeOffsets": [
                        [
                            [113918, 33739]
                        ],
                        [
                            [113817, 32811]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4205",
                "properties": {
                    "name": "宜昌市",
                    "cp": [111.1707, 30.7617],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°`U@blUbUVlVknUbV¼Èb@lXUÒkVUVVL@lVX@ll¦k@UbU@kmKULUbl@`nXV@XW`nUbV¦bmb@lV@nnlmnUm@UVnb@xVVVkbWnbVnVa@an@UaVUJXnWlXX@l¦@lKÆXbXV@VV@°¯°xXxXV@nV°UVWU_VWXkmaVnWVkn@lln@lb@UVLXWlnX@aXUmaVK@UXUU@WVIWXXVU@¥VK@UÞa²LlV@kV@UanKma@UVUnK@UVLXyVLknJ@UV@@UXKWUXaV@Vb@mVLnKWm@aUUm@@UkK@UlaLXKWaXI@alKlmUk@wVKXL@m@WWn@UVa@K@wna@aW_XWWkXbVW@k@U¯WWwka@UUaVIVkU@m±@U@@wVKka_@VV@XUVwU¥yUkm@V±ÈUKk»ÇLmmLk@ó£kmWwm@UIkWKXwWU@kLwkbmabkK@VLkmWIUKkUUÇIǫJXÅJULVÇLUV@UK@kI@WVI@UaWmXVVUL`±kÅLmKkkÅ@UaXXxWVXVbUXll@bkJb@bkVUVlnV@X"],
                    "encodeOffsets": [
                        [112906, 30961]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4206",
                "properties": {
                    "name": "襄樊市",
                    "cp": [111.9397, 31.9263],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@Xl@Xb°WlLXl_@JlVVInwVbVK@@UnlVbkmx@VUnl@U@nbWXJ@VlLUVJVLUxVb@b@VÈ@XVVWbnX@`lkx@nmVnbUVVVzlJnlVbUV@@V°L@VXLWxnLV`l@kxlXnK@nl@XlWn`Xnl@@UVa@VÈK£VLVanW°U@UVU@`VInmV@nV@Xa@aVW@UalkXKblIyÆXnlJXbl@@VV@nklU@`nVKLVKVb@VU@UÈKUVKIlUX@V`lIVbn@nblVVmV@@XXJUVV@knKVn@`@XVnKwlLVmUUU@U@aXL@WlU@UUW@UmU@KkLWaXkWmXUWm@U@nk@UmK@U@UaUVUUKV_@al@namWUI@KUK@aV@WUIb¥ULUJkImK@U@KV@U@a@UkU@K@wVaUwlU@mUULmKUkV@@anIWmUK@I¯mKkl@LUb±lUakLmk@WwUKÝVUIm`¯n@Uk@makJU_@Jma¯ImwUVkKbaUÅ@wWaU@VU@mXIVmmUkJkwm@mIlUKWzUK@VmLUV@VnbmLVbU@@lkU±KbÝV@UL@¦VWUWXUJ@XVWV@VULnbWVbW@kmWXUK@Vkam@kkm@UlmXUnbWlUXV`UX¯VmUU@Ul@Lll@nnJ@LnWmbm@b`", "@@kUUm@nllVKXXVKmU"],
                    "encodeOffsets": [
                        [113423, 32597],
                        [113794, 32800]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4211",
                "properties": {
                    "name": "黄冈市",
                    "cp": [115.2686, 30.6628],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VVUnWVXnVJ@U@V@VXV@@IVJUn@V@L@KlIVlVanLVbnVlIn@@a@Kl@@IJlI@aXU@KlKkVblJXUVlU@VbVkVKXn@VlxVa²I@VlVUxln@bJXklaVWnLmÅ@y@k@aI@W@aXIlVVaV@nnlKnLVW@IUa@a@KUVVlI@wXKVV@IUla@lUXwWnnalLlxXLll°@XwVKVaXIlnb@nln@Va@U@k°UmÆUVaXIJV¯ÇUmmkU@WaKmakVm@U@aVKkkmKkVmIkÇ°£@aUUVaVVnKlkXmk@lUVaX@@Um@UmlUXVUVU@wK²¥Ua@I@UVl@UV±UIUÇ°»VkUmVI@a@Umĉ¯V±bŹĖğaÇL¯lmkX@óĀ@mÝêb±WkLn@xXx@@b@V@LW@UblţX`kxWnXô¯¦ÆV@L@JVLxkK@V@bkz°llXz@JUlVla@XUVbVKXnW`XXV@laVV@VX@V¯xx@xULVbUJ@n@LU@VmmakbUK@bIWWUUVkUmkLm@VJkb@nUJ@`V@kXaUaVmmLkUmJ@Uk@U±lkzmJUb@bVUxVXU¤L@JX@VlL@JkLUVU@mnUl¦@V"],
                    "encodeOffsets": [
                        [117181, 32063]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4210",
                "properties": {
                    "name": "荆州市",
                    "cp": [113.291, 30.0092],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÈJVlVVLXJlnK@UlLanblaxlK@XVWxXLlJ@VnXxlnô¤l@nKnÈKl¼VL²ÇUn@VlzV¦UxWVU@@U`lbUL@xV@²@@nlVUUJVb@VlbXx°XVWX_VKUwVKVa@UVKUUVk@KnblaUU@wnWl@UX@lÆ@@aIVmUkxVJUbÜ@Uk@WWnk@VVm@I@m@Un@mXUlVlUnJ@knJVU°@@aÆLX@llL@¦nJV@XblLVa²U@UlW@VX@`@LV@@bXJlIXml_lJU°bKÆLnVVl@öVmXaVIĢllUlVnLVlX@@bannxVLbn@°ÆXmmkĉ¯w±Uċ@KÝÅƧŃÝçUw¯m¯k@WkV@¯UIUJW¼kbUwk@W`@¦Uônb@VÆlÈ@VU@£UWWnUÆUnmJkUÇ£VWUI@aUU@WkI@Ua@JW@k£kaWVUKmnkKbkkVWbVmUUmwU@kk@UakUUa@V@nlx@lUb±lUbnnWLUyk@UamUK@mlk@Wb@VXL@x@xWI@a¯¯V@bVn@LkKmL@`XmKmVU@@bkL@V±bk@UaaLKUVIWXamVVbUK@b@Lm@UWkxULWVUnm@UlUX"],
                    "encodeOffsets": [
                        [113918, 30764]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4208",
                "properties": {
                    "name": "荆门市",
                    "cp": [112.6758, 30.9979],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n@lxlInVUnWJ@nUVV@Xb@xVÆbalLVUnx°JnbI@V`lInbl@@V°mn_VJÞUVLXx@nllKVb²kVa@KlknL°@JVLXnmJ@bU@VlnLVKV@nX@lUKVaXal@VKn@¥°L@UnwbnaV@KV@VUX@lVXI@KW@@IXWV@laVLKlaXUVVnkVWV@lwXblIXWVkVmaU£VaUmVIkU@y@WakKUamU@UUK@kmK@w@@mK@LV¯U@WwkmULamVVUU@IbUKUakmm@UakLmxU@UÒWlULţÿmwkIUm@akÈblW@UVUUk@JW@XkWWUkUKUIlw@aUWknWUUmnIWaUwVaÛaVUIwVlUnJ@bÅ@@kVWk@mX@xVVkbma@LUlVVUL@VUbULVxULW`UX@V@lUXWaXlWXX`@bmb@x@LUb@VmXX@@nWKUL@xVlknkL@bWJXbWLKkb@VlL@Vn@VV@bnXmLUK@nUaU@WbXVWL@VU@@V"],
                    "encodeOffsets": [
                        [114548, 31984]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4212",
                "properties": {
                    "name": "咸宁市",
                    "cp": [114.2578, 29.6631],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÞÆLČ@V²°xĊnlWnÅ¯m@aK@°nJwnVIUaÆJÅ@wwVXW@aV_l@²V°lĊwlaXLwlUkalVVaX@lVXI@aUXJ@U°UU¥VIVKVklanLVa@VÈIVV@nk@aVa@mV_@aK@klKUa@UnKWk@@lU@@UW@@nUWUwmaVIXlV@mLXblJ@kV@kk@KU@WkUWVÅwkLmW@UmL@lULKULak@maUUÝwUJIbKUU@aWK@kUWVkUwVw@mÝ@I@wkW@aww@LU¥kJ@nVJIkVVnkVUkyUIUl@xWUkaW@@°kzWxkLUWmzk@@bVVVb@@XlV@Vl@bVbUn`Wn@WbVVI@`LVbXLV`mnU@@lL@LUak@Lk@WbUJn¦@lVb@xVb@n"],
                    "encodeOffsets": [
                        [116303, 30567]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4213",
                "properties": {
                    "name": "随州市",
                    "cp": [113.4338, 31.8768],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@n`lwkUmUVWX@lk@VanUĠ¼V@@mX@@nVVVXLmJVLnK@bV@@J@VUn@VaVUUUVWVLV@@Kk_@almaVkUU@WVVUVLXmmk@wUaUKUV@°@kmaUaÈmWmUVklaX@lVnxl@@UnaUk@VUVwVKn@VVn@VbVJUknUmmVmk_VwKUUmVak¥@UVKVIkW@UmIVWkIVkmmLkwmVU@LUU@VVXL@JmLUbmK@UUKmkKUUmVUaUnÇlk¯mJUnmLUaUJUaWL@UkJU@aklkU@¯@KWLUmUUWVkbLUKkbU@WX@JX@@LWJkUW@UVU@@LUmbamx@V¯K@¦mULk@WbUbLkVW@kVVxUb@x@LlV@V@b@VU@L@VLnlJVIVK¦aVJ@XU@bLV@LVJnXmbk@@bU`VLUVVb@V@VnL@Vml@@VXnWVXnWlXblK@LnV@VVX@VkV@XWK@bVV@VV"],
                    "encodeOffsets": [
                        [115830, 33154]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4209",
                "properties": {
                    "name": "孝感市",
                    "cp": [113.9502, 31.1188],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VnXK@L@°lVlkb@VlI@VXKVbVIVbnKVmnI°lÈkVmVbnUVVlLnVL@VnLVanK@IWKUUV@V@KVnUlxnKlnUlJUXnJ@VlXUJUL@Vl¦UbnVVLUxl`UnnnmVVlnVKbmVX@a°Ý°LaXJV@VUnKVXVK@LnKlLUbVVX@VwVJVn@@UU¥V@@UUK@maUVUkkJ@L@K@UmVUI@JU@W@U@UV@UIWmXUVmUUÇ@UVmIlmnmakK@akaW@UwVUkKVnUlKVwkVU_WKUkVW@UXaWkUa@w@VU@XaW±@IkbKb¯L@WXkW@UakL@UV@UmVUmL@UXWVL@aUVUUUVU@yUUIUa@wUKWVU@kWk¯UkwVKLUxK@nVxUlUUWVUmw@wUUyXWlX¦WbUV@U@blbUVVbXXl@lVL@bk@lxkVVnVx¦`UnkL@V@L@@@xnL@lVL@VnVVblLXb@@zlVUJVnUbV¤bUnUlWXkJWakxU@UXml"],
                    "encodeOffsets": [
                        [116033, 32091]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4201",
                "properties": {
                    "name": "武汉市",
                    "cp": [114.3896, 30.6628],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nbnmknJVUÈ@@U¥VknmV@VUlK@IkK@UW@IKV£UWVwU@aVanIly²kVl@@VnIlVnKUnVbblWU@@_VI@mlaUIn@lKVnUlVVXXJ@aVLlanbUnV@@K@mVIUaVK@ww°w@UW@UUUkbU@WWX_WmULaVU@WkbkUV@IWyk¯kly@a@UlLwUK@I@KÅUW@Å±Um@wl¥ka@@_Vw@ķa@akw@kKW£XVUVwVwUaU@VUUxWKkbĉx¯k±Uk@U`@bWXUx@xÆÅIVbUJmxIm¯@UmxnUVVbnJV@L@@kV@bVn@UVULlx°VXllV@XUVL@xVbJVV@zUVVVUVV@bUKWX@VnKUVVnU@@VlKVb@lXW@X°KaLla@JX²Wb@UV@@xVbXlWb@VUXVlXLV`UlUxkLmVUlLUVVxX@lb@blL"],
                    "encodeOffsets": [
                        [117000, 32097]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4202",
                "properties": {
                    "name": "黄石市",
                    "cp": [115.0159, 29.9213],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VUVV@VbUxaWUblUVmnKlX@bXJVIlVUxVVVIUzlx¯@VbnL@xx@UVaXKb@XkWU_Vm²klWXVKl@nXV@@wmlK²XaÞén@ôÿ@lWn°kUKmmUÑUmm@wkImWU@UakL@bVLUVċ@bUK@alIXKWK@nXnKmkUVw@¯b@LlUL±Wn@KULUaW@kL@lL@bU`@nUb@bmlU@UÇJ@UUbmKkblUULUJV¦¯V@VWIV@bWJkUW@UbkUlbkV"],
                    "encodeOffsets": [
                        [117282, 30685]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "429021",
                "properties": {
                    "name": "神农架林区",
                    "cp": [110.4565, 31.5802],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n`lIXll@ll@b°aVklKXaVn@bU`mX@VV@nmJn¼V@bÞ@lL@lJXVlLaVLVnVnalV@VLÈUlblWXIKVU@J_@annaXm@KmI@mkk@KVkWWw¯w¯°@UUU@WaÅWkL@¥@kWWXkWmIUVVbm@@bUbmUUbW@UVk@mVkU@U¯mKVUkaW@aULÆVbb@VÅ@Un@VLWl¯L"],
                    "encodeOffsets": [
                        [112624, 32266]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "429006",
                "properties": {
                    "name": "天门市",
                    "cp": [113.0273, 30.6409],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@K@UlKVm_¥UwUmlUkwl@@aUK@kkWWUaVUka@aV@VUXaW¥Xk@WWIklm@ÅxmIVÝUkxka@bWJaUL@W@l¯UULUbkVUa¯bm¤UnÇUkmUUxb@VkXÇal@bVnlJnxŤĀVKXkVÑV@nwlKVbn@nlVbVLaJ@VVUnUbVKlnXxV@°U@KnL"],
                    "encodeOffsets": [
                        [116056, 31636]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "429004",
                "properties": {
                    "name": "仙桃市",
                    "cp": [113.3789, 30.3003],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VK°VkX@@VKbXI@alblwÞVUnJÆwn@lkXJ@XWVzV@xnxVXUVVVkUw@mLVwKVU@Um@alU@@@KUmIUaVUmnwmwmb@aW@UkmKkUkVġkUJWbnUõ@UkmUÅKL¯aVkIk`WnkJ@xVLUVVbUbk@WlXbmVxnxUblbUV@@VUV@nVL"],
                    "encodeOffsets": [
                        [115662, 31259]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "429005",
                "properties": {
                    "name": "潜江市",
                    "cp": [112.7637, 30.3607],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@UbVxbXmJVnXVlmVX@bkxVJVLVlXXWlX@@IVlVUaVwVlnÈVVmn£°aVbUlaVUK@mVU@U@VUkaVamwUwnWaXkl@VaUaVUUK@wWI@aU@@K@_UW@kX@V±VUbkKWaU@mI@¥kKkW@ÅK@b¯@UVmI@lmIkVkUWVnm@@V@n@JUnU@mlXXl@@V"],
                    "encodeOffsets": [
                        [115234, 31118]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "4207",
                "properties": {
                    "name": "鄂州市",
                    "cp": [114.7302, 30.4102],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°¥WóXmlw_ŤWkVaX@@K@U@a@WwU@mWk@ULWkX±lUnV`XWl@aWLUb@Vw@wmKUa@°kwyVUJUUVwkUUJWI@akWmLUnkVaXVbUxUVWX¤lL@lx@bb@ĸUx@`@lbk¦@xn²VÆX@"],
                    "encodeOffsets": [
                        [117541, 31349]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/ji_lin_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "2224",
                "properties": {
                    "name": "延边朝鲜族自治州",
                    "cp": [129.397, 43.2587],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Wxĵm@ó¤VX@@xÜ¼ƨ²xWxVV@XVbWXllaÞU°Ċ@ô¼LôÝWanV¥Ñnĉ°¥ÅX¥°¯@w°w@»°k£°mÈŹmÈbÆŎ¦K°z@kxl¦UbU¤klVKŤÞȰ@@bV@nVVUlÞ¦lUllVlU°ÑU¯V°wbXxl@V²@nô¼ó°kmVk²ĕw@wVÞÞ@@Ġö»¯@bnb°mÞ¯°V°ÈJmX¥mamUÅUlaU¯@wKkl±n@@wkÝVUUl±¯I¯bal@kLmakb@ġŹé°Þb°ékLmwXaÅb@bVlbVbÒVbUbUUanwakbVUVak¯ULmxV°UxnôŻX@JXklbkbĉabWU@kWUU¯@@klm@@Å@awWXlKkI@WbUaVIUanU@ĕ¯KmUnWUwm@£ċèkUmbUmm@@nkJUalwk@@nmWUan_óaWmnw±KIwl@UmI@an@@mlUÅmV_KUk@U`@_KUmU@U¯mmb¯@kbImV¯LkbKÛ@ÇnɱJóaÝĢkb@xÒÇll@²VÆUVVUÇ°XóxlV¯lV@bV@nx@¤@șŎnxV¼knJnKX°¦UlnVbUbÆVnÞWVX¦llb@l°VJôÒnLVbbX"],
                    "encodeOffsets": [
                        [131086, 44798]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2202",
                "properties": {
                    "name": "吉林市",
                    "cp": [126.8372, 43.6047],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôlzaÈV°K@mLWlnVxUVÈ@ÝĬUÈnôLa²VmĀkV@ĠĊnU@bV@b@nl°UVnÞaôJ@bV¦mlkbmVXx¯@VxmnbbÈKV@bÈLwĠyônmnbÜ@nnVx@n²KJ@kal@nxÞULź±Vwkw¯LWWUkŎīVww°yVĕ°wÈVlkÛ»@wW@Uô£@nĶXwWaUamKóÑUI¯@kakkW¥XUmÝÅUVaUamVk¥W¯LmIlmU»mwȚō@£kJUÇk@am¯y¯UVwa@wġx¦K¯X°Ċ¯¦U°ċWULÅa±b¯@UkÅWmVkIUlóċ¹`óIlXWXxmbULÝbƧ@x¯bÈl@x¯zaÝ¤@nmVWb²bmn¯J¯Ò@n"],
                    "encodeOffsets": [
                        [128701, 44303]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2208",
                "properties": {
                    "name": "白城市",
                    "cp": [123.0029, 45.2637],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@óǩŁ@WlwUaƑwÛÅÇéĉamKōÇ@IôġVȁÑŹçÝUƧċĉwóóÝ@Ƒ»ğL¯ll²@ƆÅV@¦mÅb@nmlU²VxlUn@VbnWbÇbkÒn@èlnlUÒ°Lx@¼ĉb@ÒUċxÅènLVxÒbÅJ±a@_ÅJÅnVbKlnUÜĊ@UxXVÆnmVJÞ¯VĠwXw°xWLxKV¦ôUwVÝǬóÞÞ¼ÞkVôȘxÞUlVn¦ÞĊa°wb°@bÆwlŤL²`z°@V@@nJVnl@@¥nUmmn@mwnmmUnk@mlwUaLnwn¯°anWakIÇmXwÆamUXUlJXaUUklKUknmÞV@K@VWÞ@VkUwV"],
                    "encodeOffsets": [
                        [127350, 46553]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2207",
                "properties": {
                    "name": "松原市",
                    "cp": [124.0906, 44.7198],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@źèȂÒUóĢ@JŎÈLnĊbÈêÜÆƒxVbkx@XǪłôkÞ`Wb@n°abKnVw°`_X`W¦ĊIkmVakwKx°UÞbU@ll@°¦VWaÞbxÞI@mVI@VkÅUWK¥nLa@@È@°Æ@nU@KÞalkUwVékUWwkUVkkJk¯@»ókV¯ÆÇI@bĉô¯@ķw¯nmmÅL¯wVUÞy@UówÇLkmm@@UóxkkĉmL¯wVwkWWXmLõm@kÅ±V_ô»ÛÆ¯@VaVaĠVlmğwķUóÝƽ£ÇJkbǫaƽLW@nxÝ¤kzy¯XɅm@VôÇX¯Ė¯ºÝnUnLVlUÔmV"],
                    "encodeOffsets": [
                        [126068, 45580]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2201",
                "properties": {
                    "name": "长春市",
                    "cp": [125.8154, 44.2584],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@U°xÆKnn°mĸx°@Ċó@aÈJ°ÅUôl@¼l°IllUlVXxlVUêVxkllnÈUVll@Vx²IÞ¤VUlVnIôlÞlwô_bVaĶLXÅÞÇ@K¯@wÛaçn¥¯WXyW¯XwUmmÛ@manómğzxÇK@aUÇLamanUw°@WwnUalnk¥U@aóIÝbUm¯Vmk@@aU@amVğĉ@lUnÿ±UbóKmVÇÞī@ÇVUUwmXkKn@L¯ÇUbyókōè@bn@lÝX@x¯ô@ÆUV_maXm@aóJWxnX@VVnĖVnUJ@nōÆÇ¼V¼kxLklÝw@xx@zV`ÅbmxU±xUnnmknğUbUUb@Å°Üó¼U`Æ²@lönKnXWlXUx°xnKĊllôw@Vn@lnÈKôx@VÝzV"],
                    "encodeOffsets": [
                        [128262, 45940]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2206",
                "properties": {
                    "name": "白山市",
                    "cp": [127.2217, 42.0941],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ul¦kÒÆ°IlÒU¤ôz¼lJUnÆXVl°@²aÆbVKČXV¯°¥¯ĉ°WL¥Ģw@xbUx°V°znb@ÈlVlI@w@mU@akU°kUôwWÈ¯VUVUÅ±U@kÈkÑw@laÞġUÞ£@ƅKnÑĢ¯@WaUaVUVkkw@a¯@¯ÝVXnW@@WkXmK@xkKUb@bW@Uw¯mmb@WKUbmUbUaWbJĉIVW@Il±LkmUbUm@nkKWa¯n@`UbmaĉL@bÆ@W`L@n¯Xb@kb@xL@VkL±mlUIU¥mL@lÅx@_la@UaV@kmmK£LmKUnÅKVbmXVlèĉUUbmlĢÅ¤Il¯bÇ¦l@ô¼Ģ@x°l¤nal@xb"],
                    "encodeOffsets": [
                        [129567, 43262]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2205",
                "properties": {
                    "name": "通化市",
                    "cp": [125.9583, 41.8579],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÆlXnĠxĢ°lÈ°K°kXm@¦VbkŤJnÝ¤kVÞVVkÈb°y@wkÇ°awƨ@aÞKVnaWwXWkôJ_ČºôVk»óyV£kÑJÅ¯lÑk¥Va@wkbmk£¯@wġó»@kÈ¥°akJÆ£ġnkVaĊVkçWUnUaÆLVmnLKU±@m@a¯UbmV¯m@_KUaÅWó¹@UanmWak@@wmI@y@mkJVa@UaIkJ@n@Um±kkxmIkbÇm@°bXnV@°ÈmlÞ¼¯XVº¯LmkWWXLmVVlkn@@lnWÆVxbmnm¯lÝaVÈè@¼VbÆ°ÞUVJkxIxIV¤ÒXxmn"],
                    "encodeOffsets": [
                        [128273, 43330]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2203",
                "properties": {
                    "name": "四平市",
                    "cp": [124.541, 43.4894],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ɇn°WzlyÞ£mwX@ƾKǬblaÈIƾ¤ôÞĸVĠxnmmV²wVnwÆaU_@yw@wÞxlkKlwU»È»ŎÅ@mVIUmmĕUU@mWXwIô@bWnnbU`V@Å°ó@wÞW@km@aŎç@m°Ñ°Inm±aXaUn@mƑU¦@Ç¯aU£aUġ¦ÅÒJōUŻókUÇ@¥¯ak¯mUVak@@aċçÅaUm¦Ý`XbÆ@n`IxĊÞōÞml@Ub@Wl_¯JkÇUÝÆÅb@nllUb¯±a@WĉJġĀ¯Unóm¤xôaVnxôI@xV@bmÆ@lnLmÞ¯ÞxVb¯þ"],
                    "encodeOffsets": [
                        [126293, 45124]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2204",
                "properties": {
                    "name": "辽源市",
                    "cp": [125.343, 42.7643],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@żôŎVIÆÑĢ¥VbV¤°bÈ@V¥ƒÞ£lÇUUUÝlÞ£mţIlUa@¥nlW¯L¯kÇġ¯ğwWmÅk¯UVUbWlXlmnbUx¯xVVknlUbVÇKUb@VnbmlnzUº±bmJUbWÈnèmÒ@X`WL"],
                    "encodeOffsets": [
                        [127879, 44168]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/liao_ning_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "2102",
                "properties": {
                    "name": "大连市",
                    "cp": [122.2229, 39.4409],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@IÞmVk@wXWÜbnwlLnU@nLlbXW@awnbl@XLa@Ċ¥@LULnJ@xVnmV@VXXV@VJkn@VÜKXXôJlbxl@IVbnJVLUbnlnVwJVU@XUaUUlwn@°nVKnV°_VJwl@nwlVIXWlIVVnK@IWmkIVaVU@WÈUlmU@UWUalkXġŻ@kI»mmakUmĉUŁV»²ġVĕ@aUU؍IɃ`ȃ@kw@Umwĉ@WķÑIĉÇbÝLkymbIwÇmÛbmbU¯ÜõÈkÆVbŎxnXVÆnǪ¦b¤UxÝnĉÒmĊVÈ¤ÈbÆ¼ĀÆÆÞźbVVbX°²¤"],
                    "encodeOffsets": [
                        [124786, 41102]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2113",
                "properties": {
                    "name": "朝阳市",
                    "cp": [120.0696, 41.4899],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@na@UVI@mÑWkaV¥UI@wl@aÈbm@wVak@@K@k@a@UUmUUalmU@KÇUÅ±¯@±kUKVkUaaU@¥m@@¯k@WLUmkn@mmIkm@amU@wVmkU@Klk@UmaXIWWULaULVbmk@UUmUk±_Uym@mbkImaX¯WWxWKzU@WkJWwkV@Um@UbVVVVXb@VWX@W@Vkb@VnUK±aUUlwXÇWKknU@mmUkLUVVUUVUawbkKmwnIkJ@nmb`kmVkLWwUm@UUUK@UmaUa@UUaWK@mU¯Wkk¯VmUUxVXUVmL¯ymXkWUbmXUKVknWx¯JVnkLl@VVxnxlĀVL²WlXl@bÝVUn@bnlÜaXblIVl@@È¦@VmbXV@@xVVnUn@`°@VnXU@K@VV@VmbnVn@ln@bx°Ub@bLV`ÅnW@@lUnnWVU@Vbkl@Xl`XxVUblkX@°¦VUVVbUlkV@UbVbkLUxmJkX@bbxVKÆlXXbnnala@Uk@UVVklKVUXKVU°KVan@VUnLKVLWVaU_@mmUXa@mwXwVkVWXkk@k@klm@wXKl@U@KVUUUVaUV@alLxUx@b°°VnnVxlIXJmxLUVlV@bnX@VbaVx@XJ@bn@VVXÈl@llX@lUVô°°@ÞVbn@Vk@VW"],
                    "encodeOffsets": [
                        [123919, 43262]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2106",
                "properties": {
                    "name": "丹东市",
                    "cp": [124.541, 40.4242],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lzXJU@²x@@V@bUVmKUn°n@lnVKnV@n@VlV°WbXn@VzJ@¦@bkbbUl@bkbJ¯zWULWbklVnb¦VJ@K°Ukl@@WbVn°@Vm²UnX`UÜLXmVXlKVbUVVnUbnX@VUL@lUbWx@²kl`n@Vlb@nUVWVLVU@aV@²bl@ÈmxWXVÈUJVl@laWnXKÈkÈ@Va°bÆm@XV°IVV°UnalVUn@UwVU@@VVJI@bl@XK@wWmXUUVbkJVXnJVI@mknwlKXL@`l@VI@UUaVKÞnaVm@aÇ£XWU@aÇUU@mbkKm£@WWL@@Kk@klUbWKUkUU¯UõÛmUUaVUU@WU_W@kVkJ_WKkV@bUL¯¯±mk¯ġğÑ@UmwKUaka@am¥ÝIUWmk@wmţLKʝbȗKWĢklVbX@VVknÇV@XUVUblJXn@J"],
                    "encodeOffsets": [
                        [126372, 40967]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2112",
                "properties": {
                    "name": "铁岭市",
                    "cp": [124.2773, 42.7423],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XJm@¯mXUlnVbUJU@bV@UJWL@VXLmJVbkXlJXxVL@b@V@n@b@`Vbk@lxknV@VVV@bUL@bV@@bVK@VXLWLXJ@LV@nbWJ@IUVx@LVJUXVxVx@VV@@LXJWL@VU@@L@VnL@bVVmVX@@VVInJmbnLWVnVULVVU@VVmX@@JVzl@nVVKVXÞ@mk_lmUUWV_nJlUÞÑÞVVUVVLUVJ@IVna@@KV@XwWknwnKlalUwaĉÝwJl_@aUaKUUU@WU@WXUÆ@@UVK@n@UnVVblK@bllb@bbW@Xbl@UlnLl°°b¦nKlVnIV@UWU@WXkw@am@nm@aVw@I@KUaVIm±XÑlknJVnVJaX_VaUaVKmwnkmmn@lU@U@mnaXlKUmUIVmklaUK@UlUVUW@UkVma@UUU@JmUU@@bmbKWV¯XUKm@ka@UVKVk@aUKmLkKUUÝUmbXbÇJ@k@WU_@m@klm@UXKVaUI@KWUXaÇWkaWUkWUL±U@lUU@UJI@V¯JmIm@@aU@Uwa@UV@VkIV¯aUkWkb@bVL@@VVVUXW@Ua@@bÝbUVÝ@LmUkVUbVllLUV@LXWbUXm@U`@kxlnnJlbnIllLXlVlUXmVKnV@L"],
                    "encodeOffsets": [
                        [126720, 43572]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2101",
                "properties": {
                    "name": "沈阳市",
                    "cp": [123.1238, 42.1216],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ȚĊÜ°bLlÞxUbUn±@ÈnVÆL@xnLlUVbxkImJkn@V±LUxkV@bbKVKnzVl@L°@VaxÞUlbôxVV@@V±bn@llXLöXĶnal@nkVJVI@aU@@aVK@aUUUU@lmkwl@Ua@_@a@m@U@aUKWwkIlWUanIWK@UXKVIU@@aVVIUamVknW°n@WI@KUmULWnkVkUWKkkmJkamIkmlw@V_n@VWXaW@KVUkKUkValUnVK@ÞVUÞa@a@VbX@VWUU@U@UK@ala@IkKmUUa@U@VkkWVwU_@KÜUXbl@V¥XUVmXakÅlUUkIm`UIUJW@UIKmkm@UUJImmU@VUXU`mIUbUK@LJUUl@X@UbJkU@nm@Uam@@aUmLKwmWXUK@kUaÇa@JUIUa@aKVUUXmUy_@lmbkLUKWLX`n@bVL@JXLWX@Vnb@Vm@UbnVmL@V@x@LUbVV@V@LUVl@mb¯U@xU@UVVV@X@VVblJ@bnVKUnx@llnL±¤b@k`VXÆK@kV@¼kl@bWIUl@VmLnbm@@JXXmb"],
                    "encodeOffsets": [
                        [125359, 43139]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2104",
                "properties": {
                    "name": "抚顺市",
                    "cp": [124.585, 41.8579],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XVl°bUlJ@UVU@bVxV@@bn@nJ°I@UJIVV@V@k²VVKlXXVblÈXWbXV@LVJUbWL@Vkn@l@nV`@X@lÈIWanaÞVVVlLnKVL@bUlUL@Vlbn@VL°WXULna@aV@nV@IVV@VbUnl@VXnKVa@UUnyWkXaaVk@aabnm@_WKXmWanU@alaUl@XJVLVxX@wnKnVlw@V_@a¯¥@UkKWUaUUanK@IaU@WUaVw@klUVyUUVUUÇ@Iôba@mnUma@kXa@UWak@Wal@a@WULmU@U`mIUU`mUk@@UUK±nkJbUam@kwm@@a@UU@Ua@@K@VK@kmKU_UKUUaĉWmkkL@`LnmlkLkbmK@k@Ulmb@b@xUVIUlmVXXxm@JUUk@WUk@akx±@¯x¯UmbKUUVmUU¯UmVVnWkÆlWbUnWVU¦k@WaÛV@LV`UxXllU@@VVbnVlL@J"],
                    "encodeOffsets": [
                        [126754, 42992]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2114",
                "properties": {
                    "name": "葫芦岛市",
                    "cp": [120.1575, 40.578],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ll°XnV@XLVb@VVbnb@VLVV@VVnXxlKnUl_na@mlImJnxlLaxVbUVVUVUKVlnnV@lmXLÈWkxVV²bVLm@Ula@UX@XW@UWaUUUUVan@V@lUXxlIXV@yXLwXXW°nblJnan@Vz`l²nVVVl@nUaVKbVKnXVaUaVUynXK@kVK@X@m@mLXaLWU¯w@a@UVw¥°ó¯¯y¯UÇ¯»w¯Im¯ÇUUl¯»ţKċÑţķm¯w@mU_ómk¼VnU`±IkbVlnnU¼±Lk`@XWl¦UbmVUxkXVlkbllUVb@bkVmx@XVV@Jb±aULkKWXkWmX¯aUJmIkVm@xU@n"],
                    "encodeOffsets": [
                        [122097, 41575]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2109",
                "properties": {
                    "name": "阜新市",
                    "cp": [122.0032, 42.2699],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Xnb°lVlnXVJLlVnl@zÆxnK@bblKVLn@@VaVLVK@L@Vl@XVVInVVKVwlUXwlKLVVb@aV@XlUXbVW@nlWnXKV@@V@XUVVLUVV@@bVVV@@ln@VbVUXVIxVanJ@UIVWL@UV@@¤V@nInwWklnIVxlnzUVÇJ¦VVÜLĸUnW@aV_WĊXXaKnkl@nmLa@alUVw²K@UlmnIlJwaVUkmK@wÅKmU@Ç²VmVaÝwkKaÛ¯șĉķ¥ğ¥@kUWkƏīÝ@@akUK@KWIUm¯nU¯JmwUVmIkJÇLm@UImJUU@aW@U@@nUbJabXVWn@UVmX@V@b@l@L@lUb@xnÇabk@@xVJU¦lbXÒ@nUJ@Vmb"],
                    "encodeOffsets": [
                        [123919, 43262]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2107",
                "properties": {
                    "name": "锦州市",
                    "cp": [121.6626, 41.4294],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nJ@nlmVnXKl@@°n@@¦VbVbUlVL²l°@Æ²ÈV@LVknVbVVnnWVU@XmWUabIVa@mV@X@@bVVnIVJ@nÈKlInJVUnx°IV°mVnXJ@LLlV@b@ÞƐĬXllV@Ġ¦ĸ¦naWW@In@manK@UVkXJ@alk@»lU@ÅLUWl_@a²£Kkm@kwVmULm@akIUa@U@WUUVUaÝ@ğwkmĉ£UW@@bÇL@ma@_mKlXUwKLţÓ@UWw@K@UI@mU@UV¥@°UnJ°@@_KUwW@UnaWUmmI@mķwUaÇLóVĵwÝUUW¯¦Ux@Vb@xV°XKWbK@n@nW@UL@lWLmzUVVbUbmWXXWJbn@Vkl@LlVUn@xnV@bln"],
                    "encodeOffsets": [
                        [123694, 42391]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2103",
                "properties": {
                    "name": "鞍山市",
                    "cp": [123.0798, 40.6055],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lxĠÞ@bV@@w°Vna@UkV@K@UUUVa@K@w@UnKmUVan@@Uma@UXWWK@IUK@amW_XKVLlKna@kmKVak@VU@VmU@anIÆan@aUVnb@blLV`ÞLlUbnaKn@naVU@¥°IVK@anUUKVaUVak@mJkXUVwkVUUa°U@W@WlkXWlIXUlJlaxIVVXLll@nLV@lLXlKĊz¥maUlkXaVKX°yIla@aVkala@a@¥IUy@WmXa¯kU@U@mmUULkmm@¯VmnLVU@a@U@±w@VWIkymLUUkJWXJkUmxk@xUI¯`mUULm¯m@kxVVbWV@UVIUx@bkVVVxUbVV@V@zJVXUlnk@@lkLlLUU±Jkm@UIUVLUVU@K@UnnV@l@LlaUJ@zn`@nWlIUVUUUV±Ln@nmL@VUVkLVlUxVLVlÅXma@@akLmWUX@JUnVJVkXJ@X@`WXVUVUIlbW@bVUVL@`Un@¦U`@bUV@z@Jm@@XV`LUL¯J@IVKmKÅI@JnWVnLnVxV¤z@bmV@VUV@bUL"],
                    "encodeOffsets": [
                        [125123, 42447]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2105",
                "properties": {
                    "name": "本溪市",
                    "cp": [124.1455, 41.1987],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lb@VnlnVVUb@VJ@nnJ@bmXUx@xVbkbkWLUxnl@Ul@xWx@nUV@¼UllknkK@bmbnlLVJX@VIVJn_lJVVXUmnU°VVVUnVVLna°V°w²@lwbl@XVl@VVIn@wWWnUVkJVUw@@anaVk@@lnLlalKnkmK@_lKnlĊXVbVVLV`nL@lUL@@L@VbV@@V@bn@lxn@VbalI²mVL@Vl@nV_VVnJV_@nVKV@X@bkXbl@XblylUUk@Xa@UVIlK@UUWVULlm@UUUnKWU@K@UXmXVa@U°KVUUWUk@aUVKkaWkKUknaWa@U@m@mk@aUJk@@_WKkLmxl@nUJmIUWlIUaVWVXn@xWLk@@aJUI@U@UVVxm@UVkmb¯VUU¯JWU@Ån¯aUbÇ@ÇlLmWXkbk@UIÇVUXWwÇnk@±aU@@bUVUKUXmV@kaUm@k_±l@XwVa@kVK@UWmVaUmVUUakLUWWnÛKVW_m±VnU¯@Uma@Xk@l¯V"],
                    "encodeOffsets": [
                        [126552, 41839]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2108",
                "properties": {
                    "name": "营口市",
                    "cp": [122.4316, 40.4297],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĊĖÆn¤°Ċ¯ŎWô@xXbwnKl@nX@VUVKmL@VU@UxÝ@VlbxU@VUb@bk`IUlVUnV@@UV@@JnXlK@b@nbÆWUkUKVwUklKVU@UnK@mm²KVUVVVUJXk@mm_@yVIbk@K@kmUm@VLV@VUKVUVJn@l²IVVKklK@kl@kmVUWI@y@UUUVawUUUl@akmmVaUKmIUaJk@wkaóIWWÛL@UlmUIU@WW@UnUUm@wmIVK@Kĉ¦@bWKk@max@bWXkamK@mVkKmxÛaWX@xUlÝnJ"],
                    "encodeOffsets": [
                        [124786, 41102]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2110",
                "properties": {
                    "name": "辽阳市",
                    "cp": [123.4094, 41.1383],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@`VzWnVUVL@bVbVJ@IÈbVb@lVLXWnxLnKVb@n@Vbn@mV@lIVa@@WkVVI@KVLVanJV_VWUV@nnJVIVn@na@alLlmkVk@»VU@mXwwk@@VmkVwXKllaUa@wVwnW@amI@mUI@VaUUkmm@UkaL@UIĉyLWkkKU@mKk@kWKUUJwkbkIWVkJWXkl@X@X¯VVbUVlUxVWlnI@lUbVUbVLmV@bUL¯J@¦UVmbm@LmbakVÝKU_kK@amaVUbm@ÅbmJ@bVUn@UVl@UbnL"],
                    "encodeOffsets": [
                        [125562, 42194]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "2111",
                "properties": {
                    "name": "盘锦市",
                    "cp": [121.9482, 41.0449],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Vbĸx@nnJVnXmb@VXVxL@`¯@mI¯V@U¦@VV@nJ@V@LXx@VŤÔKLVxWknL@`b@nÈK@a@VXĊ¤nVK@aVU@UnU@ayU£UwmmKXUm@IÆJnLUL@J°IVKKU_@Wn@@I@yVU@aV_@¥Vm@_UKUV@aXkaVJVUUXW@_@WWIUlUIVm@IVW@IU@@VU@mUVVkJ_l@aVa@UVwka@UÞVwV@@UnKLVU@UmWk@mLxWa@wóUVUIÇÆĉ¦¯¦¯xʟJ"],
                    "encodeOffsets": [
                        [124392, 41822]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/nei_meng_gu_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "1507",
                "properties": {
                    "name": "呼伦贝尔市",
                    "cp": [120.8057, 50.2185],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@m@Łkklô@£kJ°ýɅķÑó¤ğLĉÅlÇğŁW¯¯ƥóÿlwkţÈéÝƛó°ÞÅxV¤ĉĖWƒ¯lȭţυ̃ɱÿķƅˋğɱřÝţϙȍƧĊţ@¯kWKUKm¹Å@ķJU@ƧÑƧō¥˹Ɔ@L@ÞVLn@VōČWJX¦@JŻbU@ţÞmVU@ȁýóbkWWLÅ¯UWġkmó±UŹôV¼ƽ¼ł̥ĖƽǬʉxĉŻȗKΕ̛ʵƨʟÞ˹»Ƨţ»Ǖō˷Ȍ±ȚʊĠUɾɜɨmÜ֞߼˸ƅȂ¯ǖKˢğÈÒǔnƾŎŐ@Ċbôô̐¼ƒ@ĊôĊÞĀxĖƧL±U°U°ĬƒČ°ÜêɴȂVł°@nxŎèbÈÞȌ΀Ǹl²IlxĊl²ÒmôĖÈlĵºmÈêVþxɛČʉÇĵVmÒÈɆôƐŰǀĊ°ÆǬĮƾbyĊ@ĠƒXǀċm»ôw°Ûk¥Çm¯çkkÇǫţǕéX_ĶWǖīŎaÆĵĸĊ@ȚȘĊLĢĉVÆĉʊÇĕóaU¥ĉ°mkÅ°ġUĠřk°mÑČÿÛƒWĸ£ʠÆxÈÞŎÞ»ʈ²ĊÇČalÒ°Ť±ĸzĊKÈ²m¤Ŏ@Ò°¼nyȂUźīǖƳÈē°@ÝĶ@Èkl¥ÇçkxkJXÇUÅ@£k»óƿīÛ@lÅJl¥óý@¯ƽġÆÅanċ°é¯¹"],
                    "encodeOffsets": [
                        [128194, 51014]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1529",
                "properties": {
                    "name": "阿拉善盟",
                    "cp": [102.019, 40.1001],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƏnǟƨʫŹɆÿ°¯ÆV²ˢżÿ@ÝÆŁȰ¯ȀƳĉó@ğky¹@īwl£Ź¯Ŧé@ÇÇxŋĉƩUUŃōLÇĵóÝnóç@ó@ġƱ¥çWUçÆō@éçťKçȭVһƽ̻aW¥ȁ£ʵǊǓƲɳÞǔlżÞmĠóĬȂɲȮ@ÈĢŮźÔnĶŻǠŎȭгŃċóȭţΗÆƑÞƧÅΫóȘǫɱȁġlÛkÇ°ȁÈnõl¯ôÞɛÝkĢóWĊzÇɼʝ@ÇÈķlUČÅÜķnέƒǓKȮŎŎb°ĢǀŌ@ȼôĬmĠğŰōĖƧbЇƧōx@ķó£Ål±ĀƧīXÝġÆêĉK°Ýʇƅ@ΌʉżÅÒϱʈ@˺ƾ֛।࡬ţશóЈèʞU¤Ґ_޸Ƒʠɽ̦ÝɜL׈ɛϜóȂJϚÈ@ǟͪaÞ»Ȯź"],
                    "encodeOffsets": [
                        [107764, 42750]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1525",
                "properties": {
                    "name": "锡林郭勒盟",
                    "cp": [115.6421, 44.176],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ʶĬĊIȘƨƨ@ĬÛĢșŤĉĬĀóUÈŚÜènŦƐȤȄłϰUƨťƾÑ܆ğɲƜǔÈèʈƲĊƞƒɆ¯̼V˺Ò˺ȂŤVĢêUÜxĀˌ˘ƨÆ°ѢmÞżU¼ÆlŎ@ĊçŎnÈÒͪŎźĸU°lżwUb°°°V£ÞlĠĉĊLÞɆnźÞn¦ĊaȂīġŃ¯Iĉůl»kÇý¥Ŏ¯én£ġÑÝȭxÇ@Åçķ»óƱŎ¥çWÿmlóa£ÇbyVÅČÇV»ÝU¯KĉýǕċţnġ¯»ÇōUm»ğÑwƏbċÇÅċwˋÈÛÿʉÑ°Łkw@óÇ»ĉw¥VÑŹUmW»ğğǉVÿŤÅźī@ř¯ğnõƐ@ÞÅnŁVǉóJwĊÑkĕÝw¯nk¥ŏaó¦ĉV¦Å`ğÑÑÝ@mwn¯m±@óƒÛKˍƏǓ±UÝa¯lōșkèĬÞn@ŤġŰk°ċx@ĉ`Ƨĕ°@ţÒĉwmĉ@na¥ķnÞĉVóÆókĉķ@ÝkƧƧÛa°Ç@ÝÈUóbÝ¼@ÛÒV°@V¼ˋLÞɅŤŹǠVÞȗŤÇĖÅōbȁƜ"],
                    "encodeOffsets": [
                        [113817, 44421]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1506",
                "properties": {
                    "name": "鄂尔多斯市",
                    "cp": [108.9734, 39.2487],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĶL²ĬVłƑkkl@ȎŘWńÈĬȗ¯ºlz@ĠĊôŦôÒĠ°kÞÜn@¤UĸèĸbŌÈXĸLlÒĢxɲÆ¤ÈÛƾJÈÝ°UÅĶ»²VW¯ĸJôbkV@ôlbnĊyÈzVôab@ĸÞUl°yǬ²Ǭm°k±lbn°@È»JXVŎÑÆJ@kLÆl²Ġ²ʊůĊġřóƛÞÅ@mmLUÿóĉƧ@»L@`ČĸmȗÑţů±ĉğl¯ĀwÇçƧŤÛI@±ÜĉǓçō°UwôǫůķƳÅ±bÅ£ÓÇwnÑó@ȁƽ@ÇƧĢón»ŏĕóĊ¯bÅVȯÅImōKULǓ±ÝxċŋV±Āȗ°Źl±Û@WÒȁŚŹНŚÅèŌô¼°ȰɞȂVĊ"],
                    "encodeOffsets": [
                        [109542, 39983]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1504",
                "properties": {
                    "name": "赤峰市",
                    "cp": [118.6743, 43.2642],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɲŁĢǉĊwƾōÞĭ°_ŎŃźȹƒUČÿl»¯ôķVÿǬƽɅġÅÑǫ»̐ʟȣU¯wVWÝÈġW»Þ¹mÝƒɛŎÿŎōͩůV¹ōéċóŹÅVVĢǩʈ@Ėċ@ķÛV°¯xÇÅţ¥»°Ûôĉʟ¥WýČ¥wç»±mnÅķ¥ˋVbUÒġ»ÅxğLƧbWĖÅx¦U°ÝVóŰlô²@¥ÜÞÛôV@²±`¦¯Ý@ÅVÒō¼ô¤V²ŹĬÇĊƑţxç¯Lk»ʟlƽýmłÝÆƏ@mö°Ġ@ŚŹĬţÆUĀĠǊĠX¼nźVUÒ¦ĊxÈ¼@ôlx¯łʊÒÜĀˌÇČxÆČÈƐaxÒĠn¼ŎVÈ¼Ģ°ŤmǖČĊþLV°ÞU¼ċÈUÆzÈa¤ôbknXĀè"],
                    "encodeOffsets": [
                        [122232, 46328]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1508",
                "properties": {
                    "name": "巴彦淖尔市",
                    "cp": [107.5562, 41.3196],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@²@Ζǀݴʶհĸƒ¦Ķ̒Uˌ¼ӾÇƾ¼̨UÞĉƧéÝ»ĕĉƐȍōǪakóó¯a@ôţaV¯Þ¯°@²él¥ĵğťwōxó¯k±Vó@aóbUÇyĉzmkaóU@laóķIX°±Uĵ¼Æ¯VÇÞƽIÇÜÅ£ɱġwkÑķKWŋÇķaķçV@£mÛlÝğ¯Ñťóǿƴȯ°Åł@ÞŻĀˡ±ÅU¯°ɅĀźƧʬmǠƐ"],
                    "encodeOffsets": [
                        [107764, 42750]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1505",
                "properties": {
                    "name": "通辽市",
                    "cp": [121.4758, 43.9673],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôƲĸ¼Æè@ÈȮwƾ»ʠĢ¥VÆ@²¥@»ŎÑ¯ĊJŤ£k»ÆÇX¯̼ōī°aX£ôƾȁź¥aôŤĢL°ĸ@Ȯ¼ÈÒʈŚôVXůÆaĠƛÈKķĉôÿ@ğÈĉ»ÇVnĉVwXĠÝ°ČÿĸwV¯¯ǵ±ĉǫÅÅm»²Ż±ƽIm¥ţÈķ@¯ƧJV»ÞUÝç¯UġºU£ţóaÅÅlƧī¯K¯ÞÝğL̑ȍƽ@ōŎōĀƑɜnÞÝºX¼ÇĢÞUX°xVʠȤ̏Ǭ¼ÆÒɆĢǫƾUĀóĸ°k¼ċĀƑVŹȺōń¯`ÝĮƽŎĉxġǊɱłō¦"],
                    "encodeOffsets": [
                        [122097, 46379]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1509",
                "properties": {
                    "name": "乌兰察布市",
                    "cp": [112.5769, 41.77],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ʠǠÞĸɲȺƒÒȂƛŎaÆÈĕȘţUÝźǟɆţÝˌKU»@U¯ÜÑ@Þ»ôaVÞÇÈ@¯ÜbƨƨÞlĸ@ĊôlôÅĊUÝĸm¦bmĊ@nĊxŤÑ@¯ƨĖĊ_@Čwl¯ȭLÝ»ƽ¯ķůǓ@ÇǓbċÅÅÆwÿĠÇU£óa¥¯aŎğĠţkw°»¯ůlÝĵkÇ»Ý°ɱƧǫaóôɱ»Çk¯ŃóʇŐŻĉǊŻĢ¯ÒÈUl°x°nÒĬónĊğ°ÇŚĉ¦ʵV°°ĬÛżÇJȁńʇʹó˂ƽŎÆţ¦"],
                    "encodeOffsets": [
                        [112984, 43763]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1522",
                "properties": {
                    "name": "兴安盟",
                    "cp": [121.3879, 46.1426],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÆXnlŎ°@LVLĠþxĊUȮĊnUĠV@żaW¯XIŎġ¥Ý@K@w@K@I˺ŻŎ¦ƨƨÒŎIÆ@X@VºnX°lŎ@ƾĉˤƒȘǷȘÑÝÝÞbVţĸÿŤxÈĖƐêÇKnĸ¥ô@ķÞUnÒl@UÅaīˋ¯ÑƧx@±kXřƐƏÛéVˋ»lō¯ĉÅÇÓǫÞĖġV@ğ»°ĵÇÞǓ¼¯mÛÅŃĉĠÇƾb²çéż¯VğÞml»ōÑVç»V¯¯ĕÆU¯y°k¯¯V»ôÇÑ°a@ŹkġKţóbŹ¦ƽȂóW¤¯bĬ̻ŎW°ÅÈl¼ţ¤ĉI°ōÒ@¼±¦Å@Uġ¦ʟƽ¼ÞĢÒm¤êō°¦Èþlk¼ĊŰ°JĢńȁĬ°żnÇbVÝ¼@¼óĸţ¤@°Ånl"],
                    "encodeOffsets": [
                        [122412, 48482]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1502",
                "properties": {
                    "name": "包头市",
                    "cp": [110.3467, 41.4899],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@źxżĀǔÆǬVȘĀŤ¥ÅƾōôˁʈͳȂŃÈIÜŻ¯ī¯ōm¯ɱĖ¯ķÒÝIÝ»ÅVlÅôÑġğVmÞnnWçkWÜXƝÆwU»Șĕ£ĉÑğ±±ÅkK@lÅIōÒUWIÇ¼¯@mka²l¯ǫnǫ±¯zkÝVķUôl²ô°ŎwŦxĶĠk¦±ê¯@Ý°U°bóŤ@°bôlôǩbŎƏȎĊĖÞ¼êƨÝĊ"],
                    "encodeOffsets": [
                        [112017, 43465]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1501",
                "properties": {
                    "name": "呼和浩特市",
                    "cp": [111.4124, 40.4901],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ʶUĊ¥ÈřĠ¯ĉômīÑ¯mwk¯ÇV°ÑżġĊǉǓɱţǓƝóX¯ɛÒóa@nÝÆôƜŚĉĢʉŰĊÒ¤ȗĖV¼ÅxWƞÛlXXèmÝmUnĠĢóÒkÆÆUÞ¼ÞJĸÑ°ɲĕ°Ŏn"],
                    "encodeOffsets": [
                        [114098, 42312]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1503",
                "properties": {
                    "name": "乌海市",
                    "cp": [106.886, 39.4739],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ș°ÇīXŃŗ@ȍlkƒlUŁ±īĵKō¼VÇôXĸ¯@ťê°źk¤x@Ĭ"],
                    "encodeOffsets": [
                        [109317, 40799]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/qing_hai_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "6328",
                "properties": {
                    "name": "海西蒙古族藏族自治州",
                    "cp": [94.9768, 37.1118],
                    "childNum": 7
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@V£°@laXô±źwô@UlżaÜnKw@Uaa²LmÈLÆÈxlaUawÞmÜbÞUnJ°akôÑkwÝVğwÇ@ÝkkV¯¥@ò»nŤ¥XImw@mVwa@ÅwmLkaWw¥l»kçó»@WÑĉğ@ĉŃUwóřVómĵ»Ý@VǕ¯kÝĊÅk°ÓUklkU±IÇÞk±@ƽJ@UġIk@W¦VÑșÓÅnťKULn¯X@¯mUÛ@WÅmóKknōbxÝ@U@kw@ÿÇLţÝUkmwklċVÅU¦LkUWlÅÑ@a@ÅÑ±UóġŹ¼ÈĉmŻ@@wkwKl¯Uġ@lÇUÓ¯_Waĉ²Åló¼VbknKÇÅ@ƧĢō°Ý@ğWÅxUUm@ÝXÛWULUè¯@mbUaLbUWġxIUJWza¯by@ōÈóLU`ÇXUlUĉV¯nmÛbǕLklUĉVóaġƏbġKţnkbÝmmnÝWȭÈÝXţWókUÇl¯U¯ġUɅĀ@°¯¯VÆnmJ@ĊķnóJUbÝXUlVkL@lVxnnmb@¤Vz`ÞÞŤ@VnÆJV°bUôJkzlkl@²ó@ÆÇ°kĖÇbÛU@lmbXVkzVɅĀXˢlńĬŹ@éÅ@ĉńÆ°ğbUlɜ_°@xŦkbVbƒKĢŤVŎ°@żÈźlĊôKôb@nôxŦÆ@ôŎL@þÆb@nnWˌbÈxInaŎxlU@Ñ²±ğVUĢƨbɲ@Þ¥ôUUķWVô¯ĊWʶnôaŤˁ@£nmnIôǪK°xUXô@Ŧa°mkXÆÞVŎkĊ°ÞLÈôyVaIlwX°UVwĢÑÜKôw@nV@m°nmnÜɞ£VbmXn°ÜÒ@xx@Vb²UlbkxVnJUnVVĊ°KČm°nxÇnn¤±¦@UXVV@lVbmVVÈVxÒ°IbźaČbVw@VLƾÑ@Ŧô¯ĊkôÑ"],
                        ["@@@@nòVaw²bVxxÜaČVô_ĊJIVmLa°@Ŏ¥XlK@klKVbUb@nUĢnaÈ@lmǬ»Ġ¯nmnƨVyÑǖĠ»ɲIn@@ÅĢƳ@¯°ôVKÈbVIÇ¥¯@Ýó@ÑnīWKkk@¥¯ÅaX±VÅw@±Ġ¯@»nWmw@@¯VUUWçKĉa±VkkV¯wx@UJx@bknÇbmÅ@Uw±U¯¦UKm¯I¯ť¼ğĊ@ÇŹÈ¯@Ý»ÇnˡJbÛèÇnÅK¯ġĠŹW¼Ålm@¤n²Ýb@b¯l¯@Å¤W¼nV@x°@Vx@lbUblbX¼WÇ²lU@¼V¦@bÇlVxUbVxÞbVbm¦VV"]
                    ],
                    "encodeOffsets": [
                        [
                            [100452, 39719]
                        ],
                        [
                            [91980, 35742]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6327",
                "properties": {
                    "name": "玉树藏族自治州",
                    "cp": [93.5925, 33.9368],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɆÿĢV°°VÈklVôŤXÞWȮÇÞXnmÞnlaŤmĢLƐaĢôbĊUVlkǖKÜan°mĊUVVkÈWV_ôKŎÇ@z°abXyVIJĢwVXaKVbna°@VçVKXÜÞWn@VVÆwXĠÞ@Ŏ¯ƨġÆ@ÈLlmUaô»ÆkĊ±Xb°`ÔVkÈĢ@Vk°Llx@xż@ĊnÇź»ôĢ²VÆÒ@@bÆÒXklVKV¥ÆČUklnxlç¥ċç@±m¥wÅJ@VmÈIléÈa°U¥@kÞVK²ÑW°w²ÑK²ñyÆÝVmw»kkWĉJWUVÅwLmÅ@@mwkn¥VÑ»°°@@»¯LlaJônVUÅ¯U@W¯UmÑ¯¯k@WykU@¯wV¥kVwţk»wWÇĉĶçKÞÇaĉbIlU@kwWXU°w±@UKn£WĉKWxkĕVamwXw@Wmnk@aVkbĉLlImmwUÇWxnÝJn@¥ÆkwaXÜĉ¯ÅV¯¤mkx¯kķÜ²VWôŹVU@V£¥@°wn@m@¯@UbUôķmn@ÆÛ@ÇýVaUÇĊV@Çlğ¯xÝŤlVÈÈVx¤VxkK@@x@kVĖġ¥kIWbXŎx@nxÅUW`_@±UaLUxK¯WbkVlbbmLÛÆWIUwWkwÝV@kIéUbUUkV¯Km¯k@UmÝ¯m¯mLÞĉÛUmġ£UxkKm°Lwk@kVmKVUk@¯a¯ĢmóKUUxImlÅnÇbXèVVU°@@xXnm@¼ğ°@²ÆxU²WÆb°@¦llXLmĬ@ÒÞô°@È¦UJÇaLóU¯@°ġƴ@Æ@mɱJğ¼ǕÒUzƧmnmğ°ǫ¼knÇ@bġmmV@VaUaLkl@kLWō¦¯@bKUnJĉIó`ċUÛbwUw±axbñUm@@babÇÅXmƒÝÅôVbÞblUÞVÞU°VUx@UV@l`¼nL@ĊLW¤kXķWġXUVVVķUbVb@°kVVxÈa@Č¦ĊbaźJU@ÈVl@XkôaWĢÞ@laĸUÆb²mÞLĠÞÑôbÒĊaJVbm¦"],
                    "encodeOffsets": [
                        [93285, 37030]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6326",
                "properties": {
                    "name": "果洛藏族自治州",
                    "cp": [99.3823, 34.0466],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÞVŤÈK@ĀlxV@Þ@wŎalmôLnXÆÜ@nV°@°WmVKŦLÆmȚÔÒUX¥l@ĢJV@ƾI@wW°Ån¥kÅÝVwôÈç@lÑĊĕaJnaÆLVw°kny°UnkÆVČĊll¦Vƾ@@nUźÈÇIn°XwÞKô¦VWV£@£°ókċ±Iam¯Va»ČĉV¥°@mk¥l@Ċm@aUmwX@wÆxmĢ_`VnÆbKVw@@nUVğVmVVöIll@@çÛm£UÇw°@VU¯»m¯JōĖÅLa@»ĉĢ±`U_k`ÇçókXlK@akÝÞ£WċkÝkxJÝ¯ÅwxķxmIÅx@k±J@ýŋ¤UkmV°ÅÝxkwmġnÝVU¦ŤlmóXk¤UKç@mVkK@klī£m¯VUbW¯¼ċb¯ĵam¼mVXm@k¤ÇXÇbU¯J¯¯È@bVXVÒ¤V¼kxÝV@lVWxÛ¦W¯mKnlkU@nƑUĉÝ@ÇºÛċUĉ¥UÞÅz±òL±Ò¯xX±ÒLÝU@lV¦¯ÇbkêÇJnU@ÆIxn¦@²Čè¦è"],
                    "encodeOffsets": [
                        [99709, 36130]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6325",
                "properties": {
                    "name": "海南藏族自治州",
                    "cp": [100.3711, 35.9418],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Vxń@ĊĠĊXÒ°UƾĕÞm°£nb@@LUUWÛº@nlÆǬĠ£ÞV°UXbVȂǵé@kWanm°@xzK°¯ĠVVkwLnm°kÞxÆa¥@wnĉÆ@_l_VwmĸèŤÅČU@Wn@ÑmKUnğK@°¯UÿV£nmLlUUÛé±óókkmnakV@Ç°óÝXWəÞťIţxmmVÛUVȂÓnWyȁĉkV°WnkĊa¥_K°ÿWna@mU¯wlÝIU¤UXó¥ÝLx¯WmJÇÈŹmV@ƽ@Uk¥ĉkċÅUml¯Vmz¯lUxÅKmbIbĉĖkÒ@ÇèóUxÆÞlm¦Æ¯X@x@²ÝlÈJV²klVl¯ÔlĉÆÞ°lUǖÞ@Ķ¼nUôôŚ"],
                    "encodeOffsets": [
                        [101712, 37632]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6322",
                "properties": {
                    "name": "海北藏族自治州",
                    "cp": [100.3711, 37.9138],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ōmġxƽUm±LǿþġÔ@kxmWb¯I¯mIUx@bbŹVÇkĵblĉI¯¥Um@Æ¯È@aóUlČ»@w»wXaó°ţçÝkUaV¥ÅbÝw¯lmnKlxUğU¯°Lyw¯@mnXbl@êȁǶUWa¯VÝUğ¤ǫkÅ@mÜ¹XVV@K@ma¯¤ÝnƽĖ¯V@¼ôlèk¼¦xXlbnKÆx@bUx@nnxWJţ¦m¼ñ@°¦lUÞlÈ@ĠxÞUlxÒól¯bmIÝVÛaÝnxVbkbÇwÅÇKn±Kbb@VxLmÛŻbkVó@Źxó²Wkb@¯U¤źĊ@lUX°lÆôUlLXaV°wxUb°xÜôÈKVkÈmlwkÈKwKVUŤĉŎ»»Il¥na°LV»²¯Üy@wĢ°ĸwlwĢw°±_lVk@°bÆ¯z@l_@Ģ±lÅVlUaÞLVnKlnÈ°IllČawÞÑ°xUU@wVkmĠLô»KÞýôaÞ¥ôĀÞmÆmUŎV¥Èl°²°a²¥V@@wamm@Ñn@Æ£żVĠ£@W¯Þl@»@Uk@"],
                    "encodeOffsets": [
                        [105087, 37992]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6323",
                "properties": {
                    "name": "黄南藏族自治州",
                    "cp": [101.5686, 35.1178],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôl²ôÜêVVkKmnU¤VĀ¯°@LmĠVnLÈL@alb@al@n°V_XmWUÈamaVIn@naV£óVWU£°axÈ¥@aĊwÈ¹@óağbm@kw@maÆw@In¯mm@UkkWÑÅ@@kċÅçVkÝJÅkVykŹl¥@¯ĢUÜX¥òýmmXÝÅlmU@£WlyXW»Åbl@aI»k@klm@UxUUV¼¯XlaUnķI@x@¯KĉUU`ólČ¯ô@¤ÞJk°xVn@mbX¯ĀL`¦ĉbml¯XUlȂĊXzmȁÔUÜVUnnŤwŦJɚÝXÞW¯ô@ÈlUbmln"],
                    "encodeOffsets": [
                        [103984, 36344]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6321",
                "properties": {
                    "name": "海东地区",
                    "cp": [102.3706, 36.2988],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@Òb¤ÆI°ôU¼°UnnWx@b¯L@lUUWbXxWlƨnxVUllXVUnL@lȀý²KVnƾĢwV»@mÞ£nÆÞÑmLKUaVżĕWVk²ÆÝ@Xw°@ô@a°wóUUmIkaVmÞwmkny¹VÿƧnÅm£X»naV±Ýw@ab@am¯ĉVó¦kÝWKUU@WanUb@ôÇºĉxb@Ç¦w¯bV¤UXôU¤bmm@UJnbÇbXVWn`¯Umk@@bka@bÇK"],
                    "encodeOffsets": [
                        [104108, 37030]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6301",
                "properties": {
                    "name": "西宁市",
                    "cp": [101.4038, 36.8207],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@kmKVUWkVkUmwƧXkWwXaVV@k°K@aXwmmV¯V»¯óÅJ£amX@ċVţÆķçnUx`k`@ÅmĊx@¦U¦blVÞŤèô¯Wbx¼@xċ¼kVôbÇ@Å°@nV°¦ĊJkĶalÈźUa@aVwnJ°°JanXlw@ĢÓ"],
                    "encodeOffsets": [
                        [104356, 38042]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/ning_xia_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "6403",
                "properties": {
                    "name": "吴忠市",
                    "cp": [106.853, 37.3755],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nLV@VLaÞbn@@l@bUVlUVzVx¤kÞVèXn@nm°a@UÑ@VXnV@VaUVKUUU@@U@@KVa@U²@wXkWnk±lLnU@UmmVKnIVWnI@UK@UK@@UVKXkmWLWUXmlkVwUyVa@ww@aVIK@aVÈwKlLVV@LnVVVnUÜ²°WÈIUÆ@nÞ¼@¦@UÞUVW@UxUxVnbKb¯ÞU`VbǬV@XXÆVVl°InmnUô°¯anam£WVXKXmkôaVU@Vak@@wman@K@UÛUWKXUÇ@UIb@alW@akLUKV@@Ukw±InL@kmwkWmk@JUIůVmnnU@m@UKVKlkUwknVUKmbkI±KkmVkKb@U@aVkUmn`kIlaUK@UUKmbUIÝUa@mUa@am@UUULUK@bmKkbWI@WXwlkXWa@k@kKLVkkK@L@JUVmzUKlwUUnW£XVlKUwVU@aXI@aWaUw@W@_nam@¯UkWVkUWaU@nwmJkUVkWVUmUkJ@ImbUa@@WÅ_mJknmak@@mXaUV@xU@@VUnkV@Vn@`ULUbWLXVW@kbUJ@XW`@nÅĖWJ@m°@xxbnUaw²lÞ°xŤIVVULÛWbbkVVXÆ`UbVL@kx°LlV@VWbJn@bl¤ULV°@lmL@£U@@aUwmKULVxUVVx@@kU@mK¯LÇa¯@"],
                    "encodeOffsets": [
                        [108124, 38605]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6405",
                "properties": {
                    "name": "中卫市",
                    "cp": [105.4028, 36.9525],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°@Èb°KnL@lV@@UwVUUwVKnLVx@bV@¤@nK@k¯UVKk£@amIXa@UkU¯Klw@UKVaÅ_UWlUaXaÜVKUUţJ¯wÝ±kxVbmaw@wn¯@XIÆĕm@X_@WVIlaX@WUXKVaVK@_Um@lUVm@U@Vw@VUÛwm@@W@ImKUkU@UaaX@wWaUKkw@UVaUamLUnk@»±`¯@kW@UaykbI@VWJkLWUkJwU@n¤mL¯wm@Um²XVWbnV@bmxVkxUblLUV@kVWKU¼kU@mn@JnV@bUnmJUn@k@XlxLVVnKlLVV@@LkKULVbk`WL@lkXW@kV@UÞUlÇXlkaUbmV¯@@L@V@bkb@xlWbbW@±@UJ@IU@mVkVxV@@lIlln@Vm@VUbl@JLmKÛXmVkUKULU`@LĉwKUXlVUl@VbJX¦̼bÞxŎxɜĖĠŎaô@"],
                    "encodeOffsets": [
                        [108124, 38605]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6404",
                "properties": {
                    "name": "固原市",
                    "cp": [106.1389, 35.9363],
                    "childNum": 6
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@Vnn@°xnK£mV@xlIXVlKXI@UJlazVbX@l°@²_@¼mlVnKVbUb@VlxVLXb@xWbVbV@VlnL@J@Xn@ÜxbW@nl@nblmnIÆ`@X@Vbna@aVUUWVk@kbWakbU@VwW@_l@nmn@@alVlk@UkmVak@@aUXaL@¯@KVa@axWI@KnkVaVJn_lJ@X@m@nVanUVb@mXLlJVWnLlaVVaVX@KXVVkVKlknKVa@aVU@KXb@klJUknUm@K@_UW@alIUamaU¯kJma@IUK@U@@UW@@aXLVVJVaXIKlaUkUV@ambUUJkIWJ@wUIV@JU@UwV@@Um@nU`@UkUmVUxWUUV@aÅb@aWXkKUUUUaWK@wnm@IVU@aXwm@UmVaUalk@anKUwlUwlkK@wmaUkmmIk@VmkUUbW@UVUnW@kV@xkVmbVnU@UbUV@ak@kkW@kLW¤@nV@VU@W_UVUU`VLUV@IUVõVULU@UUUJ@wmkUJ@WI@l@bkKkbVVbVbUL@UUJ@Vm@@L@xbVVVLVlVwX@Vb@bmUkbk@@JWIUVÅw@Km@UkWKXxWLÅ@UVUnWK@xkVW@KULwWVXVWzXVVKVXkVV@VUbV@UVV@@LXxVL@VbLnKVLVxXVmb@l"],
                        ["@@@J@aU@LWK¯UUxVVn@ĠLUW@UbUUUa@KUX"]
                    ],
                    "encodeOffsets": [
                        [
                            [108023, 37052]
                        ],
                        [
                            [108541, 36299]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6401",
                "properties": {
                    "name": "银川市",
                    "cp": [106.3586, 38.1775],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@UwVK@UVWÞUbwV@knV@@KU_VK@Kn@W_XWlL@Vn@Ċw@Ula@Wanamī@a»ŋó@aÆÅɲÿUaV_°ÝaLaUmVwVwX@VUVÝ@@¥Ý»@mVÅÇJ¯XÛ±VUmUmU@KUUkKLÇxU@bLUJ@bx@xUbVzUxklWnXVKnXWlUL@V@VL@VL@mJUXmJULnn@VmVkK²mlXWlx±@@VUb@L@@VV@VVULVUbU@WmU@Ò@V¯bmn@V@lVnUnVWXVl@¦VVUn@x@XL@¦lXxVb"],
                    "encodeOffsets": [
                        [108563, 39803]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6402",
                "properties": {
                    "name": "石嘴山市",
                    "cp": [106.4795, 39.0015],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@U¯ķó±ÇÛ¯ķmbXb@kb@Vĉxm@@UkKWXX`m@@LULV`@L@mU@lUxaÝVUX@VULxVkLWV@JnVLXVlUV@zlVL@V@bn@lU²WVLlLVbUVxUx@xǀLxôÒkK²VaU@wXa@WÈĉUa@bÈkm@¯"],
                    "encodeOffsets": [
                        [109542, 39938]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/shang_hai_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "310230",
                "properties": {
                    "name": "崇明县",
                    "cp": [121.5637, 31.5383],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@uŏu»GPIV±ÐɃŜ{\\qJmC[W\\t¾ÕjÕpnÃ±Â|ěÔe`² nZzZ~V|B^IpUbU{bs\\a\\OvQKªsMň£RAhQĤlA`GĂA@ĥWĝO"],
                    "encodeOffsets": [
                        [124908, 32105]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310119",
                "properties": {
                    "name": "南汇区",
                    "cp": [121.8755, 30.954],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@`yĉNǕDwǏ»ÖLxCdJ`HB@LBTD@CPFXANC@@PGBKNECCBB@EBFHEDDDSNKAUNBDMNqf[HcDCCcF@EFGLEBa@ACoCCDDD@LGHD@DJFBBJED@BGAEGGFKIGDBDLBAD@FHBEF@RFDMLE@SGANFFJBANPH@@E@FJjRIACDMDOEKLFD@DbDAJI@AP@BGHFBCBGDCC@DCA@CECGH@FKCEHFJGBFDIHACEDNJDCVFBDCRKRLDLITB@CjNJI^DBCfNVDHDFKHAFGDIICDWBIF@@CFAjFJNJBBHD@CJ@AEFJ@@DH@BFBCPDBMFEQGDIFCNDHIP@HDABFACBJFHEBSZC@DP@@JDBƤ~"],
                    "encodeOffsets": [
                        [124854, 31907]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310120",
                "properties": {
                    "name": "奉贤区",
                    "cp": [121.5747, 30.8475],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@~T~JjZdDbLXDLCB_J@@FHFZJJIAGH@HGR@BENBLID@@LFCDF\\FpDBDb@FAHKFE@dEDDdC\\GreNMACVMLBTMCCFCEGFAA@DAFDLMHA@OD@BMEWDOC@AS@KGAI_DcKwÕísƝåĆctKbMBQ@EGEBEJ@@MBKL@BJB@FIBGKE@ABG@@FMFCPL@AjCD@ZOFCJIDICIlKJHNGJALH@@FPDCTJDGDBNCn"],
                    "encodeOffsets": [
                        [124274, 31722]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310115",
                "properties": {
                    "name": "浦东新区",
                    "cp": [121.6928, 31.2561],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@EN@JJLNHjLJNR^GRYVBNZJRBV@PDvbLNDN@LGNER@nCNQNuT_TIVFV\\Z\\XnDrI|[Ʉś²ÏJUHOƣ}CA@IO@@CYDATGFIEDAEBBAGCO@GJMCEDCJRHEFANOCADAEG@@CI@FE@BDIC@AGIAIMiEEB@DE@AJCXJDCJEHGBELGCUCeMAD]CIJiM@DSAKJKCLQDQACUECDMIFCBDJGECHAEIWCK@GLMCCGEACNKCEJG@MMBMC@@CIJUINT@JAJSTEPZZCP"],
                    "encodeOffsets": [
                        [124383, 31915]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310116",
                "properties": {
                    "name": "金山区",
                    "cp": [121.2657, 30.8112],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@L@BIHFN@@EE@@EFBDGDAADVDD@@EF@CA@IIsRE@GDAF@BF@CV@|FBCHBLCNHAFCADBMDCFZXHILBVEEQA@MWFARJJ@DCX@@TEFBLHAAERE@AJABRPBNK\\BrJ\\VHGND@CNADKDADQjGAGNC@GJ@FCFFHC@JF@@dLBDSFADHVG\\DTEPDDHJALIJkJDJCDIPE@YDCBiK@DONE@EH@BAF@HLJA@EIA@ALKNA@@FIFAFHR@NALadsæąyQY@A±DŉXUVI^BF@FFF@HBJEDFFGFEBSRkVEXGHFBMFIVW@GAEEFOIAIPKABGWEKFSCQLQBSEIBC\\FdBLRR@JGACFDDEF@AWB@LJJYNABBA@CUEGPaO_AIE@MYMFIGAEFECHSAAKAO\\[JEDB@E@MMA@@AGBKMGDFFCDDFEDFJF@NPBAFLHFH@EDDHBADDC@DDCDHHCDDFDABDAD@FEFOBCJ[D@HEDDNJBDDHABJIBBvGLBJAH"],
                    "encodeOffsets": [
                        [123901, 31695]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310118",
                "properties": {
                    "name": "青浦区",
                    "cp": [121.1751, 31.1909],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@RUNKdOFDJCbRFMLAHPLDN@JGL@@APBWYCKN@TU@SHGCEJIDIJKVIZVNM`iNY@CIE@CA@KBOEGEUFCCSADEIEFCDDDIDDHC@CKIeDCG@IG@DHWFEEGCH@@GO@@O]CNpeEQDBFME[JC]DGF@CKOA@QSB@GB@@GW@@ED@AQIJIAAFE@@DO@CFI@KNG@CDACAFEGKGBEGBDCCAIFCCLIECFI@MBCLDHGNAHSF@DMB@EEKBA@@C]DEICFG@ADBHGFKCDAKKHKD@@FHGAANGEEFCHKCECBCKG@ADKCNE\\[A[I@@mGBDQQEO@BCE@AI[AML@JGACLOAFKEMM@EQKC@CUCBCCBCHEA@FF@@FM@GEAJK@GNF@EXPH@FD@M^@HIADJCFDBER@DK@@DE@CAKFOCCBDHIBCNSB@GFC@GQEEOWFICGDUAEJIDBTAHJHEB@DIF@NE@H|HBDBEH@DKBAHEF@HEEUB@FGFGCCCE@AHOB@NH@PRLVNNFBX@RCPbAvMtBfH@DJF@ELBFA@EH@HNED@FFB@HLC@CJ@@DJ@PIRf@HE@CFF@GPHD@DKE@FFBEFFD@DEFCA@DD@IjCRFBAHFDKD@HF@@PM@H@BlbDJDBFEF@DLXB@HCD@@IFCBIFEJD@FDC@FBALLF@PAACJERACAJCBD@EL@JD"],
                    "encodeOffsets": [
                        [124061, 32028]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310117",
                "properties": {
                    "name": "松江区",
                    "cp": [121.1984, 31.0268],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@DLDFRN@FNELPBDKHB@INK\\BBJF@ADP@RFCRHA@nJ@B\\[\\MFLDBCH@DLDADFGLEDFFMHBBGH@EC@GLLLCBLDHEAGBCH@DEFJ^C@DB@LAFFA@CNE@GTMBGHKCAD@NEJFDKJDDJEDBCDHAAFLHFHBEBDDCH@LMJ@DEP@@CF@BEJBJIBRC@@FX@@HA@@HTA@RPBDLE@CHD^\\INFAERCfFMo^D@PP@@HG@HDFFXECGH@@JDHfCLJ@DGDCCCJCCEDJFCFTBDDVEHFPFLAB@NBFCFKFC@CHIACNOHWHCAAFIDD@CDAGEI@ACFMF@R@R_@GQED@EGFEQEDE_IAHKAEXCQUOQCUDEN@ZI\\DDmAMHCICDSOC@EG@BKHIGMIBCGOCSF[CUHCGEBCTKA@cE@@IGDEEEDI@@HMDBHiHCRCBCLMB@DMCGH[UqI[AMLOAAQIB@BQFBFGBAKFE@SW@CDI@QIEBNXB@FRUFKAGJYWDENCCADBBEMGKDGAAD{EU@@DAEE@CB@HQFJt@JDBE@@FC@"],
                    "encodeOffsets": [
                        [123933, 31687]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310114",
                "properties": {
                    "name": "嘉定区",
                    "cp": [121.2437, 31.3625],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@F@LI@IDKJADKIEJICADGACFECCJ@HKCAFOHAJI@aCBEE@ICAEB[GFGCKL@FGEIFADMLCAEJM@ELQECEIG@BE^QKKLQCA@EHBIGQ[GEHOMGGDHKH@JOECFCjCBEFDNCACMBCILGTABDLEEOEIG@GFIMM@CGKFBFCDE@@GEAGEEACIcGaHMFITIHDN[AKF@FS@OA@BK@IHM@KCGOKBENaQIDECcPMLQVFHFB@BFBKLGD@FAJOVGIACQ@A`LPCB@JEF@RU@ANS@@RCL\\HIFpRBFRBBDKLLDADJDGBFDABHBEDNF@DGBBBADKDAHC@\\JJFBDEH[DEFDH\\LX@XLBLbT@DNJLDCEL@VJABJNDHB@HBHYFBAA@GNFB@@AFB@AFABFLFBHFCL@HJBAFBLC@DN@HN"],
                    "encodeOffsets": [
                        [124213, 32254]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310113",
                "properties": {
                    "name": "宝山区",
                    "cp": [121.4346, 31.4051],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@mÖoÖi½[s[YEUJU`SCIEBCCWJY_LIICDWU@@FaBCJIB[ICH[@@CDKEE@MK@@IMCAEBCH@AMFI@SMGEFGB@FK@BHCAIFJNQD@FEBDFMBKGACG@ECWH@@CDDTOEEBGEK@GC@EE@GPHFR\\JHGA@FDBKRLL]RAFH@FJFDKR@FINBFKDCNEBFJEHK@DLEH\\HFADB@JFFDA@bIJGBEPDBGLI@DDEFBDCHDBIJJFCLIBCL@JKJE@ADHDBHJ@HIBBDFHBBAEIJ@BJFAVL¢"],
                    "encodeOffsets": [
                        [124300, 32302]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310112",
                "properties": {
                    "name": "闵行区",
                    "cp": [121.4992, 31.0838],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@T@@ELE\\BCMJGJSNEbGdHDJFBJAFIEIFCEWG@@gMENSFCVJFAxR~B@IH@AIiI@GE@FGEAFQPDRiV[\\DFSGMHAXHDOMCJCDETBBNVJJI@DD@ANNNH@FILDDMFBDHNDHKL@XDFGLD@EHGFD@DDB@CDDHCDAEAHG@ABOJ@BIaC@CECLKPFNCDCJBiQEIF@@@OGBMIAEEBMTHF@NKEC@QFEGA@EBCKAACHCLJHEFHHB@AFCAIEACIC@HG@KCCDC[ECEED@KC@KJMAAFQ@GHG@BHIJYIGE@EI@A`KDWCaKcCiY}I}S[CYJM@CFDVPRRVWDFLBBG`JCFRFEFFHC@RF@HQ`Q@E@ENBDJ@HFCB@DCCEJBBGDGXMPBDGJ@DEDELEDMA@DJF@DMZ_jMNYUUJILCJIJDFGH@TSVM@DLXZ"],
                    "encodeOffsets": [
                        [124165, 32010]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310110",
                "properties": {
                    "name": "杨浦区",
                    "cp": [121.528, 31.2966],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@V@CXJDKJZ`XIDDFADJvSRMDM@mFQHM@KCMKMuaOCU@BDAJSX@HKJGD@PNJCJWAGT@R"],
                    "encodeOffsets": [
                        [124402, 32064]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310107",
                "properties": {
                    "name": "普陀区",
                    "cp": [121.3879, 31.2602],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@F@@FHDL@HFFAPFCSDC@@XGFDH@BDLHNACEFA@ERCIMJEDBAGL@@EHAFENHHJ\\ONQBQCIBC[MKACKI@GGGH@I_G@CW@[DMHCDIBMTDHN@JNHEH@FJFPKFACSBKHDJNABDMDECAFiDEDFDIPG@GLHCNH"],
                    "encodeOffsets": [
                        [124248, 32045]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310104",
                "properties": {
                    "name": "徐汇区",
                    "cp": [121.4333, 31.1607],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@RADL\\NCPHFfLJaJ@FWLGMGIK@IFMDOYYFOTSBI@IMSAMSACFIDNDCPWGGBHNET[CU\\QjOCERFBEHF@@HjJBJG@@J"],
                    "encodeOffsets": [
                        [124327, 31941]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310105",
                "properties": {
                    "name": "长宁区",
                    "cp": [121.3852, 31.2115],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@HFFB@HF@DCAELENSJADCNG\\CX@@D`H@JHGHHJ@BINBFUGEDO[MCKQB}AwQEBUIEDMTNF@hH@FXEDFJEJIB"],
                    "encodeOffsets": [
                        [124250, 31987]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310108",
                "properties": {
                    "name": "闸北区",
                    "cp": [121.4511, 31.2794],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@CSG@BQGODUPWTOBQAAFMECKBGEMFKEOHADDJARMR[PGI@TEJBNG@ADBFND@JL@@NFFCL@D\\@DG\\JJADI"],
                    "encodeOffsets": [
                        [124385, 32068]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310109",
                "properties": {
                    "name": "虹口区",
                    "cp": [121.4882, 31.2788],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@bA@E@QHSXBDIMI@OHCLI@GTWBIACQAYIOFGCENBBARSPOXCVHPARH@DT"],
                    "encodeOffsets": [
                        [124385, 32068]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310101",
                "properties": {
                    "name": "黄浦区",
                    "cp": [121.4868, 31.219],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@NEHFLAFDHDPEAMZUHQQ]IMKJG@EPERABHBGRUCCNGV"],
                    "encodeOffsets": [
                        [124379, 31992]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310103",
                "properties": {
                    "name": "卢湾区",
                    "cp": [121.4758, 31.2074],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VDHQGABAFQFOH@LIiKKHEXI@IbAFZB"],
                    "encodeOffsets": [
                        [124385, 31974]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "310106",
                "properties": {
                    "name": "静安区",
                    "cp": [121.4484, 31.2286],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@DLLB\\NPGLFHUDMYABEeKEVMAAJ"],
                    "encodeOffsets": [
                        [124343, 31979]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/shan_dong_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "3706",
                "properties": {
                    "name": "烟台市",
                    "cp": [120.7397, 37.5128],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ŤLLllVń²è°xżĢĠÆlÒŤbV¤ĊXnlĢVĊÒÈ°ĊŰÞèL±@џn»VUźċ²»ÆkôVɆkĊŃ²kŤVVwUUVmUa@KkU@mUmmk@UwUkmW@UVIXa@mw@aKULax@Uk@UbWU@yULmK¯@kXVUwm@@JUUknWKUVLUbU@wWykIa@w@mUI@aUVynIWak@@Wbl@@knmK@wnIl°Kna@V¥ğ@ġUķ»¥@UōJX¯¤k@wmI¯k@mwak@@lX@bUJ@VbknWxkLkxlLVlkLmb@bU@bU@VbU`Vb@nL@mbU@VnUVmnU@mm@kIUWVIUKVkkUJUnmL@VmLUaVWaXamU@U@KUUmVUJUVÇwğnm@mXĉV@l¯xnô"],
                    "encodeOffsets": [
                        [122446, 38042]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3713",
                "properties": {
                    "name": "临沂市",
                    "cp": [118.3118, 35.2936],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@bXll@zlV@lXXmkbVVlU@Vn@@Vmb@XKVXWJ@XXl@ÈbVLUl`@XXV@VVUxVbUxVb¦@WnXVJ@bnVUzl@°ÆxUKlU@mUUnUlUVWVUnVV@XX°V@Vll@VkaXVl@Ux@bmbXLlKlb@b@bUJn@@b@n°x°K@an@@UlLVKVbXb@bVVnK°LVa@UVa@XwKVxnLU°@naV@UWUkWULmVwÝKUUla@aó_@mK@aUU@WUkwVm@aVI°W@@IUw@a±¯@¥kUVUm@awkw@K@kVKk@maXalI@alLWXblaVLVUV@LnK@l@waXaLlnUlLmV@n°J@_VmnIVym£UKmI@WnIVm@anUVmÇ_kġIÅWUXÇm@U@Ý¯Å@@naWIVW@IkK@klKn@naWImk@abkKkLWnWkLWmk_@UaVUKmLUw@mn£WwUmUaóV@UkUm@UKULUwmJUX@WW@XÒzVblJXWXk@UVWKX¤UL@xU@@VUaU@@XmVkLmWkXUyÝLmKXnV@n@lx@bWLnVVn`knULmxUlWLXVb@VK@z¯x¯¼WxKUn@bk@lVVVz"],
                    "encodeOffsets": [
                        [120241, 36119]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3707",
                "properties": {
                    "name": "潍坊市",
                    "cp": [119.0918, 36.524],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@l@@UK@@L@bX@@VlL@JLUVnX@`ÜXn`V²mJ@bU@@nb@l°xnnĸVÆ°@Ċ£Þ@lWnÑnkʶJmó°w@kk»V@»¥k@V@kw@wVmaÅmaô£ŎXI@mlnKla@mV_UK@kUkw@alWIU»m@WUIl±UUÅUbkJ@a@wUKUaVIÆmXIWaka@m@Ul£XKVw@UIJUkmJVkU@aWKImV@UxmL@bX`WXU@U`ÇkUak@@°UblXkmLUKmL@VULóVk@@Vlbn@Ub@ċaUJUbIUlVLUVVbVKXVlVXU@mb¯@VmKUwLWx@Ub@VUb¯KmLUU@aWaUaULkK@Vm@@b¯L¯w@ma@m@UUU@U¦lJUXVmkb@nmXVWkbIVxUV@VUbWLXVLW`Ux@nk@Vn@x@VkJ@V`mXk@VxV@lVI@VULVUIV`°bVXXxV@VWVnL@xVUb"],
                    "encodeOffsets": [
                        [121332, 37840]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3702",
                "properties": {
                    "name": "青岛市",
                    "cp": [120.4651, 36.3373],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@nUJXL@blVUnIVlIVJ@UxWLk¤@V@nlbXbWJÅnUJVbVL@x@blIaÆVVVk²VJ@XnV¼JkX@blxlV@VLU`@nkbLkm@nWJōó¤bnÆbUn@xlxU@l@¦@¼Ul¼ĊUnW@nĠmÈxUVIVnUVV@LV@nVWbXbUVbnK@UnKVmVIllUVLUJVXlJ@nnV@nmVUUm@Vna@K@mUaV_UaV@aV@@aanlKUkKklwlKXwlma@UVI@akW@l@bnxl@°nJxl@°£WŎIUÑn»lamô¹Ŏ¥VaUUkmkġWɱIUUŹ`@kk@ĉƨřV¥_Ç@Ĭ¤ÝL¯m¯£ƽóķwUW±ī¯kōaĉĕkğmó°bW@UKkLUaVmz@V@UxVn"],
                    "encodeOffsets": [
                        [122389, 36580]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3717",
                "properties": {
                    "name": "菏泽市",
                    "cp": [115.6201, 35.2057],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@¥IVUÈmÞ»@UlU@Un@VW@UVmkk@aVUUKVÝ@UVknK@UV@VVnIV@wnmwmKXaWaXI@UV@Vy²blkVKkamU@kb@Um@VmUkmKmkXKWwkU@Ul@UnK@UVUUmKXwUVLwKU@@Wl@@wUkV¥@@I@W@_V@VWUw@UUa@aaWa@@_mKUwl¯amzmV@WKnU@kWLķaUKbÝVmV@UWÇbÛ@X°UbW@XmVlk²UJUbmLÇxÅWUzl¯Ll@VkKXUbWJ@bU@¯@kbLmKka@l_WXºVbUz@Jn²V@¤lXnV°Ln`WbXLôVlKVUxXnlXLlU@bVV@XJWLUVnVV@@nl°nnVKÈbVXÆJU°VnXVkV@@xVL@Wlb"],
                    "encodeOffsets": [
                        [118654, 36726]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3708",
                "properties": {
                    "name": "济宁市",
                    "cp": [116.8286, 35.3375],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nam_nKlVLXaIl`_@KVVXI@m@w@@k@Knô@n`VbV@@LL@KVVn@VX@VLJl@VUUU@Uam@UkwKWaXamkJmIUVUÈblaUnV@kVKl@@lXL°kVJ@VÈnVJUX@VLXl@xVLnU@VKV@aIUaV@bĊUxKkVJXUlVUVaI@WUI@KlUnwmWk@WXIWUL@Wna@Um@@UVkUUlanWW@kkU@ykWkaWVUlÝbUU@kJUIU@@JmaókLKÇUUkKWLk@WbkUUabmKn¯°¥V@XwV@VanaVaU_@Wlk@WÈ@VUÈVVÛmaklKÈ¯lLVUX@lK@aX@@kV@VmV@VwnJV_UWUwXam@kW@wVUkKVIUUVmU@UV@IVK@aUL@aV@LmUKmx@ômLkUWJ@nXmlUxUL@VknVUU@VL`Ub±LkV@kUKÇbÛ@UWó_mJ@Wk@@X@VLxUKVWxLVnUV@VmL@Vk@VlVXxWLnlLnVlUnn@@VlaV@nlbULkl±aUzU@@VWJXbWbnLnxm@xUmJUUU@@VmLUl@VUÞVLUV@bllUn@VUXm@@VkV@VÝ¼ÇnUVJ@¦nnlnVlL@Þb°KVV"],
                    "encodeOffsets": [
                        [118834, 36844]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3714",
                "properties": {
                    "name": "德州市",
                    "cp": [116.6858, 37.2107],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@¤@VmbVXnVVbVJX@ll@zlVInl@@bVxUbĠl@ÈblaIxXVWb@L@nULWVXXWWLnL@`@LUVVL@lVnJU@UUkanVôôb°¼VÞXIÜbČabôWXÞWÈzÆmnLVJ°ÈnlV²lbnW@@UUVmnwmkkKWkla@mVIUKUaaUwmnJU@@amIk@@bVlkX@mmUklUUa@_UaUUV@wwWkXmW@I@WUaÝU@UXaWUU@UUVW@UUUWUn¥nUVa@m@k@alU@wkLWa@UUm@@wnmUwla@anKn_@alK@Ý_@@WUUUmlkaIyU@UwU_Wa¯yU_mWUwkImm@InWWUk@@UVWVkW¯U@VL@b¯b@l±¦@VV@lUbV@kxVnUl¼XV@b@lV@nIWxnb@UULxÅxm¯aUwU@mUÅVÝKULm@bmKUXó@"],
                    "encodeOffsets": [
                        [118542, 37801]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3716",
                "properties": {
                    "name": "滨州市",
                    "cp": [117.8174, 37.4963],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Vb@`bVkVlnV@nlWUk@al@nJ@bV@InmVxbVbVLUJ@nkblXlLnlmxnUV@V@mXnlbĸ@nnVxb@lnXV@UJ@nVxxnxVbÆVn¯ƒĕ@@wÈçUÇlķVIb@Çmk@¥k@UkUK@aWakUóJW_UW@wkkWK@U@K@XUUkmUUalKXala@U@kkWlkÈl@kVmVIVmU_awnwVW@wwU@wU£wkJWIyUI±bkVUJ@nmVUklXmx@lnbWkVUkLWxkKUUmUkbJ±LÇxUKmkUmkkWamUaVkJÆ_²KĠ@UW@wU¥nUWwK@aÝUkÅVaVK@akLW¯I@bnbVx¯JWñWbUL@nV@VmbkUUV@IÇak@@bWak@WJUJWL@bXV@@VJlb@zUlUUImnbVmz@°UV@VbV@@V@L@xLmKUnmJVXJ@VkLW@UVUL@b"],
                    "encodeOffsets": [
                        [120083, 38442]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3715",
                "properties": {
                    "name": "聊城市",
                    "cp": [115.9167, 36.4032],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ô@VWnLan@VKÞLÆUnVV@xVbn°ÆwwKVV@maXwmJU@@k@aWUk»VUmlw@UVa@kUU@²¥@k°a@aK@UU@mmm@ówÑ±¥¯@@wKmwI¥kU¯UmakJmIUaVkKUkm@VUUaU@UaKUK¯@wUVUIUKVwk¥wbV@xn@lWnXxlL@`XlJX¦l°XxW¦@¦Uln@@@Um@@VXVmx@¯bllUnUJ@VULVn@bxVVL@bVlnVVblVÈnVlIVJLôlJ@xl²"],
                    "encodeOffsets": [
                        [118542, 37801]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3705",
                "properties": {
                    "name": "东营市",
                    "cp": [118.7073, 37.5513],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ͬUǪlô@°Uw°ōĠ¯»Ģç»XÇ@wwƑaÇkwVƑ¯@ÅķUmm¯w@ka@mV@@anIU±m_ÛW@_mWVUK@IkK@UW@@a@K@L@Vk@±U@UV@lm@mUU@kLmxV¤@xVx@xUXmxxbV`UnUJnU@lÇkkllX@l@VkbWbkLVbnVVlWV@@L@VXLll@xVXX`ôIlVXb@bVLVll@@¦nlÈ@aUJkĸVÈÇè@x"],
                    "encodeOffsets": [
                        [121005, 39066]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3701",
                "properties": {
                    "name": "济南市",
                    "cp": [117.1582, 36.8701],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@²¦Òôxn@nn@V°VlXUUX@Vl@XVmX@JnnlJVxnXV`°zXbV`VxV@zJlbkVnVV@X@`@ÞkL@bm`mL@bkbxnVm@xn@VV@XbKl@xkV@b@l@nUbmVm¦XVVV@VUXVVV@XVWb@VÞVVb@X@JnXlWXx@xUVV@aVKVUX@lK@UIUWnIVmnLK@w@K@UU@a@UVU@¯nyUmanVJVVk@ykaIU@@WU@aXKIVXIl@Xb@al@Èb@JVUlVna@UmU@VKXaòX°IUwma@aU@UU@wVW@Ñw@aI±`kbUkwUmJ@UkmÇUUkmKknUV@mJUkaWka@KmKkULmyXa¯_@WmImmbLmUkVUbUVJbUkkWJkUlIUmkLlK@knaVmkI@mWaLUKUU@@VmLUVLWK@UUUWUkkVmx@Vl¦"],
                    "encodeOffsets": [
                        [119014, 37041]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3709",
                "properties": {
                    "name": "泰安市",
                    "cp": [117.0264, 36.0516],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n¼WnxL@x°@¥Uk@nwlUVlXVV@VXLKVUnK@UV@VVLKXb@nlJUnmb@lkLKlVnJklVXIllVaIVUValUnVKannnJ@X°`WbnzKlVnL@LbXlbVlnI@VUU@UmV@U@U¥@VmV@@_Ua@m°@@kmUUm@UVmn@nX@@aanJVUVLmlIVJn@nkVLVa@KVmVLXVVL@@U°bn@VaV@@K@aVkbWaXUVymU@aUImWX@¥UaVwUaVwUUU@WW@k_VUKÇa@nmxkV@LVJ@XJUbVkUWVUIlLwĉVaU@VbJ@bUUL@mVUK@wWkK@UVWUIÇm@UUI¯lWK@kk@UL@lmUVkbÇaUVVnJlInWbXbLxVln@VbV@VUV@kIUK@UWm@UU@LK@KU@Uam_ó@m@L@l@@x@nWJUU@L`k_JWbUKkmLn`mb"],
                    "encodeOffsets": [
                        [118834, 36844]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3710",
                "properties": {
                    "name": "威海市",
                    "cp": [121.9482, 37.1393],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VbUnVVUxĊ¼¼ô@ÞÑ¯WǬLŎUÆW¹UÇō¯ÑÝkţţóġóLł̥Uwm¥kÝmkkKóbÝ@U¦@mb¯LkmJ@xLmn@lk@a@X@lXbmJUzV@bVJ@n@xblJXzxV@VaKVUXLlmVV@In@VxUlW°@nLVK@zXVVal@@VwbVKL@bnx@WbUJ@VnXVlVxl@nnnV@lV@L"],
                    "encodeOffsets": [
                        [124842, 38312]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3711",
                "properties": {
                    "name": "日照市",
                    "cp": [119.2786, 35.5023],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@UaVUUKVkJVaVIČb@Vam@ka@Ul@UôVK@UnKVLnKlkWVa@¯l@VbÈlV_V@XWW_@anKVwUmVw@@UnyUVblKVLX@aô¯ó¥mÛĊÿÈ¥Þ¹lUī¯Kĉ¼ʟbÇVUUXmakJUnmV@bUnmJ@XnJVLn¤UzmJUn@`¯ImU@nKVkkmKWbb@xk@mL@KUUVUKkbWaXkK@bkJWbnbl@UL@lL@lxx@bnUVlV@¦²°@bVx@J@¯XUJ@bUnlxVX@VV@bL@nô`@bkbVVÞLxnU"],
                    "encodeOffsets": [
                        [121883, 36895]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3703",
                "properties": {
                    "name": "淄博市",
                    "cp": [118.0371, 36.6064],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nlKV@nVn@@kVU@²VVaU@wmKXU@UUWwUW¯aU_JUVVK@UJU@kUw@UlnWU_@lI@U@wUml@@mVwX_KWUXKVa@UVUUwJlaXWUn@mlanUVWkIV¥V@VVVI@a@akakLWKna@aVwk@WUbUlk@k@U¯UWWU@mUUVUXkVmVVV@nkVLVÅw¯k@WVXbaUl@bV@@b@xkVVXVxkJ@nk@@VLUlVbVXUVVUzVLVbUbVVWVkLmkJ@n±@UxUVVkV@bx@ÒUX@xVVV@°JXlK@bULUblÆÞV@bLXxmV¦V@xXVğ@±LÅ`IUlVbnbXllVnnlVLÈwK²IlanVVVlLwXlKVlUXma@knwWlkVnU@mVIUl²aVJzXJlI"],
                    "encodeOffsets": [
                        [121129, 37891]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3704",
                "properties": {
                    "name": "枣庄市",
                    "cp": [117.323, 34.8926],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@yUUUkl@@aVmLXw°»°w@yL@UUaWXKVknwVKlm_UmmUXK@aw@k@mUWmUL@@@£@KbÝV@akwaULmbUKLUU@lm@°mL@nUJVxVXU`mIUxU@UnU@@lW@@bkLW@UVkKÇ°kLlbnUÜÇUUVÇ@@Xkl@XV`UbmbUbU@WxU@¯¦m°nLaVblVXal@XKlLVVÈLKôlnbI@V@VJI@lVVÞaVkXU"],
                    "encodeOffsets": [
                        [120241, 36119]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3712",
                "properties": {
                    "name": "莱芜市",
                    "cp": [117.6526, 36.2714],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lmnLVlÈVln@VnIVlxVla²_JlUUUVVw²@@mlInlKXUUUVaUaKUVyUUWVUUaVkUK@l@@mlIUwUWlU@w@aU@@LU@Ubm@¯a@V@UKWUUKUn@LUbUKmlm@UIkJnUKUVmIb@b@mWm@Un@VVnnVl@¯@@nVb@`U@Un@¦@V@VUVnV@"],
                    "encodeOffsets": [
                        [120173, 37334]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/shan_xi_2_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "1409",
                "properties": {
                    "name": "忻州市",
                    "cp": [112.4561, 38.8971],
                    "childNum": 14
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Vx@lnbn¦WlnnUm°²VVVVVnUnºlz@l@J@kXWVXl@La@KULlbnKlLnKLnKÆXn°bVV@bUVl°Un@LnaVJUbW@UX²l@ČwlVVIWnkÆa°anVKn°UW¯@aVUVk@Un@aV@ValwUanmWUk@WVUUanaVwnLVl°@nk@mVU@UVK@wLVKVU@K@UUKVUV@@bnLaVaôlIXmlKX_°KVV@bVV@zV`kblIVUlL@bnV@VĊllVlIXW@kaU²blKVnIlJalbXXlWVn°JnnL@l@XlJlaX@XW²@l_VmnKUblU@mnkVK¯@U@ma@kX¥VmakkLa@a@WIUUVXWWnk@a°a@kkm@kUUmJm@WUUUIk`m@VkaWWkXKmXk¯@WKLkak@±bw@aa@aka@ma¯@LKÇÅkKWbkmġ±ÅULUKVVkm¯LUVVbUwUW¯bmULxWJ@klmkUm@@KnwVkVK@akw@@a¯bKknVUIb¯mmbk@UbmKUL@xUU@klmLUlVXIVVVUVUU`mLXVWbXnW`Å²°xmxU@mĉwU@mbU@UmbkVW¦kJ@X@`¯Im@UlUVVnb@bWJXnmbJUUUUa@UamIkax@@x@b"],
                    "encodeOffsets": [
                        [113614, 39657]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1411",
                "properties": {
                    "name": "吕梁市",
                    "cp": [111.3574, 37.7325],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@a@w@wlbnJVb@VbVVVInaWmXI@aaUmVUVkn@°J@_W@lIX¥lUnaVV@naV@xĊnV@wn¯wÆ±X_WmXaWUnKV_VVUUUUWJkUVnKlk¯@@kmKUaÅ±KkU@WmI@WUIlUUmVwXw@UlUVwV@LnbW@anU@UaVkô@l»n@naJnUÈLVaÆUUVmVKV²L@mU_lK@UVWkUa@a@U¯aUaÑóÑUbKk@@ak¯mVaUwVÑkWUmK@UUKmXUWÝwUaLUU@aWJUUU@UaÝU@WL@VKVaVI@WnU@alIVK@kImIkJ@m@@@_K@x@kaW@U@Vmn@UK@mIJUXV¤XXWlkKkkK@XmJVakImJU@ó¯LWKUV@nUVLkxmKkLma@kXKmmLabLmK@V@mXVÆUxX@`nLaV@@VmLUVnLlLb@°²nx@bVUxlb@V¯bUV@zVXVĊXVx@lVn@VnnmU@LlJXVz¯VWVXbV@bmnVUVkÇþÅ@XVxmbUlVUlnW@Xl@VLXÒ@bÞJ°¦Lò@nUb@°X@XbmVUVnb@xx"],
                    "encodeOffsets": [
                        [113614, 39657]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1410",
                "properties": {
                    "name": "临汾市",
                    "cp": [111.4783, 36.1615],
                    "childNum": 17
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nW@@UnLKabKnnWL@lnblKnLlwKVU@mVUXL°KôV@nIlJUbnI@WlLllLXkWWU£VWInJ@VL@nm@UVX@lb@@wL@`@n@V@lw@nVmVXWmwnUla@_lKwVlUn°xVKVXXWlUVVI@K@Kn°KwlVlU@kna@V_WnmUVm@kXml_@mLlKXw°m@_ôJVUV@Xl@UaV@Va°Ilk»VwUkVmwUmmVn@V¯@KUwmK@U¯wUVÝ@mJUnWK@@UnKVa_lykUmKÛnm@x@UUlwVkXW@a@U@@K@kIVnammVakUl@wX@@k¯@VVbml@°UbULmlVbnbÅK±VKVXUJWa@ULWaUU@@U@aWK@UkxUKLUUUJ±UkL@V±kk@kam@UV@l@LWl@n@VVUxLlUUx@VUVU@aIUlL@°mLUbkUUaWUUaUU@aWKLWJ@bUL@VUVVbU@m@a@kmKmnĉlUKXWUblbxmIkU@xWb@lkVxLXmzVV@bklVVUzm@bk@Vx@xlU@lUbVnl@Wxnl@n@UbVmLmb@`X@lUX@@xlnkLWaUJnnWVVn@l@bULVV@lV@XnJVX"],
                    "encodeOffsets": [
                        [113063, 37784]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1407",
                "properties": {
                    "name": "晋中市",
                    "cp": [112.7747, 37.37],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@lInJlJ@ULkJ@bmV@XUJUbL@UXKV@ÞVbV@VVXI@bVVKVbÞxVXnWVL@VnLVlXÒUVxUb°nl@bl@LVaôÒÒVb°b@VnLnnV@lmn@lbUV@JUVVXkl@lUzmJ@xXklbUnJVUbnUlbV@nlLX@lakV`Ub°@XVJnUL²KlxnI@KV@lbUbVVKnVl@zlm@U@nI@WUaVl@@mVU@XkW@nkVKV_Vwy@knwVa@XalU@Vnml@X@VLKVaÞbnnlJImVKnVVVInVlU@m@mXK@UmyUI@mWUUakamw@wUwmLkakwVmKw@wUam£y@am_W@UU@knmmamU@WUa@knw@UUUUV@nJm@mVUkKVUUUkKmwKULKUImV@lUnnm@mbUK@°bUnmbUmkkWUb@am@UXkK@a±@V@ĉÅVUXVxUVkLWl¯@@bULUlm@@nm`XlWakIkmVUbUL@Vm@kI@@Km@VaXI@W@aU@kUVU_KbJkkÇb@nkKmLwÅW@kVUUVU@WUIJmIXmma@_kyVaUUlkUm@kUx¯Lm@L@LUJUkVWXUWUL¯wVmUkxkL@`bkmVnxXUWUnm@kxU@"],
                    "encodeOffsets": [
                        [114087, 37682]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1408",
                "properties": {
                    "name": "运城市",
                    "cp": [111.1487, 35.2002],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VlnJwkaVaXWVLĊknmnLl@@bnV@UaVU@UVK@aXIKXL@bVVVbXVVblVaVnK@¯KVkJ@bVVU@UVwkVKVwUUm@@Xk@K@kVUn@lbl@²l@UlK²VVIVVKVLlw@VXL@b@VV@VXbVK@XbVIUWLU²ÆLmaUankVKVa¯@nkUaU°@n@@kWaUVaXUW@IXKVw@UWU@W@@UUU@mn@`m@UUULkUmJIU@@UK@U@anak_@wmKUwmakVkmKVk¯bw`kwUIÇx¯»ÇaÅmn@@mmUkV@wkKW@kxmLUkĉLÝkxÝw¯lóVUmV@ĀVVX¦W¤kz@`Vx°²ĸ@Ul@xêĸǊ°¤VVlXLWnXxmV@nUl@"],
                    "encodeOffsets": [
                        [113232, 36597]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1402",
                "properties": {
                    "name": "大同市",
                    "cp": [113.7854, 39.8035],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@²£yl@ČĖ@bĸĢbĸXaKŤnn@ŎôllÈxnVnÞÇV@bnXllL°KbVb@J@b@UxlKXLlKlXk@UlkJlkUVKXUÇVIVm@_nÇLalwVnU@UUwma@aaÝaLmUk@@W@U@@XwVWÝUUUk@@VmLKV»nwUwaUL@`mzJUIVUaUwKUaVIlJôanÑlLVUn@a@VV@@UUwVK°Vn_lJÆLéW@UUUÅ@»lm@aÞIVwXWUUkkm@U@aU@mwU£VWU_kWmXwW_°yUkkK@UÇK@kkUVymóKU@KWIbUak@mJ@bkbmLkUmkVUW¦@lnb@@V°ULml@nkVaVmLUnk`±@XWW@kbÇ¦X¯WxI@xmbmxXlWV@bÅUz@Jb@bÞbU@Wbk@xk@WX¯VÛWÝbÝUkVUU@alI@a@akLWam@U¯UUmÇL@K@aU@¯VUkKmX@`@kJ@nVUb@lbVÆXVWULU`VbkLUV@XWl@bXJ@VbV@Vl"],
                    "encodeOffsets": [
                        [115335, 41209]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1404",
                "properties": {
                    "name": "长治市",
                    "cp": [112.8625, 36.4746],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@UkLky@IJVa@mÞaWy@_W@_WXVlUVw@nw°K@mUVamVkU@mmmnLVUmKXaU@IlKVUnK@UmWkX@WV_V@akU@aKWIXyIUVmUnUa@WaXUVKVmkUWVkULU@@VbKbIUm@mbVLxWUUkn±V¯wbÅJUbmLkbmKÅKbVnUbVKUbKUbmLKmbaKkUm@UnnVnxUVlUxl¼k¯JUbU@Vbk@WU@UVóI@`¯nWxkLK@nk`Wn@lUnVnmXU`@mb@lkV@VnklVVUblz@`nbWnnJIVJ@XUVVUV@lÆXxnKlL@maÈllIaLV`UlVV@@b@XJWUb@n@L@lJn@@UVKVaUlnlJXbkWn_@mn@VkVK@a°@XklKVUUwVWUĊÆ@U²@@blLVWn@@bVaXllVnnaVma@¯VLnan@mVm@knUVJ"],
                    "encodeOffsets": [
                        [116269, 37637]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1406",
                "properties": {
                    "name": "朔州市",
                    "cp": [113.0713, 39.6991],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XXWVXVWnnlnn@èÆ¼@xlVnblVÈUVl@blnLÜĊmUkU@Ua@WI@aXk@WVUlKUaV_VKXWUUÅka@VaU@mlI@@_nWLVl°UV@@b@LÈKVn°V@VnXblK@b@bkJ@bVVlUÞVÞaXÜ°UXWl@wl@XaV@Ýa@aa@IVyÆ@aXUWknwna@wJXw°WÈ¥kI@W@kmKm¯IUmkXWWkabkImJUkL±aVb@lWXkJUkĉk@UmU@aKkVUkJlaU_y@UU@aUU¯LW`kLWnkJóbUbmK@aU@UVVL@VL@UVULK@xUL@VUV@nml¯@UkmKUxmbVbUV@XlXVmnVbkxUbU@bm@@VUlUVb°@VX¯m"],
                    "encodeOffsets": [
                        [114615, 40562]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1405",
                "properties": {
                    "name": "晋城市",
                    "cp": [112.7856, 35.6342],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lVLbanLnKVaLVaLUVaUmaÆLnLlanKVaÆIa°x²UlmVVXwUKna@VnJaLa@UV@@alUkKVKnkmmVwUkw@@kxWUXW@@mk@aUa@a¯aLkKmwkUm@kL@K@aWIXmVXWkUVakL@UVKw@aUK@UUKmLU@¯nKUwVUIWJUWmka@UXJk@UkmW@kLWKVx@bmI@VUaVU@a¯@UUmVKmX@±`kÝKVxUL±akL@VbLkKmV@XWVUbVXb@lm@@lW@@xklVUbnnmbUlJ@@L@@Vb@WXUlkxVV@wn@ÜmnLlVkz`UbmL@V@XLmVnIÞ@VU°x@VnLxV@LU°"],
                    "encodeOffsets": [
                        [115223, 36895]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1401",
                "properties": {
                    "name": "太原市",
                    "cp": [112.3352, 37.9413],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@VV@wVKnLVal@na°naVJUlmL°a@b@lx@bULUlmx@Ln@lVknl@XIwKVn°aVXVxUaVU°KnUlUVLKÆV²ĢlnXalLÈÆLKUaVkUanmWUa@WwkUWU¯y¯Ñ@anIl@@aVUmIymULUUVakaU@@LmJkw±LKmVUI@W¯VaU_lkbW@kK@mUkaVmVaUIVmalkW@wnIVy@klkWUUVI@UVkam@knU@mmmK@bblVUX@VkLV`@n±KUULUnVVÅUbÇKmVImbm@k¼ó@Ulb@VmV@bXmaK@UUxkVV@xWUxVnkVVJ@XnJ@XlV²LÆVbnL@l@°"],
                    "encodeOffsets": [
                        [114503, 39134]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "1403",
                "properties": {
                    "name": "阳泉市",
                    "cp": [113.4778, 38.0951],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°@nb@lb@bbb@x²al@lbKXU@mkUWkkmUUVwV@XUW@naVklKXblKnLnLVanImaXKlLaV@U@KUKWalXK@£WKXUV@VUUUVW_V@W@@K@UIWmXUmULnJkImmÝaUbLK@UWk@mnU@kVWb@Ubmx@lzUx`UULml@XWl@UV@nk@UVb@XJm@@Vknyk@zJnUV@bk@mJ@b°Ò°zXVlVXx@bXVmnVbUlVb"],
                    "encodeOffsets": [
                        [115864, 39336]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/si_chuan_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "5133",
                "properties": {
                    "name": "甘孜藏族自治州",
                    "cp": [99.9207, 31.0803],
                    "childNum": 18
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@aXam¯wm@±°wUwV@UaVw²KU@UU¥a@£ÞôxKnkmX¥IUÝUwlk°V@ÈKUwlkUyV¹mx²XllÑW»lw°UŎnJl¯°V@wôIVÇnnUllLVÇLô¼XW£@±@¥k_ÇJkUékwXa@Llw²Vxbm¼ÈxlLÈVWÞn¯mÇÑUÝlÛkwlĉmULmwUJç@wkm@ÑlUXÑôġVaUÑ¯@wķÓkbVmnU@@y¯IķKV@¹aé@kmÞU°¥@a¯@anKlblU¥@óğç@Çw@wklaçÝ±k¯±@ğÝUÛmÝ¯w@kb±¯akXWÜkXUÆÇU¤X_ƐwV@¤XUbUIUlÇUkġ@aXČmlUlèUV@mVk¦Vx@¦±¯¯¯anlW¯nÅw@w°KVak£m@klKknÇU»óKīlaUaV£@¯@ÆUVÛÝÇXÇlÓlŹ»WUğJ¯£mxLĵôºXVlUll²bllxónn°ÝU¼mJU¯nV@êĉ°Uĸw@m@¯kmXamÑ¯aUwÝKU¥mÅn¥Wmn¹n±ƑƆÇôXê±ǊnUôlĖkȂVÒ¯¼VnȮ¯ĀnƆĢ@k°V°¯ĢVlkVxm¼X²Ŏ@VxknWÜ°U¯nÆÝ@`ôÝ²ÒÇznmX@xè°K°ÅUČĬóĖÝó¼ÅêÒbmk@V@Òl@nĉÜêx@ĖmlÅJ¯¦óxȭ°Ým¯LĵèĀ@Æl°żX@xmkV@z@°blnÞ°J@bn@Æ¼UVUóóL°X°ÝLxUn°Ĭn@lnL@Æ@nKÆxnUnVInĬmÆnxŎ¼ĊIĢóÞ@ĊƨbUmV¥lkwnLmÅÆ¥XwU@wwUÞ@alUUÅUVkkm°aU°Ó°w°Ub°a²K¯ĕ@ÈbÞĊa»XVm°InĬk¼VbaJô£VĊankůnÜU@anKnĮbÈmÆ»nIé£Ġ"],
                    "encodeOffsets": [
                        [103073, 33295]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5132",
                "properties": {
                    "name": "阿坝藏族羌族自治州",
                    "cp": [102.4805, 32.4536],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@l@@þ²I@lVL°wnJ°UĸŎèIlwV°¤nĮ¤ÝlèL@@xlè²ôĊ_ĊġVÈôJżīlbXÆÈVkxÇVn°¦Üb@è@nn@@°UÈ¥WÇ_Uala¯¯UÇk»mVwk»k²°VxlL@¤_@x`ÈĖöb@l²alXa@bnK°¦VK@nnWmx@nUnl@@llĉk°l°UXkmW@Un`kÇLWÛÈVxVVlVk@lIXb@ylXÈWĮWŤzy@mI²J@n°@VJ°aÅ@ŎkVÇkaUwKVwV@nkm@±ôkôĊJ¼InÑm±nIÞXÈĊxĊUÈbÜyÈ£Vkw@kVUVm@a»ÜbÈmUXwÝxUn¥@°ġÅaJVkaW¯Û@W¥UŏĶ@¯kUŃ@aI@mmanwÞW@mw°»Uřk¹±WxVx¯¦U°zţWw@°ÇVÑk¯@y°a£@mnl¼aÝÝakwU±aĉImlĵn@m@kkV¯Ñmĸ°xl@XVÞmlÛÝĉUÅ¥mwÅ¥VaUwXġċaVůÛŹlwU¯Uó±xÛV±¯¯n¯mċLmnĊm@_kJWaXmwUĉK»@mwXÝUÇkKÇw»naUw±kxK@WbxlVêlÈIl`@¦@²X¤Wó»KUÈKkkmVmUÈóJ@x¯Uk°Imō¯VxkX¼Òkk±WwnUºVzklVxLÇ@¯UklVxÞVJW¦nmlLówÝ@¤b¦V@VV±LUxVbU@Vx¯x@²n°xnWbb"],
                    "encodeOffsets": [
                        [103073, 33295]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5134",
                "properties": {
                    "name": "凉山彝族自治州",
                    "cp": [101.9641, 27.6746],
                    "childNum": 17
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĶóKnw°¤ĠIXV¼kźÔkÈWÞÈÜUVÅ°@@U¤VbkbĬôL¼ÈVlmLlkn@l¤Ub¯L@xÆx°mXmk°b°°²@¥Uwl¥nU@VUkçVnkWċbĢ@lÈVVkJVaVW@£UƏxW`£ÈVVÅlWXÛlW°b²la@°xnÞVÜĠÞ²@l°Þ²èkbl@xÈx@Ġènal£nUÇ²@ÞKnn¤@¼°U¼nVXUbnĠUVbUlV°LX@lVèÜUnK@_yXVyUwmIU»VkÇ¥ÿkkV¯m±n@n¯ÜanVVÆz@bwÜbm@wa@kmk»@a@VUUów@nb°mXmnVbÞVôanwJak£lwLÅnÝ@wl¥IÇÓ@UL¼kVÇÅó¯kVmmw@n_Vn»°LÅ»@éÇçŹīVÇÝ@ÝğUaVÝ¯ķlŭġl@óÞÛċ@¯nkUÓm±IVġUwóKUn±¯Kw»KÝVnl@óxUwţ£ĉUmÅÇÝKÝUlmK£UV@ÞÈW¦Ò@Ĭnny@nÒmV¼@°Vbl@VlnUUwl°a@@llnk°lbnKWĀnUVxU²Åm¦ÛÇÅaUVb@¦m`móXUmmxÅ@±Þnè²U¯»mVm@wU@wÝÝmLa@VÇUkl°¯VlkV¦UmxaULUèVx@kIUxmWV¼¯VmÈ¯UnlÈ@m»ÅVWxÅbÅğW@km@kVV¦mlnn@ōl¦ÅÆxk"],
                    "encodeOffsets": [
                        [102466, 28756]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5107",
                "properties": {
                    "name": "绵阳市",
                    "cp": [104.7327, 31.8713],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ńlV°@ŐĵVX»ÆUĊÑJw@È»m»£°Kk@ÇnÑÆ@w°JUwnw@wbVb@VlźLUwa»aUklyUUVakwWXwWUxkLmn¥mwkUXlJw@aIk°X¥W²l¥aUIlmkklÈL@m°nlWUaW@V@UaV¥@ak@Çk¹K@aK@kKkÇX@VU@kx±VèkIWwUVUkkKÇ@a@wkml¯@kUWn£WaaVwnaVÝw¯@UaWxnJÅUxUma@L@mbUU±VVnkxUÆVm@kkKW°X@¤ÇUkÆÇnU¦¯kmLVwÅK@UóbÇÆV¦L@±êX¦mVÞkÜÝnWU@k¯wķn°ÒUlln@@ĶmnkĊJ²bVlxÞbÞbk»mn@¤¯bz@l°UÒ¯È@xŤXyV¯°¥Uww²XlºVŚ¯¼nx@XÝmxnb@nJ@b"],
                    "encodeOffsets": [
                        [106448, 33694]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5117",
                "properties": {
                    "name": "达州市",
                    "cp": [107.6111, 31.333],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Uxn°bnlUnÒÆnn@n¤LnxlUV@Ælx°XXxl`XVWLè±nÈb°b@²x°KÜ¼°ĉV¦lJnU@¦ÞJÞğmLÞ»xUlbVÆannalVÆX@lnŎVmUmaÅXa@aWm@£@wĉJVkkkkmnk@mna@alKJ@ÞwmÅÅ@ambkU@KUġKU@mak¯±a@aĉÑÅaVwXlw±V¥l@@ak@@£mĉÝónWV@nÝÇÇxUmbaVkkk@m@m°ÝýXmakÅī@@mb@@xmnb@mxkWL@¯b@WUXmWWKkbm@kxXmm@LUlxlêóKnUallLlLó°m¯JVUK@xK²Āô¦l°"],
                    "encodeOffsets": [
                        [109519, 31917]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5108",
                "properties": {
                    "name": "广元市",
                    "cp": [105.6885, 32.2284],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÆLĊx°»Ŧ¦WLÈ@xÞKÜ°ÞnVxÅĀlÒnJ°a@wV¯l@XWknKnwVÈ°XXalX°VI°bWna¥@w°n@yÆ@nkÞ@°¯lJn°IÈlUlXÅ@ķlUV¥VUUÝÞUU@UwJUkĉm@ýlkWUwVwWJk@VUKlUkaVUmLkm@@UIk`@UmlUkV¯ÇXKÝ_mm¯@U`kwml¼±KV¯¯Vk±Vk±kzmaKUnÇ±bk¦±X¦¯WlJ@bxkIWVlxnm¦nlKVwXWxXlxUbVVkzVlb¼bVxŹKUk@Uaa@xmxVx¯Ix@ÅmÒ@Èl¯L¤n¼"],
                    "encodeOffsets": [
                        [107146, 33452]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5118",
                "properties": {
                    "name": "雅安市",
                    "cp": [102.6672, 29.8938],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ln@xèVInxVKnĊklxkÜVÞÒnÈm°nx@¼ĊLVnxWXblI`@nmĉnKČôÅlUÑmUK²¹@ÇÅVÓÅ¯VýÞWUVmXÆbnwKUÿ@UmmIUb¯¥Uw¯ÇmçmanUm»UUlk¤a¯bVU_WĕmÇÅ±ĢUlUlÛVçkU@W¯KUVkUağVmaVWUmV»¯@»m£mÝL±@ÈmVk¤mb@ô¦kVkamL@b°@b¯¦ÝVn@lêb@ºUĸL°J@zV@nmUlaĸÔ@x°VÒUbóĢÒWkV@Ò"],
                    "encodeOffsets": [
                        [104727, 30797]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5115",
                "properties": {
                    "name": "宜宾市",
                    "cp": [104.6558, 28.548],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VlÈnlXnWLX`m²nV@b°xĢçlnVmnn@@°UzlV°nÞÒkxlw`UnVbmL@albÞKÈÛmÜ¼°@XÇ@wmW@ÅKĊLlVLVŎçÞL²±ğkw@Uy@¹lKXlKVa@wČ@w@aÇU¯n@@wġakaōK@Å»VakUWmķwkbğ¥mLak@ġÞ°¯xVVÞ@VxVVWxXlxU@k²WVÅULmèULVĊklĠVJVx±nÅ¯¦mwğ@mlğkkl±@kUk@¯±ÇKkxl¤bImx"],
                    "encodeOffsets": [
                        [106099, 29279]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5111",
                "properties": {
                    "name": "乐山市",
                    "cp": [103.5791, 29.1742],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@kVkÆkV²UlºÈIlxLXèÜlUXUmkbVèx°@@¼°Knnn@mÆIUbnJ@bVI°b°±@nK@mVakkKl¯nbmĸèl@VnÈlUUwwmwnm°¥LlLnU@VaImbkmKnk@mbLVJVUUVnkVmb@a¯JUaÆkk¥IW¥KlwÑmÝU¯kVy¯@@mmnUkmġè¯w@aU±mnW_XKWmkÇmUkóbUÝUanmW¯nma@xVôUV@b@l¼n@lb@xnÛaxa@yUÅmUÛbm°@mn²U°llĀÈ¦lUV¼nJVxUzWz@`mL"],
                    "encodeOffsets": [
                        [105480, 29993]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5113",
                "properties": {
                    "name": "南充市",
                    "cp": [106.2048, 31.1517],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@È²VmLnblyl²²UUl°U°²L»knlx_V°@nnÞ`WL°ÈUVlnkV@l_JV@n@lnKV£ÇUV¯m@laXUUbVx@VkôJU°Jn@wUk°wnUV_nJmknmm¯Vwk¯ó¥±ÿL@wLVUkUbX¯mykI@a±Kk¦ULmaXVm¯Kz±klUIVbÇJkL¯lUÿUlUkJUmUUkVVklKk@@aU@J²x¦kĬ@¼±ºXnWbxU@xx@lL@bLlº@Èl@bU¦Vb@U@XbVkX¯m@nÇKkllknJV"],
                    "encodeOffsets": [
                        [107989, 32282]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5119",
                "properties": {
                    "name": "巴中市",
                    "cp": [107.0618, 31.9977],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VUlbkVVLUl@XIUxVxXkl@þĊnVlIVx@VVÝVÞUVU¦kV@ĸWÆô²@VÞn@Vaôb²W@K@XUmÑUW°¯°Ina@y_lWn¼lLUbô¼Kla@nkUyôÆx°@n£Ý@¥mVkIU¥Ċ¯Û»¯L±w@¯aÇa²mçKXUWk_Ww¯WwÅk@UkVmwK£@mmmÅmÑkVmamnnlmIU`Vm¯xVlx@m¯IVóIUl@UwVaVWkb@nU°VÈU¤"],
                    "encodeOffsets": [
                        [108957, 32569]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5105",
                "properties": {
                    "name": "泸州市",
                    "cp": [105.4578, 28.493],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VVXwVKnwnVnl@b¯xmKUbVn°°X°@blLènV@Vnl@ULnmmUnaVV_ĶV@wnJl@@kkKVólaUwnJmwUlm@aUaôKVnJWbÞ@VwVLX¥VV_Þ`wWÞŹmmnIn¥W@kWV¯@°kILk¼Ç@k¤±XknmÝ¯UlÅÛKWV¯klUwkLÓ@U@w@ġXVWX@UbVbV_kÇVlU°lnwŎ¦ÞaÆ¯nmm¯Um¥nkVmkl_ó¥¯UÇl¯@Lk`¯ķLUy¯@mw¼ķ°ġ_ÅU°mlnÇVUÞ@_JUnVUXblĢb@x@mV°Èb@xċ@@xUbkLWkL@ºzV@lxĠ±²"],
                    "encodeOffsets": [
                        [107674, 29639]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5101",
                "properties": {
                    "name": "成都市",
                    "cp": [103.9526, 30.7617],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°n°m²°ÜUw²ôV°VkxÜźUŰČbĢlaÈL»@kwVÇ@nÛÆ»ÈUÝ°Kl_V°U`Vbn@VbÈLaVU@ƨ»VnIlUUa±lIk±@VnKmÅ@WaK¦lVōkKÝ@maXÇmw¯IU@kVwUmVIçÿU±Å@¯È@xK@wLUbÇKÅ@mÝ£@yóUóóUxkI@WlIUabaVĀLmxÅaWUnVÝXUþÆ°UÔÈÆ@±ºLnVVÒkóÆ"],
                    "encodeOffsets": [
                        [105492, 31534]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5120",
                "properties": {
                    "name": "资阳市",
                    "cp": [104.9744, 30.1575],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@èUJVnxU@lV°JnxWÈnbÞ@lLŎUk¥LXbÆ@nmLU@zlbXmlnVynLçJVbUnómUnamUan¥lKV_²aValWôn@nbVK°¯VblW@kklUnlV£°W@wUXk°KVwmVkwVyVI@wkmVÅ_Umm@Uÿmbk£xUaVw±V¼V¤kLWxU@UkbyXóm°V@@zÝÒkKn±U@@_VVkÇaVwnLWalm@@kkVVl¦kIV`±n@wKk²aVUUV¤nkxmUkVWVnLUbVb`kUUmLUmX@`ÅbÇXbWLXn"],
                    "encodeOffsets": [
                        [106695, 31062]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5104",
                "properties": {
                    "name": "攀枝花市",
                    "cp": [101.6895, 26.7133],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@bKÞnÞ@xV@xnUn°¼V±mç²ÝÆ@wnnVWnôn_@¥UaVbÆÈÜn¥Æ±VUwVmXÿmLkal¯km@k@¯bkVxmVUkk@Ua@¯»UnmÑ@mzm@īÑX¥Ç@ÝxU¦ÅÇUkx@lbUWVXmV@xĵĖ±@@¯xUÆLnÆmx@nXL±lUUVwKWak@WxkbÞĉbUn@@@xó¦Ŏ"],
                    "encodeOffsets": [
                        [103602, 27816]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5114",
                "properties": {
                    "name": "眉山市",
                    "cp": [103.8098, 30.0146],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Vx°¦VanJVn@baVbkJ@XlJVwôôôV@zÞ¤@nÆÈLVaK@xL@w°ÇÆ@²VĀmWXKWaÈÆa@_nWVnKVlV_UaVamKXUWwnmmwÑm£@ynUkWĉUkWVkkV±çkJmkKK¯¦mnnxxVxVÇkUmk@çķnmak°LllUb@nmL@¯²¯aUJ@amIVaÅJnm@mm¯L@»¯@wUçanlVWVÛkWçKkwÇJk¹±VUÅlġV²ÈÆnXĖV`U°ab£lkVVn¼mVnbèÈn°"],
                    "encodeOffsets": [
                        [105683, 30685]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5116",
                "properties": {
                    "name": "广安市",
                    "cp": [106.6333, 30.4376],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VlIVkVĀVk°lKÈIUaVJlk²yLn°UWnbVKl¥²L@blJnzW°alV°Inô¯KkKkkbVmôLkéwVk@KnnWlwn@laXLnXVW@X°a@XKlnw@man@w@na@@wĕġġwUkUWb@mk@¦¥mUÛb±yÅn@bml@kV@lknVbmVnlmbÇk¯bWyk@V_UamJ@I@WaVXamIVWkUkbVaUUx@VnkVU¼bkKUxmK@WxnV@n"],
                    "encodeOffsets": [
                        [108518, 31208]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5106",
                "properties": {
                    "name": "德阳市",
                    "cp": [104.48, 31.1133],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nUW¥²é@K¥UÈÅôa@VÆLUxnKl°V¥ÈmlÅÈV@£WX¯lLln@UVÅlwUm²UVVna@@KnbVVwÆImXwWkIVwÝĕVUaIèmKUzkmWnka@y@l²kJ²VbVkmJUƧ¼@UVbÇKUam@Ua_¯VUk`¯LVÞÇÅ¼mÜ@UÈx@l¼ÇKkbWVxUbÆ¦nxÆ¦ĊV"],
                    "encodeOffsets": [
                        [106594, 32457]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5110",
                "properties": {
                    "name": "内江市",
                    "cp": [104.8535, 29.6136],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@²èlUUllXĊVXlmV@zn¤ÒnxmnXxlUnVlwmU£VVUbl±L@x²mU_lJ¥UklU@ln@kXbmKUxÈblUU@`V@²mlLÞÑ@yU@¯ônWzaVlV@XwlKU£»aVaUwm@mwUVUwklVÇ²LlKVm_@ykUm@mUçkKmxkIUÝ@LUJ@n±kºLXb¼@mmIXa@mamnkWKUx_U`UklwUwmUbV²akbmkn@`UmÒVxUbI`UaÝÈ"],
                    "encodeOffsets": [
                        [106774, 30342]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5109",
                "properties": {
                    "name": "遂宁市",
                    "cp": [105.5347, 30.6683],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÞĖUxlJXVb°@xUÞmbUxbXbm¤VX@lk°ln@xbÈ@lLVlVUXxlJç²UlwV@@UÈWlLw@wVwXaWm²¹@»lī¥w±I@V@bl@kLUllUVVn@mmUwXċbVb@VUkbmamW@ka@k@laUa@¯b@mmwó@@lkXUa¯°LUamm@ókXUb±bU`kLm¦bnVmbnVmô"],
                    "encodeOffsets": [
                        [107595, 31270]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5103",
                "properties": {
                    "name": "自贡市",
                    "cp": [104.6667, 29.2786],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lIÞÇbV_JVaUwnÑV@_lmnlab±UVanVxkxVlV_`wVLlXnmnb@WbnJ@n»WaKl¹²@mVI@KÞVlJnw@aW¯¯¯UmVanL°w@akmmUxmULWxUUÝKōèUKUkĉKL@ÆnX@xWÈ¯@Û»nÇÜÝLka@bKnUaVm_xkLX¦Jl¦ÅlVb°I@bnaUmlUVUVIUKa@nmlnLlnaJUbV@"],
                    "encodeOffsets": [
                        [106752, 30347]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/shan_xi_1_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "6108",
                "properties": {
                    "name": "榆林市",
                    "cp": [109.8743, 38.205],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ýVnIW»W@»kUÇLÝU¯¥ÇIUWWÑUWwX¯m@»n@ÜÈķô@a±kČ±wÑmwçċmU»ÆkkVyImĉÿ@Ý¹WnwÇVÅazmmĉ¦ókVmxxU¼VkVm_UlVlk°IVkmJa¦kLmmV@XmKnlUôVXbb@UaÇLğÜÅw£mKnmċwÅ@UkbmaVn@m¯aUJm_k@kWXyl@@kÅamwLUÞmWÅzUKUk±@b@nnKbX¤mzVVxÇn¯@ÒknWVUbkķÈÑWkk@VaU@mUkbÝÅ@Ý¥ÇbkĬXV`kLÇVmalUUanV±nwmkJ@In°KVw¯UnÅ@¥U±bUU±mWbÛKWnUm`UƒVK@bmnmÈÅ¼@VL@xxmŤ°n@VmK²VllKkô@êÜV@VXLlm¦UV°Ș¯²ÿ@¥@ÆĊ²ImĶnnb°bKVĸLlÞ@UȮÜ°IVÞÝÞlx@ķĀWUxèÆ@°XnlĊĖ°mnV²V°ÒÆ¦aÞ@zll@bÞĀl¼nKĊ¼óÈb²±IǪÒ¯ĖV@lxnVlkJlaXwŌĉ@VnlÆĕUÆLèŌŤôxÈlU@xlaUċĕXmIWmnkVVVW_@aÈWUUmk@¯çVm»±W¯n¥VmkXw±ÇVw"],
                    "encodeOffsets": [
                        [113592, 39645]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6106",
                "properties": {
                    "name": "延安市",
                    "cp": [109.1052, 36.4252],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@kkÇmImUwVkUU²WmVkm@m`mIĢĕUVa@mXÿVVkyUýĕ@l_UmnWKVkţ¥awğ@@aôWakUma¯¯a±£kxmmxUwÝ@xmUb¯KwóÝ@kmm¹Ub@lklVbmnnVUV@xUknƧJUX@LÇWkwLķƧÅwWJkLkþĉxWzJUnÇk@Ɛk¼ÜÔÈKè@°lÈÆk¦ln@l¼@l¯L°UUVÇ°¹`m¼mXkbUaV@U¯x@¦ÇUUmlmUVmnnmlkw@@¦ÅÇLmx¯Ikl@¦mÆ°VUx¯Lm@JInlmxU²mVbkVbUnÈlKU_WlīÈaÞ¦Æ@ÞlanV@VUbl@XlÇÒĸlVaUXlm@Ñ°ÈmUwUnyW£amL@ma²@lVVLÆynXÝVKnxÆb@lk@WzX@lln`IV°b@nmUnbaVlÆ@ČxmnnL¤ÆxĠÛÈKVb@aWaUókVmnL@WUnnKl¥bnIlU¯JlUkVkn`lUUV»wnwlUôĊ¥nnyÆb"],
                    "encodeOffsets": [
                        [113074, 37862]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6107",
                "properties": {
                    "name": "汉中市",
                    "cp": [106.886, 33.0139],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lKnb@nlWb°bkxĸwVb@łnlĊ¥L@XlÈVblÈKbakVwôml²`n@nVKlk²xŎ°¦VUJĊw@çnWçÞVkUóÛ@¥kwUmX¯WÑk@UymIUwlUn¥mUk²a°¯V»@ÝVÈÝċÅÅVl»@l@a°±@_kammÅba@m@Å¼KknõĠ@m¯LÅwLVxmb@¼kV@mw¯wVakKW»X±¼¯Vkxb¼W@nx@x±bóakb@ÝmU@ķÓÛLkVUmk¯¤ÝLUlÝ@Ýzx@x°bmX¯aUJW¯k@bÇWwÛwWx@XWlb@VÈUlwLnl°VlUô¦U°¤VUxVXUxlbkVVlI°ÅVlU°m@kÇU¯xUlLUlVL@b°ĠInĠ°ÈnK@xÞa²naUyXUKVkWô¼Èaz°JXUVÇV_JVz@nb"],
                    "encodeOffsets": [
                        [109137, 34392]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6109",
                "properties": {
                    "name": "安康市",
                    "cp": [109.1162, 32.7722],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@bĊaƨèwôô¼b°aXVÞVUÞ@aXm¥kImx¯¯V@anU@UÇéğL@¯¥V£m@ÝÈbKX°wČÿb@xÈblxÈ¯ĊmÆUVnÈ@ƨÜLĢ¥Źn°VnnKaô_ÈwUaXmnW¯klLXÇō¦ÝaÅVmbğUn¥±wÅéVan¥U»°am¥£Ý@wVw¥nUÑUmmVwmķIÅaóVWxkblb@ból@ğÒĉ¤ċX¯XxkÇ@óÆÅx@xķ_kmÝÇ£kblb@`¯²@bk@k¼ÆUČÆÞÇÞU@U¼¯°±bVlnm¦kVVxnJVz@lÒXW°nVlx@¦ôÜVUlÝXèm@è"],
                    "encodeOffsets": [
                        [110644, 34521]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6110",
                "properties": {
                    "name": "商洛市",
                    "cp": [109.8083, 33.761],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@²nlôb°aVwnKÞI`°wXôw°VĊ°@ÅÞÆVzÞK@x@aLÅ@b@nLl@lnmnLVwabVVnbU¼V°blbÈ@ĶŦb@nÇ@amIyUI@ĠVmôUVwkwlanJ¯lwó¥@an°J_@nóƒó@£l¥UwmaÑ@Um±V_J£JUW¥¯@_k¯¼mUVUè¯b@wmL»ğVmağI¯¤ċIUWXKĵ¦ķaJUbIlUóVmk@WÅÅÇ@mUÅVnĉÇ°kwÇa@waċĀ¯xWLÇa@ÞnU¤°¦@ĠKÈê@VmV@bU°°nwlJn¦WbÝ@V"],
                    "encodeOffsets": [
                        [111454, 34628]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6103",
                "properties": {
                    "name": "宝鸡市",
                    "cp": [107.1826, 34.3433],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@£@°Ib@¯°ynŹaUlU£Umĵĉ@@ylUÞ@@£kWU¯WaU£¯ÇV¥@kb¯wn¥ÇkUÇnU@¯±kULm@m±_kónUxlbaÇLkUaÇkW@Kĉ¦km@ŁUaķxlw¯aXak@mmakL@mÛ@¼m@lXV`nKU°°@²¤UÈ@VxmôxKlVV²aVwXlaVlx@UVnÇnk°VVLlkIJÇk¯V@knÆn@lznmlVkzVVVx@Uxz@x±¼VxxUlkb@¼ČkVXlĠkôV²wLUKlwJ@aIV¥Þn¯Ün@nkl²kÆ@°aVbnI@Ťn"],
                    "encodeOffsets": [
                        [110408, 35815]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6105",
                "properties": {
                    "name": "渭南市",
                    "cp": [109.7864, 35.0299],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@ÈôLxU°Þ@mÈnl¤nUôLwX`@ÞÝLUmLôôbVbnºlnÞ@ôx°LanVwÞ@Vxnwnlw²¤b°°bVnlXbó@bĠ@xb¦ŤVXġ£W¥ƽɽó@ýóƝÝ»£XmƅĊkU@ókťaĵÇ@aka¯UV»maUUabUxmKnkm@kmK@xó@¯n¯KÇ¦@ôÅèlxkx°nƾ¯KU¯WķL@VÝIUbyWbX¼Ç°"],
                    "encodeOffsets": [
                        [111589, 35657]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6104",
                "properties": {
                    "name": "咸阳市",
                    "cp": [108.4131, 34.8706],
                    "childNum": 14
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@IXyĊwlýKlXIVaķ»a£¯aVU@awÈōaL²»VUln°WÈ¯W»XazVaÞJ@U»@¯Ýbğwly@£kÑţ±WÑ@kaIUn@¯ómţUbU¯lÇIÝb@¤Ý@kV@zĊ@ĶnVV¤kVbmź¯z@°a¯J@¤@bUxb@`xUÔ±ºVXWUnUJLĢ¯ÈKlblmÈXŎ°U°LlkÞK@Èxl_°ĶUÒkbl"],
                    "encodeOffsets": [
                        [111229, 36394]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6101",
                "properties": {
                    "name": "西安市",
                    "cp": [109.1162, 34.2004],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°²@mVVÈÈl¦m°xla@U¦°ÈV¤XbV°lXÞaÈJ°kVaŤVôn°@mVJlb@XÒŤ²lÒ@¤kzĠxÞa@°¼ĸK°XV°Lƽ¯mlwkwÆç@óÈ¥°L°mô@w@aÆK@b@wÝLyÅUÝÆ@ĉ¯¯UóxW¯x_ÝJmLUx¯bóak±mÝUUW¯ba»óóxƧçĉbaĉxIUV¯¥ō±wl"],
                    "encodeOffsets": [
                        [110206, 34532]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6102",
                "properties": {
                    "name": "铜川市",
                    "cp": [109.0393, 35.1947],
                    "childNum": 2
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÆxĸƨKlxÈXK@VWƨIlmV@wVUmUnmUalk@kVaUaóaónKVÞK@ÝW_xóKmVk£ÇmnÝ@¯VwóK@Ç¯XkmVU±¼KbÇŎx@bUV°b¤b¼ĸUb"],
                    "encodeOffsets": [
                        [111477, 36192]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/tai_wan_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "7100",
                "properties": {
                    "name": "台湾",
                    "cp": [121.0295, 23.6082],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@\\s@pS}aekgKSuSsMß`¡CqZ·be@Q^o@gieMp]}}Ľc_Kk{ùA¡r[uom@ÑĥJiq©mŉq¯Bq]ÙYgSåk_gwU­isTEĕiqiUEkue_OSsZaWKo¡­qycY£w}ĩĕS§Z©SN¥SyLÑ¡±Ks^IYPdY[UoFp}´\\¬\\j]eÜò¤¡ā a\\bnUãº¹Ìs¼j®[cíȈEĝĆ`ļf¶®K|VØDdKGpVnUFjpHF`B[pMºxÖjbpÎxp¬|ÎŸÜÒC²®ÜApZG~dÞàV¨|¸`|²tx~\\~|dFf^zGĄŚhdL\\hĸ¼OªP®lV`p\\]Xpllæ¤CpQ|oF}fMRiNSon_²qämMNM\\"],
                    "encodeOffsets": [
                        [124853, 25650]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/xi_zang_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "5424",
                "properties": {
                    "name": "那曲地区",
                    "cp": [88.1982, 33.3215],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƨʔĸbÜºÞwnxźbÞ°ô@ĶĸIÈ¼ĊJŎÈôUÝƒ¤ǔLÞŎ@ĢȘblôLÇźçÈ¤ôL¥ÞIÞ¯ĶxʊťƨƿÑĉXVķŦ¯ȂKÇǕÑ¯IU£¯Óƿ£VĕÅÞÿÆwƑ£ǖxÞĕ±ÇÝaUÑÈU¯UōÈÝwWŁĵ±ÝóĢÿ°IÞ±mÅĢ¯mÿ¥°UnÑŤĢĕĶwǬŻͪwŎ¼źÇĢĠĕˎŁ°óƨ¼Èam@¥°wǔǖ°ƨÇŤġƨŎŃôbÈÛŎĊ°@Ġw²ÑÞJÆÆb²°êĊUÞlÈ²VÈKĊÒĸĉ»ÅôťUÅÇk¯@ÇÑklÇÅlĢVÑó@°@ÛĸV¯ÇĊn¯Uĕƽ¯m¯bÈ@Ò°Ĭbĵ¼kxķýÇJk£ÝaUÑÅóĶǟkÓʉnĉÝ¼Ƒó»Þmn£mČ¯@ȮÿV¯ĸk@Ýów»ğġ±ǓLōV¼Əèķĉè±b@ÒţUÑóakl£Ó@¯L@ÇlUóȁ¯aġÈÅĕÝLķ¯Ė¯@WĬxÒÈnW°ţôU²ǓÓġ²V°¯ôǔÝLċk»Ý»Ý¯ÞVwÛÝÇōͩÈĉċ»ĉm¯£W¥ţKkóġƏW@¯±kōÈb@ÒÇaÆ¯akóÛÇ¦Ýa¯Ýĉ@Ç»ÛmǓxķƛ¯lVĀÅÞġbÇJUÅVĖƑWzō»ōWn@è¯ÞóVkwƩnkźÇÞÒÞ¯ýğÇUxÆÈnè±bĉÝ»ÈŃwwÞ@m»ÈV@ýÇ°ķxaÝ¯Xċ¥ÈóW@ôkxlnxVÈóĊkŤġ¼@°¯ŰƑL̻Ű±ŎÝVÞVÇÞÅÇakƞ@èğŎĸżƾ°ÒLÞôĠKȰĖźVÈÒĠ¤VôUÈþťL@ôǬÞlÜÈnÇÒUŚ@ĊƨW°°X@ČÇþƴĉÒķ¦@ĢôWĀôłUÞĢǬź°¼@ôV°bUÆnzm¤ƽĸÈ"],
                    "encodeOffsets": [
                        [88133, 36721]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5425",
                "properties": {
                    "name": "阿里地区",
                    "cp": [82.3645, 32.7667],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Çƾķn£myVÅaU¯ó@¯»ŹġǫVÝóŁXÿġó@ĸ¥ĊÑƳÈý@ċW¯X¯ĉƧ@VřÈÑÇmkÛǫÝ@óŦKÇýVUó£ğÇÑŹUȯĕğLÝóK¯ÑƽķŻĠō@çlƝÈbÆÈÝUÝÞU²ō̼ůƒK°ů@¯UK±ĊƧbōÇmçÈġóÅóbźó¥kīÆ¯ólçKôĵUÅVŃķ¥nÅŏm¯¹Å»@ÑÇóxÝkʇȤU¤ķb@ƒ¯ĊÇx¯ĸĉKm°Āk¦lKnĬȀƾÛ¦WÆÅmǊĉ°ōUţ¤UŎ°ŎKÞłÆǓ¦Þř¯bmUÝl¯Umğl¯£șwÅǫaÝnĉĶk@¯Kō»ĉnaÞ»ťnkmlĸ¥UÅŻkÑťĉVôó°LôīĠUÿĉǕÅz±K¤²ō¤¯Ė¯UÝ¥VĵóÈťÝwķÈÑk¤óWýĵĕVĠVóǓķ°k±VU±ţ¦UǟÝÅJVÑ¥XUċUÅlÛƆǕÆȗƆ¯wŏÞÅ@ĉlÝóÒnUôÅlxólÝôÛ±LÛôÝL@ġ¯X¯ÇUÅ¼óaó¤¼XÒġŎóLk¦ôÅ¼ĸĠ¼KġƆô¦ÆƑÔĉĶ¯ImÒ°¦n°¯ÞlÝČnƒÒKĠÞĕklýƾťôIĖŤÒnƜm¼¯lnżóÞ@Ůó¦ôƽĖċŚn°Ý°ôÈUƜblÞó@ǖô°UÈƆ°XþôôlѢ²Ėm¦°@¤XĊblÜzkºƒĖmXŎWVóÞn°lĠxȚa°»żLźb@Æ°XĠÝȚxĊĕŤaȚ°È@@èŤ¦Ü¼WÞkÈ@V°lŤkŎ±²¦ƐUǉ°aÈÑŎbĢŎbÆ¥ÞIȘlôVÈUbkɲĶnmnXb̼òƾĖŎ@ĢȂÑôÓĠĖʊĊÔ"],
                    "encodeOffsets": [
                        [88133, 36721]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5423",
                "properties": {
                    "name": "日喀则地区",
                    "cp": [86.2427, 29.5093],
                    "childNum": 18
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĶĖXþôl£ÒĸÇÞxÇŦôUĶÞ¦°V°ĕŎ£±£²LÆyĊǖĀğVóĬ¯KóôUĊŦlÒżVÆķ¦klnŦmÝ¼bĊmŎ¼L@°lĊĵÞmǬbÆȚx°¤Ġkn°VÞkVn°aŚÝǔ¥ÅÝŁōL¯ōVŤ£ŎVĊ¯nǉÆXÅÜ¥ǿƽmīLkl¥ÿn¯ĊL°ķÈw°ĉ@ƑĸaV£ʈȣÞlôwÈ@Ò¼Æ°ºŐnmÆĸ¦UńÆVóĶLèôkÅ°lĬ¦ŹôôaÆôÇĢnèŎÈƨaĉ²VLĢ»lţôĉUÇwkmlw@óôXÇČ¦°WÞbwĸÈ¯@þÇUn¼Ý@xxÇńÞ¼Ċ²amçÅÇVwĠÈþ°ÝÑÈÝlŹƪmlxôU°Ý@çmXŎŎ¼yƒXĕÆUVÈIĢaÆÝUÿ°kĸƜǔwnÜÈ¼Ċ@Þ°ÞbÈ¥Üôl°bÅÈb@ÑaÇ¯UU¯Vġ»¯aV¯Ç°ÅmnÑŤçǬVǬ±ĉ¯¥Vĕ¯Ýk£ōw@±ġÛ°ÇVÑ@Ûa@ČLƳÇa¯¤ÝIĵ¼U¥ƿōķÅţŻókÝóĕ¥¯U»Æ£X¯ġŃÛkÝ°V°ó¼¯èWôÞĖȎkĀƧĀówm¥¯JÅ¹ÝJÝōVVÅaÝƑ@ğŭÇ¯_ĵVnxÅónĵxÇĖĉVÝÈğVÒó¯±Żĉ£ķÆÅLǈĉýţÛ¯VnV¤ÝÈ@°ÅÞÝ¤ŰğŁm¦ÝxóK¥ɱÈUĠôêVôÛ¼ÇWÝçĵaō¦óĖƧlÇĢƑnŎÇV¼¼ºÛ@m¦ƽĉmm¯ÝKÛç¯bŏłĬb¼ÅLmxť°ÅUÝXkÝmĉ¦W¯KÒknÝaVÝè¯KɅńÝKnÞ¯¼"],
                    "encodeOffsets": [
                        [84117, 30927]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5426",
                "properties": {
                    "name": "林芝地区",
                    "cp": [95.4602, 29.1138],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VÈłVôÈk@°K@Ôk¤lôbVÒŤ@Ñ²açĸĊƐçU»ŎǔKĢ²Ġ¼ôx@ÞlƨĬUl¯ÈLVÞJ°ÜnʊwÜbXêVÞ¯°anaU°wÆ¼ɴÑWÑ°mÈýÈam¥Þ£Ť@¥ôblÞĢź¥ôxÈÅmÝĕÅV»ĉōŤōnó»ÈīķIUĠÑ°ġĸLÞ¯VÒÆ@Āb¼WôÈ@V¼ôóŤKÈÑU»wVǫżnWÒÈx¼lŦ£ĊōŤx²¯@ÆU¯çÆ@¤°£é°k°lůÈó@¯ŤÇÈĉkkÿó¥ÝXķÑÜ@ÒóŚÝ¯°ĉówÇ±¦ÅJUÒĉĀķw¯°mĖ¯±akxÝÅn»lÑK@¯lU¯UVÑ¯óĊ¯mōğVǓƅÞWÝÈÛ@ƿô¯ÜġzÅþ¯ólmôʇġĊÅUͿřŏȁˋŁóÇˡōƧÇbw°Ķôk¦ÒnUþġÒÔkǔķèó@²@ŘōńĵyzġaÝ¤ÅI¤Ƀť¦ğÑ¯¤ķbó¯ó±U²°¤ČÜVnÈÆŚŎ°ôĢþÆzèVĀÇĀÇXŹÑ¯¤ówċķk¦łUÒġzÇ@ÆÝx@²Þ@Æ¤Uô¦U°xU"],
                    "encodeOffsets": [
                        [94737, 30809]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5421",
                "properties": {
                    "name": "昌都地区",
                    "cp": [97.0203, 30.7068],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VĖm°ĉÈU°ķÜ¯@@ôUÒġkÆkÈlÒ@Èl°ÈVÆóŦÆ¼aÅĢɄwnōw@¥Ŏ¦°ŹÞmV°wnÿwwÝw@¯mÞŗ°wĠĸkÞğlĔ²¦°@ĕĸwVóal@nĢÇĊn°@¦źUXçǔůĸVÆKÈÝĠ²ÅĔô@lÈ_mzǖlaU¼ôwV°¯¦ĬÈal@ČÇ¼nIxô»ɜ@ƨ¥ɆŁŃǪȁkƛƨȍʊȡóĭ@ÈÇVůÞĸƅmēƨťÅÈʉVǵ°ġVŭÅɧ°ÿnɛ£mķ²ŃóÑUĉ°mÇ»¯@mxUĀ¯èţ°ȁÝçġU¯ÆÇţÈ@°ÇôŰ¯k¯lê¯¤£Å@èV°Å@±°ţwĉŎť¤k»ÇwXÑŻmUǬxV¼ÇÒţLóôU»Ç@Xó»a@ÿÅUÑÝ°ķK¯ĢğÒVĸJÇĬ¼môţŎĊŎU¼ÆĖnÞÇÆówŹ¦ġkÝóa¦ţ@Ý¤n¦ÇbÇþ¯nXÒɳÒÅ»¯xVmbb¯Ý°UWéÛaxʉÛm¯ÝIUÇKk°VƧīķU°ȭĀ@ċ°nm¤Ýnô¼ƒÞ»ĊʊmlÔĵǠÆôVÒÞbl¤ÈIĸþlw»Ķa¯ī@ÑÇ°anƾ°"],
                    "encodeOffsets": [
                        [97302, 31917]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5422",
                "properties": {
                    "name": "山南地区",
                    "cp": [92.2083, 28.3392],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°ÞUĖ°¦²ĊôÇÜLǖĀɜȘŰÞLĸźêÞ@UÜUŤ°ɞ¯Ü°WŦĀmŎ¦ĢyVÑŁl¥Čĸôx°£źÒWÈÿÈUÿçÅyýóġō¯řÅmÇÛUċ¯£V±²°ôôĸa°£ĠÒŦ¥Ʉ£ÆJÞ£ĢbyĶzŎŃ@ŗ±ô@ĸçlǓÓĢÑVýmÑl¥ĵó¯̻̥ƛǫÝһÇƧĉyţ¼ҍēVĶĉŎ°ĸmÞVÝĸÒÛaċóŹĖèÈÈl¼k¤ÝX@`Þŏ¼Æō¼ÇçĉKUÝÝ£ğ¤@¦ġl¯Òġĉ¯ómóxÝÞğVƴċK@b@ÜUÒ¯ÈĢÜ@²xŎl¤"],
                    "encodeOffsets": [
                        [92363, 29672]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5401",
                "properties": {
                    "name": "拉萨市",
                    "cp": [91.1865, 30.1465],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ŏ²l@°XĢƐlôŤLX¦°¤ĊnČ¼ÇĊŎͪÞÈÜxU°ÝÞÞ¼¼lČÞKǓ°óU¯Ģ±ǔÔV±ŤóX¯ÇmÑwXī°@°ĕĸÞKÆĖĢÇ°bȂÇŁUV¯wVó¥VÅ£Ý@@±ÞwÅÈ@¥nōťÿ¯XÛɝ°ţ¯ÛVVÝ@ŹéķÝKȗůɛǕÿÛKóÈǫǫUţèmÒn¯Æ°ÈU°b¼UĢV°°V"],
                    "encodeOffsets": [
                        [92059, 30696]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/xiang_gang_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "8100",
                "properties": {
                    "name": "香港",
                    "cp": [114.2784, 22.3057],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@}ScTʟ@cWuJÁ]l¦RLj¼BĄà H@TOHCTDDDHDNAT@PEHDDNJLX@BABALHFF@DKHADBBLDHHFBLEJB@GDBBFBADDB@@KFAFBBJJA@BB@@FFDDADFF@FADDDBJC@AFBD@@DDD@DAA@D@DB@DHHBFJBBFEHDFAN@DGDC@DLCBDDCFDlAFBFCBEF@BC@GDAB@FD@DZJX´HĐMja@Ý`p_PCZ@lLnRGSDMFK|a\\Y}­§Mën"],
                    "encodeOffsets": [
                        [117078, 22678]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/xin_jiang_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "6528",
                "properties": {
                    "name": "巴音郭楞蒙古自治州",
                    "cp": [88.1653, 39.6002],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@ÈÒĊanwŎVȮ¦ͪŃĢÜōȂçČéƐżLɆóĊĊaʊŁ±¯²Um»ˌmÈ»VʠţWÑÅ¯ǓéôƑƒğÆīŎī@Ƿwô˺LÞ¯ƨVǪÑƒĢȘV°wĢôk°¯ƒ»΀@Ȃ»ĸǔ@΀͔ôôLɆó̐ÝɜLɲōͪƨóŤK@ī@IU܃ÛmȻţǩÝ˹ÛǉťǓǫō@Ɲ²¯VçōKͿŁΗÇţ»ƽɅƑLÓŏÅÅɱV@ÝĊU¯ÑĊĭÞLÞŎJ±̃XȣˌōlUÈ¯ŎKÆƅ°XÑÜ±nŗġV¯óaUƧUōŁÑ±çɲ¥lĉkğ°k¥nğţL¯ÝÝUƽĬ΁lķ°@ōXÿÝ¯V»ŹLʉÞɱŤĉó°ÝJ¦ÝKÝ£ţÜÈĉ@xǩUċƑ@ky͓¹`U²ĉVġ»ğa¯¥ť@ĉó@ŻÛÛJw¯nó¯ġWƽʩķÝɛwĉĕÝ¼ȭÞķō@ó£Å΀Ƒ¯ôȯÞ¯ȰÆōèĉXÇ¼ó@ÝnºĸÞVƜĸȚUʶõˀĵĖɱŎÝĖVࢰӒѢ°˘nϚVˌÈmɼĵŦW¤öʊõʔ@°ÈXVènŎȁb¯ǫĉ±Èğ`ġwōÔğ»mVVÝ¥ó@ĸķô@bXĶmV²²`Þ_ɴbͪÈ°ÞWĸÈŌmÞkɲÈUÆ»n¼ǬVķĸźô¯°n¦ɄÇÈ"],
                    "encodeOffsets": [
                        [86986, 44534]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6532",
                "properties": {
                    "name": "和田地区",
                    "cp": [81.167, 36.9855],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƨ¥èź٨ΘƑᩄbUࢯÞĕɲōĶĕöʿVʵķșUƛÝķm¹Þô@È»ĊWŎçÅ°ȯȰÝ°óƒÆͿĉ»̽çnmɱĵƧºóUƽ@±wóL¯°̻L±Æ¯Vƴķb¯VÇ¥ğ²Ǖbk¥ÇKlÅɱġ@ÑóK@ÇaÝXğţxĉČǫķê¯K@ÑaŹƑK¼¯VóaónġwóÞéUġbóĉğÇl¹aUóğKWVÅ¯nÇŋƑķnʇ»óxĉwçÇ°Åw°ċXób±kÈÇJm²ţx@ÒÝŦÇºnó¼n°ÇbUÒ±¼XĸĠłƽXmwĉºzÈÜmnxmx²ĖmÒbnƧêUºĊêÆVóĖóUĉ¼ÅĬƑ°ɆƆŻŚlłÞL¼nĠ¼@ÞÞź@ŎÞ°VɄɴжϼِ͈Ŏ"],
                    "encodeOffsets": [
                        [81293, 39764]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6522",
                "properties": {
                    "name": "哈密地区",
                    "cp": [93.7793, 42.9236],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WnŐÆĶLĢ¦ţºźlxÅĸƽŚɄĮè@ô²ÞUĔƐńV°¯ĸX¦Ɛm̐bƒ»Ɇa΀ĢƐLˤȘÑnІǉĸÿn¯ĶaŎ¯ĢĕȘ¯°΂la¯¥ǕǔwˤӱlťО̻nŻmɃĕċţUw°WUóƨÅţķ°ýV±óÅǓéʉ¯ƽŁéōǖȁÝƏůǕw˹ǫȗǓƧǕVýé@ĬţLƧôͩɱŎɛK̏ÞɅôóK@²@°ōŘ¼lŦ¯ŰóƜÛlV¼ķ¼°kȰŰĠǬŚÝŎmĖ`@ÇÜn"],
                    "encodeOffsets": [
                        [93387, 44539]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6529",
                "properties": {
                    "name": "阿克苏地区",
                    "cp": [82.9797, 41.0229],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VÆxˌŎÞŎ°nȂÒ°²VĊ¯VğƾˍǬƨÞÞKÈÞĊVźôɆÞĢèŌôWČ²ŤVÞĸʶbl¯ôn_VÆĸlmÞnVź_ĸ¼ȮmǖéĸW°°ĸJkʠ¼Æw°¤ÈlxɆzČºĶI²ÆǔU°ô@Þ¦UnUĠ¼ŎÓĢxĠ_²ÇĊǬ°ȂamōçUÇW@¯öʓõʉX£ĶťnɻÇUˋmϙ¯˗ӑѡᩃaΗƒɜ°xWƴUxɃÒˣ¤ɅwğʉōóÝŹ±°ȗ@¯Æƒ²¼", "@@ōгwȁ¥Ƨ°ŹÑķV¼ÞêĊ»lĵm¦ÅW@ĀôÈźaɜxÈbÞÆĶIОŘnIÇŃÛÝĊÑĠƏ"],
                    "encodeOffsets": [
                        [80022, 41294],
                        [83914, 41474]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6543",
                "properties": {
                    "name": "阿勒泰地区",
                    "cp": [88.2971, 47.0929],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɲˣĊIÈ¥ÅU±Ċýkō°ĉƽó»ĶƽXóʵʵȯƑÅȁɅ¯ĉ@ÇሗK֛@@ˤV֜ʵрƒǬVĸƑŎ@ƆϯÑóķ@ʇ»ķ¦έmlÈĸĊX¼WźÛÞÝѸĢČþĀĊôάVö¼ĊUƨ°°èŎČUÜÆóôVôô²êȘlˌç°`n²ǬĊaÛ°±kğmm»@°ÝɆÛÅÇVaÝVm͔ğôÝÈb@n¯ÜUĢÑĊ@źīżWŤÈǖWôŁÆI²ÓƨL@ĊXmmÑÆ»ȰÑkĶō@ý°m¯"],
                    "encodeOffsets": [
                        [92656, 48460]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6531",
                "properties": {
                    "name": "喀什地区",
                    "cp": [77.168, 37.8534],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Č@°ĠôÓô@Ŏĉ@Ƴĸ@Ť£ĢlVôWVóřXĉŤêÞ@ƐÒĢÑlèÈV@ĠIk°ÆŘ@ÈÈĀ@ǶťÒğ@@ÒĉlŻ_@ƧĖÅĬōÆ@bźÞnƒlVÝĬWÆ¼ʇÝÅ@ÇÅÈwWóĉ±ğzĬČƨÆÝIĉÝ¯bÇÑĉ¯ʈV°xUŰĊ¤ƪ_ôÓɚI@lȚXȮŎlɴȘ՘¦ɲÆʈ_ɴźôÞʊŎĠɆxˤ£ɄÑVwXƳ¯wɛŹ٧çƧ¦ōُ͇еϻɃɳUÝ¯@ōÝŹ@Ý»mğ»ÝKkŁżřɅƅƒ¯ÆīĊ»ôVôĕÅUĉéV¹ƨémanÑ±ĕnwmwnÇÛyĉ¹ŹlŏkĵèķmōÞġKñÔċKÅèĉzômxȗÿƿI@þÅČÝKÝ°@¼ÈVº@ÅĢÆUċłnÝÆǕČĵJm£ÝJ¦@ĊxV°ƏLċ¼ǩ@m@ÅĢómÇÆğ¹ÇÆĖÞKxwô¦ÆÑÆL²ÆƾU±ŚÅŻĖ@ĬŤÈñ@ǔÇxÈÇƒ", "@@VÇţ°ğUĠ¯mk¯ó¥ķIġÿƏbĉa±ÒĸĀlKU_m»nwm@ÈŤ¦ĉbÞ°±Þżł̦°ĢŁVé"],
                    "encodeOffsets": [
                        [76624, 39196],
                        [81507, 40877]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6542",
                "properties": {
                    "name": "塔城地区",
                    "cp": [86.6272, 45.8514],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ήnĸ¥ʈ¼ĸ@ôϰÒ@ƅƒōUķƑǫʶпU֛܃LګK@΋ĸ@Æ£ÞġÅĠċLVÝ»@Å»Ýnm¯»nŻĊ@nķŃ@¯ómóÛÝǟ¯aÝóȭ¥ōUmxĉbÇÑ@bUº¯X¯ÆƧbVÒĉnǕw¯°ƑVÇ@kx±UɱnÅK¯ƒĠǠU°ɜL@°xnĬĀŋŎÇLğϱÞέƜkôÅĀǕłĸĊŤUŰĢ°¦ȂϰÜɨ°x@°żǠÆƈČVĠ»ČL°ÇbĊÑ̐óÞlĶwÞɆVÞwǬxǪţÈ¼ÜLŐĶˢ@", "@@óKĵĀV͈ĉłƾǊÆŤzXl°ÆL²¼źôÈĢǔ¦lô°ɜÞʊĠğÅm»ʵƳƑʝȗīV¥¯ĉ°Ñ@ŃÅI»ĉmğnaċƨbVğwġ¯@UōaĉÝJğÑÆŎkŎÞĀlź¦"],
                    "encodeOffsets": [
                        [87593, 48184],
                        [86884, 45760]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6523",
                "properties": {
                    "name": "昌吉回族自治州",
                    "cp": [89.6814, 44.4507],
                    "childNum": 7
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@መL@È°ĊȂɆƒÆĊ£ťôWÓɆbĢÅŎÆ¦ČÑW¥°ķU¯ƏŃVē±Ý@óçĭɃƾřÆķkwŹŤ¹ġ¥ĵKŏÅXmˍщwǓ¤Ƒ@wóōVķ£ɱġôÛa±ÒȁóèţIVƽ¼k¤ó¹ġJmx»ÝU²@ÅÆĸǫŎĊmŎǬ՘"],
                        ["@@Þô°bÞǠôÜôn@°ĸńǶkł¼UÞKğČÆÝĢÅ¤ķ@@ΌڬL܄K@ˣȂ˭lĉÅW¥ĵVÆý@ŃÞēUŃȗƅ@ŹƩǕĉ»k»ÇVğóřXŻKƏċêȁèÛŎġͩń"]
                    ],
                    "encodeOffsets": [
                        [
                            [90113, 46080]
                        ],
                        [
                            [87638, 44579]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6530",
                "properties": {
                    "name": "克孜勒苏柯尔克孜自治州",
                    "cp": [74.6301, 39.5233],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ˎǫĠƽ°UUĉ¯±ȁÑm¯ÝōˋōwUÅ±»ÅƑ°Ș@²¯ɳʇ`ɱÅ¥՗ɳȗōkȭșW@kəJóÔƩ`ĉ£Vů¯wU°ʇĊÈÒ°aĊÞÞJÅċƧīĠyĊ²XôÇxÈÆÆ@ÞʈÅ»XÞīUƑkmŹÝ@aŎÅÆīƨĕ@ż`Ċk@ÑĠ@ŦÑ@ǵÇÿ@ÇÅŗl¯ğJ@ÇUkçġÒƏÑÝ@ţéWĊôŚUóXUġkţ¤ķ@@ƴōĊó@óÔğ¯ċ@@Ò¤kôˣŰ͓k»KX¯ċwƧôğɐÒôIVÆ¯UķǬķn¼ôb°ÒȰVVÈÞ°ĸó¤V¼°V°²êlĢÒUƨ¦ôȰƴĊVV¼ǖIċĊÞɜénČW˸ǸařÈw±īçĸ¤ĊôwĸUĢ¦éǖĬĀô¼lÞkÒ°x°ƆÞxÆV²ǔ»b°wÞȘ¥°nŎV@°ʠèŰȂb"],
                    "encodeOffsets": [
                        [80269, 42396]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6521",
                "properties": {
                    "name": "吐鲁番地区",
                    "cp": [89.6375, 42.4127],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ôKĉǪa²¼lÜô@ʠê°ĬôȂ²ÑÜbĢóɲĸ¤ŎUô@xƒǔ£ъxˎmÈÛ@_nĕÞōřǫğůlȯ¯ĸ»U»Ükôƛ°ůkť»Ŏŗ@¯@±͓óͿǓ@ķȁ¼Ϳ@Ƒ¼¯°ólġ¯xȗUġƑǩÒƧUÝ°˹Kóx@ǸōĬÅĬƑĠóƒǔêÆ°XÒʟŤUÇ¼ˋnn¼±V²°ȂUŌÝbʟǔɅô@żǬaҎÈ"],
                    "encodeOffsets": [
                        [90248, 44371]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6540",
                "properties": {
                    "name": "伊犁哈萨克自治州",
                    "cp": [82.5513, 43.5498],
                    "childNum": 10
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ĉÆŘȁ̐mÞ¯ĀX°±¼@ƾ¯ƴ°ŎÝþŋ¦WÜÞbȂĉźUÇmwVUȂóô@ȰÝ΀nÆJnƾʠŌLČóǪ¯¥ǔaǖŌaôÝĢLxÆLɲm²VlwÈ@Uƒ°¯ǖxĊmUÑƨa°Å°WV¹aÇɃÈm¥°¯ŹóĸķǫUm»Å¼ÇVɱlÝŋnķÇÝX¯ͩÇɳaÝ`±_U±ĵnWa@ĸóķ¯ǓV±ÅĵJċ¹ɅykwÇ¯£Åxʟ»lķI¯X¯ķêǕȭnķ»Ź`±kÞ@Ýô@Þ°xŤŎIƨÆUxō¯²ǔĬǬlUŚ"],
                        ["@@ÞĀlź¦¯ĸŤKÞċƨbVğwġ¯@ţƽJ"]
                    ],
                    "encodeOffsets": [
                        [
                            [82722, 44337]
                        ],
                        [
                            [86817, 45456]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6527",
                "properties": {
                    "name": "博尔塔拉蒙古自治州",
                    "cp": [81.8481, 44.6979],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ήƛϲÝĠÈKŌōÿmīw@¯ɛKV¯ğǟ°ƑwġKóÞŋbǕǓb¦ǩ°ċôŋKʟƽmÅImͿȯÞó@ȁôUVnxÈŹVȁĊÝabŻ£¯°lóxȂŤĸkĊÞyĊêĊmĢxVƨÈĠXΘÆĠÔźɆţ°LXƾŤŤb"],
                    "encodeOffsets": [
                        [84555, 46311]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6501",
                "properties": {
                    "name": "乌鲁木齐市",
                    "cp": [87.9236, 43.5883],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WôŚUĠÈl¼Ċ¼ƪǖ@źȘƆ@ýlÜXVŘÞ¦V¼kĖóÒèkĊȁˮ֜@ǫ՗nōĉǬōķÆÅ@±ÞV¼nwĢIôºl£ƾ»UŤJôçó¯īʟéó@kÛ±»ǩbĊóLҍÇǫb@ŻɆóʠǓaŋÞȁVʉłĉbĉɅô"],
                    "encodeOffsets": [
                        [88887, 44146]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "6502",
                "properties": {
                    "name": "克拉玛依市",
                    "cp": [85.2869, 45.5054],
                    "childNum": 2
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ɜÞʊĊýVaÅm»ʵƳƑʝȗīV¥¯ĉ°Ñ@ŃÅI»ĉmğnaÝţL°ķóKĵĀV͈ĉłƾǊÆŤzXl°ÆL²¼źôÈĢǔ¦lô°"],
                        ["@@ƾIŤ@UUwōaĉÝJğÑÆŎkŎ"]
                    ],
                    "encodeOffsets": [
                        [
                            [87424, 47245]
                        ],
                        [
                            [86817, 45456]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "659002",
                "properties": {
                    "name": "阿拉尔市",
                    "cp": [81.2769, 40.6549],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nIÇŃÛÝĊÑĠƏōгwȁ¥Ƨ°ŹÑķV¼ÞêĊ»lĵm¦ÅW@ĀôÈźaɜxÈbÞÆĶIОŘ"],
                    "encodeOffsets": [
                        [83824, 41929]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "659003",
                "properties": {
                    "name": "图木舒克市",
                    "cp": [79.1345, 39.8749],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@VéVÇţ°ğUĠ¯mk¯ó¥ķIġÿƏbĉa±ÒĸĀlKU_m»nwm@ÈŤ¦ĉbÞ°±Þżł̦°ĢŁ"],
                    "encodeOffsets": [
                        [81496, 40962]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "659004",
                "properties": {
                    "name": "五家渠市",
                    "cp": [87.5391, 44.3024],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@çôÑlĕU»¥ÝUŗWkÛ@þVńÝĔ@ńÅþĶUX¦Æ"],
                    "encodeOffsets": [
                        [89674, 45636]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "659001",
                "properties": {
                    "name": "石河子市",
                    "cp": [86.0229, 44.2914],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lŁǵmĉ@mż¼n°ÞmÆ¼@"],
                    "encodeOffsets": [
                        [88178, 45529]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/yun_nan_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "5308",
                "properties": {
                    "name": "普洱市",
                    "cp": [100.7446, 23.4229],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Uô²a@²²Ķ¥V°Ķ²bl¤kVxl@°Ś²@y@ô¦¯@xxVxUVbVÜm¼ŎĢmºXXWÆ@ĀmmXU°ÅÒm¼Þx°w@°XêĠ°»nV°Ul@k@V±ôī@£ČŃÆ£KÞý@¥k@ya@nWVUVwm£Jknm@wmknXX¥mUUlUnb¯°nkVInlIUw°nmk@@mlanXlanmk@wVWUw_@éĠanmUaÜ£mX¥¯@@óUmÝ¯¯ÞÝlKnxô£»»ĠJ°aVUÝÿV¥ÛbI@wmón¯yÛL@WkÅmÈ`IWa¯K@¯mUnmaXmbmak¯ĢÒÝm¯mV¯KÇb¯KÛWWX@aVknċLUWVkXóW@ka@ób¯Uwmb¥UUlaU¥U£maķKXkmÝ@kwmÑ¯k±ċbUUVakaġ¦kL@`a¯xmÅLUW@ċnÅUV°LkL@b°°@¤²nôôkl°kèÒÈzV¤ÈWôônV@¦@¼Ux"],
                    "encodeOffsets": [
                        [101903, 23637]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5325",
                "properties": {
                    "name": "红河哈尼族彝族自治州",
                    "cp": [103.0408, 23.6041],
                    "childNum": 13
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@°°nÞôV@°@¦WnÛ¤Vbmnğb@ê`VxUX@xÆÞUnnWÞĸĢÈ@Çè@zÛÜWÅêl²KnV¯ĖĊx@bk@@°JÆ£Èblnnm°nlUkVUUwVmKnnVÞxVLX¥laX@@xl@VzÈVmk@b°ÈĸmV¦`WXbUbbX¼°x@aVVkn@lþnXUlVxŤÅyIUkaIŎĊ@lXx@bz@ô¥_V@ln@ôy@al_l`nmÈ»@kmXwWKU¯»aÅ@wmUÝKUaUUwW@w²»@kÆV£mm£VKkÑV@@»nw¥@kÆnllIVlnLVakalknJWmnaUaVÑVVÞn¥m@¯Uÿl@VçaXaV¯UyVLVk@nJlXLlkxlbla²Òl@nVJVkxKlkUaVķÝÑU@Åm¯@±Uó°ğńķĠmUÑ@Ç¯¯Å¼@nml@°¯¯`@w£@¯Çk@»nmċ¯U»I¯LÇĶÛn@bó°Uwm¯UmÇ¯aI@ykIVU¯bIğ¼¼ó¤mwkLÝÞ"],
                    "encodeOffsets": [
                        [104243, 23429]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5326",
                "properties": {
                    "name": "文山壮族苗族自治州",
                    "cp": [104.8865, 23.5712],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@wô@²¯maUmôUÆx@XbÞInlVUVwJVaUK°¥xmÞXnlKlnna°@ĊČÆwUmnkl@°£nyn@VV@Vak@@kÞÝbmx°Vnw°klÞInĖÞVlKl@Xa°KlVU@JnxU@ÈĢbUKlm@ak_wanWUk°l»k@Wk@lwU_@UalóU¥ÇnkJW@mVXx±bK@nV±a@Åa£ÝK²WknamKknÇk¯aVV¯ĀUÒ¥I@mm¯¯xÅW@@`k@ó»UU¯lm£ÅWlĵw@mmwÅmWU@y±UxmwU¯U¥Ý¥¯£m@kÇVUV°VbklLwUlUImk@±ÑkbkalwkWKkmI@UlUKVzU°WbbUè@kVĀ°@nm¦ÝUUUÒVbmbXnmIkllbUbmKUkkJmkÅ@l¦mx@¼U@lÒULn¤nU¤Å@l±¼@xXxVVVbÞLVn@xÆb°¼V"],
                    "encodeOffsets": [
                        [106504, 25037]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5303",
                "properties": {
                    "name": "曲靖市",
                    "cp": [103.9417, 25.7025],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@È¦lKÞĕUV¯Um¯ÇVUnVVUĉnĊÇƾLn°°ÈJÆw@lbÞa¦VXJ°¯W¯aÞJVkUa@lKnÅmWUk¯a¯»@m±@ÑkkbWWX_WÓU»_lkÑm@U»m@l@IWċn¯l@VanVUVUVwVxKÈVmUē@n@VÝÆLwVVwnVlmkUVÑÇ°ka@kÿÝaÞUl£ċĕX±±ĉa@UnVnalónk@wlUVmkÝJaW@ÅwóVVnnb±°@óxXLWxn@lÇ¼nmk_k`@bózm@kU@`¦ó@nW@ÜÅXWw@yb¦@ÒlnUb@xlÜk@²Ç@U¯bmy@kV@bb¦U`lLVx@bLl¼Þ¤@°VVÞU@WÞUbJ@nn@lnnmxUUUbK@ÇwklkUVWakn@lbU@@ULVxkKUn°¯Ò@¼km¦m@klȰ@lUl¦@Vl°wnnþĊUÆbUxbVĖU°annaVal@@b"],
                    "encodeOffsets": [
                        [106099, 27653]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5323",
                "properties": {
                    "name": "楚雄彝族自治州",
                    "cp": [101.6016, 25.3619],
                    "childNum": 10
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@mÒXU`Wn@Xl±¦Uxnbl°knmKUxxVôUx°¼ôÒÈ°JlnÞKĠW°¦Vx²JVw_°¥@UV@@wnymknK¯I@²b°£V¥wUV¤nLkÆJÈwôô°l»Č¯ġVUU@@°ÝXl@U»°Å@U¯@w±¯VmUUlm@mÑnIVyUwmak£Vwm±@Çw@n@UxkwlÇnLmkÅ@±kka@kóJV¯Ç»U£lw¯Xalbl¥¯UX@aUaÈL@ÇVIVkaU¯mmakLWkUJ¯Umxn@kUx¯xmWÅīÝkkbŤbkxWmXwWk¯wKkLÅ¤ċń@¤óĬU²@@lk¯VmU¯¼@xV@k°l°kbU°nmVnU@°UVèÞÆbUÒÞnU¦V¼lô@Vl"],
                    "encodeOffsets": [
                        [103433, 26196]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5329",
                "properties": {
                    "name": "大理白族自治州",
                    "cp": [99.9536, 25.6805],
                    "childNum": 12
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lbKVIUa@²m@bxôÒÜxXLmbnl@K°¼kUôxôlV¦nJUÆnm@xÆwbXÆôôLUVwôK@wlmaVw@WknmIUmlnJla@_@kÝmKUaÑm¯Xw°aUaVl»²JVbÆJkôĶĀ²VVkmbVwUówVwnLlmk¯maVw²¥Wk@XmV_WnÑUk@kó»UV¥ÝmVÑÅaÝUçV@¯VUmn¯mVlak¯l¯U@@wğWé¯@¯xÝw¯¯Jċa¯U¥mLU¤bÞȤbÇLWUwmIUVW¼kb`UVb¯L±ĊÛkÿÝKkwKţêUĉþÈV¯ÞVbU°KVk²ÝmImV@kmUkVxm¯KXÈķJU¦V°ULWxL@môb@bkx±LnVUVLnkÜWnwlLÅƒmW@kkJU_VWĊÞ"],
                    "encodeOffsets": [
                        [101408, 26770]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5309",
                "properties": {
                    "name": "临沧市",
                    "cp": [99.613, 24.0546],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@xĢl`²X°Vx@x°Þ°KXağUÑWbnIl`X²°bxl°V@xVxk¦mbl@xXVÆzX¤Æk°kx@lźêlaX»VUnJVxXÈKaÝȣaV£nKV¦°Čb°I°n»ÆÑV¯nWn@ÿXÅWWn¹ġōn»ÛUaUVUww@w°ó¥@z±@ř¯@kUwlk£±aĵ¯Uĵ¦±±@bó±VÝ@ó¤w¯I@mÅóm±X¯IólK@°UllbzkKlln@@ÔºUmVk²ôÒxŎUVóLbmÈnmbnlax@z@Æ¦k"],
                    "encodeOffsets": [
                        [101251, 24734]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5334",
                "properties": {
                    "name": "迪庆藏族自治州",
                    "cp": [99.4592, 27.9327],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WXw@akk@yk°īX¥Uóķ¯w@n»UaVaUÛ¯mV¼kÞċô@n¯xÛÒmV¯Ô@x@kwmÅa@UaÝ¯VÅyVa@ÿn»ÝVmankmmÞÅô@n£±ğzÇmU¦VmnÜmbn@°nV@xmzÅ@mºV¦k°ln¤¼õôn@xkÆIUxU@Ť¦VmVkmkXW¤XzVx@Æx¼Þ¯b@lVĸÞVm¼Xm¦VÞ@Æ¹Vón¥ÆKnKX¯x@èĊÈ±łXaÆxnlV@UÛlȻkğV¥m²ǉmÅÞĕƒƛm°ÆmX¤mznÆV¦ÞVVb°bnÞWbn°l@VÈ@VĵĊ±@óInxÆw¥@£ÞW¯ĸ£UUKk±akkkbmWmÈķaÆÇUÈÆW@wmknmU¯"],
                    "encodeOffsets": [
                        [102702, 28401]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5306",
                "properties": {
                    "name": "昭通市",
                    "cp": [104.0955, 27.6031],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@mnK@wmUÅ¥móXǓŏmX@VmL@xţnk@mlUŻÒğŋ@L@mmLkm@bXÅW¼ka¯lÇŹ¯aÇ»ÝÝ_@m@@a@UklwUm@ak@bUmbmbV¯ĕUaVwÅaĉVmým¯xUk@k¥VUX¤VÈm`@ńÇÜ@ĀknĔkƞÆĠÞUVôƆÞI@UxÆ¦nl@ĊĊnxUÒ°¦Vb¯WUnWIml@xnUbô¤¼ÈxlI»KV@ÈÔJkUĖ±ÆVb@nVÜVUVLwĠlknĠ@nx°¥Æ²mUw@mmÅUl¯UÑÑUmLllIl±@VkwW@w°@U»kUóI°»ĢÑL`nUĠ²lmbôV@nJUxÆ¦X¦l@ŎUV@lVKVÅV£UaÞUnW@¯VU@ó"],
                    "encodeOffsets": [
                        [107787, 28244]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5301",
                "properties": {
                    "name": "昆明市",
                    "cp": [102.9199, 25.4663],
                    "childNum": 11
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@n@VkVUn²°@x°V@¯ÆV¼k@WÞ¯@@VVUĢċ°k¼VĊx¤Ōx°mVkÑÈL°x°X°VmĊLVxUĖ°bX¦VW@kȯlkn@¥ln@»°Ñ¯VmlLUwVK@V@ka@lmXbUlVlkÈx@LVaVVwnmm@km@mIVaÝ@XVUÝ¯U@Ý£k»K@aUwkKV_¥a@alU@nz°aVÈ@@±lÛk@wVakm@Ñ¥az@XxÆW@ÛX@m@y@aWw@kōĉJlbVJzţÆUwVkmWkým@UlU@b¯wVºUVUêĠXUaUbVĊUWXUmkKWnUUUVVVÝ@kk±¯Lk±WkXlVkl@wXbmLVUIVmk@Ubma@kkaVKUkmlXLWnJ¯ÒĊ°@zkºlLUŤn@@nô@lÆnmKkÈlxVw@@mÈx@n²Uxl¤nbVxUzmJÒn"],
                    "encodeOffsets": [
                        [104828, 25999]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5307",
                "properties": {
                    "name": "丽江市",
                    "cp": [100.448, 26.955],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@l@@w°ÓUnÜÑ°w@mČóÝlU»n°VÜUbVbm¼@°xôĸVW¦¯Ĭl@zll@bWxXaX@ÆĠÆaXwl@XaÆ¦n¼Jn@mnKW¯È»V¯°akVanXVwl@VyUĕVUbÈīlaUk°k¯l²VUkƛô@I@mVwĊaVakaÆbUVLaXIWKUwaWÑÅKUaVk°@Uw¯¥XğÝLkm¯IÇóÑ¯»anUl±UĵÿlóÅIaU±Ik¼UVb¯bWxn°ÒVbnLlÞ@@`kbmIkVnJmnXl@Uxbkn@xóLUxVKóóÅWaÅxw@nÅmVôXLlVU¤b¦m¼@ĀbUzUÆ°ÞVb@Æbnx"],
                    "encodeOffsets": [
                        [101937, 28227]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5328",
                "properties": {
                    "name": "西双版纳傣族自治州",
                    "cp": [100.8984, 21.8628],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@l²°nÒlxÞ@nWlLĸnbV¤V¦kbVV¦nax°Vôa@b@lôXlWUVXČKlmU@bWXXÜ°LÈa°LnU°ÞnÑġ°lnba¯¯KWó@kmK@UĉV@k°VV¹a@y_ċl_nÓlL@anI@óWl£VUlkĕlKVwU@kVam¯ÅL@bÝk@VnUbÇbÝwÅ@ċ¥¯lk¼ÅÒ°b@¦nlUn@ÇVmÆbWôU@ÝÅōm¯aUmkWWw@±n¯UèaL¯mLkwl@°mnÈÒ¯ów@VxĀU¤°Į°Xl"],
                    "encodeOffsets": [
                        [102376, 22579]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5305",
                "properties": {
                    "name": "保山市",
                    "cp": [99.0637, 24.9884],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@X°Il@¦È¼m¼ÞaÞÅlÈxV¼lVôÈÆlLÞ£ÈºlkUUw¯UĕVwĊ@n¦mlnVĸIWÇ°LnUwlVn@lnUnJÞl±U¯LVUa°ÝUÇĊýVŤéLlxÞLĀÜl²ĉ°KUaV_Źé@klw¯lÅW£ÅyUW@wknal¥Uw@wUk¯w¯aW±k_mJaXVÒĠWb¯L¯Ý@wwU¯±Wk_ġwwōKmb@¤bk°lĖôUJVnÅlťU¯°VbnbWxXmÞWUĀLyWzÛKmbUxVKknÝkVĀċ¤Ux@¯m@¦"],
                    "encodeOffsets": [
                        [100440, 25943]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5304",
                "properties": {
                    "name": "玉溪市",
                    "cp": [101.9312, 23.8898],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lL°xXlWxXnlwaţlaÞlÆĬnX°wVwl@mnw°VVIXllKbnnV°lbUUJ@ÈÇKVb@bW°Vk¦kaWb°kxV¤È¼U°ôI@llbl²@@ó@mm@VţkKl¹@yĉ¯°ÑIXmWKnklVULlb@lnbVal@UnVJUnKWax@lkkUlW²XlK°l²@lÞUUUVVVXmlLVnXWVUĉVaVbWğVéUVU¹W»aVaaWX_U¥nÇķ¯@alUnÇUyk@@wW@kbW¦UKÝwUmmLUnVxUVVlk¯mmnmkÇaÅ¤¯I@l@@aĉw°ĕmUL±kÆéXÜÛ@yÈç@ÇġÝķXmmÝVÅlmnkbmWkb@nl@nm¯VxkJmUJml¯°makVVnV¦WWmnl@xmnlI¤nxUVUmX@b@zl@¦Ýþ"],
                    "encodeOffsets": [
                        [103703, 24874]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5333",
                "properties": {
                    "name": "怒江傈僳族自治州",
                    "cp": [99.1516, 26.5594],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@WyX£lWlnnUU¥@ţVVwJlÅ@wmöó»£kml¯U¥n¹Æ@ny@wmU@¯mnamÛnUV¥ÈnĠy²m¤@ÆónÝnmlnbÞU¥aV£kUKWómIU¥ókwVól»¯Lk@mnaWKÛwóÑw@a±n@VbUJLkaÝXĉUV`lI@lnXÆƑkKmxÛXmlUKVmU²Klw@aaó@nKXwVKU¯V¥mUnkm¥ĉ@UxVĖ°VxVklmÞkKWĀkVWnl°Lnm@°UxlV@nk¦JVÈ°VÒ@nX°@ÆlUômlnô²nxmłnVV¯x@Èm°XblVUl°@xkXU¤WXXWXÆmkÅJmÞw±bxUīkKmÅVUĖÝèVkx@lXlnk¤LkĖk¦xUL°¯Ė@LnK@b°xVI¥Ua°Ñ@»nm@¹KŎÞÈWln²n"],
                    "encodeOffsets": [
                        [101071, 28891]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "5331",
                "properties": {
                    "name": "德宏傣族景颇族自治州",
                    "cp": [98.1299, 24.5874],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@¥n@°@VwČ£ÿUlÞlmULVwnaÜLXyzKVÿXÝnWXwmaUa°¯VŦÆkUmVIókĕl¯a@£nama@¯m¯ó@óyţbġkÅm±ÛammVkLwU`Wk@VkUmÅlUUKmbkkUVUw¦ó°¼bn°ô¦lºz@x¯@U°nU¤ţU°VƆ@ÈmlnzÞl°¦ÆaxUxLkxWƒn@²ŰW@°ÈXl°Llx"],
                    "encodeOffsets": [
                        [100440, 25943]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/zhe_jiang_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "3311",
                "properties": {
                    "name": "丽水市",
                    "cp": [119.5642, 28.1854],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@VbVl@XnUXKV@¦nxlUXVnKVmnLUV@bn¤lLXK²`nnlJXIVJIVnn°KnnVll@VLXWV@UkVaVKzV@VVaUK@U»VUl@@WnUU@wVLn@Vwl@XW°LVbn@VU@Xl`@XnKVbkl@XVJlUnlVxlL@lnXl@VUnV°°@aUVLXblWVXn@VVUV@L¤VLVUVbnalLUUVX_laVaWVzXKV@@a@KUmImmXama@kU@yVIUKaVa@kXK@aWU@VIUmW@kkVmU@VwUa@K@k@U`@kUKVk@UV@VaUm²Vy@klUUWUkVmUa@_KVaXaXmU@mUlWkaUX@mmkL@wJnVVÅbWKXa@@I@aJUUÇ@VULW@akLmb@K@aXXw@mVmUVkUy@£@aU@@VkUWm@kUKXUWU_mW@wkkmJUUkLWWUXW@IkJ@k@mW_kÓ_UlLm@I@aUa¯m@ka¯LUJ@mVVxUba@LUKkXbm@Uak@@a@Um`IUbUJ@nUVW@@LnVV@lUbVlUX@`@blXklWUmXlm¦U@@V¯bml@@nUb@llnn@VbX@lV@UVULmU@JVnbVbkbVWxU@@nUVk@"],
                    "encodeOffsets": [
                        [121546, 28992]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3301",
                "properties": {
                    "name": "杭州市",
                    "cp": [119.5313, 29.8773],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@X@l°KXXlWb@²`bIX`l@@bWl@n@VnLUV@V@°¦@l@XVlU@@xVbUb@Vkb@@XVJVzJ@LÞ@VmLUxUJ@LUVxbxXUl@VaÈwbaÞa@Vl@XUVx@V@VLlbnVal@lbVnnLnKnL@VlbVJXalIb@KUU@mVInJUVl@xUVLnU@UÞaV@lkV@UanKL@UlKVUnbÆmn@@nUlVnVJl@@UXUL@WVIVJVxVLXV@IÜKnbn@V¥V@@I@y°b@UUwnk°ÆƨVlUçXm£aÇIkV@WV@@aWIUWUIkb@WW@UnK@UU@kaWVkVIVVnU@UWVUV@VmVkKkWIkVWaULU`UImJUImmU@wmwUVIUWVkUamaU@mVkb@KVU@aVU@anKULVJU@kÛUJUVkkVakU@aVwkW@UWkXmWaULUaUK@XJUUmVU@UVUkJ@ImwmKU@k@lUW@@akKmkamIkWl_UwVm@UkaVUUa@UamakbWlkL@aUalU@mkL@U@UlmK@XkKm@Ýakb@xnXb`nUUU@U@wU@@mKkkV¯U@lULUbVbUb@Va@LºÝb@bLmKx@VUL@bk@mxULWl"],
                    "encodeOffsets": [
                        [121185, 30184]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3303",
                "properties": {
                    "name": "温州市",
                    "cp": [120.498, 27.8119],
                    "childNum": 9
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ll@xnXV`VXWVL@lXnlV@UV@@b@¤VzUlnVU@nWxW@b@LnalK@bXVKUÈ@VVI@b@J@WbXLÆaUUmI@xlKnn@VWlbkXV@nVWnWbUbL@`VbUnVlVXkV@lUz±VnUbU@@VUlVL@l_@V@l@LVbV@XLV`VÈlxn@lU@aaVVk@XJ@nl@@LU`°LVbL°a@aUVy@anI@aanV@²wÜJX@VVV°kna@WVkaWwU@m@kaUĕÝÝŤnÈaaóI»@±XWkUķ@kV±kwUkWwUÝ»ÛkɳlImaUaWóXÿǬkUnWVmmkKţnŏÞğlUlUx@XWbV@JkX°mb@VULVxUVk@@LWWk@WIkUkJmUkVmI@y@UakLmU@mUUUkaVk@mK@UlUU@UmKmbUUUJ@n@KVLUL@VkJWXX`mnULWlkL@JVLVb@°kxkU@LVV@VLV`UL@VUX"],
                    "encodeOffsets": [
                        [122502, 28334]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3302",
                "properties": {
                    "name": "宁波市",
                    "cp": [121.5967, 29.6466],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ċ¦ĸĀ°nXÞVKkƨƑźÿ°»n@wô¥ÜbU°ÆXÞWóçĉÝ±IUÈ¥@U°wÆ»²mm_@aXVKÞVlk@akk̅@£X»VwÆXWa¯aȗbKƽŰĊxLók@@¯nKUL@xkLÑkWULUUmJUXVU@mUX¯@V`mbXbV@@nn¤WXx@kJ@nVVUVl²UbÝVUVk@Wx@V@VXzmlaL@VlLU`XUVVVUnl@VbnJlnUVVnlUKkbmnnVxlJnxmbU@UL@KUVX@xmb@lk@mnVVUè"],
                    "encodeOffsets": [
                        [123784, 30977]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3309",
                "properties": {
                    "name": "舟山市",
                    "cp": [122.2559, 30.2234],
                    "childNum": 3
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@l΢ƒʠþÆVĢLĊǬXĊÜXôVÑÆwlƏÈóVĭVǓ@ĉwɛkmK@ĉXīWaĉUĵÝm¯ĉwĉ±±nÅ¼¯x@VÇ¦V²JĊÞôèÝXÅW¯VÛaó¦@xm¯¼ŹĀ"],
                    "encodeOffsets": [
                        [124437, 30983]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3310",
                "properties": {
                    "name": "台州市",
                    "cp": [121.1353, 28.6688],
                    "childNum": 7
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@lVIVWVz@bXJl@Xal@°nLll@nVxnVK@UJVb¦°k`UIWJXnÆ@bUJXl@lbWn@UzVV@bVVmVnnJVXnabKUKnUVVUnVLlKVLXaJm£@mU@WanaU_°@VWnV@UVWnIVVVKlXÒlK@wVKL°m@l@ôKwĉƾůUl£@»UVkm@ƅUaÛIŏmUk@mw@a£Wk@ţIm±@ankôUlaUUw¯ōabÇbţmÞÞVĖbl@@nVXxbUl@Xmb¯lUUUW@ÛI±xU@mb@bmJ@bUzV@b¯bKUa¯KV_@Kk@@mWI@lUUb@bkVm@kwUÇU_WKU@Ux@VUnllX@VnJ@UXV@bWL@lUbbVLUJ@zV@lnbWbnnnJV@L"],
                    "encodeOffsets": [
                        [123312, 29526]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3307",
                "properties": {
                    "name": "金华市",
                    "cp": [120.0037, 29.1028],
                    "childNum": 8
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nbVb@VbUVlb@VUnVxk`lXnJlbnlL@bX@V@klV@nLnx@JlIVU@VUVnVVI@WVLVbVKXbWnXl@VlXUxb@lVUbllVUIÜVnalKX@@bV@@aUUlUwUw@naWWUVaUUaVbLlxXJVk°UlkU¥@ka@LVlXLVlVWznVn@lxJl_@WX_@mVaa@alU@kVVnaKVLlKb@UUaVabnUWmXU@k@yVI@aÅWmXIVJl_¯¥UaVI@LmUUw@mkkmK¯k@Wbk@WI@aUyUXJkU@bU@WLUyXUbkbW`UVVkKmbUaVUUK£@KVUUUm@UWkXWaUKV@b¯¯mUV@UkmW@kkKwUmkkVUI@WlkUamL@Wk_W@UVm@Ua¯KWXk@Uxm@UK@xVmV@Xk@UVV¼@VLUbUU@yULUbVlU@@XlVUVVbU@lXXVW@XUVl@@VUVÈn@VVU@lVa@UmL@`X@`WL@VUX@lUL@xlx"],
                    "encodeOffsets": [
                        [122119, 29948]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3308",
                "properties": {
                    "name": "衢州市",
                    "cp": [118.6853, 28.8666],
                    "childNum": 5
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@XkVKnwl@@aVK@UwnLK@aÞa¹@Kb@UVaUaVaVK@k°VUllnL@V@xV@V@VVm_Wam@wlaÞbn@lL@WnLk@V@VlK@nkVVb@blKXklakw@wVK@kVW@UXK@_W@_nKV@Ub@kVUUm@ÇVU@Uk@VU@WUXWW@kVUaVUkU@WWXUKk@Ukmm¯LmmUJUIWJkImm_±WLkKm£@aVUmKUnLmWUkVmw@¥ULVWm@WUka@UmmLmm@@bUX@@WUIm@UVUK@UVUUUVVJmb@bXnmV¼nnn¦mJUVLV@VW@UzUlVnUbl`UnVl@XU@kl@bmÈUxVk@@J@¼W@ÅaVVnzmV@WJk@kWJ@lXbWbXxmVnlLXb@°lKVXnWbWVXmbV@XlbI@Kn@@x@VLlm"],
                    "encodeOffsets": [
                        [121185, 30184]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3306",
                "properties": {
                    "name": "绍兴市",
                    "cp": [120.564, 29.7565],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@x@VnnVJnIVJV_VKXblUXJllLUUnU@UVVX@mVUUUJlXUlbV@@VLVmX@@XlaVJVXXJ@b@XU@lUJÈb¤ŌJçVUUnml@@kna@wWVU@LVKV@namwkIUwmnmlaVLkUmVUkmmIUak@VmUUVUWV_kK@UKbnkWyU@@UXwl@VUÞUVak±VUUU@mlI@wXWIWbUKkLUKVmUUmVVLLambUWmIUmnUU@aUUVym@Xkak@W@z@lWVXnmVaUbVb@VakLUKLmbUU@lkV@bbUb@nW`@Xk`Ikwm@mUXyUUkWKUk@Kb@lV¦klV¯UlWIkwKUabVVUbVXXmb@VxxkVVV@bU@@aW@kLmb@lVUIVKmL@bUV@bUV@LalnUV@nbVbUlVXJVUnx"],
                    "encodeOffsets": [
                        [122997, 30561]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3304",
                "properties": {
                    "name": "嘉兴市",
                    "cp": [120.9155, 30.6354],
                    "childNum": 6
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@blIX@@VÜVUnn@lklKnI°Þl`²LVKVbnbVaVLUVn@W¦@VkVVb@VI`@blLnLaX@VVb@U@XlVa@@kVaUKV»U_lWXU@albk@VllnLVKn@@UVIUw@y°IVVXU@VV@lwm@wVkƾaJLkΡƧƒlLÝUmW¯ķÿĉ¥IŋWnèkVƧU¯ÅmlVx@V¯az@@JU@U¦m@@nVmn@VLV"],
                    "encodeOffsets": [
                        [123233, 31382]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "3305",
                "properties": {
                    "name": "湖州市",
                    "cp": [119.8608, 30.7782],
                    "childNum": 4
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@kLlkm@VmÛU@UW@kJ@aUK@UnmmU@maÛL@JWUUKUwUIUJ@XKWV@Vk@UIUmVk@mm@ÅnmaUVkL@VKmLVbU@klU@ÝbV@mVUKV@wUkVmIUJ@nVV@LakJWbUIka@UmKmLKmmUUVk@@nmLX`WXUV@@nUlkmlU@UbxVVIlVnn@@nUÒ@°n@@xmb@VbnV@@b@`@L@L@x@blVklVbnnV@aXb°VlU@Wb°ULXWVUVVwÈwÜ»ĸaĠnUVw²X@V@lVU@wlaUUVm@knUV"],
                    "encodeOffsets": [
                        [123379, 31500]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/util/mapData/geoJson/tian_jin_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "id": "120225",
                "properties": {
                    "name": "蓟县",
                    "cp": [117.4672, 40.004],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@EUDAEI@WNMNCBFAHFFNACDJDPBD@@GD@DIFFHEFGDBDEQOFG@EI_KG@OcJQM]RMEKBGPG@[LaCIICBWKCEEG@WBQHCDFD@HSLEJI@IHWECFGAAEKCGDBFCBSBIDCKKHEADMJMFABKOKEQAA@IEEG@GIQAEK@OZEESMOLlu@SLUTYFQCMG@@SQUAYKAACA@IB@BDB@B@DC@@BGAEFAA@BEGKJCC@AGAIHA@@JC@QEIP@@A@EGIDC@O@C@@@@CJCWKABFLBBEBSQGBAAMIEM@AKBcJEN@BEBCFMAEFEF@J@BG@BFABECKFG@AFQ@@F@BEB@@A@@AAAKAE@GFGDECEFEECBKIKDELDFEDYH@EIACDCHKBEB@BAAC@ADBHABKJIAIJICEDGDCD@@A@A@DHCHJHDFEFGBKRKBGIK@GIMHSBCH_BOJECCJCFKKMD@DNJEDEGC@OJCJHRUL@HRJ@H[DCNKDZHCTFDHCFFKR`TANVDFZRDLFARB@HPAPG`ILAR@TERNDFNHDLCLDDCXDYbHF@FEB@LDDVE@JPNfXPINCVDJJD@NJPAJHLXHDNANHhB@DPNLRMTBFRBHHr@`NBFEBOCCBIAQJDHCHLHFA@HSDCRLFTB@HEFLNF@PELBDJALFLTC@EPFLLP@tUHQJDfIHGTB^JTCPDLKAIBATFPADIEGECEMJ@JIAIHGECFEAGDI\\SPOXAFCL@BQTQBBTMZECYGAHA@GJAE@HCAEME@IECFKJADDBABLTHHG@ILEAMNDJCDHEBF@@JNFJELDFKTOT@JETBFFHBHEHKI@@IJEJ@XKEOUMS@AF@CEB"],
                    "encodeOffsets": [
                        [120575, 41009]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120114",
                "properties": {
                    "name": "武清区",
                    "cp": [117.0621, 39.4121],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@FWôµ@IFCLIB@EHNBp]AGEAKAEDMGZKFGBGME@ILGP@HEFB@BXMEAHUGC@IHCLOD@X[NWHWPKAEF[@EKIOL@EKGBNMJ@EIEHKBIC@BAKMIACCFQZCF]DB@ERAKADIHGEIBCGIIECFaGLZO@EFCNGAGDGAKL@BMG@IE@ADSDEH[JGC@CGA@BMDeK@EIACFE@@GG@FIAMM@CCGC@EM@ADE@CFMAAGHBDKIEAJG@DOGCDEKAGIS@KFCHKAEHIE]BeKNO[IFIOELC@A]GMBKVYCDDgGAICARc@MW@AQE@DGI@@AQ@@BKBAIQQYEFW@CEADIGGBCEIiMEMF_LGEKMBBDWEBGRC@E_CHYGCH_IAED@FFBQh@FGJaJ}AHRAREF@bE\\C@CT`FHC@\\BBF@BID@HGDDJ@@FAHKBARECKDAZBJIVNHCTA@EREAMLHDAFFBVFFC@RNRETHD@FOJMACH@CAB@P@DF@@FGDWE@FFSIEMKQDYCCHKb^JADOCIDGNDBdBCFJB@EC\\A@BJEA@JAAAD@HHD@LFBCFF@BERDHNhZQHMBGHOACCEBWEGD@PSJKCGEUD@CINLFGHE@AJK@HDABBHTB@F`DBFLBBHEDARCFG@ABJBAPVFE^FBGLGCFG_BMLEXGAAFE@@JNRVJHFALFBEHQJCTbNDHCF@PlFLJSXCHFHfVBTNJ\\BPJXC^FAVNFCHFB@FFH@JF@\\ABCFD\\BDMCAAJKQBGAILOEGHILECQLWFENJHADC@QxNHFJNLDFA@CBA@DUÂmR@FBL@BD"],
                    "encodeOffsets": [
                        [119959, 40574]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120115",
                "properties": {
                    "name": "宝坻区",
                    "cp": [117.4274, 39.5913],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@TZbB@JHD@DODCLM@AP@LL@BNH@ETFN@`E@DNG@CHLBCJA@AICFKDDBKA@\\N@AFNAGRBFjFFFL@DHLBLFQPcXAZMJ]GAVHAIZJFNE@JpDRRDCLFDGXA@EFF@CFFPDfEBDB@DCHCFCJDJIJBLI@I@CB@@ADBB@FALADGDC@@H@BB@FZGFCCE@@FMLALJDAFFFEFDFCB@@AHCF@L@@BBB@BB@FC@E@@R@BEL@HEFD@G@AH@AIB@@@FEFEBALDDEFAFO^IF@JCBBFPNJJ@D@PRDCEKBAXL@BIFD@T@JE@BHHJORFDI@@B@JGH@@B@BDDLIFFHCD@D@DEE@BAAAB@DAF@B@H@NGLJLMRDNMfGIEPMI@GDAKK@KIDIJ@GE@CFDN@FE@GFEPGV@TCDFKHBBF@RW@DD@@ID@TJFKIKLI@EP@IGBCLAEKLEN@KSHIGYACSD@SEAMBBMGEBMQBCMIGKFB[D@HDLPHDBC@IFITDLG@IIIFGVBNJDLN@VIRI@YIAIHIC@CLKZCBEE@JECEIHEAKGDGECBGEEM@@DA@CCCBBEGA[GEDBBoNAAH]MKiIAWKQoIIPMFQAEEDMH@FMSUYIeF@EK@BIOEKJEBICFKaKPFAFSE@LWCCFMHDDEKESBOGBKIEIODLG@CCDEQCEDWEMDIEIB@EHGEEDAEAa@@HqDEJGF[AECCFa@WCEIKAAEQB@FCAE^YDERDDJBLNABD@AJGLJF@FNIAMLH@FPKLJ@FE\\BFOLGXMXW\\C@KPGD@JHDGVFBWN@AEAGFO@KH@JNFAHEHYLNHFCLBFBBHo^MAFGA@KJED@Jó¶EX"],
                    "encodeOffsets": [
                        [119959, 40574]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120223",
                "properties": {
                    "name": "静海县",
                    "cp": [116.9824, 38.8312],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@NGFMDATCNDR@CCbINEHNJA@C\\EEGVE@IhE[wepc¢·²^QEKIEKIgiQDkehY£uSDBMkUDOJDHC@GF@CAFBFEN@CQ@BeP@@G@HD@@MHQKi@[IGCOCESE@GMA_OcCGDu`a@VZzKDkJBLNXGDqKEWE@cFEFA@ISIi@@KMABJGBcMuFEzGVH\\ATSEUBeALCEMG@CEBUHUCGXaBPtUBBFIBFTDFF@DDKBFNGBJPHXDDMDCLJ^mBIHIL@LR\\@LCR[@@z@NFD@LLBNb@RHDBNTPT\\F@BJF@BXCFBHHBDLFB@HODADE@@JHVXCPDHCFTLBBFNCDCCCU@@GAABEHHZHBCAEdEjFDD@GfD@DXFCHF@ERFDLBH@"],
                    "encodeOffsets": [
                        [119688, 40010]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120221",
                "properties": {
                    "name": "宁河县",
                    "cp": [117.6801, 39.3853],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@BFLBFJXDb@DEFD\\BHEFIrC@Gb@FBCBFFGH@FJAJFNCXFFCRDCFDDH@CKJPJFALPHTALFCFGCENDDKXF@ETEBObLELJDFALIPFAJL@@FfEZJTVENG@CNFFRBNEJOpJLRBXjJNLG^BBpMAAFC\\HHBAFDADDB@@CN@FFAHFDCHLHFBJGFCFUNKJJTD\\XUXF\\^F@DDDQXXBRLRCBDFEVCDLVDpUl@LEDJHAPRFGL@CETGPBTCDDVI@CFF@GFDCCVGLKEK[Y@MECISG@BKNSCGCKWEAaEBEKNGFSECO@GGM@GYI@DÅCMLHPTF@DJHAVVNKEGDETJ^[TJNNd@NOAMFYJ@@GFANDPEJB^aOadSTQSI@MHBDIEOKCG@EEFCKCqXO@@DMFENCDDHCCGJ]AKFoDaGGHYFDHKJiCMFGC@EQ@AEHGAC@IEAATKOHGIC@IXIFEoGE[JCFCDHNmRADFZMF[EEBMO{GU@AOW@@]ZeHBDEHBKEfQkuIWBs@EC@d[@[^EDMTKCEEcI@cDAB@FCBCACmOCG{PYHeBgPwPFDDALFFFCHQGSD@BHFAR[TaFYXMASUiGFL@DQNCJI@@D@PLDN`ETEFIGMCGBCE~CAIFDPEHGEQPHJADFJGHCJLB"],
                    "encodeOffsets": [
                        [120145, 40295]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120109",
                "properties": {
                    "name": "大港区",
                    "cp": [117.3875, 38.757],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@JFFL°_`ONJKDDFIFZN xlb~yFVNRrdJGzDPVFBCTNND\\UR@E`F@@Ip@IWGUoawOEE@ÏDgK{İEEMFëCb@KwOCDHHKBDJCDEEEAGHOABFABMCgDLSQ@CFEBMgYIDQINE@AUSwSAdYEHQMEyK[KI@GRMLE@@OqOoBOnpJ@BmEAFHL^FDB[C@BBDVFAHFJENB@sNEjQAMYsUgCSBGDJH@\\LjGR@NC@@G@HO@AfR@DM@EFEADBE@@HGDICCPlVANTC¤vgZlfRChjLJ"],
                    "encodeOffsets": [
                        [120065, 39771]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120107",
                "properties": {
                    "name": "塘沽区",
                    "cp": [117.6801, 38.9987],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@|ODHnPBDADEDA@CB@ddJFFLDNSFC\\]\\@@cFD@nACOMW@M@ITURBRZNHNWRQoOj½fcqAqeiDÿÍyÓįFL|Ch@ÐFFxPpbHVJXo@@JCTR^BPABQA]^MB@bE@@FQBFVJRH@FXtPNZSBAja@@NDTLJrQTHFXZFB`"],
                    "encodeOffsets": [
                        [120391, 40118]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120111",
                "properties": {
                    "name": "西青区",
                    "cp": [117.1829, 39.0022],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@LHAHRHATh`LHNHDG`HDGZ`D@FQDAHXFACNAFLVRTBFOfHDCVBFQH@HSXHEPFB@LDBF[bDbLFKJBFLADBDjLvCPEI]FGEIGCBEUSjcFiBIVWfaHCjN^HtwBBFGPBJGjFBEGECGDONMFAP]TDHQOWCMGAMHKIJEIGQ]aDlUG]VGEGDC{PEbBZmE@@GH@BCA@FMQCFMYMJECELCMI_P¯`]R±¡¸odfx\\gF@JUFFH[F@DIBGMMFaJDDQ@MCSDCBENMH"],
                    "encodeOffsets": [
                        [119688, 40010]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120113",
                "properties": {
                    "name": "北辰区",
                    "cp": [117.1761, 39.2548],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ROHFFGCOJEDB}DFHANDJHFEFSM_KC@O@CJ@DIRM@CEKKALFKACHoLSJSIBETDJaEIIE]E]K[MYUYQILC@GF[MGNKEK@A@BCWECAIFEFYAGFOMI[OFuDiKACBCEKIAELaKaCE\\CA@KEAFOWGGTG@ERUACDeGEPSAUQKHE`FNjNFJADHHCJFB@DEXZFRRBJLA@AR@@BJ@CHF@BRX@@NQdDBBJhHCCZDLUNA^H@BKDPFEJ\\JMPfL^AJFFGLBDGLET@HJLBCFHDCPH@BIJFCLGABHNBDEF@BCN@@FHDDDN@BNEJH@@HF@DEJB@FfLNC@AHB@DHD\\IFGTCBCF@@JNH@ALKHBHCHBDMFEP@KYbHDEJF"],
                    "encodeOffsets": [
                        [120139, 40273]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120110",
                "properties": {
                    "name": "东丽区",
                    "cp": [117.4013, 39.1223],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ZV\\N^L^FJFFJIbSCAFTJTIpKDGLBEKLBjHTVNBZWbE\\SBQGE@ATCRHDGEEKECBECxOhOfAZGA_YEEWSGqRKISC@Mb@BiTAMYsOEWG@IQEURA@EF@@acUOXQRYCUDCHDTEF[SUEgAYDcVGJM`iAWDWLQRMHUHgDsDBLHJFCFDFGHBFFVEAGHCJN@RJFPIhBD\\FENCPWA@LFBAFHBEJUEARCDIAEDQBRNa^"],
                    "encodeOffsets": [
                        [120048, 40134]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120108",
                "properties": {
                    "name": "汉沽区",
                    "cp": [117.8888, 39.2191],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@LMEI\\MTABKN@FCDMH@COAcH[AoēAM¡Wa[MeqpQRMXMGQYQASV@J@NNXDPmBAtJXlveRLFGACFGAYf@^X@BPV@|HNPFA\\FNEEYBCnQGMDCDE\\IHFpEFWJ@JJDGHLPBSFB@JBDGHBFR@@FHDNEjDLICGZEHGbHpCLE^BHIDDCGDCFMNE@CP@rWLDEDFFH@"],
                    "encodeOffsets": [
                        [120859, 40235]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120112",
                "properties": {
                    "name": "津南区",
                    "cp": [117.3958, 38.9603],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@TLv@CNHFFBHGZFETNPhCVGNGRQXKXCjBN_HIdUZChBVF\\TFECSDGVCZDRQPWdVNA^]RBBAAOQ]DSE@F_Q@[VMCSMADUECOHycIqMQEU}zkawENRDENB@ADG@@HF@YnaAOF|CDFHUHH^kVbCR^JHIFLJNGHBDNPXGRSCO^EBMNCPDHHFAFiEIHOAEH"],
                    "encodeOffsets": [
                        [120045, 39982]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120103",
                "properties": {
                    "name": "河西区",
                    "cp": [117.2365, 39.0804],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@d@hZNFdcLYXKRCtCMOFSYEGHEAGEDMu@SKAAsx]GMTGt"],
                    "encodeOffsets": [
                        [119992, 40041]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120102",
                "properties": {
                    "name": "河东区",
                    "cp": [117.2571, 39.1209],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ZBVFFIGABEEA@KXBDOFM[EACJgOIE@QIMGDBHUFEEGAEHECEDGIAKQDWLKZcdQPEP@FOFBJTJ@HNORJf@DBCN"],
                    "encodeOffsets": [
                        [120063, 40098]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120104",
                "properties": {
                    "name": "南开区",
                    "cp": [117.1527, 39.1065],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@NMVDCG\\E^B@HlB@YEDS@CHsNSiMGDebUXAJEjidVTAFHDFJ"],
                    "encodeOffsets": [
                        [119940, 40093]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120105",
                "properties": {
                    "name": "河北区",
                    "cp": [117.2145, 39.1615],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@DBXFADB@L@LFHM\\NHED@JKZRb]QMRAFCJBDCBQYADMCAe@QIMP@GSIAIPE@E[EGH@ZEF]^HJAXK@KF"],
                    "encodeOffsets": [
                        [119980, 40125]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120106",
                "properties": {
                    "name": "红桥区",
                    "cp": [117.1596, 39.1663],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@J\\PNHEZBFEJELEL@BWGI^]FEkA@G]A[FDHUCMNEHJ^"],
                    "encodeOffsets": [
                        [119942, 40112]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "120101",
                "properties": {
                    "name": "和平区",
                    "cp": [117.2008, 39.1189],
                    "childNum": 1
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@DT@FCHG\\FFOROMEgYc@"],
                    "encodeOffsets": [
                        [119992, 40041]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('echarts/component/base', ['require', '../config', '../util/ecData', '../util/ecQuery', '../util/number', 'zrender/tool/util', 'zrender/tool/env'], function(require) {
        var ecConfig = require('../config');
        var ecData = require('../util/ecData');
        var ecQuery = require('../util/ecQuery');
        var number = require('../util/number');
        var zrUtil = require('zrender/tool/util');

        function Base(ecTheme, messageCenter, zr, option, myChart) {
            this.ecTheme = ecTheme;
            this.messageCenter = messageCenter;
            this.zr = zr;
            this.option = option;
            this.series = option.series;
            this.myChart = myChart;
            this.component = myChart.component;

            this.shapeList = [];
            this.effectList = [];

            var self = this;

            self._onlegendhoverlink = function(param) {
                if (self.legendHoverLink) {
                    var targetName = param.target;
                    var name;
                    for (var i = self.shapeList.length - 1; i >= 0; i--) {
                        name = self.type == ecConfig.CHART_TYPE_PIE || self.type == ecConfig.CHART_TYPE_FUNNEL ? ecData.get(self.shapeList[i], 'name') : (ecData.get(self.shapeList[i], 'series') || {}).name;
                        if (name == targetName && !self.shapeList[i].invisible && !self.shapeList[i].__animating) {
                            self.zr.addHoverShape(self.shapeList[i]);
                        }
                    }
                }
            };
            messageCenter && messageCenter.bind(
                ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink
            );
        }

        /**
         * 基类方法
         */
        Base.prototype = {
            canvasSupported: require('zrender/tool/env').canvasSupported,
            _getZ: function(zWhat) {
                if (this[zWhat] != null) {
                    return this[zWhat];
                }
                var opt = this.ecTheme[this.type];
                if (opt && opt[zWhat] != null) {
                    return opt[zWhat];
                }
                opt = ecConfig[this.type];
                if (opt && opt[zWhat] != null) {
                    return opt[zWhat];
                }
                return 0;
            },

            /**
             * 获取zlevel基数配置
             */
            getZlevelBase: function() {
                return this._getZ('zlevel');
            },

            /**
             * 获取z基数配置
             */
            getZBase: function() {
                return this._getZ('z');
            },

            /**
             * 参数修正&默认值赋值
             * @param {Object} opt 参数
             *
             * @return {Object} 修正后的参数
             */
            reformOption: function(opt) {
                // 默认配置项动态多级合并，依赖加载的组件选项未被merge到ecTheme里，需要从config里取
                opt = zrUtil.merge(
                    zrUtil.merge(
                        opt || {},
                        zrUtil.clone(this.ecTheme[this.type] || {})
                    ),
                    zrUtil.clone(ecConfig[this.type] || {})
                );
                this.z = opt.z;
                this.zlevel = opt.zlevel;
                return opt;
            },

            /**
             * css类属性数组补全，如padding，margin等~
             */
            reformCssArray: function(p) {
                if (p instanceof Array) {
                    switch (p.length + '') {
                        case '4':
                            return p;
                        case '3':
                            return [p[0], p[1], p[2], p[1]];
                        case '2':
                            return [p[0], p[1], p[0], p[1]];
                        case '1':
                            return [p[0], p[0], p[0], p[0]];
                        case '0':
                            return [0, 0, 0, 0];
                    }
                } else {
                    return [p, p, p, p];
                }
            },

            getShapeById: function(id) {
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    if (this.shapeList[i].id === id) {
                        return this.shapeList[i];
                    }
                }
                return null;
            },

            /**
             * 获取自定义和默认配置合并后的字体设置
             */
            getFont: function(textStyle) {
                var finalTextStyle = this.getTextStyle(
                    zrUtil.clone(textStyle)
                );
                return finalTextStyle.fontStyle + ' ' + finalTextStyle.fontWeight + ' ' + finalTextStyle.fontSize + 'px ' + finalTextStyle.fontFamily;
            },

            /**
             * 获取统一主题字体样式
             */
            getTextStyle: function(targetStyle) {
                return zrUtil.merge(
                    zrUtil.merge(
                        targetStyle || {},
                        this.ecTheme.textStyle
                    ),
                    ecConfig.textStyle
                );
            },

            getItemStyleColor: function(itemColor, seriesIndex, dataIndex, data) {
                return typeof itemColor === 'function' ? itemColor.call(
                    this.myChart, {
                        seriesIndex: seriesIndex,
                        series: this.series[seriesIndex],
                        dataIndex: dataIndex,
                        data: data
                    }
                ) : itemColor;

            },

            /**
             * @parmas {object | number} data 目标data
             * @params {string= | number=} defaultData 无数据时默认返回
             */
            getDataFromOption: function(data, defaultData) {
                return data != null ? (data.value != null ? data.value : data) : defaultData;
            },

            // 亚像素优化
            subPixelOptimize: function(position, lineWidth) {
                if (lineWidth % 2 === 1) {
                    //position += position === Math.ceil(position) ? 0.5 : 0;
                    position = Math.floor(position) + 0.5;
                } else {
                    position = Math.round(position);
                }
                return position;
            },

            // 默认resize
            resize: function() {
                this.refresh && this.refresh();
                this.clearEffectShape && this.clearEffectShape(true);
                var self = this;
                setTimeout(function() {
                    self.animationEffect && self.animationEffect();
                }, 200);
            },

            /**
             * 清除图形数据，实例仍可用
             */
            clear: function() {
                this.clearEffectShape && this.clearEffectShape();
                this.zr && this.zr.delShape(this.shapeList);
                this.shapeList = [];
            },

            /**
             * 释放后实例不可用
             */
            dispose: function() {
                this.onbeforDispose && this.onbeforDispose();
                this.clear();
                this.shapeList = null;
                this.effectList = null;
                this.messageCenter && this.messageCenter.unbind(
                    ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink
                );
                this.onafterDispose && this.onafterDispose();
            },

            query: ecQuery.query,
            deepQuery: ecQuery.deepQuery,
            deepMerge: ecQuery.deepMerge,

            parsePercent: number.parsePercent,
            parseCenter: number.parseCenter,
            parseRadius: number.parseRadius,
            numAddCommas: number.addCommas,

            getPrecision: number.getPrecision
        };

        return Base;
    });
    define('zrender/shape/Text', ['require', '../tool/area', './Base', '../tool/util'], function(require) {
        var area = require('../tool/area');
        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Text
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Text = function(options) {
            Base.call(this, options);
            /**
             * 文字绘制样式
             * @name module:zrender/shape/Text#style
             * @type {module:zrender/shape/Text~ITextStyle}
             */
            /**
             * 文字高亮绘制样式
             * @name module:zrender/shape/Text#highlightStyle
             * @type {module:zrender/shape/Text~ITextStyle}
             */
        };

        Text.prototype = {
            type: 'text',

            brush: function(ctx, isHighlight) {
                var style = this.style;
                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style, this.highlightStyle || {}
                    );
                }

                if (typeof(style.text) == 'undefined' || style.text === false) {
                    return;
                }

                ctx.save();
                this.doClip(ctx);

                this.setContext(ctx, style);

                // 设置transform
                this.setTransform(ctx);

                if (style.textFont) {
                    ctx.font = style.textFont;
                }
                ctx.textAlign = style.textAlign || 'start';
                ctx.textBaseline = style.textBaseline || 'middle';

                var text = (style.text + '').split('\n');
                var lineHeight = area.getTextHeight('国', style.textFont);
                var rect = this.getRect(style);
                var x = style.x;
                var y;
                if (style.textBaseline == 'top') {
                    y = rect.y;
                } else if (style.textBaseline == 'bottom') {
                    y = rect.y + lineHeight;
                } else {
                    y = rect.y + lineHeight / 2;
                }

                for (var i = 0, l = text.length; i < l; i++) {
                    if (style.maxWidth) {
                        switch (style.brushType) {
                            case 'fill':
                                ctx.fillText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                                break;
                            case 'stroke':
                                ctx.strokeText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                                break;
                            case 'both':
                                ctx.fillText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                                ctx.strokeText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                                break;
                            default:
                                ctx.fillText(
                                    text[i],
                                    x, y, style.maxWidth
                                );
                        }
                    } else {
                        switch (style.brushType) {
                            case 'fill':
                                ctx.fillText(text[i], x, y);
                                break;
                            case 'stroke':
                                ctx.strokeText(text[i], x, y);
                                break;
                            case 'both':
                                ctx.fillText(text[i], x, y);
                                ctx.strokeText(text[i], x, y);
                                break;
                            default:
                                ctx.fillText(text[i], x, y);
                        }
                    }
                    y += lineHeight;
                }

                ctx.restore();
                return;
            },

            /**
             * 返回文字包围盒矩形
             * @param {module:zrender/shape/Text~ITextStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var width = area.getTextWidth(style.text, style.textFont);
                var height = area.getTextHeight(style.text, style.textFont);

                var textX = style.x; // 默认start == left
                if (style.textAlign == 'end' || style.textAlign == 'right') {
                    textX -= width;
                } else if (style.textAlign == 'center') {
                    textX -= (width / 2);
                }

                var textY;
                if (style.textBaseline == 'top') {
                    textY = style.y;
                } else if (style.textBaseline == 'bottom') {
                    textY = style.y - height;
                } else {
                    // middle
                    textY = style.y - height / 2;
                }

                style.__rect = {
                    x: textX,
                    y: textY,
                    width: width,
                    height: height
                };

                return style.__rect;
            }
        };

        require('../tool/util').inherits(Text, Base);
        return Text;
    });
    define('echarts/config', [], function() {
        // 请原谅我这样写，这显然可以直接返回个对象，但那样的话outline就显示不出来了~~
        var config = {
            // 图表类型
            CHART_TYPE_LINE: 'line',
            CHART_TYPE_BAR: 'bar',
            CHART_TYPE_SCATTER: 'scatter',
            CHART_TYPE_PIE: 'pie',
            CHART_TYPE_RADAR: 'radar',
            CHART_TYPE_VENN: 'venn',
            CHART_TYPE_TREEMAP: 'treemap',
            CHART_TYPE_TREE: 'tree',
            CHART_TYPE_MAP: 'map',
            CHART_TYPE_K: 'k',
            CHART_TYPE_ISLAND: 'island',
            CHART_TYPE_FORCE: 'force',
            CHART_TYPE_CHORD: 'chord',
            CHART_TYPE_GAUGE: 'gauge',
            CHART_TYPE_FUNNEL: 'funnel',
            CHART_TYPE_EVENTRIVER: 'eventRiver',
            CHART_TYPE_WORDCLOUD: 'wordCloud',
            CHART_TYPE_HEATMAP: 'heatmap',

            // 组件类型
            COMPONENT_TYPE_TITLE: 'title',
            COMPONENT_TYPE_LEGEND: 'legend',
            COMPONENT_TYPE_DATARANGE: 'dataRange',
            COMPONENT_TYPE_DATAVIEW: 'dataView',
            COMPONENT_TYPE_DATAZOOM: 'dataZoom',
            COMPONENT_TYPE_TOOLBOX: 'toolbox',
            COMPONENT_TYPE_TOOLTIP: 'tooltip',
            COMPONENT_TYPE_GRID: 'grid',
            COMPONENT_TYPE_AXIS: 'axis',
            COMPONENT_TYPE_POLAR: 'polar',
            COMPONENT_TYPE_X_AXIS: 'xAxis',
            COMPONENT_TYPE_Y_AXIS: 'yAxis',
            COMPONENT_TYPE_AXIS_CATEGORY: 'categoryAxis',
            COMPONENT_TYPE_AXIS_VALUE: 'valueAxis',
            COMPONENT_TYPE_TIMELINE: 'timeline',
            COMPONENT_TYPE_ROAMCONTROLLER: 'roamController',

            // 全图默认背景
            backgroundColor: 'rgba(0,0,0,0)',

            // 默认色板
            color: ['#ff7f50', '#87cefa', '#da70d6', '#32cd32', '#6495ed',
                '#ff69b4', '#ba55d3', '#cd5c5c', '#ffa500', '#40e0d0',
                '#1e90ff', '#ff6347', '#7b68ee', '#00fa9a', '#ffd700',
                '#6699FF', '#ff6666', '#3cb371', '#b8860b', '#30e0e0'
            ],

            markPoint: {
                clickable: true,
                symbol: 'pin', // 标注类型
                symbolSize: 10, // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
                // symbolRotate: null, // 标注旋转控制
                large: false,
                effect: {
                    show: false,
                    loop: true,
                    period: 15, // 运动周期，无单位，值越大越慢
                    type: 'scale', // 可用为 scale | bounce
                    scaleSize: 2, // 放大倍数，以markPoint点size为基准
                    bounceDistance: 10 // 跳动距离，单位px
                        // color: 'gold',
                        // shadowColor: 'rgba(255,215,0,0.8)',
                        // shadowBlur: 0          // 炫光模糊
                },
                itemStyle: {
                    normal: {
                        // color: 各异，
                        // borderColor: 各异,        // 标注边线颜色，优先于color 
                        borderWidth: 2, // 标注边线线宽，单位px，默认为1
                        label: {
                            show: true,
                            // 标签文本格式器，同Tooltip.formatter，不支持回调
                            // formatter: null,
                            position: 'inside' // 可选为'left'|'right'|'top'|'bottom'
                                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                        }
                    },
                    emphasis: {
                        // color: 各异
                        label: {
                            show: true
                                // 标签文本格式器，同Tooltip.formatter，不支持回调
                                // formatter: null,
                                // position: 'inside'  // 'left'|'right'|'top'|'bottom'
                                // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE
                        }
                    }
                }
            },

            markLine: {
                clickable: true,
                // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string
                symbol: ['circle', 'arrow'],
                // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
                symbolSize: [2, 4],
                // 标线起始和结束的symbol旋转控制
                //symbolRotate: null,
                //smooth: false,
                smoothness: 0.2, // 平滑度
                precision: 2,
                effect: {
                    show: false,
                    loop: true,
                    period: 15, // 运动周期，无单位，值越大越慢
                    scaleSize: 2 // 放大倍数，以markLine线lineWidth为基准
                        // color: 'gold',
                        // shadowColor: 'rgba(255,215,0,0.8)',
                        // shadowBlur: lineWidth * 2    // 炫光模糊，默认等于scaleSize计算所得
                },
                // 边捆绑
                bundling: {
                    enable: false,
                    // [0, 90]
                    maxTurningAngle: 45
                },
                itemStyle: {
                    normal: {
                        // color: 各异,               // 标线主色，线色，symbol主色
                        // borderColor: 随color,     // 标线symbol边框颜色，优先于color 
                        borderWidth: 1.5, // 标线symbol边框线宽，单位px，默认为2
                        label: {
                            show: true,
                            // 标签文本格式器，同Tooltip.formatter，不支持回调
                            // formatter: null,
                            // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom'
                            position: 'end'
                                // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                        },
                        lineStyle: {
                            // color: 随borderColor, // 主色，线色，优先级高于borderColor和color
                            // width: 随borderWidth, // 优先于borderWidth
                            type: 'dashed'
                                // shadowColor: 'rgba(0,0,0,0)', //默认透明
                                // shadowBlur: 0,
                                // shadowOffsetX: 0,
                                // shadowOffsetY: 0
                        }
                    },
                    emphasis: {
                        // color: 各异
                        label: {
                            show: false
                                // 标签文本格式器，同Tooltip.formatter，不支持回调
                                // formatter: null,
                                // position: 'inside' // 'left'|'right'|'top'|'bottom'
                                // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE
                        },
                        lineStyle: {}
                    }
                }
            },

            // 主题，主题
            textStyle: {
                decoration: 'none',
                fontFamily: 'Arial, Verdana, sans-serif',
                fontFamily2: '微软雅黑', // IE8- 字体模糊并且，不支持不同字体混排，额外指定一份
                fontSize: 12,
                fontStyle: 'normal',
                fontWeight: 'normal'
            },

            EVENT: {
                // -------全局通用
                REFRESH: 'refresh',
                RESTORE: 'restore',
                RESIZE: 'resize',
                CLICK: 'click',
                DBLCLICK: 'dblclick',
                HOVER: 'hover',
                MOUSEOUT: 'mouseout',
                //MOUSEWHEEL: 'mousewheel',
                // -------业务交互逻辑
                DATA_CHANGED: 'dataChanged',
                DATA_ZOOM: 'dataZoom',
                DATA_RANGE: 'dataRange',
                DATA_RANGE_SELECTED: 'dataRangeSelected',
                DATA_RANGE_HOVERLINK: 'dataRangeHoverLink',
                LEGEND_SELECTED: 'legendSelected',
                LEGEND_HOVERLINK: 'legendHoverLink',
                MAP_SELECTED: 'mapSelected',
                PIE_SELECTED: 'pieSelected',
                MAGIC_TYPE_CHANGED: 'magicTypeChanged',
                DATA_VIEW_CHANGED: 'dataViewChanged',
                TIMELINE_CHANGED: 'timelineChanged',
                MAP_ROAM: 'mapRoam',
                FORCE_LAYOUT_END: 'forceLayoutEnd',
                // -------内部通信
                TOOLTIP_HOVER: 'tooltipHover',
                TOOLTIP_IN_GRID: 'tooltipInGrid',
                TOOLTIP_OUT_GRID: 'tooltipOutGrid',
                ROAMCONTROLLER: 'roamController'
            },
            DRAG_ENABLE_TIME: 120, // 降低图表内元素拖拽敏感度，单位ms，不建议外部干预
            EFFECT_ZLEVEL: 10, // 特效动画zlevel
            effectBlendAlpha: 0.95,
            // 主题，默认标志图形类型列表
            symbolList: [
                'circle', 'rectangle', 'triangle', 'diamond',
                'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond'
            ],
            loadingEffect: 'spin',
            loadingText: '数据读取中...',
            noDataEffect: 'bubble',
            noDataText: '暂无数据',
            // noDataLoadingOption: null,
            // 可计算特性配置，孤岛，提示颜色
            calculable: false, // 默认关闭可计算特性
            calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色
            calculableHolderColor: '#ccc', // 可计算占位提示颜色
            nameConnector: ' & ',
            valueConnector: ': ',
            animation: true, // 过渡动画是否开启
            addDataAnimation: true, // 动态数据接口是否开启动画效果
            animationThreshold: 2000, // 动画元素阀值，产生的图形原素超过2000不出动画
            animationDuration: 2000, // 过渡动画参数：进入
            animationDurationUpdate: 500, // 过渡动画参数：更新
            animationEasing: 'ExponentialOut' //BounceOut
        };

        return config;
    });
    define('zrender/tool/event', ['require', '../mixin/Eventful'], function(require) {

        'use strict';

        var Eventful = require('../mixin/Eventful');

        /**
         * 提取鼠标（手指）x坐标
         * @memberOf module:zrender/tool/event
         * @param  {Event} e 事件.
         * @return {number} 鼠标（手指）x坐标.
         */
        function getX(e) {
            return typeof e.zrenderX != 'undefined' && e.zrenderX || typeof e.offsetX != 'undefined' && e.offsetX || typeof e.layerX != 'undefined' && e.layerX || typeof e.clientX != 'undefined' && e.clientX;
        }

        /**
         * 提取鼠标y坐标
         * @memberOf module:zrender/tool/event
         * @param  {Event} e 事件.
         * @return {number} 鼠标（手指）y坐标.
         */
        function getY(e) {
            return typeof e.zrenderY != 'undefined' && e.zrenderY || typeof e.offsetY != 'undefined' && e.offsetY || typeof e.layerY != 'undefined' && e.layerY || typeof e.clientY != 'undefined' && e.clientY;
        }

        /**
         * 提取鼠标滚轮变化
         * @memberOf module:zrender/tool/event
         * @param  {Event} e 事件.
         * @return {number} 滚轮变化，正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动
         */
        function getDelta(e) {
            return typeof e.zrenderDelta != 'undefined' && e.zrenderDelta || typeof e.wheelDelta != 'undefined' && e.wheelDelta || typeof e.detail != 'undefined' && -e.detail;
        }

        /**
         * 停止冒泡和阻止默认行为
         * @memberOf module:zrender/tool/event
         * @method
         * @param {Event} e : event对象
         */
        var stop = typeof window.addEventListener === 'function' ? function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.cancelBubble = true;
        } : function(e) {
            e.returnValue = false;
            e.cancelBubble = true;
        };

        return {
            getX: getX,
            getY: getY,
            getDelta: getDelta,
            stop: stop,
            // 做向上兼容
            Dispatcher: Eventful
        };
    });
    define('zrender/tool/util', ['require', '../dep/excanvas'], function(require) {

        var ArrayProto = Array.prototype;
        var nativeForEach = ArrayProto.forEach;
        var nativeMap = ArrayProto.map;
        var nativeFilter = ArrayProto.filter;

        // 用于处理merge时无法遍历Date等对象的问题
        var BUILTIN_OBJECT = {
            '[object Function]': 1,
            '[object RegExp]': 1,
            '[object Date]': 1,
            '[object Error]': 1,
            '[object CanvasGradient]': 1
        };

        var objToString = Object.prototype.toString;

        function isDom(obj) {
            return obj && obj.nodeType === 1 && typeof(obj.nodeName) == 'string';
        }

        /**
         * 对一个object进行深度拷贝
         * @memberOf module:zrender/tool/util
         * @param {*} source 需要进行拷贝的对象
         * @return {*} 拷贝后的新对象
         */
        function clone(source) {
            if (typeof source == 'object' && source !== null) {
                var result = source;
                if (source instanceof Array) {
                    result = [];
                    for (var i = 0, len = source.length; i < len; i++) {
                        result[i] = clone(source[i]);
                    }
                } else if (!BUILTIN_OBJECT[objToString.call(source)]
                    // 是否为 dom 对象
                    && !isDom(source)
                ) {
                    result = {};
                    for (var key in source) {
                        if (source.hasOwnProperty(key)) {
                            result[key] = clone(source[key]);
                        }
                    }
                }

                return result;
            }

            return source;
        }

        function mergeItem(target, source, key, overwrite) {
            if (source.hasOwnProperty(key)) {
                var targetProp = target[key];
                if (typeof targetProp == 'object' && !BUILTIN_OBJECT[objToString.call(targetProp)]
                    // 是否为 dom 对象
                    && !isDom(targetProp)
                ) {
                    // 如果需要递归覆盖，就递归调用merge
                    merge(
                        target[key],
                        source[key],
                        overwrite
                    );
                } else if (overwrite || !(key in target)) {
                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
                    target[key] = source[key];
                }
            }
        }

        /**
         * 合并源对象的属性到目标对象
         * @memberOf module:zrender/tool/util
         * @param {*} target 目标对象
         * @param {*} source 源对象
         * @param {boolean} overwrite 是否覆盖
         */
        function merge(target, source, overwrite) {
            for (var i in source) {
                mergeItem(target, source, i, overwrite);
            }

            return target;
        }

        var _ctx;

        function getContext() {
            if (!_ctx) {
                require('../dep/excanvas');
                /* jshint ignore:start */
                if (window['G_vmlCanvasManager']) {
                    var _div = document.createElement('div');
                    _div.style.position = 'absolute';
                    _div.style.top = '-1000px';
                    document.body.appendChild(_div);

                    _ctx = G_vmlCanvasManager.initElement(_div)
                        .getContext('2d');
                } else {
                    _ctx = document.createElement('canvas').getContext('2d');
                }
                /* jshint ignore:end */
            }
            return _ctx;
        }

        /**
         * @memberOf module:zrender/tool/util
         * @param {Array} array
         * @param {*} value
         */
        function indexOf(array, value) {
            if (array.indexOf) {
                return array.indexOf(value);
            }
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }

        /**
         * 构造类继承关系
         * @memberOf module:zrender/tool/util
         * @param {Function} clazz 源类
         * @param {Function} baseClazz 基类
         */
        function inherits(clazz, baseClazz) {
            var clazzPrototype = clazz.prototype;

            function F() {}
            F.prototype = baseClazz.prototype;
            clazz.prototype = new F();

            for (var prop in clazzPrototype) {
                clazz.prototype[prop] = clazzPrototype[prop];
            }
            clazz.constructor = clazz;
        }

        /**
         * 数组或对象遍历
         * @memberOf module:zrender/tool/util
         * @param {Object|Array} obj
         * @param {Function} cb
         * @param {*} [context]
         */
        function each(obj, cb, context) {
            if (!(obj && cb)) {
                return;
            }
            if (obj.forEach && obj.forEach === nativeForEach) {
                obj.forEach(cb, context);
            } else if (obj.length === +obj.length) {
                for (var i = 0, len = obj.length; i < len; i++) {
                    cb.call(context, obj[i], i, obj);
                }
            } else {
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        cb.call(context, obj[key], key, obj);
                    }
                }
            }
        }

        /**
         * 数组映射
         * @memberOf module:zrender/tool/util
         * @param {Array} obj
         * @param {Function} cb
         * @param {*} [context]
         * @return {Array}
         */
        function map(obj, cb, context) {
            if (!(obj && cb)) {
                return;
            }
            if (obj.map && obj.map === nativeMap) {
                return obj.map(cb, context);
            } else {
                var result = [];
                for (var i = 0, len = obj.length; i < len; i++) {
                    result.push(cb.call(context, obj[i], i, obj));
                }
                return result;
            }
        }

        /**
         * 数组过滤
         * @memberOf module:zrender/tool/util
         * @param {Array} obj
         * @param {Function} cb
         * @param {*} [context]
         * @return {Array}
         */
        function filter(obj, cb, context) {
            if (!(obj && cb)) {
                return;
            }
            if (obj.filter && obj.filter === nativeFilter) {
                return obj.filter(cb, context);
            } else {
                var result = [];
                for (var i = 0, len = obj.length; i < len; i++) {
                    if (cb.call(context, obj[i], i, obj)) {
                        result.push(obj[i]);
                    }
                }
                return result;
            }
        }

        function bind(func, context) {

            return function() {
                func.apply(context, arguments);
            }
        }

        return {
            inherits: inherits,
            clone: clone,
            merge: merge,
            getContext: getContext,
            indexOf: indexOf,
            each: each,
            map: map,
            filter: filter,
            bind: bind
        };
    });
    define('zrender/shape/Rectangle', ['require', './Base', '../tool/util'], function(require) {
        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Rectangle
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Rectangle = function(options) {
            Base.call(this, options);
            /**
             * 矩形绘制样式
             * @name module:zrender/shape/Rectangle#style
             * @type {module:zrender/shape/Rectangle~IRectangleStyle}
             */
            /**
             * 矩形高亮绘制样式
             * @name module:zrender/shape/Rectangle#highlightStyle
             * @type {module:zrender/shape/Rectangle~IRectangleStyle}
             */
        };

        Rectangle.prototype = {
            type: 'rectangle',

            _buildRadiusPath: function(ctx, style) {
                // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
                // r缩写为1         相当于 [1, 1, 1, 1]
                // r缩写为[1]       相当于 [1, 1, 1, 1]
                // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
                // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
                var x = style.x;
                var y = style.y;
                var width = style.width;
                var height = style.height;
                var r = style.radius;
                var r1;
                var r2;
                var r3;
                var r4;

                if (typeof r === 'number') {
                    r1 = r2 = r3 = r4 = r;
                } else if (r instanceof Array) {
                    if (r.length === 1) {
                        r1 = r2 = r3 = r4 = r[0];
                    } else if (r.length === 2) {
                        r1 = r3 = r[0];
                        r2 = r4 = r[1];
                    } else if (r.length === 3) {
                        r1 = r[0];
                        r2 = r4 = r[1];
                        r3 = r[2];
                    } else {
                        r1 = r[0];
                        r2 = r[1];
                        r3 = r[2];
                        r4 = r[3];
                    }
                } else {
                    r1 = r2 = r3 = r4 = 0;
                }

                var total;
                if (r1 + r2 > width) {
                    total = r1 + r2;
                    r1 *= width / total;
                    r2 *= width / total;
                }
                if (r3 + r4 > width) {
                    total = r3 + r4;
                    r3 *= width / total;
                    r4 *= width / total;
                }
                if (r2 + r3 > height) {
                    total = r2 + r3;
                    r2 *= height / total;
                    r3 *= height / total;
                }
                if (r1 + r4 > height) {
                    total = r1 + r4;
                    r1 *= height / total;
                    r4 *= height / total;
                }
                ctx.moveTo(x + r1, y);
                ctx.lineTo(x + width - r2, y);
                r2 !== 0 && ctx.quadraticCurveTo(
                    x + width, y, x + width, y + r2
                );
                ctx.lineTo(x + width, y + height - r3);
                r3 !== 0 && ctx.quadraticCurveTo(
                    x + width, y + height, x + width - r3, y + height
                );
                ctx.lineTo(x + r4, y + height);
                r4 !== 0 && ctx.quadraticCurveTo(
                    x, y + height, x, y + height - r4
                );
                ctx.lineTo(x, y + r1);
                r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
            },

            /**
             * 创建矩形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {Object} style
             */
            buildPath: function(ctx, style) {
                if (!style.radius) {
                    ctx.moveTo(style.x, style.y);
                    ctx.lineTo(style.x + style.width, style.y);
                    ctx.lineTo(style.x + style.width, style.y + style.height);
                    ctx.lineTo(style.x, style.y + style.height);
                    ctx.lineTo(style.x, style.y);
                    // ctx.rect(style.x, style.y, style.width, style.height);
                } else {
                    this._buildRadiusPath(ctx, style);
                }
                ctx.closePath();
                return;
            },

            /**
             * 计算返回矩形包围盒矩阵
             * @param {module:zrender/shape/Rectangle~IRectangleStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x: Math.round(style.x - lineWidth / 2),
                    y: Math.round(style.y - lineWidth / 2),
                    width: style.width + lineWidth,
                    height: style.height + lineWidth
                };

                return style.__rect;
            }
        };

        require('../tool/util').inherits(Rectangle, Base);
        return Rectangle;
    });
    define('echarts/util/shape/HandlePolygon', ['require', 'zrender/shape/Base', 'zrender/shape/Polygon', 'zrender/tool/util'], function(require) {
        var Base = require('zrender/shape/Base');
        var PolygonShape = require('zrender/shape/Polygon');
        var zrUtil = require('zrender/tool/util');

        function HandlePolygon(options) {
            Base.call(this, options);
        }

        HandlePolygon.prototype = {
            type: 'handle-polygon',
            /**
             * 创建多边形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                PolygonShape.prototype.buildPath(
                    ctx, style
                );
            },
            isCover: function(x, y) {
                var originPos = this.transformCoordToLocal(x, y);
                x = originPos[0];
                y = originPos[1];

                // 不能缓存rect！
                var rect = this.style.rect;
                if (x >= rect.x && x <= (rect.x + rect.width) && y >= rect.y && y <= (rect.y + rect.height)) {
                    // 矩形内
                    return true;
                } else {
                    return false;
                }
            }
        };
        zrUtil.inherits(HandlePolygon, Base);

        return HandlePolygon;
    });
    define('echarts/util/mapData/geoJson/world_geo', [], function() {
        return {
            "type": "FeatureCollection",
            "offset": {
                "x": 170,
                "y": 90
            },
            "features": [{
                "type": "Feature",
                "id": "AFG",
                "properties": {
                    "name": "Afghanistan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ࡪ͇وŐǬϠڐŶӂʮǚڦ۾ǌƀ̚ІɣʪҴMوǯʲĹ،˒˰ǋ˖ϪԈiżŬĘͺβ̈Ҕȏĝʱʪ¡ý۷ͪ˟̊ǰώĊԼϖׂ×ࢀAƬʋӧĥяƹ७ĭࣗǭӫλȤΣĪллΛ͑ɳ̡ߛͦ։՗ɅΥԕ²ԋ͡ɿ̳þٝŋğɻسDҵӇ܍થΓבôǝȁԇņ࠿űටіހހåզُƚßՔ˟ڢάҢιŮɲؒ΂ਸ"],
                    "encodeOffsets": [
                        [62680, 36506]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "AGO",
                "properties": {
                    "name": "Angola"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ȸصʌԋȘ˕͐ѯ֊æˤŠҬşŲɀɂӨԶ®ƤіHñ̡৴RfՉǞ͕ūԑÖԫ˪̷­ৃȼüκsԴŴϦ¹ĘʹĩСƨϿů̿î́ყZᦵ֤ۋպԽ໳΁᎝Š׋Ж₭ŵÏԃϞկ~ԉƝЙǅÿՈŜ݊̂ޒªΰ˚ݶȨΆӘռːϐĘج«ӊʣ̜ɡԚȵԎ®Ǩʶͬʭ߼ǣ֚сՐĄǎΌŔʒg̎ĸៜ["],
                        ["@@ɉėɣلͼδʪƘ̀˽̩ǯƍɍλ"]
                    ],
                    "encodeOffsets": [
                        [
                            [16719, -6018]
                        ],
                        [
                            [12736, -5820]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ALB",
                "properties": {
                    "name": "Albania"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ń˷ŢέΒȳiə˗ŧ»˙ϷСƛÐgȂү˰ñАîֶŖʼƗƂÉˌθаÂƿɨôǴɥȪďȨ̂"],
                    "encodeOffsets": [
                        [21085, 42860]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ARE",
                "properties": {
                    "name": "United Arab Emirates"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ƭ¤ɱڂƂ۞uԖ{ֺ֪ظՠՎԮǆ˹ŖڑѕGçճƪŝϝǑE΅ʓΏuͷǝǱᡋъ͏࡚Ț"],
                    "encodeOffsets": [
                        [52818, 24828]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ARG",
                "properties": {
                    "name": "Argentina"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ߗ§ѓ̔ԑx࣑@Aሞ͒ϵрؿનԋ୲ȿϙп"],
                        ["@@Ӵ؇͠ڰॠƊǷ໶ോۊŷਆاࡾ͡Ŧχࠡ౧ࡒɭ़ŷڔƈނ٢Ǝݐжǈфӝiڣۻҩ֟΁ॅࠃ૭ଧȽڥɣࡹT࠷ǽȇÝիËѫ੨ܙŗ׃Հν§Ч߯ઁఛ҉။ǩउĎǰԅǣػƺщԋ̏ࡱř̪͕߱ɗŜ࠳֨ʧҠˆʢѧޛʻڭԹūࡋȣ҇ߏEڃљʋؿؙࠞߦǝ˿ݭ঳Ӄձটލͧ΅Ͽ˔ࢍ֔ӡΟ¨ީƀ᎓ŒΑӪhؾ֓Ą̃̏óࢺ٤φˈՒĭьѾܔ̬૘ěӲξǄę̈́ϵǚˢΜϛ͈ȝॺ͸Ǣƙ਀ȠࡲɤݢԊ̨ʭࠐEޚَոo۰ӒࠎDޜɓƶϭฐԬࡺÿࠀ̜ބռ߂צԺʥ͢Ǭ˔ඔࣶд̀ࢎĹɂ۬ݺશȱ"]
                    ],
                    "encodeOffsets": [
                        [
                            [-67072, -56524]
                        ],
                        [
                            [-66524, -22605]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ARM",
                "properties": {
                    "name": "Armenia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@୞ƀǨə͌ƣǛɁ҄˽ʁˋΦɫϘƏl׋̣}΃ӢHżχCʝɤǩuͧʖرȼĄФƛ̒"],
                    "encodeOffsets": [
                        [44629, 42079]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ATF",
                "properties": {
                    "name": "French Southern and Antarctic Lands"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ը˃ߐĿǅɽϣಇÃq҂ŮΎÊǢ"],
                    "encodeOffsets": [
                        [70590, -49792]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "AUS",
                "properties": {
                    "name": "Australia"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ߺ́ҜŘپǊԎÉÐঽ˽́ēگ̉ɰ׍בǧ®ԫԭܘŗֈӝܸtϬռõ"],
                        ["@@̢ڇբ̈́˦ΡЖ͟đϋǴܛŸнɄĹɬܕąѥ˖֭࣬ѭצЋ֞λŋȯӔՃࣧ͜ͲȂ;ηȴźƢࢹ׬ԩϸ͋ڀڹʀڭtӏËԳА܋µݓơϵɩݡjӕǕ׻χއثЭ̫ٱ˫гʝܧ͕нɅػŉׁªˇӕ̇वޡ·ϫ͙ԕέ۟ψԥƪżѬҝǃ݁؉ܩɪӉƄӑÔ߿ʐիԮƻْțьЭ;߱ĸˢРȯزЧ׉ݝƷѮҬŶӞ͘ЬãجہܑԿ˽͏ڛٽΊ~ҀԿ،ѹ̀ǂȘઃԚןz߯Цຓāછ̝ख़˫ߡÈࢻљܯȗǉѱ̳Ϳ܉qՅõݑƶ׿ğֽԁ҃ʕуʁЗˋؕ֛Bࢽ՜ҋǄlӖкŘƚȒ̠ĺאģӼѻࡖƏӒӎͭնsʚϋͰĽڄӓڔřΪτε˳ެиʑʞ͗aјеڎă˄țʦĠӠǢȸŘрęӮΎ؀Úٕ΢׀ۀˬЦΪٜ̰ϤàɴĻڎ̺ԚĤŶȀɞüҬoࢨʖҚώɊ҆ӲѐͲvҘט܎ΠܩΦǚ̗Ј˂ТψǻĸٖҠаȮͨцƜ`ɼτĭdɂτŦОŔبϫҲӽՂMՖÿǱҦДڪϜɘſȾκӒԘ̒јıۺǂeі؛ˢ҂Ū֎ȻҀ·ۼɋʈĐԶʵӬʊ͂ñȠǊϬеɡ͉҇ͻ˿Įͱʙп̗ЭÔʁڜҫ٨ˏѠ́؈ӻʂBѰɍŶʷߤ˵ֈ˼ǐҊǠόľҤʰڞŝОÔʔīӔŌنǈǠŽˬȮѾǆҦtʈ̸̾ʂЩÎՃȾķΛ̨ёÚӇ̥"]
                    ],
                    "encodeOffsets": [
                        [
                            [148888, -41771]
                        ],
                        [
                            [147008, -14093]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "AUT",
                "properties": {
                    "name": "Austria"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Û΃ӁCǎǻ˧էǇƗܽsщȏۛÞயɐȉ̊ࠧƣĭǅԗŢѕxϝƶźȴƬʪ²ьɹŤɜݎ׸ƮЖ}ˀǣþƜšո̠ń̒ϰز˓ӀΆ̐ÚٶʱЂªϰǁãŃČ̅"],
                    "encodeOffsets": [
                        [17388, 49279]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "AZE",
                "properties": {
                    "name": "Azerbaijan"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ʞɣψDGŻ΄ӡֽŒщϰƃ͆Ǫv"],
                        ["@@ϊËƞɈԈͺѴѵђ׭ϺʸɧۗãƣٵƟ̭̍ȝvзȽ¥ԻѲ̂дʝʚ̿×যإk׌ϗƐΥɬʂˌ҃˾ǜɂ͋ƤǧɚȶƎضʍҐ¹ŘĲбҔɔŚʀ׀ԙ"]
                    ],
                    "encodeOffsets": [
                        [
                            [46083, 40694]
                        ],
                        [
                            [48511, 42210]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BDI",
                "properties": {
                    "name": "Burundi"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Á০ɃϢԜßʲӎҀÅ¸ͧǸȏT˗ȹǭ͛ѫ̧̥΍"],
                    "encodeOffsets": [
                        [30045, -4607]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BEL",
                "properties": {
                    "name": "Belgium"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@؜áުǪՐοҦȝħ֧ɕĝһܿϦћßדІϷͶϷ`ũ̒ڪǔ"],
                    "encodeOffsets": [
                        [3395, 52579]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BEN",
                "properties": {
                    "name": "Benin"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ۛįȹ׆ኞǛǦЮ̇̌ʱʞņѶ̀ĨǠξЪĀȀʤˮʘ̠F٘ә˩ȎӽǓͷĘɧСԳʵʳǁՉt՗µണ"],
                    "encodeOffsets": [
                        [2757, 6410]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BFA",
                "properties": {
                    "name": "Burkina Faso"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ֹɐϽ̍Ƀϗǰƥ˦ϙǾÅӦɮΤo˴ښۢŬּɲȴОœΚǢŘɎٴϖǆˀ޼ΒҦŢɀǇՠJáСŔϣӀչНॺȏmֻǿʣЩÿǟν˿ħ݁lϳâ˓ƉωÖร¡qӉŘم"],
                    "encodeOffsets": [
                        [-2895, 9874]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BGD",
                "properties": {
                    "name": "Bangladesh"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@i׽̉ŶÆگʉѬµєǅКΕӨޟü΋˃ҳΧǠũƵʃĠ͗øŽۖ̅لƜԒԫɤȆ̪Հ̼؅Ѽ֮̔ږεВ£ô׏ߞřު^Ӟƛϯ܅ϕµʷӍҢѥƎ՞ɶFѶ೯"],
                    "encodeOffsets": [
                        [94897, 22571]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BGR",
                "properties": {
                    "name": "Bulgaria"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ʎΉ͚Ö٦ſ௾«иɌবȜ̩ؒӴĕѥΏ̫׹˔ӏܣŒࡥ˃Uлޅÿס̊ڧɱة|Ñ֊сːƒŢĝĴƘˌ͌ˀСδ÷̬ȸȐ"],
                    "encodeOffsets": [
                        [23201, 45297]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BHS",
                "properties": {
                    "name": "The Bahamas"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ȵ£ɇӜ̿ʐǾՔʨۣ̎Jӥ"],
                        ["@@ࣷƅÏ̴Ђäֈ{~ɕ"],
                        ["@@ƟׯƷņ`ѮϓͪCĪڐϗ"]
                    ],
                    "encodeOffsets": [
                        [
                            [-79395, 24330]
                        ],
                        [
                            [-79687, 27218]
                        ],
                        [
                            [-78848, 27229]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BIH",
                "properties": {
                    "name": "Bosnia and Herzegovina"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@̦FȿσМ͓ūЃȡƽû˙țūҥݓ͈ͅΘ͋Ȅϭ̾ǻʺЩϾǬΒ̞ȕǼǨϾnܠƓ׈\\Ϟȅ"],
                    "encodeOffsets": [
                        [19462, 45937]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BLR",
                "properties": {
                    "name": "Belarus"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@߼Mࣰ̈́ȚӄېːÿϔԜƚ͖ࣘࢮɁŢȻѲĴࠒȧĊЁǷɧՄս΂Ƴ»Ʊ֦Ʃʎɡ͝ǿڳǉÿȠ˧ȸ՝ܝ¹ʵȁÃхͭĆݷ¡əȞ̿ƥ́ŨڍjफȬࡕàٱmҡɩГeϐʷϴԌǢLͰɷ͌ϊ"],
                    "encodeOffsets": [
                        [24048, 55207]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BLZ",
                "properties": {
                    "name": "Belize"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@OŮĸƴı̞ԔǄZHūǄGaɭƋεôŻĕ̝ÀăīщǓɟƱǓ̅ʣ@àॆPژ"],
                    "encodeOffsets": [
                        [-91282, 18236]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BMU",
                "properties": {
                    "name": "Bermuda"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@OEMA]NOGNG\\Q^McMOI_OK@CQSGa@WNLVWHFLJXVFGJ`ZRTDLeeWKIHGIK@@[MQNi`]VDTBHCJAPBJLVFjT^LV\\RJZRn^RH`TfJjZHHOTTFJP_NOX[EYQQKMEJOLANJH@HQHAARF@ZEPS[U_IcRQXE@EEKKOCGGCQCOGISKYGUC"],
                    "encodeOffsets": [
                        [-66334, 33083]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BOL",
                "properties": {
                    "name": "Bolivia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@य़͟گӳ؈વȲ۫ݹ؅ŗ͡୆ҋऺˆ߾ѳ΢ŏ؆ЫֲՌ࣢αۺȖ˰ƭ̶͠рh܎¤נǸ˶ܩഠزíѠnȈʪ݀;Ѷ͂સƚęؽļ͓ãࣰ֛ݫऴƑ̻ͦ֨ǕΐʑՈTӦʟӟǐʕZγʓa͒এྖūӟĜͧҞɽȤԹƫڋɯρĄӏʿǥaʶ޳јޭ^ัʓЕ݋sҋͥ৕ƉǸ"],
                    "encodeOffsets": [
                        [-64354, -22563]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BRA",
                "properties": {
                    "name": "Brazil"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@૮ନॆࠄ֠΂ۼҪjڤуӞеǇǒӜŖӼBҦ̡ƴ̿Ƌ̻į͔ýޔƿʤ֥ɪ΃ǏࢱǈÈଜʝҴˀǦăӐɰςƬڌȣԺҝɾěͨŬӠྕ͑ঐʔbYδǏʖӠӥʠՇSΏʒ֧ǖ̼ͥळƒ࣯ݬä֜Ļ͔Ěؾષƙѵ́ܿͽȇʩџmرîӃƟϡĪÈ౨ۏӷݏv҄ͅ֏¶ǲΰұԞΓݴɜƶA΢ԖʎċҔɊ̈Ôϼ०ֲێǊŔŴݴϚᘰpθſӔύ̬LؐӀƒǚē͐ӯĔYՀ࿖k˦̂ɸˉǐӷǂļҨѻٸÆǌʲشȞΊƐĮΤ׸ʆ¯Ǯ܅ðśՊ֞ϓɒǀþجŅڜȿʐȤ؀žल̮͎̾ŏʂѪȜȗŉσ̀ŵȖϷɷ̏ƅ܏ɌыÔϳԬϿЮ¥ĢǒˆϠƦ˚ɢҬíȲҚçøǢƗǘĎʐͺõЈĒӔǱξǥʺɪȊŘɿДÒ͒͊ʴؤӼޒ˺¢ȺҫҼ฽҈Ƒxׅمەʾʩ๤Ɓࡃٔր੐̟ඊԡШӱƏҫ঎ʶ࿐ѹఴఔ۝੸व٪ʏܖ̦˅˸੭Ɣԗͯ൹ёշஅୡՙोثܯȿgɻءÒ༽ɹಓęօˇͧƫ૱࡛઱ƛࢁڹηȟԋ࣯Fೕ͓סύवʗ঩ڝ܅࠯ũطƔҫƽࡓȏЧחҥट๕݉ڗ֯Ͻϥߛ։ӑɷӈψЊӟֲڇҬࡹՠ̹{ࡅٰձę"],
                    "encodeOffsets": [
                        [-59008, -30941]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BRN",
                "properties": {
                    "name": "Brunei"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ͬ̾܎ҢЯ·՛Бǭ˹ϥѦ"],
                    "encodeOffsets": [
                        [116945, 4635]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BTN",
                "properties": {
                    "name": "Bhutan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@΂ˍÏԩۇ{ۿÈՇſޅ͊kǚ֌زҒɈ׸șѺqπɥ"],
                    "encodeOffsets": [
                        [93898, 28439]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "BWA",
                "properties": {
                    "name": "Botswana"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ǜƭ˄ӡॎइήĝD̑ʚՑٰŹ՚ϝ஑أݭع˩֓ʧ́ҙãƧГďʽ՝țہ¤БɾΟĸХșȵГЉʧпϑ׻đȇ̐üԠӽߚɧŲAរࠤ|Ჾشಖ͎̎΍՜ͤʮDӂȎưÙ͔ڣ"],
                    "encodeOffsets": [
                        [26265, -18980]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CAF",
                "properties": {
                    "name": "Central African Republic"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ۜÚƺɎƔgȾȏ੔͐Τ͠Ѭ̌ĉ̐ʂüߺ½߆ϴ؊ࣺю;ՐƜĪΫӜԿF΃ƋΓÄʻ̆ʍٖοҢͻT˗֠ѫΖεɆԋغͩƊˉˣęաpكĘ̹ïųȱ˕}ͧǲधнϥĎŗÝʥԕطǐؙĊ՗̴ۓ˸҉˓͛яùדգ²֩ƘԅѻѯޱėʐϦϧ˔̳Ѡï̠ЇѮæʢċΞÞٴȬƴц࡜"],
                    "encodeOffsets": [
                        [15647, 7601]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CAN",
                "properties": {
                    "name": "Canada"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@؎œުxЯ΅̵Å੥Φȿˬ͆ʸ̎С"],
                        ["@@Хcઝ˂ޯІ̄î૆Ɂ࡮Η|Ʒ"],
                        ["@@хŝൡϢʥ̘ݩ̌Ưʈࡻư͕ҜðȚࢨǿԨŵ߄ė˺̃дЋ࠼΍Όҩ"],
                        ["@@։ܿո˴֠ǵ̏̉ݚɱϰȴ࠼ʵʹ؛טƞņѿʼԷΝ݉ϝփǂǾیɻńইܯԅצЂ߫Ȳࣙ¹࿅~ŹʠԼ̐λɬ۸Ԓࢄ೾Զӎܲ̂϶ǋɫ҅Չ"],
                        ["@@@@@@@@߰äʥ॓ܶگͯDԑϪ̵ϮчʾƻτºˎЂŋ"],
                        ["@@͡ѳχîəʢ Î͖ʦΆkɈǣ"],
                        ["@@ঝҧץnǿɪزϲ଼SiǍ"],
                        ["@@ƼυјżӨɗं˽४ʽöЍؤÞ׶˥ݙ˃ಳȬҽϚ࠭ҁ஡ѣ˿Ӯଗăܴдņڌ˺ޔ؈å"],
                        ["@@ष¥ȿЪΦҼޖŜپɷXέħřձʛ"],
                        ["@@Է̍ଉʬۃğଫϘ݊ʼטζࢼʃԎƯʦǅԠ͍"],
                        ["@@G࡭૰ڄ৐եʡح߾֥࢚؈ؖܨ°ईஞÝఔūૼй¼зس҃פ҇ŃУ࿩חୡŻࢃʨʣуߵ۽ʓοই֩ளÇڏΡÇձ঍Ŀਉڻ࣭ु͙ڏ±উంƕϜ޻ϼّ୲ǔ༞εࡀ͋׺Ѕ੆ɳࢸΟ൶µࣴąƍܫʼࡋ،ळనߗ٨˚ҔࡺѭೢףѶഎЀ॒לҮהç֭֘܌৷لলࢤνݾ˫ಾגȘ෸ɫࡸć۠ɚ޴˵ਚӣʮ͙ຄÛ}۷˪ਜ਼ގſ،ӵ௖Ұߦऔ֌ϸٺݣબੳघ৙͵Յ૤Ӂݰӓംɏբˍͬ܃ټŏͶͅÖऻ؍́׽̏൯̗੏ۑ෇ƋᅛǮుPࢇÍ۱׽ੳω௉૗ॵޡ܌Ɛഘૄᄈ۪సČݔЫߍ֟ˊࣟ˜هતп൸ŨࡆीÎ؍ժ̥ਣսᇷԁ࠯ͽय؁ٓÖ܆ฤ۞഍णĹջӆBନύʐ֛ƛ˧ɚٙىʱٹ̕ϡΥŽˏ¥čȹ໽A౥MϛƷࢵ؃Ŀßˍ͝ޗBࠛGϛƅƊǑøʯeďષлࡽſউ҅Ɂ@˷ƂĥŦnĔȂ̎ЂҦʘӺǙܴǵނ࢕ЂľƬūĺɳ@ǛƆ¥ȤǍēɥ¾ĊȡĊćɚٵːڹ˪ࠑ͘߁̨ݧʃ˝Sਕɔڻŉࠁʺ࡫Ɔו¾ʻƜƫҤ˳IE͓჏BᮝA᭯@ᡃ@ᠿ@៙@ᢡ@ࠛ@᠁@ᛷ@őF྽ࠜ׵δຽΐҳݖŤԨ੻ΨƧڴ৭؎iѠҲКwՌෙ՘࡭ॠՁ׾ޑϚ֣ΈѿѢࡇ˕ࠇҹݛւדπࠋɸࠟ|JⷎNᷲ༬ȭ೘Й࢘û݆ΖৰˀఢĹ఼τ൘Ⱦ־ΑظȠȊЄ׈ęෆݫ૦֬ŖّਔƐ͆ʖৰ·౼Λዸ̭ୄƛࠖÄଊэ஁зຶǷᗘĲܒƦࣆԋࣴьࡩΦժ˼৾ڦĎڴȩࡊҗरä๢ϛಬƄ௬oĭԺݞƦದ˵KߑՖڠڰuϞࡊ࣑԰কͺäघশ؎ૌƇࡘχଞॅݗЭ༠ǝ"],
                        ["@@нϿሎʬୠщॊіސ˟یࠛфΒ׭ࡰ݊Ŭ࠲Ƈश͹ՆࠉʼץථеະЉĝσൡã՚͓˱ູ̯Ƃฃɪঋ»ཅ˷ᒃű๻āҕІଫɮݙģਛږ֔ĚಘƜஈરƦྷȞᅗã஗jѷ̴ዎͲಗ[ืɚ۶ـגͮᖬԠ࡬ǋ"],
                        ["@@݉ևಹך˸Ş૸ٔȁ"],
                        ["@@öɵࢿ|ࣟjࣿőʑ¼ऍѾ̠ИÈነěชң"],
                        ["@@ڎԽޤڴᒆΈ෺ࢅůջဒʒߒͮሀыୄЏŊν༚Ȑ࢘՗᎐ܸͩ͹ߐ޻໯ϹጘչೲȁீޙೖÇʽכ้ঋਗά೓߲ઙĿŁӕࢪӥଜϯΌɟմࠩ́׿੕ɪᑏڨஎܣ࢔ԕƎ̉ᗱͲᅩӤ৳Ц̌ʂయќ௥Т`ʑᝡƅ܃˾ֆؤ཈dႸņ˫̜̊оચࠊɳϊ͕˾౿Рၳ˺՞ɆࢷԺ݋´ڏ˸҇ʛ຿ŅᵝȈᄫʚഹŴۥ̐࢞Ϧ஝Hˉ࡚٦ݨࡺ΄ᓪɢأի"],
                        ["@@৊ǯຄńɖʑ޷Е౜αƱݳ൝͗߳ê׉͎ᐡٮjˎ႖ĽएռসР"],
                        ["@@࣓عय़Խ݆`кѮΨ࠰ɮცྈȱళݟ৉Ǎ"],
                        ["@@ᕍЙѷςኹѺήΤ׌ؘܰւࠑԦᭊƀ஬ǧᒰ±ࠄʑࣖΝ੍ɃᏝןਫי@ν"],
                        ["@@ҙ͙௝Øৱɖ҂Ϛீɨܼ̬̍ˇ"],
                        ["@@ٞϵљϣس൱đࣗƈjӬ൝ÝÁٮࣜౌ˺ஂµÜŎ"],
                        ["@@̙͢ݠƘࢢƪЩԝЋ᭗Žᑯη౩mŅ˜პϊ④ĳ୯Ʈପࠐ߈ɾᛄ˳๶ӻฺÛறߨޔ̪ࢄĭ˲Џ"],
                        ["@@ढ˓ကFܨˡȑ́८ȍՔȧଊ௬ë೸ǼႊðീÏ࣒ͅȊ΍ԽɟభǷ੽ĸᜱŻႫcഫļᖁ˔̃ҦĹжࡇξ჋ĺঅʼ͂ΈႾÁ"],
                        ["@@ŗ٣٩̇޹£༝Ϋ഍ŹଗǼ@@ුؼႮծಆ[ସŬ"],
                        ["@@ϣy༽Âɡɼၜ]מƻĵĩ"],
                        ["@@༩ʋఝ˔ڼˎ௮Đஈſ˩ʥ"],
                        ["@@৽ǏඉBbŤࡴʦҌદǝ"],
                        ["@@కǥۃȚέ͂áΎજӪÅ৐̇ɫ̣"],
                        ["@@͜Ε൏Ĥ൩˘ሏߺʠ৫ȮÕ͐࿶ŕᗢ̫ٞЍ"],
                        ["@@০˕ଽʟ༇ك๥Óდņࣗ΄^̦ڔɢ໡Oए˨ՑϠ׌ώ׊ʲࡴÎοȖዜ¨੶҅මǵ൞ǃڒև"],
                        ["@@ᖢßᅮŅ໤ɫɡᏅη᎙ǟݻȉᆬJጡԙേʃ෯ۇႿƓՙǡᡷěୈĿׇƭ۞бߙ˽ಛʃЋ͡୫ʣŞȏ෬lȳᖟԋᔧɴឿŻధĸཟªĿЖ༊Ȑб؆ԢÐᖤγ଩բഹǈڼ͘๰Ȩʄ̊஋͠ΥѠᘞڒĝ಼̪ቃĬ᰽Á๣˸۩ͼগʘȁ˺దǈঘ࿲ƌం̺ਬ©ࣤɽٔҒૐƈບĢᢲҀĝ᝚ƚᆔÁᆒÁ"]
                    ],
                    "encodeOffsets": [
                        [
                            [-65192, 47668]
                        ],
                        [
                            [-63289, 50284]
                        ],
                        [
                            [-126474, 49675]
                        ],
                        [
                            [-57481, 51904]
                        ],
                        [
                            [-135895, 55337]
                        ],
                        [
                            [-81168, 63651]
                        ],
                        [
                            [-83863, 64216]
                        ],
                        [
                            [-87205, 67234]
                        ],
                        [
                            [-77686, 68761]
                        ],
                        [
                            [-97943, 70767]
                        ],
                        [
                            [-92720, 71166]
                        ],
                        [
                            [-116907, 74877]
                        ],
                        [
                            [-107008, 75183]
                        ],
                        [
                            [-78172, 74858]
                        ],
                        [
                            [-88639, 74914]
                        ],
                        [
                            [-102764, 75617]
                        ],
                        [
                            [-95433, 74519]
                        ],
                        [
                            [-123351, 73097]
                        ],
                        [
                            [-95859, 76780]
                        ],
                        [
                            [-100864, 78562]
                        ],
                        [
                            [-110808, 78031]
                        ],
                        [
                            [-96956, 78949]
                        ],
                        [
                            [-118987, 79509]
                        ],
                        [
                            [-96092, 79381]
                        ],
                        [
                            [-112831, 79562]
                        ],
                        [
                            [-112295, 80489]
                        ],
                        [
                            [-98130, 79931]
                        ],
                        [
                            [-102461, 80205]
                        ],
                        [
                            [-89108, 81572]
                        ],
                        [
                            [-70144, 85101]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CHE",
                "properties": {
                    "name": "Switzerland"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƫŹȳϞƵіwá΅χƙةŀǻ͹ЏơƄһ˵Л¡αǶ˽ςБſ^ϠؚҾɈϤûɲƞ܎MǦǼ࣒ʱ"],
                    "encodeOffsets": [
                        [9825, 48666]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CHL",
                "properties": {
                    "name": "Chile"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@Bም࣒@Ԓw˧ͻܛʻЭӻä؏ʨ࢟ŨੑҸ࡫Ҏୃशۘǭ୼֗૜̟ѢϬ˘ֺޠΎװı"],
                        ["@@͢୅؆ŘĺɁ˿ࢍࣵгඓǫ˓ʦ͡ץԹջ߁̛ރĀ߿ԫࡹϮฏɔƵCޛӑࠍpۯٍշFޙʮࠏԉ̧ɣݡȟࡱƚ৿ͷǡȞॹϜ͇ˡΛ϶ǙĚ̓νǃĜӱ̫૗ѽܓĮыˇՑ٣υôࢹ̧̐֔ÄgؽΒө᎔őުſݝPЙȷݷ̣Ɖ޹Σoॅ˚१ג@@ਲ਼ӔˁՒʄӰх֒Ņ෤Φ߰ࢴٰౣʔߞݒ˸ඊत̏Ѯგ֝ɠʿ਻ՉŠ˂ல˺༒ϮָʍࠎéूΠԨപ׈എΤబȗ఼ʤۚĵਞӮਆưྺ˒ნˀሤÕ൘ǩ஄ќɌɦњЬֱŐ؅ѴΡ˅߽Ҍह"]
                    ],
                    "encodeOffsets": [
                        [
                            [-70281, -53899]
                        ],
                        [
                            [-69857, -22010]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CHN",
                "properties": {
                    "name": "China"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ԑഓΫۏѷ܂ĩخӶࠜڦَϨʡƣԓ", "@@ܩЗۏʺyܢаϠࣾɾӚoȊ͍σσșӟ"],
                        ["@@ฬˍ঺ׯͼ߃౨Cܰͨ൸ʜѳݱ͙̭˽ः֡ࠇ৵ƪܝ̑ɜܙť঳ѕwLяթӺͯһಙαƀѹܩЍ˂ֽ׭ऑҋۃա୭ʑأϽࣝɭ҂ϴǭ͞ږ֠ѹѲܷ̓ॉ׏ԫթ࠙¡ѓϻѸ֩یƏϕڔʕस׶ݚ͝լuƌѱஓɻϻҏࠇућיࣜҥͦࠝԞޓ֮٥_دՅɯȪ҃ӶʻŻۃɇڗҷ÷ؗࣧڹિޭোିޡୟۻृĩԣύ̃˘Ӈй୭сࢵŹ˻ࢱҭ·ə؎Ȧ͘ૻːЇƍࡍɔЏ΀ƄӜޏƶЙܑ̀҃ࠇīڡJ҉ȳѥūŶ॥҃x÷Ȣ}Ύ؝ʓεƸر͂ʔۤՏǎȧޜࢱƓĴাߔۮۚ{٠νȨ˭ӶӭÙࣟŲ˴ΜϿԺ׳Ν۵ȸॷ՗އسڳĿοɦѹr׷Țґɇ֋رëڌԟǭওĈोȖڿτٵǔ˯ЖҽŦࡓոکʴΑȩଢ଼טࠛՒɽऐ׾őіͭјĐۆࣙঠ൧ͼʝ٦ةϼƫʌųӎ͜ԛȔ˟ďɇިʈȔśȠߤЈ׈ǐࢸő͆՜ંĲͮ̚೜ҔŠȐãӐּɔݱฦဘͲјȈ؆ຒဠˡҲϞ¢ࡆۦĀٖ֔͢èɚו۸ѽப̿׆ڱ͕ঙ̢ηূƝଆŝ৪ԻԲġϤޟӲӿऒnჄȉ૤Ŝࠦůఔԛ৮BόʽঐҌബ̈ాঘ̒׾҈ך˰Ƌˤˍ͔ѴըӀùࡺǝ࠸Ѿ౲͚؞֊נʆ௠ŐڐĥĠ̘ݿזګː٥̳ࠣžӇŃɏΆר࠾Цو৚̓ஆՎQτݸࢾҲːWҪңȦۜмਰƲ૜vసʡ݈̱԰ࡏ̀α̊ԩ̶ࠕ"]
                    ],
                    "encodeOffsets": [
                        [
                            [124701, 24980],
                            [112988, 19127]
                        ],
                        [
                            [130722, 50955]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CIV",
                "properties": {
                    "name": "Ivory Coast"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ϣUוǒ՟Wহƥ׍ʍ̯ࠫǋvÞۖĄŀ}ͨΣΚˉÈʕɲǾώčО ʔƄB¸ξÝǌĄŜ̸ĶȹڨȗΎæ˸ǘÞŊúɸųٮOƸʖƢgʎĦžΫȞłΌŰϚǽƦ˥Ϙǯ̎ɄϾֺɏɠ஡Ο۷ɕेθܣͧ"],
                    "encodeOffsets": [
                        [-2924, 5115]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CMR",
                "properties": {
                    "name": "Cameroon"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ľ°ӻŇԝŒЋÅ൅nŬڒ͟֊ϧƚǟϖɋŦXɶɎתЎ߸ʒRԄӮ͈bҾΉ־˲ĀΔȌͺžь҆ΊǞךǲȊŢѨɜ՚۾ٲ¬˨ĠƲͫͰˌʂ¶ͮ՟Ê֏֏ҜޅҷTʁÏϥČǻЅӸөμƛŠΏˆ׃ſɩх࡛ȫƳÝٳČΝåʡЈѭð̴̟џϨ˓ϥĘʏÓґڛȤڷɜ੗"],
                    "encodeOffsets": [
                        [13390, 2322]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "COD",
                "properties": {
                    "name": "Democratic Republic of the Congo"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@»ঙͶŕˑ̗͓ɟ͍ѫǯϷ±ګț͍OهʍɹԃŗÝýҟɄϡÂ৥ưޝċѧǘӣӤҹҒ੕ͥĒ૿ƙɣĵʇՙȊχƫষĻࡇɨƫט͝ɲƴìٟࣟR·Ҧ̳ΨٟŠȋѰԣ˅ڧŞ˫ϢՕüϽqµʾ́rϥºԳųιtȻû®ৄ˩̸ÕԬŬԒǝ͖eՊ৳Qò̢ѕG­ƣԵɁӧűȿҫŠˣş։å͏Ѱȗ˖ʋԌȷض៛\\̍ķʑh΋œşʼɊĘμƎɎ̪ǰɚđ˼͐ҜSÄʃ̼ƩӶՄӨШɆː۔θࠆϬўքМĪˌt̰Ǝ̆«ӊŀݖǐԾʦ҈¸Ԕúה͜ѐҊ˔۔˷՘ؚ̳ĉظǏʦԖŘÞϦčनоͨǱ˖~ŴȲ̺ðلėբoˤĚԘۙϘķɤƖϲÅҶǲȦΫ݊֏"],
                    "encodeOffsets": [
                        [31574, 3594]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "COG",
                "properties": {
                    "name": "Republic of the Congo"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@̿˾ʩƗͻγۏࢸٖҪ̓֌˾ɂ֦ĺäό҆ЗݐʴЈł֒ĝڀЉӺζ঄ȽǘسçɻѢÔξ੘ڸɛڜȣÔҒѰ޲ԆѼ֪Ɨդ±·ԓʥ҇ǏԽĿݕ¬Ӊƍ̅s̯ĩˋփЛϫѝηࠅۓɅˏӧЧӵՃ̻ƪÃʄқT˻͏əĒ"],
                    "encodeOffsets": [
                        [13308, -4895]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "COL",
                "properties": {
                    "name": "Colombia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ΫȤЭ˨ʅƅ܉Ŝȱΰƽ_࠿Ӓŕʺ̼ÚтȢ̦иÊΞՆ͐Ѵ̳ȦǄӦȏސǸɚƃ܄ͻ҄ņТ˔ÑǂʠțӶĺŬѢـהΌĚT˦ƺ܂ӖϸՊfäǪڂéڌъ͞ȊОК̖»ɚɛǍ˱գƕɇп͗ʋʓ̷Ĺ׵ɷӭѢÇņϭȄȁâ͹ĳ̵ǫȸéȨ̉ઊĄӦŃעܡͼĚ؂­ӐĪ̔ƟƱҍȇ˯ß׻ǜ֑ʆʟȉэл̨ȃɠ̋ʰ࠹ǁĻǏӸɷˊ˥́࿕lZԿӰē͏ǙĔҿƑK؏ώ̫ƀӓoηϙᘯп҂ʣpժࡤٟϾԍị̈ƤҧɝصŀӵࢤϳɐˍІ֑Њɡā"],
                    "encodeOffsets": [
                        [-77182, -155]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CRI",
                "properties": {
                    "name": "Costa Rica"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@җȆǟǮĬƤȄɷȪͥǔ́ņÅʖəƮÄʑǗȩȓɸˑĊŗǞLʮŎˆʁŠȖǌŴňֆɝȖŊˊéƔǥʜÇȪǲɈҙ͖ͷЂΩ͗õLͷǪűűıƱëǟ©Ǖ"],
                    "encodeOffsets": [
                        [-84956, 8423]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CUB",
                "properties": {
                    "name": "Cuba"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ܨÑڊW߄˹̭ͮ޺Ĩ̔ȡ܈ԳԺϛˢ\\ԆǟÕʁئٌ΅ıȟ֑Ń֡¥׃âளą֜Ҷ΁ɔէÈ̃ʐȥӎӃ޵ɦʥǬભž̋ǐ̀ɀࠗ¨׿ѧΏ[ťȳеğΫĂѺʸǼ̤ϞȈіǎَĄȰĢ"],
                    "encodeOffsets": [
                        [-84242, 23746]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "-99",
                "properties": {
                    "name": "Northern Cyprus"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÐJŨȮ؄Yކʢ֧ΧÔƿęǇÙűj¥iĎÑ¾ǋVɫïƿ¬"],
                    "encodeOffsets": [
                        [33518, 35984]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CYP",
                "properties": {
                    "name": "Cyprus"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ãࡱͿЩŊȟͶЎǀ«ɬðǌUÒ½jč¦ŲiǈÚĚ"],
                    "encodeOffsets": [
                        [34789, 35900]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CZE",
                "properties": {
                    "name": "Czech Republic"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ϯǂЁ©ٵʲ̏Ùҿ΅ر˔ӃΰѕȬėΠƧʠؒǾ̸Ⱦ׾ǎɂǆɜīϒĖЊ˓ؼñ¿ɳҘǧŲɒּĥĄʿز»ϮЯʡCŽƯȕÅȑǇ¡wý˹ēϋbšȁ"],
                    "encodeOffsets": [
                        [17368, 49764]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "DEU",
                "properties": {
                    "name": "Germany"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@d͗ࡔțS̗ࡢǂҾɰॊͧІˋȞёɹɣ̨̙Ⱥ҅ß́Έ՛ϑĕɛĬɁǅ׽Ǎ̷ȽؑǽƨʟĘΟіȫӄί̑ϯ̟ŃŢշýƛʿǤЕ~׷ƭݍţɛыɺʩ±࣑ʲǥǻ܍Nń״ьֺ௅ƸЇɘ´ςǗȐĨ֨ƗࢢԎ@Ɉ͂Ⱦޔƿ˴ǐǲ۰°Ƽȃ֮вȓ̀ӈٌōՠŸ"],
                    "encodeOffsets": [
                        [10161, 56303]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "DJI",
                "properties": {
                    "name": "Djibouti"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ȤʹΑӏȩήɯ̱҇ȅƬȭÏҷb_ʮßɶ˴Ѐ̐ϊήñʪȴ"],
                    "encodeOffsets": [
                        [44116, 13005]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "DNK",
                "properties": {
                    "name": "Denmark"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ԋڹ࢟ӄŝΒ௼˨ˎу"],
                        ["@@ȵ̓ʡĞ؁؁ɮХ՟ŷًŎͽҲ}࡬Ɣɪʌʦ݌À̐ɴڮʂѝʟ˙ĶɽҘŵ"]
                    ],
                    "encodeOffsets": [
                        [
                            [12995, 56945]
                        ],
                        [
                            [11175, 57814]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "DOM",
                "properties": {
                    "name": "Dominican Republic"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ŀƞپIӾɏɜtƴ̕ҠhʡϐЮ̷̯ͿЍǼϫˡ¢ƱƵ͑½ŷȲˣťͳֻɏƆ§ʎjɬɍʦȲƚÞ͒óҜ"],
                    "encodeOffsets": [
                        [-73433, 20188]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "DZA",
                "properties": {
                    "name": "Algeria"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ᮩཽᝩ࿷இϑटćU՘ϵƌԹʊȧЀᬻᆴᬻᆴṕᎠfǌ@ÊQ঺ബب࠼Ÿێɦ͎тচͪجӢòϞ̶સƚƸ͜ɛǲ̃ࢲ¹Ԟ́ՠ߰ҠࣦƢՌΎ߶ʰ෎Ƭർæшůߊͨ࣌P΀ȝֺ¾ǟћƄߟȡۙԭҵôمۊԃRȯԮ͹Ϊຝ˖ݏ°ϵƧۇÔϥŃҟòՇͫΗӺؓέ̘ҵϼƸڒϷςՃ"],
                    "encodeOffsets": [
                        [12288, 24035]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ECU",
                "properties": {
                    "name": "Ecuador"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@҂غǻξ͍ϵԉςǞʀƙބ̎ŴƺԼ͆զÍ΄ҢǸ׀Ͱࡀӑƾ`Ȳί܊śʆƆЮ˧άȣŞٓʽճࣷ࢟য়ͧԥܵǃ֣Ӆ΋ΙъͻĞ΍áw̮ʈȨıΔ"],
                    "encodeOffsets": [
                        [-82229, -3486]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "EGY",
                "properties": {
                    "name": "Egypt"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɽͷǹىɫѩȝƥ˩˔ϛϒ׵ஸđùΐࢯԪࡋٌವ̴ҙ˒ӃݮछǗƣճ঒ݭƨǣΏ@Ὁ@⁩@@ᶶ@Ჴʥڲɐ԰Żά̤Ж૦b߲ɝ࠲ʛϴſ٨ˊΌʊݎêװŃɮеȜ˜ڨȣټ³аɄւ෽"],
                    "encodeOffsets": [
                        [35761, 30210]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ERI",
                "properties": {
                    "name": "Eritrea"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@˻˖ΉӰϋ˒ɏܷ̄ͶֻXȭǬӯȡԛϢʽط঑ǬęʹβఀĊ֒ˆʴؤƐьӒӦঃɴޗҢУବߏҲӍҖӝˀ˿аʧʩȳέò"],
                    "encodeOffsets": [
                        [43368, 12844]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ESP",
                "properties": {
                    "name": "Spain"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@¦״΃θஒ؆ਊƱ૾NࣂƝۦªമͰ͛໺ϡ̨ǺीϝআŊ®ӥߓ֓ઁǯõ˱ԩү͕ہ͞ӑӟϑǹճىǗש٥੧_ߟhՃ͍̓ͅЩê̵˴ʃӚ޷žé˦̶̀Śɬ̃ʢɶրͳԌδèЈƎŬZپϲɪɻфөƝŁӹCɁЬ΃ū̥ɇ"],
                    "encodeOffsets": [
                        [-9251, 42886]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "EST",
                "properties": {
                    "name": "Estonia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĮӸ̱ŁՓ̘ñӘਫ਼ɼ੔Ũ࣮Ƒࢂ|Ŵƣׯӝʞ޵ΫˉۙDܡ̸ρļ܏Ʃ"],
                    "encodeOffsets": [
                        [24897, 59181]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ETH",
                "properties": {
                    "name": "Ethiopia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ԜϡӰȢȮǫּWܸ͵ɐ̃όˑΊӯ˼˕̏ω˳Ͽàɵ`ʭҸaȮÐȆƫǽ̴̕ҧ̴Й̛͎ᩨঽۺNᛛᡃફݟףաeɯ˅ַB͹˴ލΙʝΓ֕àȃĬȟwˇT੟܌ב@˹ˢ@ҾѧƘӻࣴϥȚƧʹэЦԧÒ˸ӐҀrŲʰ[ݲʞࢠЊɾĎ΄ήٜԔи΀ࠠƆܠ঒ǫʾظ"],
                    "encodeOffsets": [
                        [38816, 15319]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "FIN",
                "properties": {
                    "name": "Finland"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ūיಀ֓ޡى঎ख़֡ܛݴس΅յఘֻ́ѓޭӟᅡੵໃá๑̯ൃǯӡҞ߿ˠȈࠢСݶАӪނՆ኎࣮֖Ǭē΢ୟЈ˳͜uಒ಻ֲ૩ЪԊɞतѻલ¦ࣘȭߠϊЬ؞ಬ˶઄ͯΡכ"],
                    "encodeOffsets": [
                        [29279, 70723]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "FJI",
                "properties": {
                    "name": "Fiji"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@̂ʍƓѭԳŗҩļąτ͖̀ϤĻȼƐ"],
                        ["@@՛ǯŅ̼оǤˊ°Ӱˀ@ЧՕȷ"],
                        ["@@é­@ШǨĽЗ"]
                    ],
                    "encodeOffsets": [
                        [
                            [182655, -17756]
                        ],
                        [
                            [183669, -17204]
                        ],
                        [
                            [-184235, -16897]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "FLK",
                "properties": {
                    "name": "Falkland Islands"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@৘Ԍ܎ȿԌʹڦϙʥ̋ଋʥϙ̌܋ϙпϚ"],
                    "encodeOffsets": [
                        [-62668, -53094]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "FRA",
                "properties": {
                    "name": "France"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ˣ٭ϡǠș֢ǜ̺ը͎Ɯܛ"],
                        ["@@הЅќà݀ϥȊñʎjЈɗெƷыֹŃ׳ɱƝϣüɇؙҽ]ϟВƀ˾ρʁʚ̿̅ʯɐٱҖŃĩηݿӅစɬ௧˗ĩԑঅŉिϞ̧ǹ໹Ϣͯ͜ѢԎǆူࢁࢤإю౹͒čؖઠǾථɏˇॎߌέዠپʨێܾǞŪ̑ϸ_ϸ͵"]
                    ],
                    "encodeOffsets": [
                        [
                            [9790, 43165]
                        ],
                        [
                            [3675, 51589]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GAB",
                "properties": {
                    "name": "Gabon"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ࡹࡔ։ۚԙࢄ˨ǾˎȲؔǜخ˴¶௢SOৠЌÆԞőӼňľ¯ÓνɼѡشèȾǗεঃЊӹĞٿŁ֑ʳЇݏ҅Иãϋ֥Ĺ˽Ɂ̈́֋ٕҩ"],
                    "encodeOffsets": [
                        [11361, -4074]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GBR",
                "properties": {
                    "name": "United Kingdom"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@҉ֽًǦԱ[ǦҊǥ҈۴ࣔԳ"],
                        ["@@࣋ࣧࡦŘऄIɕۅݯݩࢄÃäĕݠ঱ֺƇԬढ़ʈͧৰǅķ՝ѓʗͲѣݱѯ૳Rෝɱϻǒ։ϿޥĪם͍ҁǘ௼ࢨݪǺOBಽƔʃͰ࢜ʺҡҐǆռఢ÷D@ŮӤ֛Ԯ_\\৵ƨȧɬ̨ϒˡɴҍЇ·߶щє̨ࢆٶھڤá০ì"]
                    ],
                    "encodeOffsets": [
                        [
                            [-5797, 55864]
                        ],
                        [
                            [-3077, 60043]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GEO",
                "properties": {
                    "name": "Georgia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ųάȿִӟ̲ҭĬ̯ʴĺĲ܄ƝఆƋଦЕƦƻԚƂ޶ǭʴ·Նșɓřвғŗıҏºصʎȵƍଢ଼ſ߳Юࣅ¡"],
                    "encodeOffsets": [
                        [42552, 42533]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GHA",
                "properties": {
                    "name": "Ghana"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@೉ӯҳ˽ݳʑݡʆͨηܤɖैΠ۸ɟ஢ŗنrӊฤ¢ϊÕ˔ƊϴáÕʿΖџC؍Ąڍɂ̫ȅݳäйɢՓȈ̍"],
                    "encodeOffsets": [
                        [1086, 6072]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GIN",
                "properties": {
                    "name": "Guinea"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ʃtǡͷʁJǏǴÈͶΗԨɕħǵmɳ³V̮ƇɘʔǻΜɹ̜ڥDțǁɵoƝǷīɹ҅σρӼ͛͢ɋŊȿǖħϊūȂʓƐώЦʮeɖƘȄDƄŎï˨ĢĖd˶МU؀ȱȄlÚĤҜáŨ´¶̭ƆBɖŒƔɸɇάãɲǺ˖ŒȬŠǚuȈȁĴɳΆΙǣɏ˙ǴĊŀį«ʡʲʍǗÝå˷Ș΍Ⱥڧ̷ĵăśÞǋ·νƃA"],
                    "encodeOffsets": [
                        [-8641, 7871]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GMB",
                "properties": {
                    "name": "Gambia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ņόࣶzȎȦˊ`ͨȷʼIˢƚǞʏεȋιdέǰ̷ȗƭQȫŝއl"],
                    "encodeOffsets": [
                        [-17245, 13468]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GNB",
                "properties": {
                    "name": "Guinea Bissau"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@҅ΘΝÈȕʀLŸʯǴÁǶѼƌ˦ɦĨ༈c˵ġĕð˧ƃōȃCɕƗʭfύХ"],
                    "encodeOffsets": [
                        [-15493, 11306]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GNQ",
                "properties": {
                    "name": "Equatorial Guinea"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƿŴ़̀െmPয়௡T˳µ"],
                    "encodeOffsets": [
                        [9721, 1035]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GRC",
                "properties": {
                    "name": "Greece"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@Ҡ˱ٺ¶شÑqƣҜĶĿʛ௃íTƒਁǎƺΦ"],
                        ["@@ʹՁȥĥԟ|ѫĀৱɓ׌ҿяƋҳAѻўƿȁȊԅрЁ̓ǿҴϯжʑ^ӅޥɠʜѕՓĕ͈ݏ֏Yۍμ̿ڦƧ֒͝ϮљӐÉʆϸТ¼˚˘Ũjɚռö͌ȀҖgƒƦǆت{ڨɲע̉ކĀVмЦɝ"]
                    ],
                    "encodeOffsets": [
                        [
                            [24269, 36562]
                        ],
                        [
                            [27243, 42560]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GRL",
                "properties": {
                    "name": "Greenland"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ᬜԆ᱒ੴ̴ᲈĄ䀦Ŀ㉊ڗ༅͕ộ⭏ćшƫᲐĠᡚ́࿈ʴۦ̝इӧᒞ̺✘͚ᠼǋҾΫ⃝ױӃȕ᧑ơወ¡ছؕگկध৚շಽ൧ˇ༂ѽȢ܋࣍ýઞܡህÑঈ΁˟̑இŽ୥E੆֩\\Ϗပΐћɣଌȿ઼ԣ͈ڱກǉ٫͖ਣӘ˼֭উѵᕖ୆¯ᖯܵᗿڏឧ́ओIࢅ͓ୟࢱᅵכׅ૧ȷ஽ȝܛԱ[כыտോڧͺٿϗ۝љࠍஅ½఍ۈဿLࠁҢ֕ࠐฝਲэոŗݮ୓ޢ̢ئ֗̒ࠪচొ̺ͨΘǬڀॡ̕қůݯţਏ˜Éְ͢҂ެ\\႔ɟ෿Քݩ˾࠷ş۫ȼम޴ԝ̺ڗ׈ৡࢼ੯͚XΚᖷӮᄻÖᖟᏅ×ইˌวՈᕂ˄ၚ¬≹ɖ቉΄Ś͜ẊИᶎИ̪͘ᗗ̠ܺͰ᯲ז௢ĚΓϘጲɜᣚƂᣖRࣺʽᕺҨፘ̽୺áპ˙ፅҐŘή"],
                    "encodeOffsets": [
                        [-47886, 84612]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GTM",
                "properties": {
                    "name": "Guatemala"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ћƦԻfϩǖҍΌrʖĮȠšƾКۆ઄Ft˸Ƌ¾ġǺ̵Ț̹ˬϜDBӂ޸BަUOڗßॅʤ@˚ƱòŰʘŃϥ͍ЉɻÏǉâǑǧɇȟ½¬ıƿġ˽Ƀ}ŭ"],
                    "encodeOffsets": [
                        [-92257, 14065]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GUF",
                "properties": {
                    "name": "French Guiana"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@͉͑ГÑŗʀȉʹɩνǦɈΪòϤƢή͛ӸáֺѪܠ˸ğؤȥࢸۿƔ·ӻޑʳأ"],
                    "encodeOffsets": [
                        [-53817, 2565]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "GUY",
                "properties": {
                    "name": "Guyana"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ր̯Դյzџ̈́o҈Чͪ̇Ƈݱԛɕ°ȣƹџϊ؏ːAŎӃԢܳȱҫî˙ɡϟƥ˅ġǑЭ¦ԫЀÓϴɋьƆܐɸ̐ȕϸ˿ŶŊτțȘѩْ֩ɬɲiϲԬƊȾƾ˽̸ô̬ږӲ"],
                    "encodeOffsets": [
                        [-61192, 8568]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "HND",
                "properties": {
                    "name": "Honduras"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ơˀʭòÐʹŗĞǣÒσĳŔʩƈǷǚʛìǨɈáǒÐǊЊɼϦ͎ĔȂƨʊ\\þåž¦ϸùϲv˒ĢİĦˎ©ȪÉɘnǖòϨśƄkʲƿʐį̏Źɜɳ˽jśŕ̇ŋɃAȅŃǙƛźĕ{ŇȩăRaǥ̉ɳƹıđĽʛǞǹɣǫPȟqlЭūQĿȓʽ"],
                    "encodeOffsets": [
                        [-89412, 13297]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "HRV",
                "properties": {
                    "name": "Croatia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ȳ͗ˊʇ͓̓ϝȆׇ[ܟƔϽmǻǧ̝ȖǫΑЪϽǼʹϮ̽͌ȃ͆Ηݔ͇ġƛ߃̶ӣ̢ޑʠ۹ؤǞØϥΞe˲եƄʱγʝˮn̆bגƸƚ˸ƍͤgGɼ̈ĒĈͺڞɠˊĻؼέۜǉ̼Ų"],
                    "encodeOffsets": [
                        [19282, 47011]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "HTI",
                "properties": {
                    "name": "Haiti"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ԢܰƁôқÝ͑ȱƙɎʥiɫ֏ƜЅÍԡÔϽƿ҉ʾö˔ޜśيã̢ȈϧθP͎ՋžȌɶ"],
                    "encodeOffsets": [
                        [-74946, 20394]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "HUN",
                "properties": {
                    "name": "Hungary"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@˨ըǍǼӂDÜ΄ђɋ̲ğ۸ļäǚͮ~ЦžĜÃЂŀȠȢˠ¼࣒ʭǴĒҲɭÎɣԡǭЉ֫ԕ֭کǁԽ١ə̻űۛǊػήˉļǍ˴ƗV"],
                    "encodeOffsets": [
                        [16592, 47977]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "IDN",
                "properties": {
                    "name": "Indonesia"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@Λe૝ך޴ǒѴʭ̎ʭ»ɩ"],
                        ["@@ܙȁĳĶø˸ΰԢࠨͬĐǓfʫշع"],
                        ["@@̢ɣԲèȼΥॿǛ׉őҍP̀ӚҤPɤ̖"],
                        ["@@ūұ౅ʅૣľE̬ښǪՂʥ֔Üݬ̮"],
                        ["@@ྔċȂΌ༘З̪կీƵਐӿय़͋ऍ͸ݻwࢍØ޻ưঅ͎؝ČΓŁ໕ΌƣΰޑØּߤ৶·ڴ͡ΒÛŘ̗"],
                        ["@@ѝֱćنƬ̠Ǭ˴ȒʗCЏ"],
                        ["@@̿˥ׅƸǏΰࡘ¢Ⱦˣ"],
                        ["@@̨ٝۿΌۯìӃÅׇȦҦਠऎʕ"],
                        ["@@ɼയ࢈ԉ۰ࢼ८ԔݜBܘ̉خ̛ࣘǇbᩑbᩑݟې࡟ǜȷʇ੡}ΦۂՈɺɕࣲЕ۸࿃܆ۗêృަʛУ͑óȏ̮GκٛЮ̢ࣞ״gëɠ௵DͩԄݥƺΡдଈȰњ˜ഘ·Ƃ̹"],
                        ["@@ڭ࠭كǉ߱ǐඓ¥ܽŧţٍݪݛҒϠ༪˸çϯλŪιӯ͙݉ߒ੿Ƶ˿ݲॻQտ҅ʙ̐͡Мی࠙͗ȻɶŊ͖؅ӲØࠌ֕ʭîওறՓũίʚʌޜŽ߸ΛPʻֺΎվŤښф౎ǮΎ܎ذپʛ੖śॴࠨ؎Ʀȉ"],
                        ["@@©ܽџĈŷԝΌѷɽĵ͹Ւʟ੺ǚڤ˨̨ÔҝӸóĀ΃"],
                        ["@@सާহį˫ֵݿַ߱u࠷͕౻ŭ̚ॕϙͫԤ׳´лːৃ̟̩Оս¯ۗĬŹૺнɺЕܘŝ݀ĮުԂ֐Ɩָ֗ӅըǠ՜ÑӪъЖôߒɽۆǶњୠ͔̈̆क़ॲ@ܰƙӍݷآߓơϭ"],
                        ["@@छkۻ۰અۊέԚٍۄзؾٕ୴۪݅ʙܠ̳ڀݵՊѭܘمҺࢗऒóђզಢǋݔࠓٮ֫ҪΓߔࣙࡢ_ۺֹӠ۳٘ϥͳۉӖ̞̅sƜו̊ҵؠõФՏɁ਱ಟ"]
                    ],
                    "encodeOffsets": [
                        [
                            [123613, -10485]
                        ],
                        [
                            [127423, -10383]
                        ],
                        [
                            [120730, -8289]
                        ],
                        [
                            [125854, -8288]
                        ],
                        [
                            [111231, -6940]
                        ],
                        [
                            [137959, -6363]
                        ],
                        [
                            [130304, -3542]
                        ],
                        [
                            [133603, -3168]
                        ],
                        [
                            [137363, -1179]
                        ],
                        [
                            [128247, 1454]
                        ],
                        [
                            [131777, 1160]
                        ],
                        [
                            [120705, 1872]
                        ],
                        [
                            [108358, -5992]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "IND",
                "properties": {
                    "name": "India"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ࣚটďۅͮїѕ׽ŒɾएࠜՑ୞חՑϟ͛޻ࠀͅߊЭરһସŉӜёٮāৠȝ۪bĪͪŋՖÞβԠǮìڋlǙކ͉Ոƀ܀Çۈ|ÐԪ΁ˎڴŀވشॸ՘۶ȷ״ΞЀԹ˳Λ࣠űÜ͇̍Ʒèԫ׷Ʋછׅ~ӓҩ۵§ХϏۗځȒࢇȏ˹ĚΣгȥѵ೰ɵEƍ՝ҡѦʸӎϖ¶ϰ܆ӝƜީ]ߝŚóאБ¤ڕζ֭̓؆ѻԿ̻ȅ̩Ԭɣƛԑ̆كžەţֱ̫Zਛǩ´ك҃ӻ௃֡ळ঩كՋ࠷ջCϭлȹݳ̝Ͻ«ʥٙǪધ®ۡΣߙI෗ѣ¡ϣٙʰˣދʃ˱֯͵ʍߑ޸ϳ୴͑ࡒ̍Јѿ߰ȻੂơՀޅ଼Α࿀ʣ੾HৰǍ޾௣ԉףĶ઱৲И̤ʝͤড܊֖֔ᇜCǗܞҽюĩ٨ջϘऒࢢঊÙ࢞ࢢՄ࡞ࠄࡈ_״ܒӠڳд֪݂̇̕Ьβ౤ȱपŰߺ۸"],
                    "encodeOffsets": [
                        [79706, 36346]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "IRL",
                "properties": {
                    "name": "Ireland"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƒ׷ًݣ๯ӹ஑Ŷڼ࢚ѭࡢତڄٌϼǦ҇ǥ҉Բ\\ٌǥ"],
                    "encodeOffsets": [
                        [-6346, 55161]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "IRN",
                "properties": {
                    "name": "Iran"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@݈ǌװӔ֚{τƾװýघэڤğ।ݓظòۻ΁਷ɱؑκŭΫҡˠڡàՓِƙæեݿݿжѵ͸ԓߦυx݉ДƋêϯ௉ѡ̓উཌྷʪࣷȖेŊΧਐЕƪ٣ƭࡑНਇ˦ࡑ٦߳ʈ֗ߘا૪ҍƋՕ˦̻͝ҭѴS҂ˍ@Ɛ،ѝٔ਍Ң׉ߜȜپц̂ÙӬտʨխ৊ҟڨǐʼʿ६ּʈƄͅъϯ־ő̤~রئ̀Øʞʙ́гԼѱȾ¦ˈإߖǩ׎у஠ƟಾɞĄȞ"],
                    "encodeOffsets": [
                        [55216, 38092]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "IRQ",
                "properties": {
                    "name": "Iraq"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@րʧÚӫх́țٽ׊ߛ਎ҡўٓƏ؋ˎ@TҁҮѳӿ¤֟ê؝߭༟äᛍၖఫךৡɪ͹৾ᇶ࢔͆৬āؘҢȺјԾΰž঎Ň̐ɉЖƚծ৉"],
                    "encodeOffsets": [
                        [46511, 36842]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ISL",
                "properties": {
                    "name": "Iceland"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@șիॊֵથٙᝓֹܣƵૉŮᚑˈࠠψᆧЪ๪ǎʘᄋȜ֨նౠŰಸ֭౨Ҝ੒ʃൌ҄ආÑ"],
                    "encodeOffsets": [
                        [-14856, 68051]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ISR",
                "properties": {
                    "name": "Israel"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƥ˅̣Ŝǫ֓ɂĥɋřɛЄŖp͛нഉց෾ʔˢË¶ɞϼǠيŤɆzVˬCþƦɤ\\`·ŕŵhM"],
                    "encodeOffsets": [
                        [36578, 33495]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ITA",
                "properties": {
                    "name": "Italy"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@̟ڋŲʹǭѝٝ̈́ёĞ୩ѐŞќজûࡪĠْò"],
                        ["@@Ԍ׭ş૕ϣÂ΁˫͇ɞ২ȓӒҨ¥рʼ"],
                        ["@@ரɏĝЯȬΧڝŪہ̗²зĻʇˠё߀чцۛदڱچLȲȃɽǗݪ̥ؠʩܜѫĔƿƽ̛үϼܳƐΝի؈̷ıѫΗ¹҅ܛΕÝHʲǢҊǼǶ͝ӤʱшΑŀʛδգƴεͶثÆٿϜޑմ֯ӜʿࠪйĮہˤϯŕӝϵΓÕĪθҕńɏٲ̆ʰʙ̀ʂβǵМ¢Ҽ˶ƢƃАǼͺتĿψƚâΆԘšĮǆࠨƤȊ̉"]
                    ],
                    "encodeOffsets": [
                        [
                            [15893, 39149]
                        ],
                        [
                            [9432, 42200]
                        ],
                        [
                            [12674, 47890]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "JAM",
                "properties": {
                    "name": "Jamaica"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@֢÷ҀȫƔɯןeʭƗҹƊӑ̪ĶȔΜÎȒ"],
                    "encodeOffsets": [
                        [-79431, 18935]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "JOR",
                "properties": {
                    "name": "Jordan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ʀˆपͫ࿪ࣆͺ৽ǅų၅у࠸࠿ˣƛƑ˭ٙřȩ̡εʵधƆŨоഊo͜Ůʚ@Ԥ"],
                    "encodeOffsets": [
                        [36399, 33172]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "JPN",
                "properties": {
                    "name": "Japan"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ņ˽ҿԕΉːљțɝӭշʈRЊҬԆӌīΊΜؠǹ"],
                        ["@@́ڡƤсѩף੹Ѓ๏½ணॡ͔֡غษȃষЃঝe࡞أ֗෗իΝН͜ȶݶՏʒͿ־ߐʶѲՈࡌѢ؞ָာʤ࣎ǣࢠ๺֔Б௾ࡀӌ͜ՈਈƟा΢ՎࣀƸҞୗ}ڻޥࡍbࢁ"],
                        ["@@נǵרΤȈहఝɯ݁࠱೓ָқँण]ř࠴д٨࣌²ʖ୐ʜټন࢓٤˯"]
                    ],
                    "encodeOffsets": [
                        [
                            [137870, 34969]
                        ],
                        [
                            [144360, 38034]
                        ],
                        [
                            [147365, 45235]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "KAZ",
                "properties": {
                    "name": "Kazakhstan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ӕƹ્דο׹̹KɱЊ੫ǡێХNÚࡆ৓ؘ෷ßডũߣݶۋ͆ಥ׼ƽðᓗӹᶽљ£יچ֧ɼॕǩχ˧±ȲȶΖǅ̊অ˺ϛݮҩɆ˜ࠊāؘ܎ƎܼűƲࠎƭԲ࠿£܍ȴঃσ޵ǭяƌĐўՙ֘دw܉֬ӞِʕǢڢऊࡺӣŀؘჄࣴಾtᇢ׉঺ͻࢼΠ೰j੺ѥʔʠ୼ɂЊഷ׀߮Цƿɮ߮ɔ؅ֺϬ˼Ḯ̈ШȺᑆ̴ݰΒຢǹ˄ࢉ࢚Ȳઆ˹éҝ߮´ᑌߎ̭ˁ੶٭ሠᒑ҄ѰୄӛீɎҪƯКӟטǋΨΥ઎ŒѾԣٕ֓ۥÿ¡ࡅұϝဟˢ؅ຑїȇဗͱݲลֻɓäӏԭŬу̠ఝĖඃx̧ġ஥ΞӉǧŽӹ൩̂փşȉρ"],
                    "encodeOffsets": [
                        [72666, 43281]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "KEN",
                "properties": {
                    "name": "Kenya"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ӾۙיͱȹΕ̿Õšףˑ͹Ǐ֑ͷ˥஻ࡀËӤᵁႌƙĢSࢺʊ;а֌̨ؔσ॰įтЉ׎ԬԈ֬ֆѨƗ@ҽ˺ˡג@੠܋ˈSȠxȄī֖ßʞΔގΚͺ˳ָAܽ॑Xᵣ"],
                    "encodeOffsets": [
                        [41977, -878]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "KGZ",
                "properties": {
                    "name": "Kyrgyzstan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ȊςքŠ൪́žӺӊǨ஦Ν̨Ģ඄wఞĕф̟Ԯūşȏ೛ғ̙ͭઁıͅ՛ࢷŒׇǏߣЇŜȟʇȓཟŵਡ˘࣫ÝĂӜࣴƕ̮ʸٖĉ੾؂঻ѸױȽإ͂۶ծʟĊ"],
                    "encodeOffsets": [
                        [72666, 43281]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "KHM",
                "properties": {
                    "name": "Cambodia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@΁Ѭыࢄȣ২ՠۨઘǆ߀ťۚ͡Ϟׄݖ̱Ȝ֕Ļ৕ඳ٧τԙࢥÓܫͷ۱Ū"],
                    "encodeOffsets": [
                        [105982, 10888]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "KOR",
                "properties": {
                    "name": "South Korea"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ܨযȺխPॷ̓ҥݽǉڥΏݳïĥҚƼـχ࢔ذƚֻܘÂúϒ͞Ϝצ¢ΨÈŨȮ"],
                    "encodeOffsets": [
                        [131431, 39539]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "CS-KM",
                "properties": {
                    "name": "Kosovo"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ǣŃPĘ́ȩĐǳɦƾȌȪÒŜ˨ư²Ţşƾ¿ŌƅƒǎƻŢLĥȳĳĳ×ȉӹŻ"],
                    "encodeOffsets": [
                        [21261, 43062]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "KWT",
                "properties": {
                    "name": "Kuwait"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ǭχõȓ˔هשuȽАݟĆ؞߮֠é"],
                    "encodeOffsets": [
                        [49126, 30696]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LAO",
                "properties": {
                    "name": "Laos"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@˚Ϝ܆ڹܸ¿ٕࠦھٍÎǛ̉ӯyʣƨࢯԅoݬȸࢮ֧³ԎηʸǴ̲ܐնøȡ҄wŵ०ѦŬӮڏϖޅਚO͚ܹ՝ɗʉ̟৔ԉۦ঳Ռ݋َ׏ɄץƵ࠿ݕ̲ϝ׃ۙ͢"],
                    "encodeOffsets": [
                        [107745, 14616]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LBN",
                "properties": {
                    "name": "Lebanon"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɣ[ýƥ˫D̘ۄмעfϘ§Ɛͣқ̓ȷҟ"],
                    "encodeOffsets": [
                        [36681, 34077]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LBR",
                "properties": {
                    "name": "Liberia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɗQࡽАޅٖ܏Ң֣ըȪː¬ʔϜҘϺϺǶnɖĨΘԧÇ͵ǐǳʂIǢ͸ʄsʓĎНǽύʖɱˊÇΤΙ~ͧăĿÝە"],
                    "encodeOffsets": [
                        [-7897, 4470]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LBY",
                "properties": {
                    "name": "Libya"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ק̷ҿҤ೧βρՄڑϸϻƷ̗ҶήӹؔͬΘñՈńҠÓϦƨۈ¯϶˕ݐШȜðΠėΒ־͔ʶːЦʌ´٦দ́ΜðۮƓ૞ϓЀݛݮǍஆΙࣆйЦɔЖϮț٠˂Ф؄ЀׂŘ଒ǣ˺ϑ̺Iˌƛ࠴ıȲˣ̣ЕżΫɏԯʦڱ@Ჳ@ᶵ@့ॱGYΙ‧ྐ‧ྒࡓҟ"],
                    "encodeOffsets": [
                        [15208, 23412]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LKA",
                "properties": {
                    "name": "Sri Lanka"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ų࢓ΙʇܵȓЍڜƫீϠ഼׆ұϺסО࢓"],
                    "encodeOffsets": [
                        [83751, 7704]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LSO",
                "properties": {
                    "name": "Lesotho"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@̆ʩʳУƛ˛ҳſƹˍ̛ċؿ٨҄ՐҖ͢ϼǠξʵ"],
                    "encodeOffsets": [
                        [29674, -29650]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LTU",
                "properties": {
                    "name": "Lithuania"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ãɊĚɲχƄࢡƨǱ۸२ʴඬÁࠜĊŞǩ҂Ã߲СĀϓۏˏșӃ࣯̓߻NȫʶљĜ"],
                    "encodeOffsets": [
                        [23277, 55632]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LUX",
                "properties": {
                    "name": "Luxembourg"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ǘȏ³ρʍiȉòĞҼɖ"],
                    "encodeOffsets": [
                        [6189, 51332]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "LVA",
                "properties": {
                    "name": "Latvia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@نЮՆߊ˼ڜعڪhǊ٤ܐƪςĻܢ̷ۚCКȕîС˒ӷ͕ࣗԛƙ߱ТҁÄŝǪࠛĉණÂ१ʳ"],
                    "encodeOffsets": [
                        [21562, 57376]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MAR",
                "properties": {
                    "name": "Morocco"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ԒΥߜÎࢊȃκU͂՟ºԝ̄ࢱɜǱƷ͛ષƙϝ̵ӡñثঙ͍ͩсۍɥ࠻ŷഫاRহŷ@@@p҉Ա˓ȑϡ@̥Ŋ۹ě˛ٻʿÕЁ੕ୟ࣡ˣୋ΅ϗĵ̡ቅãaD ϶͒ɮ˞ѪÃ˶̀פҴՖ˲ƊɞӬp҂̤Բ̪֔Ւ࡬f\\ц͔ްĢڎָтɠۮۮȿਸ਼͊ܢŔѶդ֨ࡈϦخΐ֘࢈˄ԪؤI"],
                    "encodeOffsets": [
                        [-5318, 36614]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MDA",
                "properties": {
                    "name": "Moldova"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ȨŮ֒ĊؤʽΊϞɥÑ˵̪ƏŨΗ̊ɇÏűƾčɝ×ӷ|ĉŜǫãÒƭɱˍƥ˽ɁĝƯϦĘΪςӝԂˉΠʹʠʯĈ"],
                    "encodeOffsets": [
                        [27259, 49379]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MDG",
                "properties": {
                    "name": "Madagascar"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɠΥȺ։Ɗঢ়ɒϽĉЗƩʙ˷ӰǁʝǈثõΥɵȗ¿܅ͧওб୅ԯཧ͑ୟϛইہȣܻΡӛɊڙ̜ɳѺÇݘ̑ڠù؂Ʈ؄ϰƢD˪Дِø՚șЈǃՌãޠ̊ҺŔՒмҶǤ̶Ʋτ\\ӐӎۖԮʦцŗάΦĵҪ׎fԐ˦ϔ̊ί"],
                    "encodeOffsets": [
                        [50733, -12769]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MEX",
                "properties": {
                    "name": "Mexico"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@͙݅ƥ؁Õ૷ąЧƤқʺЧǚٳ֎سȞӏ͢бࢾɝΐΙ݄ɾٚĎؼưՊƠՖ΂ȨӬè۸Ƣʖ֬ɚࢶȚݔԚîȬǱЙҋԁȥԝƸƥűγɁٽɅɎǭcǃY̝ԓƳĲķPŭޥV޷AAӁϛC̺˫̶șĢǹƌ½s˷ઃEЙۅŢƽĭȟqʕ्ࣞџ˘ۇɖҷÓګ́чĉץɜؿǄ޹ϬؿŠ्ϸ۱ВɃɤҹº࡯ˈΓϦࣗӊсՌȧЦ˪ĈđʈȖɔJ̄˱Ϙùͮ˭ъ݋࠴ࡋڀУԼܝ΄ƷȴŸԲѓȞӹФȽהҍæӣѸϿФˀҍو̓٠^͔؇ͬ˫ӑɴƇͿƔЕĆف̀΋خׁƒȡŸÓŎ˽Ƭ\\ǜթʮɇǴ̕Նё˨ޯʠρɸϿ²ѷКͶϡ̨ϑqƭΝ̱ƫJɛԞջӎ؃РїɈؚŵҖЏʺֿϒŏŇɃɖԭȰӷӦÖÚΊ³̸̼Ϝ٩׶ӱɶ̱Հ̷վϳڦͿݲॖÞ੪ĞÿǑ౔СኀףဪPژ@DΌผ@̪̕јˇԀσ˨ѭȾҥѢʩۤʥՊڒۊhפͱфֹ̄ӯӸӏȂחɾЃپʹ׮ȁ͞|"],
                    "encodeOffsets": [
                        [-99471, 26491]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MKD",
                "properties": {
                    "name": "Macedonia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ńOǤӺżȊ˺¶ϴbтˏÒ։ǅƑƥҕh͋ǿջõΑȴšήń˸"],
                    "encodeOffsets": [
                        [21085, 42860]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MLI",
                "properties": {
                    "name": "Mali"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@˰ƶƘӶˊpזɻӄǖ͖ÇŴȈ⁚^ȈךƣļЛ⋈Л⋆౾dᬼᆳᬼᆳȨϿԺʉ϶ƋV՗ठĈFካҟ֗íԭݛƃ଩ï̳̗ա՟Iȿǈҥš޻ΑǅʿٳϕŗɍΙǡНŔɱȳūֻڙۡp˳ɭΣÆӥ΋ůȝŁŽάʍĥơhƷʕ٭PɷŴŉùʱʎ¬ʢĿİǳĉ˚Ǥɐ΅ΚĳɴȇȂǙvȫş˕őɱǹΫäɷɈƓɕőƅAµ̮ʾí̽͘ʀǓӔԺ"],
                    "encodeOffsets": [
                        [-12462, 14968]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MMR",
                "properties": {
                    "name": "Myanmar"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ӫηץϥࣥΟƳО݅ՔؗΈօ̭ܵ̃ƹȪу֖ڙĪҷ_ϵ͠ދң޵Сࡷăذʴ٠˯ӼæࣸͽѤ˛৔Ʊਗ਼εۢօуॕ׳ҽöԳȠ̂ਪǫ޾څॺļ̢ӭņ׭ۆÅڰ̊ŵj׾дȦęΤȐ˺࢈ڂȑϐۘ¨ЦҪ۶}Ӕજ׆׸ƱçԬ̎ƸÛ͈ӮÚˮӵξȧ|ٟۙߓۭĳঽࢲƔȨޛՐǍʓۣز́ζƷ؞ʔ~΍܏յǳ̱ӓȗ"],
                    "encodeOffsets": [
                        [101933, 20672]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MNE",
                "properties": {
                    "name": "Montenegro"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÁǀηЯÊˋǫÞɽ˞εǖĢƜŬҦ˚ȜƾüɠƟŬśˠě͌ǧçïƽȋɧó"],
                    "encodeOffsets": [
                        [20277, 43521]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MNG",
                "properties": {
                    "name": "Mongolia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ࢮƢ྄ܤ౬Єܴʳ࢚]֘Ͻ࠼ௐɁࠈגͿӶࢊࢊश΍ނįনɍǈؿஜΛߐƺਫ਼ŌࡆōࠖЗԚѕެT੒Ƌޜȼૈƒ௸פԌĝѰ˭ৌêХهק࠽ɐ΅ӈńࠤŽ٦̴ڬˏހוğ̗ڏĦ௟ŏןʅ؝։౱͙࠷ѽࡹǞҿúѳէˎ͓ƌˣי˯׽҇গ̑ఽഫ̇এҋϋʾ৭AఓԜࠥŰૣśჃȊऑmӱԀϣޠԱĢ৩ԼଅŞুƞ̡θ͖চׅڲன̀۷Ѿəז"],
                    "encodeOffsets": [
                        [89858, 50481]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MOZ",
                "properties": {
                    "name": "Mozambique"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@لæ৞ʁɖńגt̚ʦԌaऀ͜ڞӤƊϕ࠷ľ݅ಿƨЫʣ׷͙׍՗Եޏ͉ृСॉ͓ࣕƵוׯ΋ȗí׳ЌُǔӱZʣƪ¦{ࠗƋϷȤƝűΓΗ̗ۗ˳য়ҕρ̳ðΟɊÉíѵّRïϊůϖí̠ƬपɓװГஂࢬ॔ɜ؆ŶúĨӶƉʞغǐ׌E੠ѥ˒ЏÔǹȼϳǰ۫gÅ̼āװᢈۘӚЕɴüͨɅ¸͵ǯϷØסոԱʲ׌ζǰíઊΙ؈̣˖̅]ɽદɾٔ"],
                    "encodeOffsets": [
                        [35390, -11796]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MRT",
                "properties": {
                    "name": "Mauritania"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@և־ԗؤ֍ɞГʚҵUЧǽйð˽ˏïҐɺаŀߊģࠨĵкČмɑЎѵδǾˬᾔMǃ௎ȴќ߀øᒸ᪂©F౞Ṗ᎟౽cМ⋅М⋇ƤĻȇי⁙]ųȇ͕ÈӃǕוɼˉoƗӵ˯Ƶ"],
                    "encodeOffsets": [
                        [-12462, 14968]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MWI",
                "properties": {
                    "name": "Malawi"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɽٓɾથ̆^̤˕Κ؇îઉεǯʱ׋շԲ×עǰϸ·ͶͧɆɳûәЖѵɔʮޮ˄̈Ǉۢǚڼƞɪɉ܌Ѕϐ࠘ƽǜɵ˶Ϲɾଡ"],
                    "encodeOffsets": [
                        [35390, -11796]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "MYS",
                "properties": {
                    "name": "Malaysia"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@àћֈĶ˞ΈȘýӸԓΜ֛¶֣ęϡĆ˿Öӻ̒ɵͤݑe˳׫Éߑخ঵ښįђӟ֚ś̡۠ҜĠؔȃΤƤƮۈρ"],
                        ["@@أ˹ܯƚॱ@̅ॗ͓̇љୟۅǵߑɾЕóөщ՛Òէǟַӆƕ֘؜˽ٮǀǜ܆άǂ৖Ǻ׾ڔЬՐϦѥǮ˺В¸՜а٪אшڀͼHќыιֆɻ۬ʧÑ֝͡¥ƮЧ"]
                    ],
                    "encodeOffsets": [
                        [
                            [103502, 6354]
                        ],
                        [
                            [121466, 4586]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NAM",
                "properties": {
                    "name": "Namibia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@رٌؖ͡ȃࠊȷ،˯ಒm৒ŅҞ͛Όѡۜѳ৘ǽՆۃࠐ»٢КǆԊƞհ}ԄϝŶÐ₮׌Е᎞ş໴΂یȒհµͨȍPéӁȍʭC՛͍ͣΎಕ̍س{ᲽࠣBយA᷋ݣѕҋÕՇǄϗÔƗάͩɰГг"],
                    "encodeOffsets": [
                        [16738, -29262]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NCL",
                "properties": {
                    "name": "New Caledonia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ېԵѨϭ͉ȫҥɪ׹ϚէѼ։פś˶β[Һ˹φ˷ˎɻ"],
                    "encodeOffsets": [
                        [169759, -21585]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NER",
                "properties": {
                    "name": "Niger"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@nּॹȐОҿպœϤâТբ̴̘ପðݜƄîԮҠ֘Eኬஈϒᝪ࿸᮪ཾ೨αӀңר̸ȸಯ̾ɓ`ˋΔ˽ǻί͕ၻ«ધੳߋγૉΔ̵CեբmčЃʁµˋƻm֩ंȟځҷٱʔҍ¸ʏşӯ~ӷΧѓq৯ѢЉȵѓb̿͆ࡅ̼ࣗıɕǻşӗʋ͹ÍݣٗӚ̟E˭ʗ"],
                    "encodeOffsets": [
                        [2207, 12227]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NGA",
                "properties": {
                    "name": "Nigeria"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ࢍ̡͉¬͓ȉڥl҇Ղˡ؊שֆكYݍB¶തs՘ǂՊʶʴТԴėɨǔ͸ȍӾ˪ÎݤʌͺŠӘɖǼࣘĲࡆ̻̀ͅєaЊȶৰѡєrӸΨӰ}ʐŠҎ·ٲʓڂҸȠ֪ँƼnͬͯğƱ«˧۽ٱɛՙšѧǱȉǝי҅ΉŽыȋ͹ÿΓֽ˱ҽΊ͇aԃӭʑQЍ߷ɍש"],
                    "encodeOffsets": [
                        [8705, 4887]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NIC",
                "properties": {
                    "name": "Nicaragua"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@̃ˆϽͺȁ˲Ο˄сϜĤžƒŵÚÒʾŀȔŬRkЮȠrǬOǺɤʜǝĒľƺĲ̊ɴbǦĄQňȪĖ|ƜŹǚȆńɄB̈ŌŜŖ˾iïă§ȉĐ̫ȗ˹ěͷυ®ɏtϙŹĉýΫÌɛǣɋ ɩźƏȩǱʛÈƓǦˉêȕŉօɞųŇ"],
                    "encodeOffsets": [
                        [-87769, 11355]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NLD",
                "properties": {
                    "name": "Netherlands"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ۦyǀ˳Ƚޓɇ́ԍ@ƘࢡҥȞՏπީǩ؛âѠɲ݀ఆଲΘ"],
                    "encodeOffsets": [
                        [6220, 54795]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NOR",
                "properties": {
                    "name": "Norway"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@᥆ؙઍɣऄՅෛ͵ڵû΢לઃͰಫ˵Ы؝ߟωࣗȮ઱¥णѼԉɝԷūփནƊɝҵ߭Hևױ࠿झಫ஁̨˹̇ͫ࠯bձ޿¾૟՞э˥ধֻۧυӛ֝Ԫဋঁ૫ȟ୏є̛ࣚˇ኶ޞզᕠ۶ဌࢂ໤୦፺ྴඦلᘼ੊ᇎπ൪­౮ۢ໖ພǘ"],
                        ["@@ም΅๝Ȝ׆ɐԕˎეǚͮ̿ொȍ"],
                        ["@@᪖صᑟͥұأ݅ǁЍۡৣᅵԢނ̘ఽʐ࿕܂ٷڄᘎ̜Ң̋஦\\͊˼௾੖̋"],
                        ["@@࿮̏ఝҍ᝱ı៙ƖƫɴஹdँϬᣴɼ௞ȫࡘʤᑺȽ"]
                    ],
                    "encodeOffsets": [
                        [
                            [28842, 72894]
                        ],
                        [
                            [25318, 79723]
                        ],
                        [
                            [18690, 81615]
                        ],
                        [
                            [26059, 82338]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NPL",
                "properties": {
                    "name": "Nepal"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÝαŌՕĩͩ۩aয়Ȟ٭ĂӛђଷŊયҼ߉Ю߿͆͜޼ՒϠΒȪڪʳࡔշҾť˰ЕٶǓۀσौȕঔć"],
                    "encodeOffsets": [
                        [90236, 28546]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "NZL",
                "properties": {
                    "name": "New Zealand"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@Ȓ΋װ;ʐΡBΝ̹ϳչإїͷ̴З٭Yܗ̓ɣջӋࡗڇϓнʇޝlխˢࣱÐƗ̰Ҍذ੐ࠦժǀ׾͌ܜѰԎѦώظ͈ɆŰҶלϴȆΧ"],
                        ["@@،ࢫlָϜɯŲًڰ˛֨ãӒ͎юĭȯݗʯӫٛjɡʭþαūƻͅҏзֹ٭ͯƟɘΕŨӞ۔˟ҨࣛͲz̦؈̌ƚ٨լͻ֜vƪБΎڋݔΗת̸àҚұٺɑʂݡ"]
                    ],
                    "encodeOffsets": [
                        [
                            [177173, -41901]
                        ],
                        [
                            [178803, -37024]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "OMN",
                "properties": {
                    "name": "Oman"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ֹ̻ϟªǩȧƉэļ֗ÿĻϯFԽ̻ćХȓǯԹP͡ɃJͻПɷҩĂ֗˳ϱ³˝טٿ൴ᠾ࠾֖၂ϩתv͸ʔΐFΆϞǒƩŞèմіHϖֵҸ̧؞ŋӼƳϜӕɨ˧̞ŃCȉ̩ԃƅɽΟˏ"],
                        ["@@ŉƳǅ˺ʔ˺ľñā΍"]
                    ],
                    "encodeOffsets": [
                        [
                            [60274, 21621]
                        ],
                        [
                            [57745, 26518]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PAK",
                "properties": {
                    "name": "Pakistan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@تϻʞ٥൨ͻ߹۷ऩůౣȲЫα̖݁̈֩ڴгܑӟ`׳ࠃࡇՃ࡝࢝ࢡউÚऑࢡռϗĪ٧ҾэǘܝᇛD֓֕؛Ɇʣ؀٭٘໻ǁിeஃŝ̈́ঊொѢéϰГƌw݊ߥφͷԔеѶඨѕࡀŲԈŅǞȂגóદΔ܎ҶӈشCĠɼٞŌ̴ý͢ʀ±ԌΦԖ՘Ɇͥ֊ߜɴ̢͒мΜĩмȣΤӬμࣘǮ८ĮѐƺӨĦ"],
                    "encodeOffsets": [
                        [76962, 38025]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PAN",
                "properties": {
                    "name": "Panama"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@˫ʎǵҒȺɢɅÎƿˤлɸοÁǝ̇ͻɁǽĉǩВҗɯŅŧŭϷ©ơԈŋƛˡ¸ǝ͸·ÈɓİέCǻĩŶªǖìǠƲŲĲǩŲK͸͘ö̠̝iǱͲĀæɴȵЮÔΨɄԜǞ˺ʤҬ·ĉҶώơ˜ʧ̈́ɵĹūȜӵǁʟ˓ÒŅС"],
                    "encodeOffsets": [
                        [-79750, 7398]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PER",
                "properties": {
                    "name": "Peru"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɥљћɋࡅӘñΈရࡊທࣾ٫԰ΏۜƐʎ܅ાࠣ༄ߍီ΅Ϥ˃ؤٷպױͼ˖ϒПߢʼךڢՎĲΓʇȧx̭ΎâͼĝΚщӆΌǄ֤ԦܶৠͨࣸࢠʾմŝٔɢĂ֒ЉˎЅϴɏӶࢣضĿҨɞ̤ƣԎð٠Ͻթࡣʤoрҁݳ œųۍǉ॥ֱÓϻɉ̇ČғԕʍBΡɛƵΔݳҲԝǱί֐µ͆҃ݐuېӸÇ౧ϢĩӄƠܪടǷ˵£ןg܍͟пƮ̵ȕ˯β۹Ջ࣡"],
                    "encodeOffsets": [
                        [-71260, -18001]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PHL",
                "properties": {
                    "name": "Philippines"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@Đ֏ºҽ˹ޑ̫ࡨϽэˎإʉϿ঩Ӧɿ؊ʰЎՑЈˁΑЃثҵƑʖ͢۾ՌʀҜ̈́̔ϝٔɰƎϒרv·ٰڼЋêхÐ̱"],
                        ["@@̟ˡˁՍ˃ʝԫ׈ǦɤɂɾĢԸҨ¸Ɖ֣جߺāߡ"],
                        ["@@ૣߕЬט؈԰Ԏ׊Ѱ࠲Ʈۅևҧѳֿ"],
                        ["@@Ԏʹ՘BgΗϳΣՕʧϸÒєŽА"],
                        ["@@ʀभ٫ɞj˭ȶԯЍȋעʧªƁԘӶãY͈ԣٜ߮mɴ̻"],
                        ["@@ɟܩέоѓ٘ܚ̡̈"],
                        ["@@ԮʉʶɖüɇƍΑ˼׻ɛۥӷ˥ƁڳȊڝѾġϊĲਾүăҙ˜ȫēϯٻЮ̵Ѵɍ̯՗ԊރůлȆ¨ΎˀɊʣȘŇ̡бӚűμߨͺˡĔೄ˜ހԘA"]
                    ],
                    "encodeOffsets": [
                        [
                            [129410, 8617]
                        ],
                        [
                            [126959, 10526]
                        ],
                        [
                            [121349, 9540]
                        ],
                        [
                            [124809, 12178]
                        ],
                        [
                            [128515, 12455]
                        ],
                        [
                            [124445, 13384]
                        ],
                        [
                            [124234, 18949]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PNG",
                "properties": {
                    "name": "Papua New Guinea"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ɽčε͔ρՔǷ٘ŜĆĜʡʬȏРՑЈ˵ŝɽ"],
                        ["@@ѯçƃɽҟȱћȟѽBۏʔӑɺêʺݬũҠàŶЖŦrĆѽӐÜʂ˼Ҹ̚ġӸԌfǜƏgү˯ԡ"],
                        ["@@ݤտղࢻӖω٬ƛʥǁࣀΝġʏ֋ÏȷɔܟĦࡕŴٷ՚ӉҦѧ݀ભπ܇ʇԡˣńإڇ˿һƖࢅaᩒaᩒภ׃༊ӓׄїҴхŸӵඔԱȲѽޛěȄ֕"],
                        ["@@ʿɡǁӸȝ͘ϝ˞ӍΪ؇ʚɺȮҒɻ˸ȁΜȫʹΛ͊ˏĶѧ"]
                    ],
                    "encodeOffsets": [
                        [
                            [159622, -6983]
                        ],
                        [
                            [155631, -5609]
                        ],
                        [
                            [150725, -7565]
                        ],
                        [
                            [156816, -4607]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "POL",
                "properties": {
                    "name": "Poland"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@·՜à̂ȹ̧҆̚ɺɤȝђָʘ಼ϴ੒˴࠼ƙÚȱ߸Yਚħ໶^њěȬʵωɸ͋KͯԋǡʸϳfϏцܻěɽзįރۥɒϗǿ¶ߙ͔؁šЇĒӹǵч̖Ήŕ³¼ϭаر¼ăˀֻĦűɑҗǨÀɴػòЉ˔"],
                    "encodeOffsets": [
                        [15378, 52334]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PRI",
                "properties": {
                    "name": "Puerto Rico"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@јõưǕɋɃمLӫ·άŢŬیK"],
                    "encodeOffsets": [
                        [-67873, 18960]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PRK",
                "properties": {
                    "name": "North Korea"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Şƥ͉ºη˵ʣ˷׽ѣȅƫƧ̓ʝ֓ƏηɥηįġͰƋӈσŧȭΧÇץ¡͝ϛϑÁùСǆĵƿʙéǀɑüɥƆɰφȤİõƶɆҒÅƎөĠЇɤۄբऒҌ־׮ЎˁܪſѺಚβͰҼժӹ"],
                    "encodeOffsets": [
                        [133776, 43413]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PRT",
                "properties": {
                    "name": "Portugal"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@̦Ɉ΄ŬɂЫӺDƞłӪɼуϱɩYٽƍūЇγçʹԋɵտ̄ʡřɫ̵̿ê˥ͷɓѷŠџġŸڂÿԬϓþȩ͈äռͰ̨ÒͼǪԎkΤǙ̠˲"],
                    "encodeOffsets": [
                        [-9251, 42886]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PRY",
                "properties": {
                    "name": "Paraguay"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ͦ৖tҌЖ݌าʔޮ]޴їbʵʞҳÇଛࢲǇ΄ǐ֦ɩǀʣþޓİ͓̼̀ƌ̢ƳAҥŕӻǑӛƍݏށ١ړƇऻŸࡑɮࠢ౨ťψࡽ͢ਅبۉŸ໵ൌ"],
                    "encodeOffsets": [
                        [-64189, -22783]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "QAT",
                "properties": {
                    "name": "Qatar"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ÇؔɨѲɰĜʬˁdӯǽӳɵÑʫǖ"],
                    "encodeOffsets": [
                        [52030, 25349]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ROU",
                "properties": {
                    "name": "Romania"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@δǶԴġՠGϸȳ˺źبĄɄȠΠ@ʰćʺʟˊΟӞԁρėΩưϥϒƹЂƊϠƟpɏПǹʯĀɻ৥ӳĖ̪ؑফțзɋ௽¬٥ƀ͙ÕʍΊƵƦȚƘȷŀ˃ȋөʔßΌԟȢĥˌҕͤڪǂԖ֮Њ֬ԢǮ"],
                    "encodeOffsets": [
                        [23256, 49032]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "RUS",
                "properties": {
                    "name": "Russia"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ࡌ๫కˤԫ்ࠌࡳyוُԒսٱƻ۸Ĥࠊħ࣢Țٌ૴ӯࠜôରަϮͭϴϐŠɔ։̆ߵuࠟΎࡑ"],
                        ["@@໵]ਙĨȒτ୊˚ࢢƧψƃęɱäɉ"],
                        ["@@֦Ƚțؐᗸű࿨޻࠭λ൛ēsࠑͳǩ޽~ٗ̊ૣʖȉθ࡟Ǝॗŉҗ̎Ǽ̸৓ȥϚЃӉΣ@„Ꮪٛᔺ࠳ïԷ"],
                        ["@@ः©ƭˌੲΖ@ַ"],
                        ["@@ળ»@ָň܈E௒ʉïŗࡽȩ"],
                        ["@@ౡMႣĤƧ¬ߘͪੀþஞ͏ĸə"],
                        ["@@ॿͩഉø༛ͨȪ˖༨ųᑔɗ"],
                        ["@@ډرᶽzඃȣမղҎ׀૎ǂᕞᴬѽ"],
                        ["@@ӹóᩣŊɟώູɦūҒ࡮ǶҞသܒޙĺ፨݆ɩϢሤѺ᪪բ᫠ǀ෴̸࿐Ŋאͩ֟ʻᲗз᢭Џᤙߝఫࠍ೉߱Ǡۥྎۏ"],
                        ["@@ɨгސȲឤYቈЧڬ̿ȽѧङʝᕅүفʟਬşఖɃݴǄєաτɔഊƂ᧪ƑȴϽ↲ů´ٜᄼƥഄLബѷϮ՝ӹΙੌڋ೔Ϳ߸ࢦഖϙ෢ɦྼʵؤʀൖş؅ޮૐζ䢀ձܐӿᔲٛ₎ǄာƑ۪΍Ĺؙਜʇ૴Ǥ๰vཚǑཪĢะݛਪˎڷ՞ϐώᧆɻფºᝂБ୲ν@”MKઇσઝÖݶҁԄەϲɧĮΏɑɝ༧Ǿ᚝مݛĭ౽ן௛ԧ̱ϣய׊ᔗڇϣ̸ߵΫ૱Ř˓ց৙߽ͻड़ȋő௣ޭΫ۱Δα฽ѕ̅ॡభȳʥ࡟ே޳ׂ̳έ௬ҵለИ୘܀ԆªϾರȊຊ੒คࡺຢڢڮஆ৷ëԍۗᒉइۍਖᓧ˷ᑃටۚԧሙɕಝēÔ؊ಯŶ਩ЭᢵƠ᪏ʟᨩ࿛ủጝ೚ŁаՃࠄȅ՞оईÃௌऍ܍ځ࠽ë্ϛഉ్௓˯ׇଙ঑ଇॻթӹ૩ӱՉYՇФૻؙſ˩ŝƦKѐіxŦ঴ɛܚܞ̒৶Ʃ֢ࠈ˾ऄ͚̮Ѵݲ൷ʛܯͧ౧Dͻ߄হװหˎ̵ࠖ̉Ԫ̿βԯࡐ̲݇షʢ૛uਯƱۛлҤȥXҩұˑݷࢻRσஅՍ৙̈́োéѯˮԋĞ௷ףેƑޛȻੑƌޫSԙіࠕИࡅŎ੝ŋߏƹ஛ΜǇـধɎށİवΎࢉࢉ΀ӵࠇב௏ɂ࠻֗Ͼ࢙^ܳʴ౫Ѓྃܣࢭơ͡çѽԤઍőΧΦחǌЙӠҩưிɍୃӜ҃ѯሟᒒੵٮ̮˂ᑋߍ߭³êҞઅ˺࢙ȱ˃ࢊມǺݯΑᑅ̳Чȹḭ̇ϫ˻؆ֹ߭ɓǀɭ߭ХസֿɁЉ୻ʓʟ੹Ѧ೯iࢻΟহͼᇡ׊ಽsჃࣳĿؗࡹӤڡउʖǡӝُ܊֫ذx՚֗ďѝѐƋϥӽ߿Ƒ࠳ࢁކߕĉ֣ࣼফԇ͹ƝɇωÌֿԚɿՅȚʳΈ޵ǮԙƁƥƼଥЖఅƌ܃ƞĹıੱ܂य़̈́ܩӴؒƈۤ۰ҹͪఌ΄uȀݯƉώѠɼ߼ÖƄ˪ȅҪ΀ѰWʚఉ˚ӭUԯЀ١ƃ੩̐lǒ̗θڟ¤éʼɀǞ՝ӈࢋąʭ¦Ƀȑ̽ȷ՞ȟ˨ǊĀڴ͞Ȁʍɢ֥ƪ¼Ʋ΁ƴՃվǸɨĉЂࠑȨѱĳšȼࢭɂˑӸíТЙȖάˊʝ޶װӞųƤक़ҬࢡЎᅢ੶ޮӠ͂єగּΆնݳش֢ܜ঍ग़ޢي౿֔ŬךڶüොͶࢀ̈൦ԕᘨȧṺो٤ЋÆ֓टѳ൏ɡ⏷ٔ؟Ńൌ؛ÂϵÆ࡫ઌʯڂɓňРԑΰ՘͈᎖Թ۾Ȳ֣؜ዦࠖޢµ޸̋Ӫ׀۫ԄЪԊءԶᚠˑӔҹ੡ĻNҳڌ˽ಜǼȶ՚ჶАᰪܞي£ࠣԙਬĕ׼˼༾xఢΐफ़ԏॖ֌ࢡӢѪˤ២ʫ୒ʿᴾॣ֚ѰࡡѺ{ǴৣĈˢЌ҅ټ}ː༄ݾրކزǒᕮɛǬұߕڽԺˋ˒חȏଵऒԧέ֕࿫஝०ŭ̢ͮऎɎɞжܮЎөӌϼֈࣿêȫҲڢࡈણۆຒ֦șװмnѴүͧ߷࣐Ƶϥ؄ඤͦლ¬༈ӏݛ۪ċࣆศǞ፾ᆘŌہѮংւॲx࿎иᕠŐ˪ɲᕂþیȋሴҀ໲aɶδߤΨጤΈ෸˗ଥȷበŹ"],
                        ["@@ⵙ͕ໞીےĦقÃᒈӋʟͿ"],
                        ["@@૽ōݱÛśƏঙƑ࣫ȦӐʾል~࿞ƶ౨XǢɧӘȬߊƐఞǿ͗ŷ"],
                        ["@@ᆳĿᚉʎඅ͎٣׾଩ǔᔆָᆎȎ࿌чኬ߻ȹݯ"]
                    ],
                    "encodeOffsets": [
                        [
                            [147096, 51966]
                        ],
                        [
                            [23277, 55632]
                        ],
                        [
                            [-179214, 68183]
                        ],
                        [
                            [184320, 72533]
                        ],
                        [
                            [-182982, 72595]
                        ],
                        [
                            [147051, 74970]
                        ],
                        [
                            [154350, 76887]
                        ],
                        [
                            [148569, 77377]
                        ],
                        [
                            [58917, 72418]
                        ],
                        [
                            [109538, 78822]
                        ],
                        [
                            [107598, 80187]
                        ],
                        [
                            [52364, 82481]
                        ],
                        [
                            [102339, 80775]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "RWA",
                "properties": {
                    "name": "Rwanda"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ͬӃµӵʏŁѿÆʱӍԛàþҠŘÞԄʎɺȰďԈʸ"],
                    "encodeOffsets": [
                        [31150, -1161]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ESH",
                "properties": {
                    "name": "Western Sahara"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@oҊŸ@@ÉeǋEౝ᪁ªᒷ޿÷ȳћǄ்ᾓNǽ˫΢bCቆäĶ̢ΆϘˤୌୠ࣢Ђ੖ˀÖ˜ټۺĜ̦ŉϢ@˔ȒԲ"],
                    "encodeOffsets": [
                        [-9005, 27772]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SAU",
                "properties": {
                    "name": "Saudi Arabia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ŉΪʩʨÝͲѡ̞҃۴ʁۆׇ׀ϑƐ֋ߠīאӾӕञϿ͠ґǨˡӖ°ȎɹѦʕȊ͝زԟڴѓ־лIžҦ̌ļͲनƅζʶȪ̢ٚŚƒˮˤƜ࠷ࡀ၆фǆŴৢɩబיᛎၕ༠ãݠąȾЏתv͠ܥаȓƠִ̏Λ¼΍ċ˩ł˯ʎɽŐ˟ŲȵʬǕɶÒǆ͍ș࡙͐ᡌщǞǲϪש֕၁ᠽ࠽ᝑ͑޷ϙ׻ࢥϹƕɁˬ͏§߻ĎƷČॹmɫùΉɔɝЭĒΟρˋ"],
                    "encodeOffsets": [
                        [43807, 16741]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SDN",
                "properties": {
                    "name": "Sudan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@śhdмĵ̀џͨĵ؄ĶبϳÌÍȇԍ©Ȭʕðԍңңл؅џđ۹Ӫͅǥđʓџǃǥ࠵@řǦ؃̡ƝɳîѝӬƟɲ؃ŗɱϵɏݣ˿ǁʳğå ̅ʎÃʼƌΔE΄ӛՀĩάZȰ̱ʜUӦǭ͖̍µĎ̰ɒΖħΐˢʴǫȞɞ԰ϨئܦÏ¥ ZΚॲH@း⁪@Ὂ@ῼ@˔ࠗȁƳŪࡻ্̰͌ȷҠ̳ыӑأƏ˅ʳĉ֑α௿ĚͳƅܟͿࠟԓзέٛč΃Љɽʝ࢟Dĳ"],
                    "encodeOffsets": [
                        [34779, 9692]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SDS",
                "properties": {
                    "name": "South Sudan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Xٽűʯѿq˷ӏԨÑюХƨͳϦșӼࣳ֫օԫԇԫϭסFگȟՕȊ΋ɭ݉֐ȥάҵǱϱÆɣƕϗĸԗۚƉˊعͪɅԌΕζ֟ѬS˘ҡͼ֯͠ʴĠ̀ǂɐݤɲ϶؄ŘƠɱўӫɴí̢ƞ؄Śǥ࠶@ǦѠǄĒʔ͆ǦۺөѠĒм؆ҤҤïԎȫʖԎªÎȈϴËĵاĶ؃ѠͧĶ˿cлŜg"],
                    "encodeOffsets": [
                        [34779, 9692]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SEN",
                "properties": {
                    "name": "Senegal"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@΍ٺн̚φǄРמȦќ˾ːкïШǾҶVДʙ֎ɝԘأֈֽԹǔӓ̾ɿî͗ʽŧ³қâÙģȃk׿ȲЛV༇ɥħ˥ѻƋƏ٢ވkȬŞƮR̸ȘήǯκcζȌǝʐˡƙʻJͧȸˉ_ȍȥࣵy"],
                    "encodeOffsets": [
                        [-17114, 13922]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SLB",
                "properties": {
                    "name": "Solomon Islands"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ɾ˿חN͉ԬԈȯǜ"],
                        ["@@͝mԧĎǫżÀͮֈƁ˜ǭƎə"],
                        ["@@ųƹحܰǫԈ˺@̠ڥʹЗ"],
                        ["@@ǛڅΦҟ̠̿˪ŰĐϮȫېϭȢˉ"],
                        ["@@Ǘ³οȒ·Ί¨ƖԈΡͰ˛"]
                    ],
                    "encodeOffsets": [
                        [
                            [166010, -10734]
                        ],
                        [
                            [164713, -10109]
                        ],
                        [
                            [165561, -9830]
                        ],
                        [
                            [163713, -8537]
                        ],
                        [
                            [161320, -7524]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SLE",
                "properties": {
                    "name": "Sierra Leone"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ɧØ؁ͺѩ҈Ƨ̬Ĺت҆τĬɺƞǸɶpȜǂڦCɺ̛ǼΛʓƈɗṶɴ´ϹϹϛҗ«ʓȩˏ"],
                    "encodeOffsets": [
                        [-11713, 6949]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SLV",
                "properties": {
                    "name": "El Salvador"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ġȡӡ^̡Ą΍ǘұÀʃǶ~Ů˾ɄǀĢ«ĲȠ¾ʜëǸǙʪƇœτĴǤÑŘĝÏͳ"],
                    "encodeOffsets": [
                        [-89900, 13706]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "-99",
                "properties": {
                    "name": "Somaliland"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ϛԩד۫۹Mᩧা͍̜̳К̳ҨǾ̖̲҈˚ƹǒΏϜΗкGߊɌࣴĴ݌ʼиÆ̚ƶӎKaE΋Aࡑ@ѫ"],
                    "encodeOffsets": [
                        [50113, 9679]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SOM",
                "properties": {
                    "name": "Somalia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ѼĎЊ˾͈FpɵýӧHѳǯ̣ʁࣥЙयԱ੷ܝ௷ܓवধ଩ࡁڹష࠯޳ٕँৱȗѷȍȣӽۚWᵤܾ॒ɰˆբfݠפબᛜᡄה۬ϜԪ@ѬBࡒFΌLbːhϰŰ"],
                    "encodeOffsets": [
                        [50923, 11857]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SRB",
                "properties": {
                    "name": "Republic of Serbia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@Ԡȡà΋Ӫʓ˄ȌȸĿșƗƶƥȷȏø̫Тγ͋ʿƗˋĞĳƑšϳa˹µØĴĴĦȴšKǍƼƑ ŋƆƽÀšŠƯ±ś˧ȩÑèð͋Ǩ˟ĜūŜɟƠȢŬЄЛ͔ɀτ̥Ë͔́ˉʈȱ͘٢ɚԾҖͣĦˋ"],
                    "encodeOffsets": [
                        [21376, 46507]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SUR",
                "properties": {
                    "name": "Suriname"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@৔ǙĞưڶÔࣚɥѩܟâֹͤӽƥίóϩɉΛӓǲЇđ͹öčʏƘǗ÷ǡҙèԡܴōӄˏBωؐƺѠ¯ȤԜɖƈݲ"],
                    "encodeOffsets": [
                        [-58518, 6117]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SVK",
                "properties": {
                    "name": "Slovakia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@´»ΊŖш̕ӺǶЈđ؂Ţߚ͓ɷɓǏ͹ǳđ࣑ʮ˟»ȟȡЁĿěÄХŽͭ}ãǙ۷Ļ̱ĠёɌċ̆äńŢȂόa˺Ĕxþǈ¢ÆȒȖžưʢD"],
                    "encodeOffsets": [
                        [19306, 50685]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SVN",
                "properties": {
                    "name": "Slovenia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ۜÝъȐܾtǈƘƘUǎ˳ڝɟć͹̇đHɻͣh˷ƎƷƙבȈúȫΨĞа"],
                    "encodeOffsets": [
                        [14138, 47626]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SWE",
                "properties": {
                    "name": "Sweden"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ࠁוƀԥ೹ڭྱܡؓஃײףߦүޗॅ࢑ȝ͍තӋ޿৳ĆӅڗঃˉߐ۳॔ٓஐφӜּۨ˦ন՝ю½ૠղ߀࠰ä̧ͬ˺ಬஂࡀञֈײ߮GɞҶཔƉŬքԸ૪Щ಼ֱv಑˴͛ฃʃ"],
                    "encodeOffsets": [
                        [22716, 67302]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SWZ",
                "properties": {
                    "name": "Swaziland"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ǡύӭěԅҖS̄ɰ̀ĂʔʐÒшƵŰϕðω"],
                    "encodeOffsets": [
                        [32842, -27375]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "SYR",
                "properties": {
                    "name": "Syria"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@࿩ࣅऩͬgNŖŶ_ΈȸҠҜ̈́Əͤϗ¨ÿٞȶΌɤȀɤȀ°Ҹ˞Ǐऎɺ҂ƿۖFॴ̀Ґaक़žїԽҡȹĂؗͅ৫ᇵ࢓"],
                    "encodeOffsets": [
                        [39724, 34180]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TCD",
                "properties": {
                    "name": "Chad"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĎЄաnDզΓ̶δ૊ੴߌ¬ન͖ၼǼΰΓ˾_ˌ̽ɔȷರࡔҠ…ྑ…ྏ¦ ܥÐϧإɝԯǬȝˡʳĨΏɑΕč̯̎¶Ǯ͕Vӥ̲ʛYȯՏƛэͽ؉ࣹ߅ϳ߹¾ʁûĊ̏ѫ̋Σ͟੓͏ȽȐƓhƹɍۛÙƀɪ˅ׄşΐλƜӷӪǼІϦċʂÐҸSқކ֐É֐ͭՠ"],
                    "encodeOffsets": [
                        [14844, 13169]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TGO",
                "properties": {
                    "name": "Togo"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ڱǳȇ̎ɡՔãкȆݴɁ̬ăڎD؎ΕѠÖˀ݂kŅѵʲʝ̈̋ЭǜǥኝȺׅ"],
                    "encodeOffsets": [
                        [1911, 6290]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "THA",
                "properties": {
                    "name": "Thailand"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ݭϬܗeŬڈ݉Káऋґ௯˙ݏÌ؋ն΀ދưܭҶӓԚĭѤѧ˝·ևĵßќۇςƣƭͧ͒ƝжҁӄПЌƏӳǃҲĠԾʚ߬ТࡸҤ޶͟ތ`϶ĩҸ֕ښȩф̄ƺ̮ܶ·ֆՓؘН݆ΠƴϦࣦצӬθӔȘθʷ´ԍ֨ȷࢭpݫࢰԆʤƧӰzǜَ̊ÍٖڽÀࠥںܷ܅˙ϛ޿Ŧગǅ՟ۧȤ১"],
                    "encodeOffsets": [
                        [105047, 12480]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TJK",
                "properties": {
                    "name": "Tajikistan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@̭ʷࣳƖāӛ࣬Þਢ˗འŶɈާˠĐԜȓ͛ŴӍࡿBׁØԻϕύĉ̉ǯͩˠþ۸ʩ¢ĞʲғȐα̇ė͹Żūԇj˕ϩ˯ǌ؋ˑʱĺӀࡘǹض؟ȨɔφۮЌҬˌբ૲ȜǩϵŤɹΎv"],
                    "encodeOffsets": [
                        [72719, 41211]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TKM",
                "properties": {
                    "name": "Turkmenistan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ñۼطॣݔڣĠगюׯþσƽ֙|ׯӓ݇ǋƻרŪ࢞ٽ˶Ɏֺ֏¸Ȇ۾ߊȵ݈ˎؓԎʉӔڱɋď؛ʿհψ˨ॖǪ֨ɻךڅњ¤ॆ\\Əцܖ̂۾ӦଆѹĜڡ͐ǣࣦˮƳаࡽ०ׇոЃ࢞Щ૤ΫwԥʩЅɤſ̙۽ǋǙڥӁʭڏŵǫϟهŏࡩ͈"],
                    "encodeOffsets": [
                        [62680, 36506]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TLS",
                "properties": {
                    "name": "East Timor"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ĲȤܢȌזˀŀ͆Ľ̯ɫ࢕ο۳ʋeʬďǔ"],
                    "encodeOffsets": [
                        [127968, -9106]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TTO",
                "properties": {
                    "name": "Trinidad and Tobago"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ӚŊǮصۭġƯúʒɲiͪ"],
                    "encodeOffsets": [
                        [-63160, 11019]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TUN",
                "properties": {
                    "name": "Tunisia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ΩພԭͺQȰۉԄóنԮҶȢۚƃߠǠќࣶͺךĵ}ы܊̲ÒǉпЫMϱ̆ȽōܫփхǄқѤaɄЍ͊ſ³٥Хʋʵˏֽ͓ĘΑïΟЧț"],
                    "encodeOffsets": [
                        [9710, 31035]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TUR",
                "properties": {
                    "name": "Turkey"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@஺͗ঐżܤõলѬࣆ¢ߴЭƜ̑ăУزȻͨʕֻʇˀ५ǏʻҠڧЕƙ̏Ɋ঍ňίŽॗŽҏbॳ̿ەEҁǀऍɹ˝ǐ¯ҷɣǿɣǿ̱Ϡ͈͂ԟí۱ȖֿәౣĥڹҊࣟȗΑׇĳ߻҄ࣻeӽ࠶ؗҰЦٸՓВठߨಒΜྀٔŏ৞հ঒ʄർlุף"],
                        ["@@۫ҏ˃Ϻ\\ǦȦĦʺՂХɞࡦ˄ܤőĴ͓ܼ˓Ƶȵি±Ωʷ"]
                    ],
                    "encodeOffsets": [
                        [
                            [37800, 42328]
                        ],
                        [
                            [27845, 41668]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "TZA",
                "properties": {
                    "name": "United Republic of Tanzania"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ƚġᵂႋÌӣ஼࠿ϱਙ¸Ӊՠ̩~ɓɳԓ¶ʭÇГ̌Ճΐ̰ࠡǿڝӣࣿ͛ԋb̙ʥבsɕŃঢ়ʂكåɽଢ˵ϺǛɶࠗƾӉʨՕƘͯƘΗɈґ੖ӣҺǗӤČѨƯޞΎ ̨̦͜ѬȺǮS˘ǷȐ·ͨʐł¶Ӷͫӄ̎Ķऄ[ႎà"],
                    "encodeOffsets": [
                        [34718, -972]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "UGA",
                "properties": {
                    "name": "Uganda"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ः\\̍ĵԇʷȯĐPوȜ͎²ڬǰϸ͎Ѭ͔ɠ˒̘͵Ŗ¼চΌɮՖȉڰȠעEԬϮЊ׍İсτ९̧ؓЯ֋ʉͽTࢹႍß"],
                    "encodeOffsets": [
                        [32631, -1052]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "UKR",
                "properties": {
                    "name": "Ukraine"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@̾ɄȒʮ¥ࢌĆ՞Ӈȿǝêʻڠ£̘ηkǑ੪̏٢Ƅ԰ϿӮVఊ˙XʙͿѯȆҩƃ˩߻Õџɻύڡã֑˕޽«ܣ̻¸ԹЪȭࡨ¼Ǐ̛ँơଛӟұǠȄЂࣽʘƨǈߪ˪ʑȔಯɆË̼ީĻ̷ҧٱةϟƠЁƉϑƺɂĞƦ˾ɲˎÑƮǬäĊśӸ{ɞØƽĎÐŲ̉ɈŧΘ̩ƐÒ˶ϝɦΉأʾ֑ĉȧŭΟ@Ƀȟاă˹ŹϷȴ՟HԳĢγǵÍɤұɮǐͺɸɔȀµɑϘބۦиİĜɾхܼДҢɪٲnࡖßबȫڎi͂ŧ̀Ʀɚȝݸ¢ͮąÄцʶȂܞº"],
                    "encodeOffsets": [
                        [32549, 53353]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "URY",
                "properties": {
                    "name": "Uruguay"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ղĚࡆٯ̺|ࡺ՟ڈҫӠֱχЉɸӇεՇॉұاǚғěޥΰ֫ԟҬÞլǾȈS࠸ɤࡺȾڦ"],
                    "encodeOffsets": [
                        [-59008, -30941]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "USA",
                "properties": {
                    "name": "United States of America"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ũƕȽŤ|ɾƓ̨¦ĤƤƎÍǔ¸þÜe͐ƙƬñƌőɊ̍q¯͟ǵˏſ"],
                        ["@@˭ÑƟǮīèQÀĈî̘āɘŹëĵ"],
                        ["@@ĝ҉|Úĸа"],
                        ["@@­µÓŻŃȒɤŚêÃʐ˥"],
                        ["@@ıĉ˱ƴªÖŸĈȘijȝ"],
                        ["@@Ƭңʼƛז½࡬ƅࠂʹڼŊਖɓ˞Tݨʄ߂̧ࠒ͗ں˩ٶˏĈəȢĉ½ĉɦǎĔ¦ȣǜƅɴ@ŬĹĽƫ࢖ЁǶށǚܳʗӹЁҥȁ̍mēĦť˸Ɓɂ@ঊ҆ࡾƀસмfĐ÷ʰƉǒϜƆࠜHޘAˎ͞ŀàࢶ؄ϜƸ౦N໾BĎȺː¦Φž̖Ϣʲٺٚي˨ə֜ƜώʏAଧռӅƢ˝࣋Пࡷ̃ࢱʝѻӿƛȋSѽˤѽΒsė̬ʦȇãʇ֥ƋЗhةƥλ¥ӥ¥۫ʏఀǂʠǃ୳ʥ՗C|ĺʭɷʚǹ׽ؑ٧×Ɏȁª˟ɀǪҍȼƭ^ͅˏ͛ҿڡûʺֲѕ͎įۦǉεǴՑևƀׂ˓ߛʊÍĖ̃ŠࡁՕدࢇʝցӱнÁэ̱ţ˭इձӁЍЅӽŻׯƪ׍ˬܗώשLεЊঅ֥͛ȿԡʣŃЯĺƁς͋ȖѻܢϹٞű͢Ǥ֐ɽҦٻ۲͟źࡑϡƭ¦СϼՃȺोŁݗĤٙÍΏſƲɟaͽǴǓǇō̵Ů́ǃ؍طѺܻĿ؏ȚԹÏۻȝއح࠳γҝБȕϗUׅ¨ЕǄ˹͝{׭ȂٽʺɽЄȁטӷӐ̃ӰуֺףͲۉgՉڑۣʦѡʪȽҦ˧Ѯӿτїˈ̩̖ป@C΋ڗ@ဩOቿפ౓ТĀǒ੩ĝॕÝƙіխӚϻĴğʌһ¦̝ɪޭĊɉƌĹҢࠁࡊ۩ୠȚχˤٯ۴řۆ҃ҞȀۢܜˍ٢͠ߊĸނĺނƱૼˇܘʓ϶ĸǐ௒˷҂ߋȺɜƇې˷ێᛸ@᠂@ࠜ@ᢢ@៚@ᡀ@ᡄ@᭰@ᮞBაAF͔˴J"],
                        ["@@࠽͋ѕɐŽЀބ̘҆Ÿ֐ÉΤʻܫЍ"],
                        ["@@ԧŽսƾԛɮࠦƞښùĂ͑"],
                        ["@@԰ǅԾĒڸɛ࠲őéĝُǱٕǾ͋Ʋݍµȧôº̈́"],
                        ["@@؊ϛώǌහ»¹ȕ౾ƛࡨČᄚ˅ྤā٨ŉ૦Ǝౢʧࣲŝ@@MᷱIⷍࠠ{ࠌɵהρݜցࠈҺࡈ˖Ҁѡ֤·ޒϙՂ׽࡮य़ේ՗xՋұЙҥ͂ݍˌʃܺએںҍߎ߯Ä೷rটʌ჉ࢎߩǄ฽̜୑í࿻ϬৃΨटǯǦ׏ҫÁঁǫ݉˱झǳťӶϚࠚࣀʶɱɂੱҵֵ֑௅ױؚСߏ׿ࣗΗࡁʱȻωಽѡ˅ϿছΫֽÞ޷ɻ࡝˹ۧ˫෹ʉſƘऀϾࠔʸࣆҠਬĨвΈ୘ԊȈǚب̒ƢْђӸॹʫ˓Ơҕ̧շюɧ̝̽м࠿ͳԩBïԄƲ̮ե̚થǇ܁ЀַȬIӈ٩Ϊ͘ӘۆҸ̚њںÖ־ƇڴМ؎ï٘ʼƻϨҹưج͖ԩWࢻǽʯȃڏȄஏĥ௷ȬΛ͸੟Ӧ୾ΘመШ۔@ŕнᄢڽԶਕ͌ױр߫ΨଽˈҺѲ๰ਗ਼ϦȨФ࡬ЎࠊĪཪώޜÉಐ҄ౚǭ"]
                    ],
                    "encodeOffsets": [
                        [
                            [-159275, 19542]
                        ],
                        [
                            [-159825, 21140]
                        ],
                        [
                            [-160520, 21686]
                        ],
                        [
                            [-161436, 21834]
                        ],
                        [
                            [-163169, 22510]
                        ],
                        [
                            [-97093, 50575]
                        ],
                        [
                            [-156678, 58487]
                        ],
                        [
                            [-169553, 61348]
                        ],
                        [
                            [-175853, 65314]
                        ],
                        [
                            [-158789, 72856]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "UZB",
                "properties": {
                    "name": "Uzbekistan"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@xԦૣά࢝ЪշЄ॥׈Яࡾ˭ƴࣥ͏ǤěڢଅѺ۽ӥܕ́Ɛхॅ[ᶾᓘӺƾïದ׻یͅߤݵঢŪ෸à৔ؗÙࡅЦMǢۍ੬ɲЉ̺Lπ׺૎הӖƺʠĉ۵խئ́ײȾ়ѷ੽؁ٕĊ΍uţɺǪ϶૱țˋաЋҫۭ ɓυؠȧǺصҿࡗهǰҳN"],
                    "encodeOffsets": [
                        [68116, 38260]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "VEN",
                "properties": {
                    "name": "Venezuela"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@yȣӱĭ˜ϡYѭυӥ͆ڙδÆȌ؈ʻ̒§َਸ਼΀řІ̎ˆ̞ןל_մҵ˧ݮQ࣌ĔӖϕٞĻҼʾXɄਨ¼৖\\܉ʛ˼Їڦ×ِЯƆڧѬn͢ȣڕӱó̫˾̷ȽƽԫƉjϱɫɱّ֪Őʁ̭͍ऱ̽׿Žʏȣڛɀثņƿýϔɑ֝ŜՉ܆ï°ǭ׷ʅĭΣΉƏسȝǋʱٷÅҧѼʯ࠺ɟ̧̌ȄюмȊʅʠǛ֒à׼Ȉ˰ƲҎ̓Ơӏĩ؁®ͻęסܢӥńઉăȧ̊ȷêǬĴ̶áͺȃȂŅϮѡÈɸӮĺ׶ʔ̸͘ʌɈрդƖ"],
                    "encodeOffsets": [
                        [-73043, 12059]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "VNM",
                "properties": {
                    "name": "Vietnam"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@૭ܗ۫ߍȁ׍٠ࢭ޺ળނԱԞګϪ།ŕ๓۫փ१եۇ۫਷ޱ̧ՠʀ֬دӌܬ͸ࢦÔσԚප٨ļ৖ț֖ƶࡀɃצٍאՋ݌ۥ঴৓Ԋʊ̠՞ɘ͙ܺਙPϕކӭڐҊȴڢIࠈĬܒ҄К̿ސƵƃӛАͿࡎɓ"],
                    "encodeOffsets": [
                        [110644, 22070]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "VUT",
                "properties": {
                    "name": "Vanuatu"
                },
                "geometry": {
                    "type": "MultiPolygon",
                    "coordinates": [
                        ["@@ˣō˭ςɤՆӗ"],
                        ["@@ƌڱɥŀǩ­ťɴi٢Дʵ"]
                    ],
                    "encodeOffsets": [
                        [
                            [171874, -16861]
                        ],
                        [
                            [171119, -15292]
                        ]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "PSE",
                "properties": {
                    "name": "West Bank"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@@ԣŭʙЃŕɜɌŚɁĦǬ̤֔ś"],
                    "encodeOffsets": [
                        [36399, 33172]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "YEM",
                "properties": {
                    "name": "Yemen"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@؉ɥǋύo˹࠷Οഇϻݩףυ±ʥºӭΑ՗ǉ۷©ɃµǿɛəÕŻɇеlˍœ׉¨ɓӬzҠƍʜǑتʋΊǚ¤đϨĸǊξςˌđΠɞЮΊɓɬúॺnƸċ߼č͐¨ɂ˫ϺƖ׼ࢦ޸Ϛᝒ͒ڀ൳˞ח"],
                    "encodeOffsets": [
                        [54384, 17051]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ZAF",
                "properties": {
                    "name": "South Africa"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ǏŧΣяɻћӇ׻ोࢁףԋًϣ࢛͙ѓ«ŇɷԛŰеǅ࣫ǊԙĹΏ¬ࡿͩܓƃԱͅϡoΣ̚˳fαϒśŏɦLӰ˙֞˔ƴs٤ս޼х܈AF׽તДдͪɯƘΫϘÓՈǃҌÖݤіB᷌ɨűӾߙûԟȈ̏׼ĒрϒЊʨȶДЦȚΠķВɽۂ£՞ȜĐʾƨДҚäʨ͂˪֔ݮغஒؤ΂UОƛ˲Ķ҂ċД஁ɔׯƫऩî̟чƶʏÑāʓɯ̿T̃ԆҕӮĜǢώْQȿؑıۥɑϛֵщ", "@@νʶϻǟҕ҃͡Տـ٧̜ČƺˎҴƀƜ˜ʴФ̅ʪ"],
                    "encodeOffsets": [
                        [32278, -29959],
                        [29674, -29650]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ZMB",
                "properties": {
                    "name": "Zambia"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ІϏɊ܋ƝɩǙڻǈۡ˃̇ʭޭѶɓᢇۗĂׯٍřӍͯĹ̛̅ßܵۓҭխ˳o˗ĬऱĠƯÚOêͧȎկ¶ۋȑչԾ֣یᦶშYí̂Ű̀ƧЀĪТėʺ̂q¶ʽϾrՖûˬϡڨŝԤˆȌѯ٠ş̴ΧΈҥ٠Që࣠ɱƳח͞ɧƬļࡈƬসȉψʈ՚ɤĶ଀ƚͦđΘɇͰƗՖƗӊʧ"],
                    "encodeOffsets": [
                        [33546, -9452]
                    ]
                }
            }, {
                "type": "Feature",
                "id": "ZWE",
                "properties": {
                    "name": "Zimbabwe"
                },
                "geometry": {
                    "type": "Polygon",
                    "coordinates": ["@@ҁČ˱ĵНƜ΁VՙϞٯźʙՒC̒έĞ्ई˃ӢǛƮ͓ڤलğ˘ī˴pҮծܶ۔̜àĺ̆ӎͰَŚÆ̻۬hϴǯǺȻАÓѦˑF੟Ǐ׋عƊʝħӵŵùɛ؅ࢫ॓"],
                    "encodeOffsets": [
                        [31941, -22785]
                    ]
                }
            }],
            "UTF8Encoding": true
        };
    });
    define('zrender/tool/area', ['require', './util', './curve'], function(require) {

        'use strict';

        var util = require('./util');
        var curve = require('./curve');

        var _ctx;

        var _textWidthCache = {};
        var _textHeightCache = {};
        var _textWidthCacheCounter = 0;
        var _textHeightCacheCounter = 0;
        var TEXT_CACHE_MAX = 5000;

        var PI2 = Math.PI * 2;

        function normalizeRadian(angle) {
            angle %= PI2;
            if (angle < 0) {
                angle += PI2;
            }
            return angle;
        }
        /**
         * 包含判断
         *
         * @param {Object} shape : 图形
         * @param {Object} area ： 目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         */
        function isInside(shape, area, x, y) {
            if (!area || !shape) {
                // 无参数或不支持类型
                return false;
            }
            var zoneType = shape.type;

            _ctx = _ctx || util.getContext();

            // 未实现或不可用时(excanvas不支持)则数学运算，主要是line，polyline，ring
            var _mathReturn = _mathMethod(shape, area, x, y);
            if (typeof _mathReturn != 'undefined') {
                return _mathReturn;
            }

            if (shape.buildPath && _ctx.isPointInPath) {
                return _buildPathMethod(shape, _ctx, area, x, y);
            }

            // 上面的方法都行不通时
            switch (zoneType) {
                case 'ellipse': // Todo，不精确
                    return true;
                    // 旋轮曲线  不准确
                case 'trochoid':
                    var _r = area.location == 'out' ? area.r1 + area.r2 + area.d : area.r1 - area.r2 + area.d;
                    return isInsideCircle(area, x, y, _r);
                    // 玫瑰线 不准确
                case 'rose':
                    return isInsideCircle(area, x, y, area.maxr);
                    // 路径，椭圆，曲线等-----------------13
                default:
                    return false; // Todo，暂不支持
            }
        }

        /**
         * @param {Object} shape : 图形
         * @param {Object} area ：目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         * @return {boolean=} true表示坐标处在图形中
         */
        function _mathMethod(shape, area, x, y) {
            var zoneType = shape.type;
            // 在矩形内则部分图形需要进一步判断
            switch (zoneType) {
                // 贝塞尔曲线
                case 'bezier-curve':
                    if (typeof(area.cpX2) === 'undefined') {
                        return isInsideQuadraticStroke(
                            area.xStart, area.yStart,
                            area.cpX1, area.cpY1,
                            area.xEnd, area.yEnd,
                            area.lineWidth, x, y
                        );
                    }
                    return isInsideCubicStroke(
                        area.xStart, area.yStart,
                        area.cpX1, area.cpY1,
                        area.cpX2, area.cpY2,
                        area.xEnd, area.yEnd,
                        area.lineWidth, x, y
                    );
                    // 线
                case 'line':
                    return isInsideLine(
                        area.xStart, area.yStart,
                        area.xEnd, area.yEnd,
                        area.lineWidth, x, y
                    );
                    // 折线
                case 'polyline':
                    return isInsidePolyline(
                        area.pointList, area.lineWidth, x, y
                    );
                    // 圆环
                case 'ring':
                    return isInsideRing(
                        area.x, area.y, area.r0, area.r, x, y
                    );
                    // 圆形
                case 'circle':
                    return isInsideCircle(
                        area.x, area.y, area.r, x, y
                    );
                    // 扇形
                case 'sector':
                    var startAngle = area.startAngle * Math.PI / 180;
                    var endAngle = area.endAngle * Math.PI / 180;
                    if (!area.clockWise) {
                        startAngle = -startAngle;
                        endAngle = -endAngle;
                    }
                    return isInsideSector(
                        area.x, area.y, area.r0, area.r,
                        startAngle, endAngle, !area.clockWise,
                        x, y
                    );
                    // 多边形
                case 'path':
                    return area.pathArray && isInsidePath(
                        area.pathArray, Math.max(area.lineWidth, 5),
                        area.brushType, x, y
                    );
                case 'polygon':
                case 'star':
                case 'isogon':
                    return isInsidePolygon(area.pointList, x, y);
                    // 文本
                case 'text':
                    var rect = area.__rect || shape.getRect(area);
                    return isInsideRect(
                        rect.x, rect.y, rect.width, rect.height, x, y
                    );
                    // 矩形
                case 'rectangle':
                    // 图片
                case 'image':
                    return isInsideRect(
                        area.x, area.y, area.width, area.height, x, y
                    );
            }
        }

        /**
         * 通过buildPath方法来判断，三个方法中较快，但是不支持线条类型的shape，
         * 而且excanvas不支持isPointInPath方法
         *
         * @param {Object} shape ： shape
         * @param {Object} context : 上下文
         * @param {Object} area ：目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         * @return {boolean} true表示坐标处在图形中
         */
        function _buildPathMethod(shape, context, area, x, y) {
            // 图形类实现路径创建了则用类的path
            context.beginPath();
            shape.buildPath(context, area);
            context.closePath();
            return context.isPointInPath(x, y);
        }

        /**
         * !isInside
         */
        function isOutside(shape, area, x, y) {
            return !isInside(shape, area, x, y);
        }

        /**
         * 线段包含判断
         * @param  {number}  x0
         * @param  {number}  y0
         * @param  {number}  x1
         * @param  {number}  y1
         * @param  {number}  lineWidth
         * @param  {number}  x
         * @param  {number}  y
         * @return {boolean}
         */
        function isInsideLine(x0, y0, x1, y1, lineWidth, x, y) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            var _a = 0;
            var _b = x0;
            // Quick reject
            if (
                (y > y0 + _l && y > y1 + _l) || (y < y0 - _l && y < y1 - _l) || (x > x0 + _l && x > x1 + _l) || (x < x0 - _l && x < x1 - _l)
            ) {
                return false;
            }

            if (x0 !== x1) {
                _a = (y0 - y1) / (x0 - x1);
                _b = (x0 * y1 - x1 * y0) / (x0 - x1);
            } else {
                return Math.abs(x - x0) <= _l / 2;
            }
            var tmp = _a * x - y + _b;
            var _s = tmp * tmp / (_a * _a + 1);
            return _s <= _l / 2 * _l / 2;
        }

        /**
         * 三次贝塞尔曲线描边包含判断
         * @param  {number}  x0
         * @param  {number}  y0
         * @param  {number}  x1
         * @param  {number}  y1
         * @param  {number}  x2
         * @param  {number}  y2
         * @param  {number}  x3
         * @param  {number}  y3
         * @param  {number}  lineWidth
         * @param  {number}  x
         * @param  {number}  y
         * @return {boolean}
         */
        function isInsideCubicStroke(
            x0, y0, x1, y1, x2, y2, x3, y3,
            lineWidth, x, y
        ) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            // Quick reject
            if (
                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l) || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l) || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l) || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
            ) {
                return false;
            }
            var d = curve.cubicProjectPoint(
                x0, y0, x1, y1, x2, y2, x3, y3,
                x, y, null
            );
            return d <= _l / 2;
        }

        /**
         * 二次贝塞尔曲线描边包含判断
         * @param  {number}  x0
         * @param  {number}  y0
         * @param  {number}  x1
         * @param  {number}  y1
         * @param  {number}  x2
         * @param  {number}  y2
         * @param  {number}  lineWidth
         * @param  {number}  x
         * @param  {number}  y
         * @return {boolean}
         */
        function isInsideQuadraticStroke(
            x0, y0, x1, y1, x2, y2,
            lineWidth, x, y
        ) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            // Quick reject
            if (
                (y > y0 + _l && y > y1 + _l && y > y2 + _l) || (y < y0 - _l && y < y1 - _l && y < y2 - _l) || (x > x0 + _l && x > x1 + _l && x > x2 + _l) || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
            ) {
                return false;
            }
            var d = curve.quadraticProjectPoint(
                x0, y0, x1, y1, x2, y2,
                x, y, null
            );
            return d <= _l / 2;
        }

        /**
         * 圆弧描边包含判断
         * @param  {number}  cx
         * @param  {number}  cy
         * @param  {number}  r
         * @param  {number}  startAngle
         * @param  {number}  endAngle
         * @param  {boolean}  anticlockwise
         * @param  {number} lineWidth
         * @param  {number}  x
         * @param  {number}  y
         * @return {Boolean}
         */
        function isInsideArcStroke(
            cx, cy, r, startAngle, endAngle, anticlockwise,
            lineWidth, x, y
        ) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);

            x -= cx;
            y -= cy;
            var d = Math.sqrt(x * x + y * y);
            if ((d - _l > r) || (d + _l < r)) {
                return false;
            }
            if (Math.abs(startAngle - endAngle) >= PI2) {
                // Is a circle
                return true;
            }
            if (anticlockwise) {
                var tmp = startAngle;
                startAngle = normalizeRadian(endAngle);
                endAngle = normalizeRadian(tmp);
            } else {
                startAngle = normalizeRadian(startAngle);
                endAngle = normalizeRadian(endAngle);
            }
            if (startAngle > endAngle) {
                endAngle += PI2;
            }

            var angle = Math.atan2(y, x);
            if (angle < 0) {
                angle += PI2;
            }
            return (angle >= startAngle && angle <= endAngle) || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
        }

        function isInsidePolyline(points, lineWidth, x, y) {
            var lineWidth = Math.max(lineWidth, 10);
            for (var i = 0, l = points.length - 1; i < l; i++) {
                var x0 = points[i][0];
                var y0 = points[i][1];
                var x1 = points[i + 1][0];
                var y1 = points[i + 1][1];

                if (isInsideLine(x0, y0, x1, y1, lineWidth, x, y)) {
                    return true;
                }
            }

            return false;
        }

        function isInsideRing(cx, cy, r0, r, x, y) {
            var d = (x - cx) * (x - cx) + (y - cy) * (y - cy);
            return (d < r * r) && (d > r0 * r0);
        }

        /**
         * 矩形包含判断
         */
        function isInsideRect(x0, y0, width, height, x, y) {
            return x >= x0 && x <= (x0 + width) && y >= y0 && y <= (y0 + height);
        }

        /**
         * 圆形包含判断
         */
        function isInsideCircle(x0, y0, r, x, y) {
            return (x - x0) * (x - x0) + (y - y0) * (y - y0) < r * r;
        }

        /**
         * 扇形包含判断
         */
        function isInsideSector(
            cx, cy, r0, r, startAngle, endAngle, anticlockwise, x, y
        ) {
            return isInsideArcStroke(
                cx, cy, (r0 + r) / 2, startAngle, endAngle, anticlockwise,
                r - r0, x, y
            );
        }

        /**
         * 多边形包含判断
         * 与 canvas 一样采用 non-zero winding rule
         */
        function isInsidePolygon(points, x, y) {
            var N = points.length;
            var w = 0;

            for (var i = 0, j = N - 1; i < N; i++) {
                var x0 = points[j][0];
                var y0 = points[j][1];
                var x1 = points[i][0];
                var y1 = points[i][1];
                w += windingLine(x0, y0, x1, y1, x, y);
                j = i;
            }
            return w !== 0;
        }

        function windingLine(x0, y0, x1, y1, x, y) {
            if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
                return 0;
            }
            if (y1 == y0) {
                return 0;
            }
            var dir = y1 < y0 ? 1 : -1;
            var t = (y - y0) / (y1 - y0);
            var x_ = t * (x1 - x0) + x0;

            return x_ > x ? dir : 0;
        }

        // 临时数组
        var roots = [-1, -1, -1];
        var extrema = [-1, -1];

        function swapExtrema() {
            var tmp = extrema[0];
            extrema[0] = extrema[1];
            extrema[1] = tmp;
        }

        function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
            // Quick reject
            if (
                (y > y0 && y > y1 && y > y2 && y > y3) || (y < y0 && y < y1 && y < y2 && y < y3)
            ) {
                return 0;
            }
            var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
            if (nRoots === 0) {
                return 0;
            } else {
                var w = 0;
                var nExtrema = -1;
                var y0_, y1_;
                for (var i = 0; i < nRoots; i++) {
                    var t = roots[i];
                    var x_ = curve.cubicAt(x0, x1, x2, x3, t);
                    if (x_ < x) { // Quick reject
                        continue;
                    }
                    if (nExtrema < 0) {
                        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
                        if (extrema[1] < extrema[0] && nExtrema > 1) {
                            swapExtrema();
                        }
                        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
                        if (nExtrema > 1) {
                            y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
                        }
                    }
                    if (nExtrema == 2) {
                        // 分成三段单调函数
                        if (t < extrema[0]) {
                            w += y0_ < y0 ? 1 : -1;
                        } else if (t < extrema[1]) {
                            w += y1_ < y0_ ? 1 : -1;
                        } else {
                            w += y3 < y1_ ? 1 : -1;
                        }
                    } else {
                        // 分成两段单调函数
                        if (t < extrema[0]) {
                            w += y0_ < y0 ? 1 : -1;
                        } else {
                            w += y3 < y0_ ? 1 : -1;
                        }
                    }
                }
                return w;
            }
        }

        function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
            // Quick reject
            if (
                (y > y0 && y > y1 && y > y2) || (y < y0 && y < y1 && y < y2)
            ) {
                return 0;
            }
            var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
            if (nRoots === 0) {
                return 0;
            } else {
                var t = curve.quadraticExtremum(y0, y1, y2);
                if (t >= 0 && t <= 1) {
                    var w = 0;
                    var y_ = curve.quadraticAt(y0, y1, y2, t);
                    for (var i = 0; i < nRoots; i++) {
                        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
                        if (x_ < x) {
                            continue;
                        }
                        if (roots[i] < t) {
                            w += y_ < y0 ? 1 : -1;
                        } else {
                            w += y2 < y_ ? 1 : -1;
                        }
                    }
                    return w;
                } else {
                    var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
                    if (x_ < x) {
                        return 0;
                    }
                    return y2 < y0 ? 1 : -1;
                }
            }
        }

        // TODO
        // Arc 旋转
        function windingArc(
            cx, cy, r, startAngle, endAngle, anticlockwise, x, y
        ) {
            y -= cy;
            if (y > r || y < -r) {
                return 0;
            }
            var tmp = Math.sqrt(r * r - y * y);
            roots[0] = -tmp;
            roots[1] = tmp;

            if (Math.abs(startAngle - endAngle) >= PI2) {
                // Is a circle
                startAngle = 0;
                endAngle = PI2;
                var dir = anticlockwise ? 1 : -1;
                if (x >= roots[0] + cx && x <= roots[1] + cx) {
                    return dir;
                } else {
                    return 0;
                }
            }

            if (anticlockwise) {
                var tmp = startAngle;
                startAngle = normalizeRadian(endAngle);
                endAngle = normalizeRadian(tmp);
            } else {
                startAngle = normalizeRadian(startAngle);
                endAngle = normalizeRadian(endAngle);
            }
            if (startAngle > endAngle) {
                endAngle += PI2;
            }

            var w = 0;
            for (var i = 0; i < 2; i++) {
                var x_ = roots[i];
                if (x_ + cx > x) {
                    var angle = Math.atan2(y, x_);
                    var dir = anticlockwise ? 1 : -1;
                    if (angle < 0) {
                        angle = PI2 + angle;
                    }
                    if (
                        (angle >= startAngle && angle <= endAngle) || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
                    ) {
                        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                            dir = -dir;
                        }
                        w += dir;
                    }
                }
            }
            return w;
        }

        /**
         * 路径包含判断
         * 与 canvas 一样采用 non-zero winding rule
         */
        function isInsidePath(pathArray, lineWidth, brushType, x, y) {
            var w = 0;
            var xi = 0;
            var yi = 0;
            var x0 = 0;
            var y0 = 0;
            var beginSubpath = true;
            var firstCmd = true;

            brushType = brushType || 'fill';

            var hasStroke = brushType === 'stroke' || brushType === 'both';
            var hasFill = brushType === 'fill' || brushType === 'both';

            // var roots = [-1, -1, -1];
            for (var i = 0; i < pathArray.length; i++) {
                var seg = pathArray[i];
                var p = seg.points;
                // Begin a new subpath
                if (beginSubpath || seg.command === 'M') {
                    if (i > 0) {
                        // Close previous subpath
                        if (hasFill) {
                            w += windingLine(xi, yi, x0, y0, x, y);
                        }
                        if (w !== 0) {
                            return true;
                        }
                    }
                    x0 = p[p.length - 2];
                    y0 = p[p.length - 1];
                    beginSubpath = false;
                    if (firstCmd && seg.command !== 'A') {
                        // 如果第一个命令不是M, 是lineTo, bezierCurveTo
                        // 等绘制命令的话，是会从该绘制的起点开始算的
                        // Arc 会在之后做单独处理所以这里忽略
                        firstCmd = false;
                        xi = x0;
                        yi = y0;
                    }
                }
                switch (seg.command) {
                    case 'M':
                        xi = p[0];
                        yi = p[1];
                        break;
                    case 'L':
                        if (hasStroke) {
                            if (isInsideLine(
                                    xi, yi, p[0], p[1], lineWidth, x, y
                                )) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += windingLine(xi, yi, p[0], p[1], x, y);
                        }
                        xi = p[0];
                        yi = p[1];
                        break;
                    case 'C':
                        if (hasStroke) {
                            if (isInsideCubicStroke(
                                    xi, yi, p[0], p[1], p[2], p[3], p[4], p[5],
                                    lineWidth, x, y
                                )) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += windingCubic(
                                xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], x, y
                            );
                        }
                        xi = p[4];
                        yi = p[5];
                        break;
                    case 'Q':
                        if (hasStroke) {
                            if (isInsideQuadraticStroke(
                                    xi, yi, p[0], p[1], p[2], p[3],
                                    lineWidth, x, y
                                )) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += windingQuadratic(
                                xi, yi, p[0], p[1], p[2], p[3], x, y
                            );
                        }
                        xi = p[2];
                        yi = p[3];
                        break;
                    case 'A':
                        // TODO Arc 旋转
                        // TODO Arc 判断的开销比较大
                        var cx = p[0];
                        var cy = p[1];
                        var rx = p[2];
                        var ry = p[3];
                        var theta = p[4];
                        var dTheta = p[5];
                        var x1 = Math.cos(theta) * rx + cx;
                        var y1 = Math.sin(theta) * ry + cy;
                        // 不是直接使用 arc 命令
                        if (!firstCmd) {
                            w += windingLine(xi, yi, x1, y1);
                        } else {
                            firstCmd = false;
                            // 第一个命令起点还未定义
                            x0 = x1;
                            y0 = y1;
                        }
                        // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
                        var _x = (x - cx) * ry / rx + cx;
                        if (hasStroke) {
                            if (isInsideArcStroke(
                                    cx, cy, ry, theta, theta + dTheta, 1 - p[7],
                                    lineWidth, _x, y
                                )) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += windingArc(
                                cx, cy, ry, theta, theta + dTheta, 1 - p[7],
                                _x, y
                            );
                        }
                        xi = Math.cos(theta + dTheta) * rx + cx;
                        yi = Math.sin(theta + dTheta) * ry + cy;
                        break;
                    case 'z':
                        if (hasStroke) {
                            if (isInsideLine(
                                    xi, yi, x0, y0, lineWidth, x, y
                                )) {
                                return true;
                            }
                        }
                        beginSubpath = true;
                        break;
                }
            }
            if (hasFill) {
                w += windingLine(xi, yi, x0, y0, x, y);
            }
            return w !== 0;
        }

        /**
         * 测算多行文本宽度
         * @param {Object} text
         * @param {Object} textFont
         */
        function getTextWidth(text, textFont) {
            var key = text + ':' + textFont;
            if (_textWidthCache[key]) {
                return _textWidthCache[key];
            }
            _ctx = _ctx || util.getContext();
            _ctx.save();

            if (textFont) {
                _ctx.font = textFont;
            }

            text = (text + '').split('\n');
            var width = 0;
            for (var i = 0, l = text.length; i < l; i++) {
                width = Math.max(
                    _ctx.measureText(text[i]).width,
                    width
                );
            }
            _ctx.restore();

            _textWidthCache[key] = width;
            if (++_textWidthCacheCounter > TEXT_CACHE_MAX) {
                // 内存释放
                _textWidthCacheCounter = 0;
                _textWidthCache = {};
            }

            return width;
        }

        /**
         * 测算多行文本高度
         * @param {Object} text
         * @param {Object} textFont
         */
        function getTextHeight(text, textFont) {
            var key = text + ':' + textFont;
            if (_textHeightCache[key]) {
                return _textHeightCache[key];
            }

            _ctx = _ctx || util.getContext();

            _ctx.save();
            if (textFont) {
                _ctx.font = textFont;
            }

            text = (text + '').split('\n');
            // 比较粗暴
            var height = (_ctx.measureText('国').width + 2) * text.length;

            _ctx.restore();

            _textHeightCache[key] = height;
            if (++_textHeightCacheCounter > TEXT_CACHE_MAX) {
                // 内存释放
                _textHeightCacheCounter = 0;
                _textHeightCache = {};
            }
            return height;
        }

        return {
            isInside: isInside,
            isOutside: isOutside,
            getTextWidth: getTextWidth,
            getTextHeight: getTextHeight,

            isInsidePath: isInsidePath,
            isInsidePolygon: isInsidePolygon,
            isInsideSector: isInsideSector,
            isInsideCircle: isInsideCircle,
            isInsideLine: isInsideLine,
            isInsideRect: isInsideRect,
            isInsidePolyline: isInsidePolyline,

            isInsideCubicStroke: isInsideCubicStroke,
            isInsideQuadraticStroke: isInsideQuadraticStroke
        };
    });
    define('zrender/tool/color', ['require', '../tool/util'], function(require) {
        var util = require('../tool/util');

        var _ctx;

        // Color palette is an array containing the default colors for the chart's
        // series.
        // When all colors are used, new colors are selected from the start again.
        // Defaults to:
        // 默认色板
        var palette = [
            '#ff9277', ' #dddd00', ' #ffc877', ' #bbe3ff', ' #d5ffbb',
            '#bbbbff', ' #ddb000', ' #b0dd00', ' #e2bbff', ' #ffbbe3',
            '#ff7777', ' #ff9900', ' #83dd00', ' #77e3ff', ' #778fff',
            '#c877ff', ' #ff77ab', ' #ff6600', ' #aa8800', ' #77c7ff',
            '#ad77ff', ' #ff77ff', ' #dd0083', ' #777700', ' #00aa00',
            '#0088aa', ' #8400dd', ' #aa0088', ' #dd0000', ' #772e00'
        ];
        var _palette = palette;

        var highlightColor = 'rgba(255,255,0,0.5)';
        var _highlightColor = highlightColor;

        // 颜色格式
        /*jshint maxlen: 330 */
        var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

        var _nameColors = {
            aliceblue: '#f0f8ff',
            antiquewhite: '#faebd7',
            aqua: '#0ff',
            aquamarine: '#7fffd4',
            azure: '#f0ffff',
            beige: '#f5f5dc',
            bisque: '#ffe4c4',
            black: '#000',
            blanchedalmond: '#ffebcd',
            blue: '#00f',
            blueviolet: '#8a2be2',
            brown: '#a52a2a',
            burlywood: '#deb887',
            cadetblue: '#5f9ea0',
            chartreuse: '#7fff00',
            chocolate: '#d2691e',
            coral: '#ff7f50',
            cornflowerblue: '#6495ed',
            cornsilk: '#fff8dc',
            crimson: '#dc143c',
            cyan: '#0ff',
            darkblue: '#00008b',
            darkcyan: '#008b8b',
            darkgoldenrod: '#b8860b',
            darkgray: '#a9a9a9',
            darkgrey: '#a9a9a9',
            darkgreen: '#006400',
            darkkhaki: '#bdb76b',
            darkmagenta: '#8b008b',
            darkolivegreen: '#556b2f',
            darkorange: '#ff8c00',
            darkorchid: '#9932cc',
            darkred: '#8b0000',
            darksalmon: '#e9967a',
            darkseagreen: '#8fbc8f',
            darkslateblue: '#483d8b',
            darkslategray: '#2f4f4f',
            darkslategrey: '#2f4f4f',
            darkturquoise: '#00ced1',
            darkviolet: '#9400d3',
            deeppink: '#ff1493',
            deepskyblue: '#00bfff',
            dimgray: '#696969',
            dimgrey: '#696969',
            dodgerblue: '#1e90ff',
            firebrick: '#b22222',
            floralwhite: '#fffaf0',
            forestgreen: '#228b22',
            fuchsia: '#f0f',
            gainsboro: '#dcdcdc',
            ghostwhite: '#f8f8ff',
            gold: '#ffd700',
            goldenrod: '#daa520',
            gray: '#808080',
            grey: '#808080',
            green: '#008000',
            greenyellow: '#adff2f',
            honeydew: '#f0fff0',
            hotpink: '#ff69b4',
            indianred: '#cd5c5c',
            indigo: '#4b0082',
            ivory: '#fffff0',
            khaki: '#f0e68c',
            lavender: '#e6e6fa',
            lavenderblush: '#fff0f5',
            lawngreen: '#7cfc00',
            lemonchiffon: '#fffacd',
            lightblue: '#add8e6',
            lightcoral: '#f08080',
            lightcyan: '#e0ffff',
            lightgoldenrodyellow: '#fafad2',
            lightgray: '#d3d3d3',
            lightgrey: '#d3d3d3',
            lightgreen: '#90ee90',
            lightpink: '#ffb6c1',
            lightsalmon: '#ffa07a',
            lightseagreen: '#20b2aa',
            lightskyblue: '#87cefa',
            lightslategray: '#789',
            lightslategrey: '#789',
            lightsteelblue: '#b0c4de',
            lightyellow: '#ffffe0',
            lime: '#0f0',
            limegreen: '#32cd32',
            linen: '#faf0e6',
            magenta: '#f0f',
            maroon: '#800000',
            mediumaquamarine: '#66cdaa',
            mediumblue: '#0000cd',
            mediumorchid: '#ba55d3',
            mediumpurple: '#9370d8',
            mediumseagreen: '#3cb371',
            mediumslateblue: '#7b68ee',
            mediumspringgreen: '#00fa9a',
            mediumturquoise: '#48d1cc',
            mediumvioletred: '#c71585',
            midnightblue: '#191970',
            mintcream: '#f5fffa',
            mistyrose: '#ffe4e1',
            moccasin: '#ffe4b5',
            navajowhite: '#ffdead',
            navy: '#000080',
            oldlace: '#fdf5e6',
            olive: '#808000',
            olivedrab: '#6b8e23',
            orange: '#ffa500',
            orangered: '#ff4500',
            orchid: '#da70d6',
            palegoldenrod: '#eee8aa',
            palegreen: '#98fb98',
            paleturquoise: '#afeeee',
            palevioletred: '#d87093',
            papayawhip: '#ffefd5',
            peachpuff: '#ffdab9',
            peru: '#cd853f',
            pink: '#ffc0cb',
            plum: '#dda0dd',
            powderblue: '#b0e0e6',
            purple: '#800080',
            red: '#f00',
            rosybrown: '#bc8f8f',
            royalblue: '#4169e1',
            saddlebrown: '#8b4513',
            salmon: '#fa8072',
            sandybrown: '#f4a460',
            seagreen: '#2e8b57',
            seashell: '#fff5ee',
            sienna: '#a0522d',
            silver: '#c0c0c0',
            skyblue: '#87ceeb',
            slateblue: '#6a5acd',
            slategray: '#708090',
            slategrey: '#708090',
            snow: '#fffafa',
            springgreen: '#00ff7f',
            steelblue: '#4682b4',
            tan: '#d2b48c',
            teal: '#008080',
            thistle: '#d8bfd8',
            tomato: '#ff6347',
            turquoise: '#40e0d0',
            violet: '#ee82ee',
            wheat: '#f5deb3',
            white: '#fff',
            whitesmoke: '#f5f5f5',
            yellow: '#ff0',
            yellowgreen: '#9acd32'
        };

        /**
         * 自定义调色板
         */
        function customPalette(userPalete) {
            palette = userPalete;
        }

        /**
         * 复位默认色板
         */
        function resetPalette() {
            palette = _palette;
        }

        /**
         * 获取色板颜色
         * @memberOf module:zrender/tool/color
         * @param {number} idx 色板位置
         * @param {Array.<string>} [userPalete] 自定义色板
         * @return {string} 颜色
         */
        function getColor(idx, userPalete) {
            idx = idx | 0;
            userPalete = userPalete || palette;
            return userPalete[idx % userPalete.length];
        }

        /**
         * 自定义默认高亮颜色
         */
        function customHighlight(userHighlightColor) {
            highlightColor = userHighlightColor;
        }

        /**
         * 重置默认高亮颜色
         */
        function resetHighlight() {
            _highlightColor = highlightColor;
        }

        /**
         * 获取默认高亮颜色
         */
        function getHighlightColor() {
            return highlightColor;
        }

        /**
         * 径向渐变
         * @memberOf module:zrender/tool/color
         * @param {number} x0 渐变起点
         * @param {number} y0
         * @param {number} r0
         * @param {number} x1 渐变终点
         * @param {number} y1
         * @param {number} r1
         * @param {Array} colorList 颜色列表
         * @return {CanvasGradient}
         */
        function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {
            if (!_ctx) {
                _ctx = util.getContext();
            }
            var gradient = _ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
            for (var i = 0, l = colorList.length; i < l; i++) {
                gradient.addColorStop(colorList[i][0], colorList[i][1]);
            }
            gradient.__nonRecursion = true;
            return gradient;
        }

        /**
         * 线性渐变
         * @param {Object} x0 渐变起点
         * @param {Object} y0
         * @param {Object} x1 渐变终点
         * @param {Object} y1
         * @param {Array} colorList 颜色列表
         */
        function getLinearGradient(x0, y0, x1, y1, colorList) {
            if (!_ctx) {
                _ctx = util.getContext();
            }
            var gradient = _ctx.createLinearGradient(x0, y0, x1, y1);
            for (var i = 0, l = colorList.length; i < l; i++) {
                gradient.addColorStop(colorList[i][0], colorList[i][1]);
            }
            gradient.__nonRecursion = true;
            return gradient;
        }

        /**
         * 获取两种颜色之间渐变颜色数组
         * @param {color} start 起始颜色
         * @param {color} end 结束颜色
         * @param {number} step 渐变级数
         * @return {Array}  颜色数组
         */
        function getStepColors(start, end, step) {
            start = toRGBA(start);
            end = toRGBA(end);
            start = getData(start);
            end = getData(end);

            var colors = [];
            var stepR = (end[0] - start[0]) / step;
            var stepG = (end[1] - start[1]) / step;
            var stepB = (end[2] - start[2]) / step;
            var stepA = (end[3] - start[3]) / step;
            // 生成颜色集合
            // fix by linfeng 颜色堆积
            for (var i = 0, r = start[0], g = start[1], b = start[2], a = start[3]; i < step; i++) {
                colors[i] = toColor([
                    adjust(Math.floor(r), [0, 255]),
                    adjust(Math.floor(g), [0, 255]),
                    adjust(Math.floor(b), [0, 255]),
                    a.toFixed(4) - 0
                ], 'rgba');
                r += stepR;
                g += stepG;
                b += stepB;
                a += stepA;
            }
            r = end[0];
            g = end[1];
            b = end[2];
            a = end[3];
            colors[i] = toColor([r, g, b, a], 'rgba');
            return colors;
        }

        /**
         * 获取指定级数的渐变颜色数组
         * @memberOf module:zrender/tool/color
         * @param {Array.<string>} colors 颜色组
         * @param {number} [step=20] 渐变级数
         * @return {Array.<string>}  颜色数组
         */
        function getGradientColors(colors, step) {
            var ret = [];
            var len = colors.length;
            if (step === undefined) {
                step = 20;
            }
            if (len === 1) {
                ret = getStepColors(colors[0], colors[0], step);
            } else if (len > 1) {
                for (var i = 0, n = len - 1; i < n; i++) {
                    var steps = getStepColors(colors[i], colors[i + 1], step);
                    if (i < n - 1) {
                        steps.pop();
                    }
                    ret = ret.concat(steps);
                }
            }
            return ret;
        }

        /**
         * 颜色值数组转为指定格式颜色,例如:<br/>
         * data = [60,20,20,0.1] format = 'rgba'
         * 返回：rgba(60,20,20,0.1)
         * @param {Array} data 颜色值数组
         * @param {string} format 格式,默认rgb
         * @return {string} 颜色
         */
        function toColor(data, format) {
            format = format || 'rgb';
            if (data && (data.length === 3 || data.length === 4)) {
                data = map(data,
                    function(c) {
                        return c > 1 ? Math.ceil(c) : c;
                    }
                );

                if (format.indexOf('hex') > -1) {
                    return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);
                } else if (format.indexOf('hs') > -1) {
                    var sx = map(data.slice(1, 3),
                        function(c) {
                            return c + '%';
                        }
                    );
                    data[1] = sx[0];
                    data[2] = sx[1];
                }

                if (format.indexOf('a') > -1) {
                    if (data.length === 3) {
                        data.push(1);
                    }
                    data[3] = adjust(data[3], [0, 1]);
                    return format + '(' + data.slice(0, 4).join(',') + ')';
                }

                return format + '(' + data.slice(0, 3).join(',') + ')';
            }
        }

        /**
         * 颜色字符串转换为rgba数组
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {Array.<number>} 颜色值数组
         */
        function toArray(color) {
            color = trim(color);
            if (color.indexOf('rgba') < 0) {
                color = toRGBA(color);
            }

            var data = [];
            var i = 0;
            color.replace(/[\d.]+/g, function(n) {
                if (i < 3) {
                    n = n | 0;
                } else {
                    // Alpha
                    n = +n;
                }
                data[i++] = n;
            });
            return data;
        }

        /**
         * 颜色格式转化
         *
         * @param {string} color 颜色值数组
         * @param {string} format 格式,默认rgb
         * @return {string} 颜色
         */
        function convert(color, format) {
            if (!isCalculableColor(color)) {
                return color;
            }
            var data = getData(color);
            var alpha = data[3];
            if (typeof alpha === 'undefined') {
                alpha = 1;
            }

            if (color.indexOf('hsb') > -1) {
                data = _HSV_2_RGB(data);
            } else if (color.indexOf('hsl') > -1) {
                data = _HSL_2_RGB(data);
            }

            if (format.indexOf('hsb') > -1 || format.indexOf('hsv') > -1) {
                data = _RGB_2_HSB(data);
            } else if (format.indexOf('hsl') > -1) {
                data = _RGB_2_HSL(data);
            }

            data[3] = alpha;

            return toColor(data, format);
        }

        /**
         * 转换为rgba格式的颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} rgba颜色，rgba(r,g,b,a)
         */
        function toRGBA(color) {
            return convert(color, 'rgba');
        }

        /**
         * 转换为rgb数字格式的颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} rgb颜色，rgb(0,0,0)格式
         */
        function toRGB(color) {
            return convert(color, 'rgb');
        }

        /**
         * 转换为16进制颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} 16进制颜色，#rrggbb格式
         */
        function toHex(color) {
            return convert(color, 'hex');
        }

        /**
         * 转换为HSV颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} HSVA颜色，hsva(h,s,v,a)
         */
        function toHSVA(color) {
            return convert(color, 'hsva');
        }

        /**
         * 转换为HSV颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} HSV颜色，hsv(h,s,v)
         */
        function toHSV(color) {
            return convert(color, 'hsv');
        }

        /**
         * 转换为HSBA颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} HSBA颜色，hsba(h,s,b,a)
         */
        function toHSBA(color) {
            return convert(color, 'hsba');
        }

        /**
         * 转换为HSB颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} HSB颜色，hsb(h,s,b)
         */
        function toHSB(color) {
            return convert(color, 'hsb');
        }

        /**
         * 转换为HSLA颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} HSLA颜色，hsla(h,s,l,a)
         */
        function toHSLA(color) {
            return convert(color, 'hsla');
        }

        /**
         * 转换为HSL颜色
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} HSL颜色，hsl(h,s,l)
         */
        function toHSL(color) {
            return convert(color, 'hsl');
        }

        /**
         * 转换颜色名
         * 
         * @param {string} color 颜色
         * @return {string} 颜色名
         */
        function toName(color) {
            for (var key in _nameColors) {
                if (toHex(_nameColors[key]) === toHex(color)) {
                    return key;
                }
            }
            return null;
        }

        /**
         * 移除颜色中多余空格
         * 
         * @param {string} color 颜色
         * @return {string} 无空格颜色
         */
        function trim(color) {
            return String(color).replace(/\s+/g, '');
        }

        /**
         * 颜色规范化
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} 规范化后的颜色
         */
        function normalize(color) {
            // 颜色名
            if (_nameColors[color]) {
                color = _nameColors[color];
            }
            // 去掉空格
            color = trim(color);
            // hsv与hsb等价
            color = color.replace(/hsv/i, 'hsb');
            // rgb转为rrggbb
            if (/^#[\da-f]{3}$/i.test(color)) {
                color = parseInt(color.slice(1), 16);
                var r = (color & 0xf00) << 8;
                var g = (color & 0xf0) << 4;
                var b = color & 0xf;

                color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
            }
            // 或者使用以下正则替换，不过 chrome 下性能相对差点
            // color = color.replace(/^#([\da-f])([\da-f])([\da-f])$/i, '#$1$1$2$2$3$3');
            return color;
        }

        /**
         * 颜色加深或减淡，当level>0加深，当level<0减淡
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @param {number} level 升降程度,取值区间[-1,1]
         * @return {string} 加深或减淡后颜色值
         */
        function lift(color, level) {
            if (!isCalculableColor(color)) {
                return color;
            }
            var direct = level > 0 ? 1 : -1;
            if (typeof level === 'undefined') {
                level = 0;
            }
            level = Math.abs(level) > 1 ? 1 : Math.abs(level);
            color = toRGB(color);
            var data = getData(color);
            for (var i = 0; i < 3; i++) {
                if (direct === 1) {
                    data[i] = data[i] * (1 - level) | 0;
                } else {
                    data[i] = ((255 - data[i]) * level + data[i]) | 0;
                }
            }
            return 'rgb(' + data.join(',') + ')';
        }

        /**
         * 颜色翻转,[255-r,255-g,255-b,1-a]
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @return {string} 翻转颜色
         */
        function reverse(color) {
            if (!isCalculableColor(color)) {
                return color;
            }
            var data = getData(toRGBA(color));
            data = map(data,
                function(c) {
                    return 255 - c;
                }
            );
            return toColor(data, 'rgb');
        }

        /**
         * 简单两种颜色混合
         * @memberOf module:zrender/tool/color
         * @param {string} color1 第一种颜色
         * @param {string} color2 第二种颜色
         * @param {number} weight 混合权重[0-1]
         * @return {string} 结果色,rgb(r,g,b)或rgba(r,g,b,a)
         */
        function mix(color1, color2, weight) {
            if (!isCalculableColor(color1) || !isCalculableColor(color2)) {
                return color1;
            }

            if (typeof weight === 'undefined') {
                weight = 0.5;
            }
            weight = 1 - adjust(weight, [0, 1]);

            var w = weight * 2 - 1;
            var data1 = getData(toRGBA(color1));
            var data2 = getData(toRGBA(color2));

            var d = data1[3] - data2[3];

            var weight1 = (((w * d === -1) ? w : (w + d) / (1 + w * d)) + 1) / 2;
            var weight2 = 1 - weight1;

            var data = [];

            for (var i = 0; i < 3; i++) {
                data[i] = data1[i] * weight1 + data2[i] * weight2;
            }

            var alpha = data1[3] * weight + data2[3] * (1 - weight);
            alpha = Math.max(0, Math.min(1, alpha));

            if (data1[3] === 1 && data2[3] === 1) { // 不考虑透明度
                return toColor(data, 'rgb');
            }
            data[3] = alpha;
            return toColor(data, 'rgba');
        }

        /**
         * 随机颜色
         * 
         * @return {string} 颜色值，#rrggbb格式
         */
        function random() {
            return '#' + (Math.random().toString(16) + '0000').slice(2, 8);
        }

        /**
         * 获取颜色值数组,返回值范围： <br/>
         * RGB 范围[0-255] <br/>
         * HSL/HSV/HSB 范围[0-1]<br/>
         * A透明度范围[0-1]
         * 支持格式：
         * #rgb
         * #rrggbb
         * rgb(r,g,b)
         * rgb(r%,g%,b%)
         * rgba(r,g,b,a)
         * hsb(h,s,b) // hsv与hsb等价
         * hsb(h%,s%,b%)
         * hsba(h,s,b,a)
         * hsl(h,s,l)
         * hsl(h%,s%,l%)
         * hsla(h,s,l,a)
         *
         * @param {string} color 颜色
         * @return {Array.<number>} 颜色值数组或null
         */
        function getData(color) {
            color = normalize(color);
            var r = color.match(colorRegExp);
            if (r === null) {
                throw new Error('The color format error'); // 颜色格式错误
            }
            var d;
            var a;
            var data = [];
            var rgb;

            if (r[2]) {
                // #rrggbb
                d = r[2].replace('#', '').split('');
                rgb = [d[0] + d[1], d[2] + d[3], d[4] + d[5]];
                data = map(rgb,
                    function(c) {
                        return adjust(parseInt(c, 16), [0, 255]);
                    }
                );

            } else if (r[4]) {
                // rgb rgba
                var rgba = (r[4]).split(',');
                a = rgba[3];
                rgb = rgba.slice(0, 3);
                data = map(
                    rgb,
                    function(c) {
                        c = Math.floor(
                            c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                        );
                        return adjust(c, [0, 255]);
                    }
                );

                if (typeof a !== 'undefined') {
                    data.push(adjust(parseFloat(a), [0, 1]));
                }
            } else if (r[5] || r[6]) {
                // hsb hsba hsl hsla
                var hsxa = (r[5] || r[6]).split(',');
                var h = parseInt(hsxa[0], 0) / 360;
                var s = hsxa[1];
                var x = hsxa[2];
                a = hsxa[3];
                data = map([s, x],
                    function(c) {
                        return adjust(parseFloat(c) / 100, [0, 1]);
                    }
                );
                data.unshift(h);
                if (typeof a !== 'undefined') {
                    data.push(adjust(parseFloat(a), [0, 1]));
                }
            }
            return data;
        }

        /**
         * 设置颜色透明度
         * @memberOf module:zrender/tool/color
         * @param {string} color 颜色
         * @param {number} a 透明度,区间[0,1]
         * @return {string} rgba颜色值
         */
        function alpha(color, a) {
            if (!isCalculableColor(color)) {
                return color;
            }
            if (a === null) {
                a = 1;
            }
            var data = getData(toRGBA(color));
            data[3] = adjust(Number(a).toFixed(4), [0, 1]);

            return toColor(data, 'rgba');
        }

        // 数组映射
        function map(array, fun) {
            if (typeof fun !== 'function') {
                throw new TypeError();
            }
            var len = array ? array.length : 0;
            for (var i = 0; i < len; i++) {
                array[i] = fun(array[i]);
            }
            return array;
        }

        // 调整值区间
        function adjust(value, region) {
            // < to <= & > to >=
            // modify by linzhifeng 2014-05-25 because -0 == 0
            if (value <= region[0]) {
                value = region[0];
            } else if (value >= region[1]) {
                value = region[1];
            }
            return value;
        }

        function isCalculableColor(color) {
            return color instanceof Array || typeof color === 'string';
        }

        // 参见 http:// www.easyrgb.com/index.php?X=MATH
        function _HSV_2_RGB(data) {
            var H = data[0];
            var S = data[1];
            var V = data[2];
            // HSV from 0 to 1
            var R;
            var G;
            var B;
            if (S === 0) {
                R = V * 255;
                G = V * 255;
                B = V * 255;
            } else {
                var h = H * 6;
                if (h === 6) {
                    h = 0;
                }
                var i = h | 0;
                var v1 = V * (1 - S);
                var v2 = V * (1 - S * (h - i));
                var v3 = V * (1 - S * (1 - (h - i)));
                var r = 0;
                var g = 0;
                var b = 0;

                if (i === 0) {
                    r = V;
                    g = v3;
                    b = v1;
                } else if (i === 1) {
                    r = v2;
                    g = V;
                    b = v1;
                } else if (i === 2) {
                    r = v1;
                    g = V;
                    b = v3;
                } else if (i === 3) {
                    r = v1;
                    g = v2;
                    b = V;
                } else if (i === 4) {
                    r = v3;
                    g = v1;
                    b = V;
                } else {
                    r = V;
                    g = v1;
                    b = v2;
                }

                // RGB results from 0 to 255
                R = r * 255;
                G = g * 255;
                B = b * 255;
            }
            return [R, G, B];
        }

        function _HSL_2_RGB(data) {
            var H = data[0];
            var S = data[1];
            var L = data[2];
            // HSL from 0 to 1
            var R;
            var G;
            var B;
            if (S === 0) {
                R = L * 255;
                G = L * 255;
                B = L * 255;
            } else {
                var v2;
                if (L < 0.5) {
                    v2 = L * (1 + S);
                } else {
                    v2 = (L + S) - (S * L);
                }

                var v1 = 2 * L - v2;

                R = 255 * _HUE_2_RGB(v1, v2, H + (1 / 3));
                G = 255 * _HUE_2_RGB(v1, v2, H);
                B = 255 * _HUE_2_RGB(v1, v2, H - (1 / 3));
            }
            return [R, G, B];
        }

        function _HUE_2_RGB(v1, v2, vH) {
            if (vH < 0) {
                vH += 1;
            }
            if (vH > 1) {
                vH -= 1;
            }
            if ((6 * vH) < 1) {
                return (v1 + (v2 - v1) * 6 * vH);
            }
            if ((2 * vH) < 1) {
                return (v2);
            }
            if ((3 * vH) < 2) {
                return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6);
            }
            return v1;
        }

        function _RGB_2_HSB(data) {
            // RGB from 0 to 255
            var R = (data[0] / 255);
            var G = (data[1] / 255);
            var B = (data[2] / 255);

            var vMin = Math.min(R, G, B); // Min. value of RGB
            var vMax = Math.max(R, G, B); // Max. value of RGB
            var delta = vMax - vMin; // Delta RGB value
            var V = vMax;
            var H;
            var S;

            // HSV results from 0 to 1
            if (delta === 0) {
                H = 0;
                S = 0;
            } else {
                S = delta / vMax;

                var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
                var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
                var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

                if (R === vMax) {
                    H = deltaB - deltaG;
                } else if (G === vMax) {
                    H = (1 / 3) + deltaR - deltaB;
                } else if (B === vMax) {
                    H = (2 / 3) + deltaG - deltaR;
                }

                if (H < 0) {
                    H += 1;
                }
                if (H > 1) {
                    H -= 1;
                }
            }
            H = H * 360;
            S = S * 100;
            V = V * 100;
            return [H, S, V];
        }

        function _RGB_2_HSL(data) {
            // RGB from 0 to 255
            var R = (data[0] / 255);
            var G = (data[1] / 255);
            var B = (data[2] / 255);

            var vMin = Math.min(R, G, B); // Min. value of RGB
            var vMax = Math.max(R, G, B); // Max. value of RGB
            var delta = vMax - vMin; // Delta RGB value

            var L = (vMax + vMin) / 2;
            var H;
            var S;
            // HSL results from 0 to 1
            if (delta === 0) {
                H = 0;
                S = 0;
            } else {
                if (L < 0.5) {
                    S = delta / (vMax + vMin);
                } else {
                    S = delta / (2 - vMax - vMin);
                }

                var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
                var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
                var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

                if (R === vMax) {
                    H = deltaB - deltaG;
                } else if (G === vMax) {
                    H = (1 / 3) + deltaR - deltaB;
                } else if (B === vMax) {
                    H = (2 / 3) + deltaG - deltaR;
                }

                if (H < 0) {
                    H += 1;
                }

                if (H > 1) {
                    H -= 1;
                }
            }

            H = H * 360;
            S = S * 100;
            L = L * 100;

            return [H, S, L];
        }

        return {
            customPalette: customPalette,
            resetPalette: resetPalette,
            getColor: getColor,
            getHighlightColor: getHighlightColor,
            customHighlight: customHighlight,
            resetHighlight: resetHighlight,
            getRadialGradient: getRadialGradient,
            getLinearGradient: getLinearGradient,
            getGradientColors: getGradientColors,
            getStepColors: getStepColors,
            reverse: reverse,
            mix: mix,
            lift: lift,
            trim: trim,
            random: random,
            toRGB: toRGB,
            toRGBA: toRGBA,
            toHex: toHex,
            toHSL: toHSL,
            toHSLA: toHSLA,
            toHSB: toHSB,
            toHSBA: toHSBA,
            toHSV: toHSV,
            toHSVA: toHSVA,
            toName: toName,
            toColor: toColor,
            toArray: toArray,
            alpha: alpha,
            getData: getData
        };
    });
    define('zrender/tool/env', [], function() {
        // Zepto.js
        // (c) 2010-2013 Thomas Fuchs
        // Zepto.js may be freely distributed under the MIT license.

        function detect(ua) {
            var os = this.os = {};
            var browser = this.browser = {};
            var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
            var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
            var touchpad = webos && ua.match(/TouchPad/);
            var kindle = ua.match(/Kindle\/([\d.]+)/);
            var silk = ua.match(/Silk\/([\d._]+)/);
            var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
            var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
            var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
            var playbook = ua.match(/PlayBook/);
            var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
            var firefox = ua.match(/Firefox\/([\d.]+)/);
            var ie = ua.match(/MSIE ([\d.]+)/);
            var safari = webkit && ua.match(/Mobile\//) && !chrome;
            var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
            var ie = ua.match(/MSIE\s([\d.]+)/);

            // Todo: clean this up with a better OS/browser seperation:
            // - discern (more) between multiple browsers on android
            // - decide if kindle fire in silk mode is android or not
            // - Firefox on Android doesn't specify the Android version
            // - possibly devide in os, device and browser hashes

            if (browser.webkit = !!webkit) browser.version = webkit[1];

            if (android) os.android = true, os.version = android[2];
            if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
            if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
            if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
            if (webos) os.webos = true, os.version = webos[2];
            if (touchpad) os.touchpad = true;
            if (blackberry) os.blackberry = true, os.version = blackberry[2];
            if (bb10) os.bb10 = true, os.version = bb10[2];
            if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
            if (playbook) browser.playbook = true;
            if (kindle) os.kindle = true, os.version = kindle[1];
            if (silk) browser.silk = true, browser.version = silk[1];
            if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
            if (chrome) browser.chrome = true, browser.version = chrome[1];
            if (firefox) browser.firefox = true, browser.version = firefox[1];
            if (ie) browser.ie = true, browser.version = ie[1];
            if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
            if (webview) browser.webview = true;
            if (ie) browser.ie = true, browser.version = ie[1];

            os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
                (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
            os.phone = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||
                (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
                (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));

            return {
                browser: browser,
                os: os,
                // 原生canvas支持，改极端点了
                // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
                canvasSupported: document.createElement('canvas').getContext ? true : false
            };
        }

        return detect(navigator.userAgent);
    });
    define('echarts/component', [], function( /*require*/ ) { // component
        var self = {};

        var _componentLibrary = {}; // echart组件库

        /**
         * 定义图形实现
         * @param {Object} name
         * @param {Object} clazz 图形实现
         */
        self.define = function(name, clazz) {
            _componentLibrary[name] = clazz;
            return self;
        };

        /**
         * 获取图形实现
         * @param {Object} name
         */
        self.get = function(name) {
            return _componentLibrary[name];
        };

        return self;
    });
    define('zrender/zrender', ['require', './dep/excanvas', './tool/util', './tool/log', './tool/guid', './Handler', './Painter', './Storage', './animation/Animation', './tool/env'], function(require) {
        /*
         * HTML5 Canvas for Internet Explorer!
         * Modern browsers like Firefox, Safari, Chrome and Opera support
         * the HTML5 canvas tag to allow 2D command-based drawing.
         * ExplorerCanvas brings the same functionality to Internet Explorer.
         * To use, web developers only need to include a single script tag
         * in their existing web pages.
         *
         * https://code.google.com/p/explorercanvas/
         * http://explorercanvas.googlecode.com/svn/trunk/excanvas.js
         */
        // 核心代码会生成一个全局变量 G_vmlCanvasManager，模块改造后借用于快速判断canvas支持
        require('./dep/excanvas');

        var util = require('./tool/util');
        var log = require('./tool/log');
        var guid = require('./tool/guid');

        var Handler = require('./Handler');
        var Painter = require('./Painter');
        var Storage = require('./Storage');
        var Animation = require('./animation/Animation');

        var _instances = {}; // ZRender实例map索引

        /**
         * @exports zrender
         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
         *         pissang (https://www.github.com/pissang)
         */
        var zrender = {};
        /**
         * @type {string}
         */
        zrender.version = '2.1.1';

        /**
         * 创建zrender实例
         *
         * @param {HTMLElement} dom 绘图容器
         * @return {module:zrender/ZRender} ZRender实例
         */
        // 不让外部直接new ZRender实例，为啥？
        // 不为啥，提供全局可控同时减少全局污染和降低命名冲突的风险！
        zrender.init = function(dom) {
            var zr = new ZRender(guid(), dom);
            _instances[zr.id] = zr;
            return zr;
        };

        /**
         * zrender实例销毁
         * @param {module:zrender/ZRender} zr ZRender对象，不传则销毁全部
         */
        // 在_instances里的索引也会删除了
        // 管生就得管死，可以通过zrender.dispose(zr)销毁指定ZRender实例
        // 当然也可以直接zr.dispose()自己销毁
        zrender.dispose = function(zr) {
            if (zr) {
                zr.dispose();
            } else {
                for (var key in _instances) {
                    _instances[key].dispose();
                }
                _instances = {};
            }

            return zrender;
        };

        /**
         * 获取zrender实例
         * @param {string} id ZRender对象索引
         * @return {module:zrender/ZRender}
         */
        zrender.getInstance = function(id) {
            return _instances[id];
        };

        /**
         * 删除zrender实例，ZRender实例dispose时会调用，
         * 删除后getInstance则返回undefined
         * ps: 仅是删除，删除的实例不代表已经dispose了~~
         *     这是一个摆脱全局zrender.dispose()自动销毁的后门，
         *     take care of yourself~
         *
         * @param {string} id ZRender对象索引
         */
        zrender.delInstance = function(id) {
            delete _instances[id];
            return zrender;
        };

        function getFrameCallback(zrInstance) {
            return function() {
                if (zrInstance._needsRefreshNextFrame) {
                    zrInstance.refresh();
                }
            };
        }

        /**
         * @module zrender/ZRender
         */
        /**
         * ZRender接口类，对外可用的所有接口都在这里
         * 非get接口统一返回支持链式调用
         *
         * @constructor
         * @alias module:zrender/ZRender
         * @param {string} id 唯一标识
         * @param {HTMLElement} dom dom对象，不帮你做document.getElementById
         * @return {ZRender} ZRender实例
         */
        var ZRender = function(id, dom) {
            /**
             * 实例 id
             * @type {string}
             */
            this.id = id;
            this.env = require('./tool/env');

            this.storage = new Storage();
            this.painter = new Painter(dom, this.storage);
            this.handler = new Handler(dom, this.storage, this.painter);

            /**
             * @type {module:zrender/animation/Animation}
             */
            this.animation = new Animation({
                stage: {
                    update: getFrameCallback(this)
                }
            });
            this.animation.start();

            var self = this;
            this.painter.refreshNextFrame = function() {
                self.refreshNextFrame();
            };

            this._needsRefreshNextFrame = false;

            // 修改 storage.delFromMap, 每次删除元素之前删除动画
            // FIXME 有点ugly
            var self = this;
            var storage = this.storage;
            var oldDelFromMap = storage.delFromMap;
            storage.delFromMap = function(elId) {
                var el = storage.get(elId);
                self.stopAnimation(el);
                oldDelFromMap.call(storage, elId);
            };
        };

        /**
         * 获取实例唯一标识
         * @return {string}
         */
        ZRender.prototype.getId = function() {
            return this.id;
        };

        /**
         * 添加图形形状到根节点
         * @deprecated Use {@link module:zrender/ZRender.prototype.addElement} instead
         * @param {module:zrender/shape/Base} shape 形状对象，可用属性全集，详见各shape
         */
        ZRender.prototype.addShape = function(shape) {
            this.addElement(shape);
            return this;
        };

        /**
         * 添加组到根节点
         * @deprecated Use {@link module:zrender/ZRender.prototype.addElement} instead
         * @param {module:zrender/Group} group
         */
        ZRender.prototype.addGroup = function(group) {
            this.addElement(group);
            return this;
        };

        /**
         * 从根节点删除图形形状
         * @deprecated Use {@link module:zrender/ZRender.prototype.delElement} instead
         * @param {string} shapeId 形状对象唯一标识
         */
        ZRender.prototype.delShape = function(shapeId) {
            this.delElement(shapeId);
            return this;
        };

        /**
         * 从根节点删除组
         * @deprecated Use {@link module:zrender/ZRender.prototype.delElement} instead
         * @param {string} groupId
         */
        ZRender.prototype.delGroup = function(groupId) {
            this.delElement(groupId);
            return this;
        };

        /**
         * 修改图形形状
         * @deprecated Use {@link module:zrender/ZRender.prototype.modElement} instead
         * @param {string} shapeId 形状对象唯一标识
         * @param {Object} shape 形状对象
         */
        ZRender.prototype.modShape = function(shapeId, shape) {
            this.modElement(shapeId, shape);
            return this;
        };

        /**
         * 修改组
         * @deprecated Use {@link module:zrender/ZRender.prototype.modElement} instead
         * @param {string} groupId
         * @param {Object} group
         */
        ZRender.prototype.modGroup = function(groupId, group) {
            this.modElement(groupId, group);
            return this;
        };

        /**
         * 添加元素
         * @param  {string|module:zrender/Group|module:zrender/shape/Base} el
         */
        ZRender.prototype.addElement = function(el) {
            this.storage.addRoot(el);
            this._needsRefreshNextFrame = true;
            return this;
        };

        /**
         * 删除元素
         * @param  {string|module:zrender/Group|module:zrender/shape/Base} el
         */
        ZRender.prototype.delElement = function(el) {
            this.storage.delRoot(el);
            this._needsRefreshNextFrame = true;
            return this;
        };

        /**
         * 修改元素, 主要标记图形或者组需要在下一帧刷新。
         * 第二个参数为需要覆盖到元素上的参数，不建议使用。
         *
         * @example
         *     el.style.color = 'red';
         *     el.position = [10, 10];
         *     zr.modElement(el);
         * @param  {string|module:zrender/Group|module:zrender/shape/Base} el
         * @param {Object} [params]
         */
        ZRender.prototype.modElement = function(el, params) {
            this.storage.mod(el, params);
            this._needsRefreshNextFrame = true;
            return this;
        };

        /**
         * 修改指定zlevel的绘制配置项
         * 
         * @param {string} zLevel
         * @param {Object} config 配置对象
         * @param {string} [config.clearColor=0] 每次清空画布的颜色
         * @param {string} [config.motionBlur=false] 是否开启动态模糊
         * @param {number} [config.lastFrameAlpha=0.7]
         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
         * @param {Array.<number>} [config.position] 层的平移
         * @param {Array.<number>} [config.rotation] 层的旋转
         * @param {Array.<number>} [config.scale] 层的缩放
         * @param {boolean} [config.zoomable=false] 层是否支持鼠标缩放操作
         * @param {boolean} [config.panable=false] 层是否支持鼠标平移操作
         */
        ZRender.prototype.modLayer = function(zLevel, config) {
            this.painter.modLayer(zLevel, config);
            this._needsRefreshNextFrame = true;
            return this;
        };

        /**
         * 添加额外高亮层显示，仅提供添加方法，每次刷新后高亮层图形均被清空
         * 
         * @param {Object} shape 形状对象
         */
        ZRender.prototype.addHoverShape = function(shape) {
            this.storage.addHover(shape);
            return this;
        };

        /**
         * 渲染
         * 
         * @param {Function} callback  渲染结束后回调函数
         */
        ZRender.prototype.render = function(callback) {
            this.painter.render(callback);
            this._needsRefreshNextFrame = false;
            return this;
        };

        /**
         * 视图更新
         * 
         * @param {Function} callback  视图更新后回调函数
         */
        ZRender.prototype.refresh = function(callback) {
            this.painter.refresh(callback);
            this._needsRefreshNextFrame = false;
            return this;
        };

        /**
         * 标记视图在浏览器下一帧需要绘制
         */
        ZRender.prototype.refreshNextFrame = function() {
            this._needsRefreshNextFrame = true;
            return this;
        };

        /**
         * 绘制高亮层
         * @param {Function} callback  视图更新后回调函数
         */
        ZRender.prototype.refreshHover = function(callback) {
            this.painter.refreshHover(callback);
            return this;
        };

        /**
         * 视图更新
         * 
         * @param {Array.<module:zrender/shape/Base>} shapeList 需要更新的图形列表
         * @param {Function} callback  视图更新后回调函数
         */
        ZRender.prototype.refreshShapes = function(shapeList, callback) {
            this.painter.refreshShapes(shapeList, callback);
            return this;
        };

        /**
         * 调整视图大小
         */
        ZRender.prototype.resize = function() {
            this.painter.resize();
            return this;
        };

        /**
         * 动画
         * 
         * @param {string|module:zrender/Group|module:zrender/shape/Base} el 动画对象
         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
         * @param {boolean} [loop] 动画是否循环
         * @return {module:zrender/animation/Animation~Animator}
         * @example:
         *     zr.animate(circle.id, 'style', false)
         *         .when(1000, {x: 10} )
         *         .done(function(){ // Animation done })
         *         .start()
         */
        ZRender.prototype.animate = function(el, path, loop) {
            var self = this;

            if (typeof(el) === 'string') {
                el = this.storage.get(el);
            }
            if (el) {
                var target;
                if (path) {
                    var pathSplitted = path.split('.');
                    var prop = el;
                    for (var i = 0, l = pathSplitted.length; i < l; i++) {
                        if (!prop) {
                            continue;
                        }
                        prop = prop[pathSplitted[i]];
                    }
                    if (prop) {
                        target = prop;
                    }
                } else {
                    target = el;
                }

                if (!target) {
                    log(
                        'Property "' + path + '" is not existed in element ' + el.id
                    );
                    return;
                }

                if (el.__animators == null) {
                    // 正在进行的动画记数
                    el.__animators = [];
                }
                var animators = el.__animators;

                var animator = this.animation.animate(target, {
                        loop: loop
                    })
                    .during(function() {
                        self.modShape(el);
                    })
                    .done(function() {
                        var idx = util.indexOf(el.__animators, animator);
                        if (idx >= 0) {
                            animators.splice(idx, 1);
                        }
                    });
                animators.push(animator);

                return animator;
            } else {
                log('Element not existed');
            }
        };

        /**
         * 停止动画对象的动画
         * @param  {string|module:zrender/Group|module:zrender/shape/Base} el
         */
        ZRender.prototype.stopAnimation = function(el) {
            if (el.__animators) {
                var animators = el.__animators;
                var len = animators.length;
                for (var i = 0; i < len; i++) {
                    animators[i].stop();
                }
                animators.length = 0;
            }
            return this;
        };

        /**
         * 停止所有动画
         */
        ZRender.prototype.clearAnimation = function() {
            this.animation.clear();
            return this;
        };

        /**
         * loading显示
         * 
         * @param {Object=} loadingEffect loading效果对象
         */
        ZRender.prototype.showLoading = function(loadingEffect) {
            this.painter.showLoading(loadingEffect);
            return this;
        };

        /**
         * loading结束
         */
        ZRender.prototype.hideLoading = function() {
            this.painter.hideLoading();
            return this;
        };

        /**
         * 获取视图宽度
         */
        ZRender.prototype.getWidth = function() {
            return this.painter.getWidth();
        };

        /**
         * 获取视图高度
         */
        ZRender.prototype.getHeight = function() {
            return this.painter.getHeight();
        };

        /**
         * 图像导出
         * @param {string} type
         * @param {string} [backgroundColor='#fff'] 背景色
         * @return {string} 图片的Base64 url
         */
        ZRender.prototype.toDataURL = function(type, backgroundColor, args) {
            return this.painter.toDataURL(type, backgroundColor, args);
        };

        /**
         * 将常规shape转成image shape
         * @param {module:zrender/shape/Base} e
         * @param {number} width
         * @param {number} height
         */
        ZRender.prototype.shapeToImage = function(e, width, height) {
            var id = guid();
            return this.painter.shapeToImage(id, e, width, height);
        };

        /**
         * 事件绑定
         * 
         * @param {string} eventName 事件名称
         * @param {Function} eventHandler 响应函数
         * @param {Object} [context] 响应函数
         */
        ZRender.prototype.on = function(eventName, eventHandler, context) {
            this.handler.on(eventName, eventHandler, context);
            return this;
        };

        /**
         * 事件解绑定，参数为空则解绑所有自定义事件
         * 
         * @param {string} eventName 事件名称
         * @param {Function} eventHandler 响应函数
         */
        ZRender.prototype.un = function(eventName, eventHandler) {
            this.handler.un(eventName, eventHandler);
            return this;
        };

        /**
         * 事件触发
         * 
         * @param {string} eventName 事件名称，resize，hover，drag，etc
         * @param {event=} event event dom事件对象
         */
        ZRender.prototype.trigger = function(eventName, event) {
            this.handler.trigger(eventName, event);
            return this;
        };


        /**
         * 清除当前ZRender下所有类图的数据和显示，clear后MVC和已绑定事件均还存在在，ZRender可用
         */
        ZRender.prototype.clear = function() {
            this.storage.delRoot();
            this.painter.clear();
            return this;
        };

        /**
         * 释放当前ZR实例（删除包括dom，数据、显示和事件绑定），dispose后ZR不可用
         */
        ZRender.prototype.dispose = function() {
            this.animation.stop();

            this.clear();
            this.storage.dispose();
            this.painter.dispose();
            this.handler.dispose();

            this.animation =
                this.storage =
                this.painter =
                this.handler = null;

            // 释放后告诉全局删除对自己的索引，没想到啥好方法
            zrender.delInstance(this.id);
        };

        return zrender;
    });
    define('zrender/config', [], function() {
        /**
         * config默认配置项
         * @exports zrender/config
         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
         */
        var config = {
            /**
             * @namespace module:zrender/config.EVENT
             */
            EVENT: {
                /**
                 * 窗口大小变化
                 * @type {string}
                 */
                RESIZE: 'resize',
                /**
                 * 鼠标按钮被（手指）按下，事件对象是：目标图形元素或空
                 * @type {string}
                 */
                CLICK: 'click',
                /**
                 * 双击事件
                 * @type {string}
                 */
                DBLCLICK: 'dblclick',
                /**
                 * 鼠标滚轮变化，事件对象是：目标图形元素或空
                 * @type {string}
                 */
                MOUSEWHEEL: 'mousewheel',
                /**
                 * 鼠标（手指）被移动，事件对象是：目标图形元素或空
                 * @type {string}
                 */
                MOUSEMOVE: 'mousemove',
                /**
                 * 鼠标移到某图形元素之上，事件对象是：目标图形元素
                 * @type {string}
                 */
                MOUSEOVER: 'mouseover',
                /**
                 * 鼠标从某图形元素移开，事件对象是：目标图形元素
                 * @type {string}
                 */
                MOUSEOUT: 'mouseout',
                /**
                 * 鼠标按钮（手指）被按下，事件对象是：目标图形元素或空
                 * @type {string}
                 */
                MOUSEDOWN: 'mousedown',
                /**
                 * 鼠标按键（手指）被松开，事件对象是：目标图形元素或空
                 * @type {string}
                 */
                MOUSEUP: 'mouseup',
                /**
                 * 全局离开，MOUSEOUT触发比较频繁，一次离开优化绑定
                 * @type {string}
                 */
                GLOBALOUT: 'globalout', // 

                // 一次成功元素拖拽的行为事件过程是：
                // dragstart > dragenter > dragover [> dragleave] > drop > dragend
                /**
                 * 开始拖拽时触发，事件对象是：被拖拽图形元素
                 * @type {string}
                 */
                DRAGSTART: 'dragstart',
                /**
                 * 拖拽完毕时触发（在drop之后触发），事件对象是：被拖拽图形元素
                 * @type {string}
                 */
                DRAGEND: 'dragend',
                /**
                 * 拖拽图形元素进入目标图形元素时触发，事件对象是：目标图形元素
                 * @type {string}
                 */
                DRAGENTER: 'dragenter',
                /**
                 * 拖拽图形元素在目标图形元素上移动时触发，事件对象是：目标图形元素
                 * @type {string}
                 */
                DRAGOVER: 'dragover',
                /**
                 * 拖拽图形元素离开目标图形元素时触发，事件对象是：目标图形元素
                 * @type {string}
                 */
                DRAGLEAVE: 'dragleave',
                /**
                 * 拖拽图形元素放在目标图形元素内时触发，事件对象是：目标图形元素
                 * @type {string}
                 */
                DROP: 'drop',
                /**
                 * touch end - start < delay is click
                 * @type {number}
                 */
                touchClickDelay: 300
            },

            elementClassName: 'zr-element',

            // 是否异常捕获
            catchBrushException: false,

            /**
             * debug日志选项：catchBrushException为true下有效
             * 0 : 不生成debug数据，发布用
             * 1 : 异常抛出，调试用
             * 2 : 控制台输出，调试用
             */
            debugMode: 0,

            // retina 屏幕优化
            devicePixelRatio: Math.max(window.devicePixelRatio || 1, 1)
        };
        return config;
    });
    define('echarts/chart/island', ['require', './base', 'zrender/shape/Circle', '../config', '../util/ecData', 'zrender/tool/util', 'zrender/tool/event', 'zrender/tool/color', '../util/accMath', '../chart'], function(require) {
        var ChartBase = require('./base');

        // 图形依赖
        var CircleShape = require('zrender/shape/Circle');

        var ecConfig = require('../config');
        ecConfig.island = {
            zlevel: 0, // 一级层叠
            z: 5, // 二级层叠
            r: 15,
            calculateStep: 0.1 // 滚轮可计算步长 0.1 = 10%
        };

        var ecData = require('../util/ecData');
        var zrUtil = require('zrender/tool/util');
        var zrEvent = require('zrender/tool/event');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表选项
         */
        function Island(ecTheme, messageCenter, zr, option, myChart) {
            // 图表基类
            ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);

            this._nameConnector;
            this._valueConnector;
            this._zrHeight = this.zr.getHeight();
            this._zrWidth = this.zr.getWidth();

            var self = this;
            /**
             * 滚轮改变孤岛数据值
             */
            self.shapeHandler.onmousewheel = function(param) {
                var shape = param.target;

                var event = param.event;
                var delta = zrEvent.getDelta(event);
                delta = delta > 0 ? (-1) : 1;
                shape.style.r -= delta;
                shape.style.r = shape.style.r < 5 ? 5 : shape.style.r;

                var value = ecData.get(shape, 'value');
                var dvalue = value * self.option.island.calculateStep;
                value = dvalue > 1 ? (Math.round(value - dvalue * delta)) : +(value - dvalue * delta).toFixed(2);

                var name = ecData.get(shape, 'name');
                shape.style.text = name + ':' + value;

                ecData.set(shape, 'value', value);
                ecData.set(shape, 'name', name);

                self.zr.modShape(shape.id);
                self.zr.refreshNextFrame();
                zrEvent.stop(event);
            };
        }

        Island.prototype = {
            type: ecConfig.CHART_TYPE_ISLAND,
            /**
             * 孤岛合并
             *
             * @param {string} tarShapeIndex 目标索引
             * @param {Object} srcShape 源目标，合入目标后删除
             */
            _combine: function(tarShape, srcShape) {
                var zrColor = require('zrender/tool/color');
                var accMath = require('../util/accMath');
                var value = accMath.accAdd(
                    ecData.get(tarShape, 'value'),
                    ecData.get(srcShape, 'value')
                );
                var name = ecData.get(tarShape, 'name') + this._nameConnector + ecData.get(srcShape, 'name');

                tarShape.style.text = name + this._valueConnector + value;

                ecData.set(tarShape, 'value', value);
                ecData.set(tarShape, 'name', name);
                tarShape.style.r = this.option.island.r;
                tarShape.style.color = zrColor.mix(
                    tarShape.style.color,
                    srcShape.style.color
                );
            },

            /**
             * 刷新
             */
            refresh: function(newOption) {
                if (newOption) {
                    newOption.island = this.reformOption(newOption.island);
                    this.option = newOption;

                    this._nameConnector = this.option.nameConnector;
                    this._valueConnector = this.option.valueConnector;
                }
            },

            getOption: function() {
                return this.option;
            },

            resize: function() {
                var newWidth = this.zr.getWidth();
                var newHieght = this.zr.getHeight();
                var xScale = newWidth / (this._zrWidth || newWidth);
                var yScale = newHieght / (this._zrHeight || newHieght);
                if (xScale === 1 && yScale === 1) {
                    return;
                }
                this._zrWidth = newWidth;
                this._zrHeight = newHieght;
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    this.zr.modShape(
                        this.shapeList[i].id, {
                            style: {
                                x: Math.round(this.shapeList[i].style.x * xScale),
                                y: Math.round(this.shapeList[i].style.y * yScale)
                            }
                        }
                    );
                }
            },

            add: function(shape) {
                var name = ecData.get(shape, 'name');
                var value = ecData.get(shape, 'value');
                var seriesName = ecData.get(shape, 'series') != null ? ecData.get(shape, 'series').name : '';
                var font = this.getFont(this.option.island.textStyle);
                var islandOption = this.option.island;
                var islandShape = {
                    zlevel: islandOption.zlevel,
                    z: islandOption.z,
                    style: {
                        x: shape.style.x,
                        y: shape.style.y,
                        r: this.option.island.r,
                        color: shape.style.color || shape.style.strokeColor,
                        text: name + this._valueConnector + value,
                        textFont: font
                    },
                    draggable: true,
                    hoverable: true,
                    onmousewheel: this.shapeHandler.onmousewheel,
                    _type: 'island'
                };
                if (islandShape.style.color === '#fff') {
                    islandShape.style.color = shape.style.strokeColor;
                }
                this.setCalculable(islandShape);
                islandShape.dragEnableTime = 0;
                ecData.pack(
                    islandShape, {
                        name: seriesName
                    }, -1,
                    value, -1,
                    name
                );
                islandShape = new CircleShape(islandShape);
                this.shapeList.push(islandShape);
                this.zr.addShape(islandShape);
            },

            del: function(shape) {
                this.zr.delShape(shape.id);
                var newShapeList = [];
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    if (this.shapeList[i].id != shape.id) {
                        newShapeList.push(this.shapeList[i]);
                    }
                }
                this.shapeList = newShapeList;
            },

            /**
             * 数据项被拖拽进来， 重载基类方法
             */
            ondrop: function(param, status) {
                if (!this.isDrop || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }
                // 拖拽产生孤岛数据合并
                var target = param.target; // 拖拽安放目标
                var dragged = param.dragged; // 当前被拖拽的图形对象

                this._combine(target, dragged);
                this.zr.modShape(target.id);

                status.dragIn = true;

                // 处理完拖拽事件后复位
                this.isDrop = false;

                return;
            },

            /**
             * 数据项被拖拽出去， 重载基类方法
             */
            ondragend: function(param, status) {
                var target = param.target; // 拖拽安放目标
                if (!this.isDragend) {
                    // 拖拽的不是孤岛数据，如果没有图表接受孤岛数据，需要新增孤岛数据
                    if (!status.dragIn) {
                        target.style.x = zrEvent.getX(param.event);
                        target.style.y = zrEvent.getY(param.event);
                        this.add(target);
                        status.needRefresh = true;
                    }
                } else {
                    // 拖拽的是孤岛数据，如果有图表接受了孤岛数据，需要删除孤岛数据
                    if (status.dragIn) {
                        this.del(target);
                        status.needRefresh = true;
                    }
                }

                // 处理完拖拽事件后复位
                this.isDragend = false;

                return;
            }
        };

        zrUtil.inherits(Island, ChartBase);

        // 图表注册
        require('../chart').define('island', Island);

        return Island;
    });
    define('echarts/component/toolbox', ['require', './base', 'zrender/shape/Line', 'zrender/shape/Image', 'zrender/shape/Rectangle', '../util/shape/Icon', '../config', 'zrender/tool/util', 'zrender/config', 'zrender/tool/event', './dataView', '../component'], function(require) {
        var Base = require('./base');

        // 图形依赖
        var LineShape = require('zrender/shape/Line');
        var ImageShape = require('zrender/shape/Image');
        var RectangleShape = require('zrender/shape/Rectangle');
        var IconShape = require('../util/shape/Icon');

        var ecConfig = require('../config');
        ecConfig.toolbox = {
            zlevel: 0, // 一级层叠
            z: 6, // 二级层叠
            show: false,
            orient: 'horizontal', // 布局方式，默认为水平布局，可选为：
            // 'horizontal' ¦ 'vertical'
            x: 'right', // 水平安放位置，默认为全图右对齐，可选为：
            // 'center' ¦ 'left' ¦ 'right'
            // ¦ {number}（x坐标，单位px）
            y: 'top', // 垂直安放位置，默认为全图顶端，可选为：
            // 'top' ¦ 'bottom' ¦ 'center'
            // ¦ {number}（y坐标，单位px）
            color: ['#1e90ff', '#22bb22', '#4b0082', '#d2691e'],
            disableColor: '#ddd',
            effectiveColor: 'red',
            backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色
            borderColor: '#ccc', // 工具箱边框颜色
            borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框）
            padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5，
            // 接受数组分别设定上右下左边距，同css
            itemGap: 10, // 各个item之间的间隔，单位px，默认为10，
            // 横向布局时为水平间隔，纵向布局时为纵向间隔
            itemSize: 16, // 工具箱图形宽度
            showTitle: true,
            // textStyle: {},
            feature: {
                mark: {
                    show: false,
                    title: {
                        mark: '辅助线开关',
                        markUndo: '删除辅助线',
                        markClear: '清空辅助线'
                    },
                    lineStyle: {
                        width: 1,
                        color: '#1e90ff',
                        type: 'dashed'
                    }
                },
                dataZoom: {
                    show: false,
                    title: {
                        dataZoom: '区域缩放',
                        dataZoomReset: '区域缩放后退'
                    }
                },
                dataView: {
                    show: false,
                    title: '数据视图',
                    readOnly: false,
                    lang: ['数据视图', '关闭', '刷新']
                },
                magicType: {
                    show: false,
                    title: {
                        line: '折线图切换',
                        bar: '柱形图切换',
                        stack: '堆积',
                        tiled: '平铺',
                        force: '力导向布局图切换',
                        chord: '和弦图切换',
                        pie: '饼图切换',
                        funnel: '漏斗图切换'
                    },
                    /*
                    option: {
                        line: {},
                        bar: {},
                        stack: {},
                        tiled: {},
                        force: {},
                        chord: {},
                        pie: {},
                        funnel: {}
                    },
                    */
                    type: [] // 'line', 'bar', 'stack', 'tiled', 'force', 'chord', 'pie', 'funnel'
                },
                restore: {
                    show: false,
                    title: '还原'
                },
                saveAsImage: {
                    show: false,
                    title: '保存为图片',
                    type: 'png',
                    lang: ['点击保存']
                }
            }
        };

        var zrUtil = require('zrender/tool/util');
        var zrConfig = require('zrender/config');
        var zrEvent = require('zrender/tool/event');

        var _MAGICTYPE_STACK = 'stack';
        var _MAGICTYPE_TILED = 'tiled';

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {HtmlElement} dom 目标对象
         * @param {ECharts} myChart 当前图表实例
         */
        function Toolbox(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.dom = myChart.dom;

            this._magicType = {};
            this._magicMap = {};
            this._isSilence = false;

            this._iconList;
            this._iconShapeMap = {};
            //this._itemGroupLocation;
            this._featureTitle = {}; // 文字
            this._featureIcon = {}; // 图标
            this._featureColor = {}; // 颜色
            this._featureOption = {};
            this._enableColor = 'red';
            this._disableColor = '#ccc';
            // this._markStart;
            // this._marking;
            // this._markShape;
            // this._zoomStart;
            // this._zooming;
            // this._zoomShape;
            // this._zoomQueue;
            // this._dataView;
            this._markShapeList = [];
            var self = this;
            self._onMark = function(param) {
                self.__onMark(param);
            };
            self._onMarkUndo = function(param) {
                self.__onMarkUndo(param);
            };
            self._onMarkClear = function(param) {
                self.__onMarkClear(param);
            };
            self._onDataZoom = function(param) {
                self.__onDataZoom(param);
            };
            self._onDataZoomReset = function(param) {
                self.__onDataZoomReset(param);
            };
            self._onDataView = function(param) {
                self.__onDataView(param);
            };
            self._onRestore = function(param) {
                self.__onRestore(param);
            };
            self._onSaveAsImage = function(param) {
                self.__onSaveAsImage(param);
            };
            self._onMagicType = function(param) {
                self.__onMagicType(param);
            };
            self._onCustomHandler = function(param) {
                self.__onCustomHandler(param);
            };
            self._onmousemove = function(param) {
                return self.__onmousemove(param);
            };

            self._onmousedown = function(param) {
                return self.__onmousedown(param);
            };

            self._onmouseup = function(param) {
                return self.__onmouseup(param);
            };

            self._onclick = function(param) {
                return self.__onclick(param);
            };
        }

        Toolbox.prototype = {
            type: ecConfig.COMPONENT_TYPE_TOOLBOX,
            _buildShape: function() {
                this._iconList = [];
                var toolboxOption = this.option.toolbox;
                this._enableColor = toolboxOption.effectiveColor;
                this._disableColor = toolboxOption.disableColor;
                var feature = toolboxOption.feature;
                var iconName = [];
                for (var key in feature) {
                    if (feature[key].show) {
                        switch (key) {
                            case 'mark':
                                iconName.push({
                                    key: key,
                                    name: 'mark'
                                });
                                iconName.push({
                                    key: key,
                                    name: 'markUndo'
                                });
                                iconName.push({
                                    key: key,
                                    name: 'markClear'
                                });
                                break;
                            case 'magicType':
                                for (var i = 0, l = feature[key].type.length; i < l; i++) {
                                    feature[key].title[feature[key].type[i] + 'Chart'] = feature[key].title[feature[key].type[i]];
                                    if (feature[key].option) {
                                        feature[key].option[feature[key].type[i] + 'Chart'] = feature[key].option[feature[key].type[i]];
                                    }
                                    iconName.push({
                                        key: key,
                                        name: feature[key].type[i] + 'Chart'
                                    });
                                }
                                break;
                            case 'dataZoom':
                                iconName.push({
                                    key: key,
                                    name: 'dataZoom'
                                });
                                iconName.push({
                                    key: key,
                                    name: 'dataZoomReset'
                                });
                                break;
                            case 'saveAsImage':
                                if (this.canvasSupported) {
                                    iconName.push({
                                        key: key,
                                        name: 'saveAsImage'
                                    });
                                }
                                break;
                            default:
                                iconName.push({
                                    key: key,
                                    name: key
                                });
                                break;
                        }
                    }
                }
                if (iconName.length > 0) {
                    var name;
                    var key;
                    for (var i = 0, l = iconName.length; i < l; i++) {
                        name = iconName[i].name;
                        key = iconName[i].key;
                        this._iconList.push(name);
                        this._featureTitle[name] = feature[key].title[name] || feature[key].title;
                        if (feature[key].icon) {
                            this._featureIcon[name] = feature[key].icon[name] || feature[key].icon;
                        }
                        if (feature[key].color) {
                            this._featureColor[name] = feature[key].color[name] || feature[key].color;
                        }
                        if (feature[key].option) {
                            this._featureOption[name] = feature[key].option[name] || feature[key].option;
                        }
                    }
                    this._itemGroupLocation = this._getItemGroupLocation();

                    this._buildBackground();
                    this._buildItem();

                    for (var i = 0, l = this.shapeList.length; i < l; i++) {
                        this.zr.addShape(this.shapeList[i]);
                    }
                    if (this._iconShapeMap['mark']) {
                        this._iconDisable(this._iconShapeMap['markUndo']);
                        this._iconDisable(this._iconShapeMap['markClear']);
                    }
                    if (this._iconShapeMap['dataZoomReset'] && this._zoomQueue.length === 0) {
                        this._iconDisable(this._iconShapeMap['dataZoomReset']);
                    }
                }
            },

            /**
             * 构建所有图例元素
             */
            _buildItem: function() {
                var toolboxOption = this.option.toolbox;
                var iconLength = this._iconList.length;
                var lastX = this._itemGroupLocation.x;
                var lastY = this._itemGroupLocation.y;
                var itemSize = toolboxOption.itemSize;
                var itemGap = toolboxOption.itemGap;
                var itemShape;

                var color = toolboxOption.color instanceof Array ? toolboxOption.color : [toolboxOption.color];

                var textFont = this.getFont(toolboxOption.textStyle);
                var textPosition;
                var textAlign;
                var textBaseline;
                if (toolboxOption.orient === 'horizontal') {
                    textPosition = this._itemGroupLocation.y / this.zr.getHeight() < 0.5 ? 'bottom' : 'top';
                    textAlign = this._itemGroupLocation.x / this.zr.getWidth() < 0.5 ? 'left' : 'right';
                    textBaseline = this._itemGroupLocation.y / this.zr.getHeight() < 0.5 ? 'top' : 'bottom';
                } else {
                    textPosition = this._itemGroupLocation.x / this.zr.getWidth() < 0.5 ? 'right' : 'left';
                }

                this._iconShapeMap = {};
                var self = this;

                for (var i = 0; i < iconLength; i++) {
                    // 图形
                    itemShape = {
                        type: 'icon',
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        style: {
                            x: lastX,
                            y: lastY,
                            width: itemSize,
                            height: itemSize,
                            iconType: this._iconList[i],
                            lineWidth: 1,
                            strokeColor: this._featureColor[this._iconList[i]] || color[i % color.length],
                            brushType: 'stroke'
                        },
                        highlightStyle: {
                            lineWidth: 1,
                            text: toolboxOption.showTitle ? this._featureTitle[this._iconList[i]] : undefined,
                            textFont: textFont,
                            textPosition: textPosition,
                            strokeColor: this._featureColor[this._iconList[i]] || color[i % color.length]
                        },
                        hoverable: true,
                        clickable: true
                    };

                    if (this._featureIcon[this._iconList[i]]) {
                        itemShape.style.image = this._featureIcon[this._iconList[i]].replace(
                            new RegExp('^image:\\/\\/'), ''
                        );
                        itemShape.style.opacity = 0.8;
                        itemShape.highlightStyle.opacity = 1;
                        itemShape.type = 'image';
                    }

                    if (toolboxOption.orient === 'horizontal') {
                        // 修正左对齐第一个或右对齐最后一个
                        if (i === 0 && textAlign === 'left') {
                            itemShape.highlightStyle.textPosition = 'specific';
                            itemShape.highlightStyle.textAlign = textAlign;
                            itemShape.highlightStyle.textBaseline = textBaseline;
                            itemShape.highlightStyle.textX = lastX;
                            itemShape.highlightStyle.textY = textBaseline === 'top' ? lastY + itemSize + 10 : lastY - 10;
                        }
                        if (i === iconLength - 1 && textAlign === 'right') {
                            itemShape.highlightStyle.textPosition = 'specific';
                            itemShape.highlightStyle.textAlign = textAlign;
                            itemShape.highlightStyle.textBaseline = textBaseline;
                            itemShape.highlightStyle.textX = lastX + itemSize;
                            itemShape.highlightStyle.textY = textBaseline === 'top' ? lastY + itemSize + 10 : lastY - 10;
                        }
                    }

                    switch (this._iconList[i]) {
                        case 'mark':
                            itemShape.onclick = self._onMark;
                            break;
                        case 'markUndo':
                            itemShape.onclick = self._onMarkUndo;
                            break;
                        case 'markClear':
                            itemShape.onclick = self._onMarkClear;
                            break;
                        case 'dataZoom':
                            itemShape.onclick = self._onDataZoom;
                            break;
                        case 'dataZoomReset':
                            itemShape.onclick = self._onDataZoomReset;
                            break;
                        case 'dataView':
                            if (!this._dataView) {
                                var DataView = require('./dataView');
                                this._dataView = new DataView(
                                    this.ecTheme, this.messageCenter, this.zr, this.option, this.myChart
                                );
                            }
                            itemShape.onclick = self._onDataView;
                            break;
                        case 'restore':
                            itemShape.onclick = self._onRestore;
                            break;
                        case 'saveAsImage':
                            itemShape.onclick = self._onSaveAsImage;
                            break;
                        default:
                            if (this._iconList[i].match('Chart')) {
                                itemShape._name = this._iconList[i].replace('Chart', '');
                                itemShape.onclick = self._onMagicType;
                            } else {
                                itemShape.onclick = self._onCustomHandler;
                            }
                            break;
                    }

                    if (itemShape.type === 'icon') {
                        itemShape = new IconShape(itemShape);
                    } else if (itemShape.type === 'image') {
                        itemShape = new ImageShape(itemShape);
                    }
                    this.shapeList.push(itemShape);
                    this._iconShapeMap[this._iconList[i]] = itemShape;

                    if (toolboxOption.orient === 'horizontal') {
                        lastX += itemSize + itemGap;
                    } else {
                        lastY += itemSize + itemGap;
                    }
                }
            },

            _buildBackground: function() {
                var toolboxOption = this.option.toolbox;
                var padding = this.reformCssArray(this.option.toolbox.padding);

                this.shapeList.push(new RectangleShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this._itemGroupLocation.x - padding[3],
                        y: this._itemGroupLocation.y - padding[0],
                        width: this._itemGroupLocation.width + padding[3] + padding[1],
                        height: this._itemGroupLocation.height + padding[0] + padding[2],
                        brushType: toolboxOption.borderWidth === 0 ? 'fill' : 'both',
                        color: toolboxOption.backgroundColor,
                        strokeColor: toolboxOption.borderColor,
                        lineWidth: toolboxOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算图例实体的位置坐标
             */
            _getItemGroupLocation: function() {
                var toolboxOption = this.option.toolbox;
                var padding = this.reformCssArray(this.option.toolbox.padding);
                var iconLength = this._iconList.length;
                var itemGap = toolboxOption.itemGap;
                var itemSize = toolboxOption.itemSize;
                var totalWidth = 0;
                var totalHeight = 0;

                if (toolboxOption.orient === 'horizontal') {
                    // 水平布局，计算总宽度，别忘减去最后一个的itemGap
                    totalWidth = (itemSize + itemGap) * iconLength - itemGap;
                    totalHeight = itemSize;
                } else {
                    // 垂直布局，计算总高度
                    totalHeight = (itemSize + itemGap) * iconLength - itemGap;
                    totalWidth = itemSize;
                }

                var x;
                var zrWidth = this.zr.getWidth();
                switch (toolboxOption.x) {
                    case 'center':
                        x = Math.floor((zrWidth - totalWidth) / 2);
                        break;
                    case 'left':
                        x = padding[3] + toolboxOption.borderWidth;
                        break;
                    case 'right':
                        x = zrWidth - totalWidth - padding[1] - toolboxOption.borderWidth;
                        break;
                    default:
                        x = toolboxOption.x - 0;
                        x = isNaN(x) ? 0 : x;
                        break;
                }

                var y;
                var zrHeight = this.zr.getHeight();
                switch (toolboxOption.y) {
                    case 'top':
                        y = padding[0] + toolboxOption.borderWidth;
                        break;
                    case 'bottom':
                        y = zrHeight - totalHeight - padding[2] - toolboxOption.borderWidth;
                        break;
                    case 'center':
                        y = Math.floor((zrHeight - totalHeight) / 2);
                        break;
                    default:
                        y = toolboxOption.y - 0;
                        y = isNaN(y) ? 0 : y;
                        break;
                }

                return {
                    x: x,
                    y: y,
                    width: totalWidth,
                    height: totalHeight
                };
            },

            __onmousemove: function(param) {
                if (this._marking) {
                    this._markShape.style.xEnd = zrEvent.getX(param.event);
                    this._markShape.style.yEnd = zrEvent.getY(param.event);
                    this.zr.addHoverShape(this._markShape);
                }
                if (this._zooming) {
                    this._zoomShape.style.width =
                        zrEvent.getX(param.event) - this._zoomShape.style.x;
                    this._zoomShape.style.height =
                        zrEvent.getY(param.event) - this._zoomShape.style.y;
                    this.zr.addHoverShape(this._zoomShape);
                    this.dom.style.cursor = 'crosshair';
                    zrEvent.stop(param.event);
                }
                if (this._zoomStart && (this.dom.style.cursor != 'pointer' && this.dom.style.cursor != 'move')) {
                    this.dom.style.cursor = 'crosshair';
                }
            },

            __onmousedown: function(param) {
                if (param.target) {
                    return;
                }
                this._zooming = true;
                var x = zrEvent.getX(param.event);
                var y = zrEvent.getY(param.event);
                var zoomOption = this.option.dataZoom || {};
                this._zoomShape = new RectangleShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: x,
                        y: y,
                        width: 1,
                        height: 1,
                        brushType: 'both'
                    },
                    highlightStyle: {
                        lineWidth: 2,
                        color: zoomOption.fillerColor || ecConfig.dataZoom.fillerColor,
                        strokeColor: zoomOption.handleColor || ecConfig.dataZoom.handleColor,
                        brushType: 'both'
                    }
                });
                this.zr.addHoverShape(this._zoomShape);
                return true; // 阻塞全局事件
            },

            __onmouseup: function( /*param*/ ) {
                if (!this._zoomShape || Math.abs(this._zoomShape.style.width) < 10 || Math.abs(this._zoomShape.style.height) < 10) {
                    this._zooming = false;
                    return true;
                }
                if (this._zooming && this.component.dataZoom) {
                    this._zooming = false;

                    var zoom = this.component.dataZoom.rectZoom(this._zoomShape.style);
                    if (zoom) {
                        this._zoomQueue.push({
                            start: zoom.start,
                            end: zoom.end,
                            start2: zoom.start2,
                            end2: zoom.end2
                        });
                        this._iconEnable(this._iconShapeMap['dataZoomReset']);
                        this.zr.refreshNextFrame();
                    }
                }
                return true; // 阻塞全局事件
            },

            __onclick: function(param) {
                if (param.target) {
                    return;
                }
                if (this._marking) {
                    this._marking = false;
                    this._markShapeList.push(this._markShape);
                    this._iconEnable(this._iconShapeMap['markUndo']);
                    this._iconEnable(this._iconShapeMap['markClear']);
                    this.zr.addShape(this._markShape);
                    this.zr.refreshNextFrame();
                } else if (this._markStart) {
                    this._marking = true;
                    var x = zrEvent.getX(param.event);
                    var y = zrEvent.getY(param.event);
                    this._markShape = new LineShape({
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        style: {
                            xStart: x,
                            yStart: y,
                            xEnd: x,
                            yEnd: y,
                            lineWidth: this.query(
                                this.option,
                                'toolbox.feature.mark.lineStyle.width'
                            ),
                            strokeColor: this.query(
                                this.option,
                                'toolbox.feature.mark.lineStyle.color'
                            ),
                            lineType: this.query(
                                this.option,
                                'toolbox.feature.mark.lineStyle.type'
                            )
                        }
                    });
                    this.zr.addHoverShape(this._markShape);
                }
            },

            __onMark: function(param) {
                var target = param.target;
                if (this._marking || this._markStart) {
                    // 取消
                    this._resetMark();
                    this.zr.refreshNextFrame();
                } else {
                    // 启用Mark
                    this._resetZoom(); // mark与dataZoom互斥

                    this.zr.modShape(target.id, {
                        style: {
                            strokeColor: this._enableColor
                        }
                    });
                    this.zr.refreshNextFrame();
                    this._markStart = true;
                    var self = this;
                    setTimeout(function() {
                        self.zr && self.zr.on(zrConfig.EVENT.CLICK, self._onclick) && self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                    }, 10);
                }
                return true; // 阻塞全局事件
            },

            __onMarkUndo: function() {
                if (this._marking) {
                    this._marking = false;
                } else {
                    var len = this._markShapeList.length;
                    if (len >= 1) {
                        var target = this._markShapeList[len - 1];
                        this.zr.delShape(target.id);
                        this.zr.refreshNextFrame();
                        this._markShapeList.pop();
                        if (len === 1) {
                            this._iconDisable(this._iconShapeMap['markUndo']);
                            this._iconDisable(this._iconShapeMap['markClear']);
                        }
                    }
                }
                return true;
            },

            __onMarkClear: function() {
                if (this._marking) {
                    this._marking = false;
                }
                var len = this._markShapeList.length;
                if (len > 0) {
                    while (len--) {
                        this.zr.delShape(this._markShapeList.pop().id);
                    }
                    this._iconDisable(this._iconShapeMap['markUndo']);
                    this._iconDisable(this._iconShapeMap['markClear']);
                    this.zr.refreshNextFrame();
                }
                return true;
            },

            __onDataZoom: function(param) {
                var target = param.target;
                if (this._zooming || this._zoomStart) {
                    // 取消
                    this._resetZoom();
                    this.zr.refreshNextFrame();
                    this.dom.style.cursor = 'default';
                } else {
                    // 启用Zoom
                    this._resetMark(); // mark与dataZoom互斥

                    this.zr.modShape(target.id, {
                        style: {
                            strokeColor: this._enableColor
                        }
                    });
                    this.zr.refreshNextFrame();
                    this._zoomStart = true;
                    var self = this;
                    setTimeout(function() {
                        self.zr && self.zr.on(zrConfig.EVENT.MOUSEDOWN, self._onmousedown) && self.zr.on(zrConfig.EVENT.MOUSEUP, self._onmouseup) && self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                    }, 10);

                    this.dom.style.cursor = 'crosshair';
                }
                return true; // 阻塞全局事件
            },

            __onDataZoomReset: function() {
                if (this._zooming) {
                    this._zooming = false;
                }
                this._zoomQueue.pop();
                //console.log(this._zoomQueue)
                if (this._zoomQueue.length > 0) {
                    this.component.dataZoom.absoluteZoom(
                        this._zoomQueue[this._zoomQueue.length - 1]
                    );
                } else {
                    this.component.dataZoom.rectZoom();
                    this._iconDisable(this._iconShapeMap['dataZoomReset']);
                    this.zr.refreshNextFrame();
                }

                return true;
            },

            _resetMark: function() {
                this._marking = false;
                if (this._markStart) {
                    this._markStart = false;
                    if (this._iconShapeMap['mark']) {
                        // 还原图标为未生效状态
                        this.zr.modShape(
                            this._iconShapeMap['mark'].id, {
                                style: {
                                    strokeColor: this._iconShapeMap['mark']
                                        .highlightStyle
                                        .strokeColor
                                }
                            }
                        );
                    }

                    this.zr.un(zrConfig.EVENT.CLICK, this._onclick);
                    this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
                }
            },

            _resetZoom: function() {
                this._zooming = false;
                if (this._zoomStart) {
                    this._zoomStart = false;
                    if (this._iconShapeMap['dataZoom']) {
                        // 还原图标为未生效状态
                        this.zr.modShape(
                            this._iconShapeMap['dataZoom'].id, {
                                style: {
                                    strokeColor: this._iconShapeMap['dataZoom']
                                        .highlightStyle
                                        .strokeColor
                                }
                            }
                        );
                    }

                    this.zr.un(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
                    this.zr.un(zrConfig.EVENT.MOUSEUP, this._onmouseup);
                    this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
                }
            },

            _iconDisable: function(target) {
                if (target.type != 'image') {
                    this.zr.modShape(target.id, {
                        hoverable: false,
                        clickable: false,
                        style: {
                            strokeColor: this._disableColor
                        }
                    });
                } else {
                    this.zr.modShape(target.id, {
                        hoverable: false,
                        clickable: false,
                        style: {
                            opacity: 0.3
                        }
                    });
                }
            },

            _iconEnable: function(target) {
                if (target.type != 'image') {
                    this.zr.modShape(target.id, {
                        hoverable: true,
                        clickable: true,
                        style: {
                            strokeColor: target.highlightStyle.strokeColor
                        }
                    });
                } else {
                    this.zr.modShape(target.id, {
                        hoverable: true,
                        clickable: true,
                        style: {
                            opacity: 0.8
                        }
                    });
                }
            },

            __onDataView: function() {
                this._dataView.show(this.option);
                return true;
            },

            __onRestore: function() {
                this._resetMark();
                this._resetZoom();
                this.messageCenter.dispatch(ecConfig.EVENT.RESTORE, null, null, this.myChart);
                return true;
            },

            __onSaveAsImage: function() {
                var saveOption = this.option.toolbox.feature.saveAsImage;
                var imgType = saveOption.type || 'png';
                if (imgType != 'png' && imgType != 'jpeg') {
                    imgType = 'png';
                }

                var image;
                if (!this.myChart.isConnected()) {
                    image = this.zr.toDataURL(
                        'image/' + imgType,
                        this.option.backgroundColor && this.option.backgroundColor.replace(' ', '') === 'rgba(0,0,0,0)' ? '#fff' : this.option.backgroundColor
                    );
                } else {
                    image = this.myChart.getConnectedDataURL(imgType);
                }

                var downloadDiv = document.createElement('div');
                downloadDiv.id = '__echarts_download_wrap__';
                downloadDiv.style.cssText = 'position:fixed;' + 'z-index:99999;' + 'display:block;' + 'top:0;left:0;' + 'background-color:rgba(33,33,33,0.5);' + 'text-align:center;' + 'width:100%;' + 'height:100%;' + 'line-height:' + document.documentElement.clientHeight + 'px;';

                var downloadLink = document.createElement('a');
                //downloadLink.onclick = _saveImageForIE;
                downloadLink.href = image;
                downloadLink.setAttribute(
                    'download', (saveOption.name ? saveOption.name : (this.option.title && (this.option.title.text || this.option.title.subtext)) ? (this.option.title.text || this.option.title.subtext) : 'ECharts') + '.' + imgType
                );
                downloadLink.innerHTML = '<img style="vertical-align:middle" src="' + image + '" title="' + ((!!window.ActiveXObject || 'ActiveXObject' in window) ? '右键->图片另存为' : (saveOption.lang ? saveOption.lang[0] : '点击保存')) + '"/>';

                downloadDiv.appendChild(downloadLink);
                document.body.appendChild(downloadDiv);
                downloadLink = null;
                downloadDiv = null;

                setTimeout(function() {
                    var _d = document.getElementById('__echarts_download_wrap__');
                    if (_d) {
                        _d.onclick = function() {
                            var d = document.getElementById(
                                '__echarts_download_wrap__'
                            );
                            d.onclick = null;
                            d.innerHTML = '';
                            document.body.removeChild(d);
                            d = null;
                        };
                        _d = null;
                    }
                }, 500);

                /*
                function _saveImageForIE() {
                    window.win = window.open(image);
                    win.document.execCommand("SaveAs");
                    win.close()
                }
                */
                return;
            },

            __onMagicType: function(param) {
                this._resetMark();
                var itemName = param.target._name;
                if (!this._magicType[itemName]) {
                    // 启用
                    this._magicType[itemName] = true;
                    // 折柱互斥
                    if (itemName === ecConfig.CHART_TYPE_LINE) {
                        this._magicType[ecConfig.CHART_TYPE_BAR] = false;
                    } else if (itemName === ecConfig.CHART_TYPE_BAR) {
                        this._magicType[ecConfig.CHART_TYPE_LINE] = false;
                    }
                    // 饼图漏斗互斥
                    if (itemName === ecConfig.CHART_TYPE_PIE) {
                        this._magicType[ecConfig.CHART_TYPE_FUNNEL] = false;
                    } else if (itemName === ecConfig.CHART_TYPE_FUNNEL) {
                        this._magicType[ecConfig.CHART_TYPE_PIE] = false;
                    }
                    // 力导和弦互斥
                    if (itemName === ecConfig.CHART_TYPE_FORCE) {
                        this._magicType[ecConfig.CHART_TYPE_CHORD] = false;
                    } else if (itemName === ecConfig.CHART_TYPE_CHORD) {
                        this._magicType[ecConfig.CHART_TYPE_FORCE] = false;
                    }
                    // 堆积平铺互斥
                    if (itemName === _MAGICTYPE_STACK) {
                        this._magicType[_MAGICTYPE_TILED] = false;
                    } else if (itemName === _MAGICTYPE_TILED) {
                        this._magicType[_MAGICTYPE_STACK] = false;
                    }
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.MAGIC_TYPE_CHANGED,
                        param.event, {
                            magicType: this._magicType
                        },
                        this.myChart
                    );
                }

                return true;
            },

            setMagicType: function(magicType) {
                this._resetMark();
                this._magicType = magicType;

                !this._isSilence && this.messageCenter.dispatch(
                    ecConfig.EVENT.MAGIC_TYPE_CHANGED,
                    null, {
                        magicType: this._magicType
                    },
                    this.myChart
                );
            },

            // 用户自定义扩展toolbox方法
            __onCustomHandler: function(param) {
                var target = param.target.style.iconType;
                var featureHandler = this.option.toolbox.feature[target].onclick;
                if (typeof featureHandler === 'function') {
                    featureHandler.call(this, this.option);
                }
            },

            // 重置备份还原状态等
            reset: function(newOption, isRestore) {
                isRestore && this.clear();

                if (this.query(newOption, 'toolbox.show') && this.query(newOption, 'toolbox.feature.magicType.show')) {
                    var magicType = newOption.toolbox.feature.magicType.type;
                    var len = magicType.length;
                    this._magicMap = {}; // 标识可控类型
                    while (len--) {
                        this._magicMap[magicType[len]] = true;
                    }

                    len = newOption.series.length;
                    var oriType; // 备份还原可控类型
                    var axis;
                    while (len--) {
                        oriType = newOption.series[len].type;
                        if (this._magicMap[oriType]) {
                            axis = newOption.xAxis instanceof Array ? newOption.xAxis[newOption.series[len].xAxisIndex || 0] : newOption.xAxis;
                            if (axis && (axis.type || 'category') === 'category') {
                                axis.__boundaryGap = axis.boundaryGap != null ? axis.boundaryGap : true;
                            }
                            axis = newOption.yAxis instanceof Array ? newOption.yAxis[newOption.series[len].yAxisIndex || 0] : newOption.yAxis;
                            if (axis && axis.type === 'category') {
                                axis.__boundaryGap = axis.boundaryGap != null ? axis.boundaryGap : true;
                            }
                            newOption.series[len].__type = oriType;
                            // 避免不同类型图表类型的样式污染
                            newOption.series[len].__itemStyle = zrUtil.clone(
                                newOption.series[len].itemStyle || {}
                            );
                        }

                        if (this._magicMap[_MAGICTYPE_STACK] || this._magicMap[_MAGICTYPE_TILED]) {
                            newOption.series[len].__stack = newOption.series[len].stack;
                        }
                    }
                }

                this._magicType = isRestore ? {} : (this._magicType || {});
                for (var itemName in this._magicType) {
                    if (this._magicType[itemName]) {
                        this.option = newOption;
                        this.getMagicOption();
                        break;
                    }
                }

                // 框选缩放
                var zoomOption = newOption.dataZoom;
                if (zoomOption && zoomOption.show) {
                    var start = zoomOption.start != null && zoomOption.start >= 0 && zoomOption.start <= 100 ? zoomOption.start : 0;
                    var end = zoomOption.end != null && zoomOption.end >= 0 && zoomOption.end <= 100 ? zoomOption.end : 100;
                    if (start > end) {
                        // 大小颠倒自动翻转
                        start = start + end;
                        end = start - end;
                        start = start - end;
                    }
                    this._zoomQueue = [{
                        start: start,
                        end: end,
                        start2: 0,
                        end2: 100
                    }];
                } else {
                    this._zoomQueue = [];
                }
            },

            getMagicOption: function() {
                var axis;
                var chartType;
                if (this._magicType[ecConfig.CHART_TYPE_LINE] || this._magicType[ecConfig.CHART_TYPE_BAR]) {
                    // 图表类型有折柱切换
                    var boundaryGap = this._magicType[ecConfig.CHART_TYPE_LINE] ? false : true;
                    for (var i = 0, l = this.option.series.length; i < l; i++) {
                        chartType = this.option.series[i].type;
                        if (chartType == ecConfig.CHART_TYPE_LINE || chartType == ecConfig.CHART_TYPE_BAR) {
                            axis = this.option.xAxis instanceof Array ? this.option.xAxis[this.option.series[i].xAxisIndex || 0] : this.option.xAxis;
                            if (axis && (axis.type || 'category') === 'category') {
                                axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                            }
                            axis = this.option.yAxis instanceof Array ? this.option.yAxis[this.option.series[i].yAxisIndex || 0] : this.option.yAxis;
                            if (axis && axis.type === 'category') {
                                axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                            }
                        }
                    }

                    this._defaultMagic(ecConfig.CHART_TYPE_LINE, ecConfig.CHART_TYPE_BAR);
                }
                this._defaultMagic(ecConfig.CHART_TYPE_CHORD, ecConfig.CHART_TYPE_FORCE);
                this._defaultMagic(ecConfig.CHART_TYPE_PIE, ecConfig.CHART_TYPE_FUNNEL);

                if (this._magicType[_MAGICTYPE_STACK] || this._magicType[_MAGICTYPE_TILED]) {
                    // 有堆积平铺切换
                    for (var i = 0, l = this.option.series.length; i < l; i++) {
                        if (this._magicType[_MAGICTYPE_STACK]) {
                            // 启用堆积
                            this.option.series[i].stack = '_ECHARTS_STACK_KENER_2014_';
                            chartType = _MAGICTYPE_STACK;
                        } else if (this._magicType[_MAGICTYPE_TILED]) {
                            // 启用平铺
                            this.option.series[i].stack = null;
                            chartType = _MAGICTYPE_TILED;
                        }
                        if (this._featureOption[chartType + 'Chart']) {
                            zrUtil.merge(
                                this.option.series[i],
                                this._featureOption[chartType + 'Chart'] || {},
                                true
                            );
                        }
                    }
                }
                return this.option;
            },

            _defaultMagic: function(cType1, cType2) {
                if (this._magicType[cType1] || this._magicType[cType2]) {
                    for (var i = 0, l = this.option.series.length; i < l; i++) {
                        var chartType = this.option.series[i].type;
                        if (chartType == cType1 || chartType == cType2) {
                            this.option.series[i].type = this._magicType[cType1] ? cType1 : cType2;
                            // 避免不同类型图表类型的样式污染
                            this.option.series[i].itemStyle = zrUtil.clone(
                                this.option.series[i].__itemStyle
                            );
                            chartType = this.option.series[i].type;
                            if (this._featureOption[chartType + 'Chart']) {
                                zrUtil.merge(
                                    this.option.series[i],
                                    this._featureOption[chartType + 'Chart'] || {},
                                    true
                                );
                            }
                        }
                    }
                }
            },

            silence: function(s) {
                this._isSilence = s;
            },

            resize: function() {
                this._resetMark();
                this.clear();
                if (this.option && this.option.toolbox && this.option.toolbox.show) {
                    this._buildShape();
                }
                if (this._dataView) {
                    this._dataView.resize();
                }
            },

            hideDataView: function() {
                if (this._dataView) {
                    this._dataView.hide();
                }
            },

            clear: function(notMark) {
                if (this.zr) {
                    this.zr.delShape(this.shapeList);
                    this.shapeList = [];

                    if (!notMark) {
                        this.zr.delShape(this._markShapeList);
                        this._markShapeList = [];
                    }
                }
            },

            /**
             * 释放后实例不可用
             */
            onbeforDispose: function() {
                if (this._dataView) {
                    this._dataView.dispose();
                    this._dataView = null;
                }
                this._markShapeList = null;
            },

            /**
             * 刷新
             */
            refresh: function(newOption) {
                if (newOption) {
                    this._resetMark();
                    this._resetZoom();

                    newOption.toolbox = this.reformOption(newOption.toolbox);
                    this.option = newOption;

                    this.clear(true);

                    if (newOption.toolbox.show) {
                        this._buildShape();
                    }

                    this.hideDataView();
                }
            }
        };

        zrUtil.inherits(Toolbox, Base);

        require('../component').define('toolbox', Toolbox);

        return Toolbox;
    });
    define('echarts/component/title', ['require', './base', 'zrender/shape/Text', 'zrender/shape/Rectangle', '../config', 'zrender/tool/util', 'zrender/tool/area', 'zrender/tool/color', '../component'], function(require) {
        var Base = require('./base');

        // 图形依赖
        var TextShape = require('zrender/shape/Text');
        var RectangleShape = require('zrender/shape/Rectangle');

        var ecConfig = require('../config');
        // 图表标题
        ecConfig.title = {
            zlevel: 0, // 一级层叠
            z: 6, // 二级层叠
            show: true,
            text: '',
            // link: null,             // 超链接跳转
            // target: null,           // 仅支持self | blank
            subtext: '',
            // sublink: null,          // 超链接跳转
            // subtarget: null,        // 仅支持self | blank
            x: 'left', // 水平安放位置，默认为左对齐，可选为：
            // 'center' ¦ 'left' ¦ 'right'
            // ¦ {number}（x坐标，单位px）
            y: 'top', // 垂直安放位置，默认为全图顶端，可选为：
            // 'top' ¦ 'bottom' ¦ 'center'
            // ¦ {number}（y坐标，单位px）
            //textAlign: null          // 水平对齐方式，默认根据x设置自动调整
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc', // 标题边框颜色
            borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框）
            padding: 5, // 标题内边距，单位px，默认各方向内边距为5，
            // 接受数组分别设定上右下左边距，同css
            itemGap: 5, // 主副标题纵向间隔，单位px，默认为10，
            textStyle: {
                fontSize: 18,
                fontWeight: 'bolder',
                color: '#333' // 主标题文字颜色
            },
            subtextStyle: {
                color: '#aaa' // 副标题文字颜色
            }
        };

        var zrUtil = require('zrender/tool/util');
        var zrArea = require('zrender/tool/area');
        var zrColor = require('zrender/tool/color');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         */
        function Title(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.refresh(option);
        }

        Title.prototype = {
            type: ecConfig.COMPONENT_TYPE_TITLE,
            _buildShape: function() {
                if (!this.titleOption.show) {
                    return;
                }
                // 标题元素组的位置参数，通过计算所得x, y, width, height
                this._itemGroupLocation = this._getItemGroupLocation();

                this._buildBackground();
                this._buildItem();

                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            /**
             * 构建所有标题元素
             */
            _buildItem: function() {
                var text = this.titleOption.text;
                var link = this.titleOption.link;
                var target = this.titleOption.target;
                var subtext = this.titleOption.subtext;
                var sublink = this.titleOption.sublink;
                var subtarget = this.titleOption.subtarget;
                var font = this.getFont(this.titleOption.textStyle);
                var subfont = this.getFont(this.titleOption.subtextStyle);

                var x = this._itemGroupLocation.x;
                var y = this._itemGroupLocation.y;
                var width = this._itemGroupLocation.width;
                var height = this._itemGroupLocation.height;

                var textShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        y: y,
                        color: this.titleOption.textStyle.color,
                        text: text,
                        textFont: font,
                        textBaseline: 'top'
                    },
                    highlightStyle: {
                        color: zrColor.lift(this.titleOption.textStyle.color, 1),
                        brushType: 'fill'
                    },
                    hoverable: false
                };
                if (link) {
                    textShape.hoverable = true;
                    textShape.clickable = true;
                    textShape.onclick = function() {
                        if (!target || target != 'self') {
                            window.open(link);
                        } else {
                            window.location = link;
                        }
                    };
                }

                var subtextShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        y: y + height,
                        color: this.titleOption.subtextStyle.color,
                        text: subtext,
                        textFont: subfont,
                        textBaseline: 'bottom'
                    },
                    highlightStyle: {
                        color: zrColor.lift(this.titleOption.subtextStyle.color, 1),
                        brushType: 'fill'
                    },
                    hoverable: false
                };
                if (sublink) {
                    subtextShape.hoverable = true;
                    subtextShape.clickable = true;
                    subtextShape.onclick = function() {
                        if (!subtarget || subtarget != 'self') {
                            window.open(sublink);
                        } else {
                            window.location = sublink;
                        }
                    };
                }

                switch (this.titleOption.x) {
                    case 'center':
                        textShape.style.x = subtextShape.style.x = x + width / 2;
                        textShape.style.textAlign = subtextShape.style.textAlign = 'center';
                        break;
                    case 'left':
                        textShape.style.x = subtextShape.style.x = x;
                        textShape.style.textAlign = subtextShape.style.textAlign = 'left';
                        break;
                    case 'right':
                        textShape.style.x = subtextShape.style.x = x + width;
                        textShape.style.textAlign = subtextShape.style.textAlign = 'right';
                        break;
                    default:
                        x = this.titleOption.x - 0;
                        x = isNaN(x) ? 0 : x;
                        textShape.style.x = subtextShape.style.x = x;
                        break;
                }

                if (this.titleOption.textAlign) {
                    textShape.style.textAlign = subtextShape.style.textAlign = this.titleOption.textAlign;
                }

                this.shapeList.push(new TextShape(textShape));
                subtext !== '' && this.shapeList.push(new TextShape(subtextShape));
            },

            _buildBackground: function() {
                var padding = this.reformCssArray(this.titleOption.padding);

                this.shapeList.push(new RectangleShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this._itemGroupLocation.x - padding[3],
                        y: this._itemGroupLocation.y - padding[0],
                        width: this._itemGroupLocation.width + padding[3] + padding[1],
                        height: this._itemGroupLocation.height + padding[0] + padding[2],
                        brushType: this.titleOption.borderWidth === 0 ? 'fill' : 'both',
                        color: this.titleOption.backgroundColor,
                        strokeColor: this.titleOption.borderColor,
                        lineWidth: this.titleOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算标题实体的位置坐标
             */
            _getItemGroupLocation: function() {
                var padding = this.reformCssArray(this.titleOption.padding);
                var text = this.titleOption.text;
                var subtext = this.titleOption.subtext;
                var font = this.getFont(this.titleOption.textStyle);
                var subfont = this.getFont(this.titleOption.subtextStyle);

                var totalWidth = Math.max(
                    zrArea.getTextWidth(text, font),
                    zrArea.getTextWidth(subtext, subfont)
                );
                var totalHeight = zrArea.getTextHeight(text, font) + (subtext === '' ? 0 : (this.titleOption.itemGap + zrArea.getTextHeight(subtext, subfont)));

                var x;
                var zrWidth = this.zr.getWidth();
                switch (this.titleOption.x) {
                    case 'center':
                        x = Math.floor((zrWidth - totalWidth) / 2);
                        break;
                    case 'left':
                        x = padding[3] + this.titleOption.borderWidth;
                        break;
                    case 'right':
                        x = zrWidth - totalWidth - padding[1] - this.titleOption.borderWidth;
                        break;
                    default:
                        x = this.titleOption.x - 0;
                        x = isNaN(x) ? 0 : x;
                        break;
                }

                var y;
                var zrHeight = this.zr.getHeight();
                switch (this.titleOption.y) {
                    case 'top':
                        y = padding[0] + this.titleOption.borderWidth;
                        break;
                    case 'bottom':
                        y = zrHeight - totalHeight - padding[2] - this.titleOption.borderWidth;
                        break;
                    case 'center':
                        y = Math.floor((zrHeight - totalHeight) / 2);
                        break;
                    default:
                        y = this.titleOption.y - 0;
                        y = isNaN(y) ? 0 : y;
                        break;
                }

                return {
                    x: x,
                    y: y,
                    width: totalWidth,
                    height: totalHeight
                };
            },

            /**
             * 刷新
             */
            refresh: function(newOption) {
                if (newOption) {
                    this.option = newOption;

                    this.option.title = this.reformOption(this.option.title);
                    this.titleOption = this.option.title;
                    this.titleOption.textStyle = this.getTextStyle(
                        this.titleOption.textStyle
                    );
                    this.titleOption.subtextStyle = this.getTextStyle(
                        this.titleOption.subtextStyle
                    );
                }

                this.clear();
                this._buildShape();
            }
        };

        zrUtil.inherits(Title, Base);

        require('../component').define('title', Title);

        return Title;
    });
    define('echarts/util/ecData', [], function() {
        /**
         * 打包私有数据
         *
         * @param {shape} shape 修改目标
         * @param {Object} series
         * @param {number} seriesIndex
         * @param {number | Object} data
         * @param {number} dataIndex
         * @param {*=} special
         * @param {*=} special2
         */
        function pack(
            shape, series, seriesIndex, data, dataIndex, name, special, special2
        ) {
            var value;
            if (typeof data != 'undefined') {
                value = data.value == null ? data : data.value;
            }

            shape._echartsData = {
                '_series': series,
                '_seriesIndex': seriesIndex,
                '_data': data,
                '_dataIndex': dataIndex,
                '_name': name,
                '_value': value,
                '_special': special,
                '_special2': special2
            };
            return shape._echartsData;
        }

        /**
         * 从私有数据中获取特定项
         * @param {shape} shape
         * @param {string} key
         */
        function get(shape, key) {
            var data = shape._echartsData;
            if (!key) {
                return data;
            }

            switch (key) {
                case 'series':
                case 'seriesIndex':
                case 'data':
                case 'dataIndex':
                case 'name':
                case 'value':
                case 'special':
                case 'special2':
                    return data && data['_' + key];
            }

            return null;
        }

        /**
         * 修改私有数据中获取特定项
         * @param {shape} shape
         * @param {string} key
         * @param {*} value
         */
        function set(shape, key, value) {
            shape._echartsData = shape._echartsData || {};
            switch (key) {
                case 'series': // 当前系列值
                case 'seriesIndex': // 系列数组位置索引
                case 'data': // 当前数据值
                case 'dataIndex': // 数据数组位置索引
                case 'name':
                case 'value':
                case 'special':
                case 'special2':
                    shape._echartsData['_' + key] = value;
                    break;
            }
        }

        /**
         * 私有数据克隆，把source拷贝到target上
         * @param {shape} source 源
         * @param {shape} target 目标
         */
        function clone(source, target) {
            target._echartsData = {
                '_series': source._echartsData._series,
                '_seriesIndex': source._echartsData._seriesIndex,
                '_data': source._echartsData._data,
                '_dataIndex': source._echartsData._dataIndex,
                '_name': source._echartsData._name,
                '_value': source._echartsData._value,
                '_special': source._echartsData._special,
                '_special2': source._echartsData._special2
            };
        }

        return {
            pack: pack,
            set: set,
            get: get,
            clone: clone
        };
    });
    define('echarts/chart', [], function( /*require*/ ) { //chart
        var self = {};

        var _chartLibrary = {}; //echart图表库

        /**
         * 定义图形实现
         * @param {Object} name
         * @param {Object} clazz 图形实现
         */
        self.define = function(name, clazz) {
            _chartLibrary[name] = clazz;
            return self;
        };

        /**
         * 获取图形实现
         * @param {Object} name
         */
        self.get = function(name) {
            return _chartLibrary[name];
        };

        return self;
    });
    define('echarts/component/timeline', ['require', './base', 'zrender/shape/Rectangle', '../util/shape/Icon', '../util/shape/Chain', '../config', 'zrender/tool/util', 'zrender/tool/area', 'zrender/tool/event', '../component'], function(require) {
        var Base = require('./base');

        // 图形依赖
        var RectangleShape = require('zrender/shape/Rectangle');
        var IconShape = require('../util/shape/Icon');
        var ChainShape = require('../util/shape/Chain');

        var ecConfig = require('../config');
        ecConfig.timeline = {
            zlevel: 0, // 一级层叠
            z: 4, // 二级层叠
            show: true,
            type: 'time', // 模式是时间类型，支持 number
            notMerge: false,
            realtime: true,
            x: 80,
            // y: {number},
            x2: 80,
            y2: 0,
            // width: {totalWidth} - x - x2,
            height: 50,
            backgroundColor: 'rgba(0,0,0,0)', // 时间轴背景颜色
            borderColor: '#ccc', // 时间轴边框颜色
            borderWidth: 0, // 时间轴边框线宽，单位px，默认为0（无边框）
            padding: 5, // 时间轴内边距，单位px，默认各方向内边距为5，
            controlPosition: 'left', // 'right' | 'none'
            autoPlay: false,
            loop: true,
            playInterval: 2000, // 播放时间间隔，单位ms
            lineStyle: {
                width: 1,
                color: '#666',
                type: 'dashed'
            },
            label: { // 文本标签
                show: true,
                interval: 'auto',
                rotate: 0,
                // formatter: null,
                textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                    color: '#333'
                }
            },
            checkpointStyle: {
                symbol: 'auto',
                symbolSize: 'auto',
                color: 'auto',
                borderColor: 'auto',
                borderWidth: 'auto',
                label: { // 文本标签
                    show: false,
                    textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: 'auto'
                    }
                }
            },
            controlStyle: {
                itemSize: 15,
                itemGap: 5,
                normal: {
                    color: '#333'
                },
                emphasis: {
                    color: '#1e90ff'
                }
            },
            symbol: 'emptyDiamond',
            symbolSize: 4,
            currentIndex: 0
                // data: []
        };

        var zrUtil = require('zrender/tool/util');
        var zrArea = require('zrender/tool/area');
        var zrEvent = require('zrender/tool/event');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         */
        function Timeline(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            self._onclick = function(param) {
                return self.__onclick(param);
            };
            self._ondrift = function(dx, dy) {
                return self.__ondrift(this, dx, dy);
            };
            self._ondragend = function() {
                return self.__ondragend();
            };
            self._setCurrentOption = function() {
                var timelineOption = self.timelineOption;
                self.currentIndex %= timelineOption.data.length;
                // console.log(self.currentIndex);
                var curOption = self.options[self.currentIndex] || {};
                self.myChart._setOption(curOption, timelineOption.notMerge, true);

                self.messageCenter.dispatch(
                    ecConfig.EVENT.TIMELINE_CHANGED,
                    null, {
                        currentIndex: self.currentIndex,
                        data: timelineOption.data[self.currentIndex].name != null ? timelineOption.data[self.currentIndex].name : timelineOption.data[self.currentIndex]
                    },
                    self.myChart
                );
            };
            self._onFrame = function() {
                self._setCurrentOption();
                self._syncHandleShape();

                if (self.timelineOption.autoPlay) {
                    self.playTicket = setTimeout(
                        function() {
                            self.currentIndex += 1;
                            if (!self.timelineOption.loop && self.currentIndex >= self.timelineOption.data.length) {
                                self.currentIndex = self.timelineOption.data.length - 1;
                                self.stop();
                                return;
                            }
                            self._onFrame();
                        },
                        self.timelineOption.playInterval
                    );
                }
            };

            this.setTheme(false);
            this.options = this.option.options;
            this.currentIndex = this.timelineOption.currentIndex % this.timelineOption.data.length;

            if (!this.timelineOption.notMerge && this.currentIndex !== 0) {
                /*
                for (var i = 1, l = this.timelineOption.data.length; i < l; i++) {
                    this.options[i] = zrUtil.merge(
                        this.options[i], this.options[i - 1]
                    );
                }
                */
                this.options[this.currentIndex] = zrUtil.merge(
                    this.options[this.currentIndex], this.options[0]
                );
            }

            if (this.timelineOption.show) {
                this._buildShape();
                this._syncHandleShape();
            }

            this._setCurrentOption();

            if (this.timelineOption.autoPlay) {
                var self = this;
                this.playTicket = setTimeout(
                    function() {
                        self.play();
                    },
                    this.ecTheme.animationDuration != null ? this.ecTheme.animationDuration : ecConfig.animationDuration
                );
            }
        }

        Timeline.prototype = {
            type: ecConfig.COMPONENT_TYPE_TIMELINE,
            _buildShape: function() {
                // 位置参数，通过计算所得x, y, width, height
                this._location = this._getLocation();
                this._buildBackground();
                this._buildControl();
                this._chainPoint = this._getChainPoint();
                if (this.timelineOption.label.show) {
                    // 标签显示的挑选间隔
                    var interval = this._getInterval();
                    for (var i = 0, len = this._chainPoint.length; i < len; i += interval) {
                        this._chainPoint[i].showLabel = true;
                    }
                }
                this._buildChain();
                this._buildHandle();

                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            /**
             * 根据选项计算实体的位置坐标
             */
            _getLocation: function() {
                var timelineOption = this.timelineOption;
                var padding = this.reformCssArray(this.timelineOption.padding);

                // 水平布局
                var zrWidth = this.zr.getWidth();
                var x = this.parsePercent(timelineOption.x, zrWidth);
                var x2 = this.parsePercent(timelineOption.x2, zrWidth);
                var width;
                if (timelineOption.width == null) {
                    width = zrWidth - x - x2;
                    x2 = zrWidth - x2;
                } else {
                    width = this.parsePercent(timelineOption.width, zrWidth);
                    x2 = x + width;
                }

                var zrHeight = this.zr.getHeight();
                var height = this.parsePercent(timelineOption.height, zrHeight);
                var y;
                var y2;
                if (timelineOption.y != null) {
                    y = this.parsePercent(timelineOption.y, zrHeight);
                    y2 = y + height;
                } else {
                    y2 = zrHeight - this.parsePercent(timelineOption.y2, zrHeight);
                    y = y2 - height;
                }

                return {
                    x: x + padding[3],
                    y: y + padding[0],
                    x2: x2 - padding[1],
                    y2: y2 - padding[2],
                    width: width - padding[1] - padding[3],
                    height: height - padding[0] - padding[2]
                };
            },

            _getReformedLabel: function(idx) {
                var timelineOption = this.timelineOption;
                var data = timelineOption.data[idx].name != null ? timelineOption.data[idx].name : timelineOption.data[idx];
                var formatter = timelineOption.data[idx].formatter || timelineOption.label.formatter;
                if (formatter) {
                    if (typeof formatter === 'function') {
                        data = formatter.call(this.myChart, data);
                    } else if (typeof formatter === 'string') {
                        data = formatter.replace('{value}', data);
                    }
                }
                return data;
            },

            /**
             * 计算标签显示挑选间隔
             */
            _getInterval: function() {
                var chainPoint = this._chainPoint;
                var timelineOption = this.timelineOption;
                var interval = timelineOption.label.interval;
                if (interval === 'auto') {
                    // 麻烦的自适应计算
                    var fontSize = timelineOption.label.textStyle.fontSize;
                    var data = timelineOption.data;
                    var dataLength = timelineOption.data.length;

                    // 横向
                    if (dataLength > 3) {
                        var isEnough = false;
                        var labelSpace;
                        var labelSize;
                        interval = 0;
                        while (!isEnough && interval < dataLength) {
                            interval++;
                            isEnough = true;
                            for (var i = interval; i < dataLength; i += interval) {
                                labelSpace = chainPoint[i].x - chainPoint[i - interval].x;
                                if (timelineOption.label.rotate !== 0) {
                                    // 有旋转
                                    labelSize = fontSize;
                                } else if (data[i].textStyle) {
                                    labelSize = zrArea.getTextWidth(
                                        chainPoint[i].name,
                                        chainPoint[i].textFont
                                    );
                                } else {
                                    // 不定义data级特殊文本样式，用fontSize优化getTextWidth
                                    var label = chainPoint[i].name + '';
                                    var wLen = (label.match(/\w/g) || '').length;
                                    var oLen = label.length - wLen;
                                    labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                                }

                                if (labelSpace < labelSize) {
                                    // 放不下，中断循环让interval++
                                    isEnough = false;
                                    break;
                                }
                            }
                        }
                    } else {
                        // 少于3个则全部显示
                        interval = 1;
                    }
                } else {
                    // 用户自定义间隔
                    interval = interval - 0 + 1;
                }

                return interval;
            },

            /**
             * 根据选项计算时间链条上的坐标及symbolList
             */
            _getChainPoint: function() {
                var timelineOption = this.timelineOption;
                var symbol = timelineOption.symbol.toLowerCase();
                var symbolSize = timelineOption.symbolSize;
                var rotate = timelineOption.label.rotate;
                var textStyle = timelineOption.label.textStyle;
                var textFont = this.getFont(textStyle);
                var dataTextStyle;
                var data = timelineOption.data;
                var x = this._location.x;
                var y = this._location.y + this._location.height / 4 * 3;
                var width = this._location.x2 - this._location.x;
                var len = data.length;

                function _getName(i) {
                    return (data[i].name != null ? data[i].name : data[i] + '');
                }
                var xList = [];
                if (len > 1) {
                    var boundaryGap = width / len;
                    boundaryGap = boundaryGap > 50 ? 50 : (boundaryGap < 20 ? 5 : boundaryGap);
                    width -= boundaryGap * 2;
                    if (timelineOption.type === 'number') {
                        // 平均分布
                        for (var i = 0; i < len; i++) {
                            xList.push(x + boundaryGap + width / (len - 1) * i);
                        }
                    } else {
                        // 时间比例
                        xList[0] = new Date(_getName(0).replace(/-/g, '/'));
                        xList[len - 1] = new Date(_getName(len - 1).replace(/-/g, '/')) - xList[0];
                        for (var i = 1; i < len; i++) {
                            xList[i] = x + boundaryGap + width * (new Date(_getName(i).replace(/-/g, '/')) - xList[0]) / xList[len - 1];
                        }
                        xList[0] = x + boundaryGap;
                    }
                } else {
                    xList.push(x + width / 2);
                }

                var list = [];
                var curSymbol;
                var n;
                var isEmpty;
                var textAlign;
                var rotation;
                for (var i = 0; i < len; i++) {
                    x = xList[i];
                    curSymbol = (data[i].symbol && data[i].symbol.toLowerCase()) || symbol;
                    if (curSymbol.match('empty')) {
                        curSymbol = curSymbol.replace('empty', '');
                        isEmpty = true;
                    } else {
                        isEmpty = false;
                    }
                    if (curSymbol.match('star')) {
                        n = (curSymbol.replace('star', '') - 0) || 5;
                        curSymbol = 'star';
                    }

                    dataTextStyle = data[i].textStyle ? zrUtil.merge(data[i].textStyle || {}, textStyle) : textStyle;

                    textAlign = dataTextStyle.align || 'center';

                    if (rotate) {
                        textAlign = rotate > 0 ? 'right' : 'left';
                        rotation = [rotate * Math.PI / 180, x, y - 5];
                    } else {
                        rotation = false;
                    }

                    list.push({
                        x: x,
                        n: n,
                        isEmpty: isEmpty,
                        symbol: curSymbol,
                        symbolSize: data[i].symbolSize || symbolSize,
                        color: data[i].color,
                        borderColor: data[i].borderColor,
                        borderWidth: data[i].borderWidth,
                        name: this._getReformedLabel(i),
                        textColor: dataTextStyle.color,
                        textAlign: textAlign,
                        textBaseline: dataTextStyle.baseline || 'middle',
                        textX: x,
                        textY: y - (rotate ? 5 : 0),
                        textFont: data[i].textStyle ? this.getFont(dataTextStyle) : textFont,
                        rotation: rotation,
                        showLabel: false
                    });
                }

                return list;
            },

            _buildBackground: function() {
                var timelineOption = this.timelineOption;
                var padding = this.reformCssArray(this.timelineOption.padding);
                var width = this._location.width;
                var height = this._location.height;

                if (timelineOption.borderWidth !== 0 || timelineOption.backgroundColor.replace(/\s/g, '') != 'rgba(0,0,0,0)') {
                    // 背景
                    this.shapeList.push(new RectangleShape({
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            x: this._location.x - padding[3],
                            y: this._location.y - padding[0],
                            width: width + padding[1] + padding[3],
                            height: height + padding[0] + padding[2],
                            brushType: timelineOption.borderWidth === 0 ? 'fill' : 'both',
                            color: timelineOption.backgroundColor,
                            strokeColor: timelineOption.borderColor,
                            lineWidth: timelineOption.borderWidth
                        }
                    }));
                }
            },

            _buildControl: function() {
                var self = this;
                var timelineOption = this.timelineOption;
                var lineStyle = timelineOption.lineStyle;
                var controlStyle = timelineOption.controlStyle;
                if (timelineOption.controlPosition === 'none') {
                    return;
                }
                var iconSize = controlStyle.itemSize;
                var iconGap = controlStyle.itemGap;
                var x;
                if (timelineOption.controlPosition === 'left') {
                    x = this._location.x;
                    this._location.x += (iconSize + iconGap) * 3;
                } else {
                    x = this._location.x2 - ((iconSize + iconGap) * 3 - iconGap);
                    this._location.x2 -= (iconSize + iconGap) * 3;
                }

                var y = this._location.y;
                var iconStyle = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    style: {
                        iconType: 'timelineControl',
                        symbol: 'last',
                        x: x,
                        y: y,
                        width: iconSize,
                        height: iconSize,
                        brushType: 'stroke',
                        color: controlStyle.normal.color,
                        strokeColor: controlStyle.normal.color,
                        lineWidth: lineStyle.width
                    },
                    highlightStyle: {
                        color: controlStyle.emphasis.color,
                        strokeColor: controlStyle.emphasis.color,
                        lineWidth: lineStyle.width + 1
                    },
                    clickable: true
                };

                this._ctrLastShape = new IconShape(iconStyle);
                this._ctrLastShape.onclick = function() {
                    self.last();
                };
                this.shapeList.push(this._ctrLastShape);

                x += iconSize + iconGap;
                this._ctrPlayShape = new IconShape(zrUtil.clone(iconStyle));
                this._ctrPlayShape.style.brushType = 'fill';
                this._ctrPlayShape.style.symbol = 'play';
                this._ctrPlayShape.style.status = this.timelineOption.autoPlay ? 'playing' : 'stop';
                this._ctrPlayShape.style.x = x;
                this._ctrPlayShape.onclick = function() {
                    if (self._ctrPlayShape.style.status === 'stop') {
                        self.play();
                    } else {
                        self.stop();
                    }
                };
                this.shapeList.push(this._ctrPlayShape);

                x += iconSize + iconGap;
                this._ctrNextShape = new IconShape(zrUtil.clone(iconStyle));
                this._ctrNextShape.style.symbol = 'next';
                this._ctrNextShape.style.x = x;
                this._ctrNextShape.onclick = function() {
                    self.next();
                };
                this.shapeList.push(this._ctrNextShape);
            },

            /**
             * 构建时间轴
             */
            _buildChain: function() {
                var timelineOption = this.timelineOption;
                var lineStyle = timelineOption.lineStyle;
                this._timelineShae = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: this._location.x,
                        y: this.subPixelOptimize(this._location.y, lineStyle.width),
                        width: this._location.x2 - this._location.x,
                        height: this._location.height,
                        chainPoint: this._chainPoint,
                        brushType: 'both',
                        strokeColor: lineStyle.color,
                        lineWidth: lineStyle.width,
                        lineType: lineStyle.type
                    },
                    hoverable: false,
                    clickable: true,
                    onclick: this._onclick
                };

                this._timelineShae = new ChainShape(this._timelineShae);
                this.shapeList.push(this._timelineShae);
            },

            /**
             * 构建拖拽手柄
             */
            _buildHandle: function() {
                var curPoint = this._chainPoint[this.currentIndex];
                var symbolSize = curPoint.symbolSize + 1;
                symbolSize = symbolSize < 5 ? 5 : symbolSize;

                this._handleShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    hoverable: false,
                    draggable: true,
                    style: {
                        iconType: 'diamond',
                        n: curPoint.n,
                        x: curPoint.x - symbolSize,
                        y: this._location.y + this._location.height / 4 - symbolSize,
                        width: symbolSize * 2,
                        height: symbolSize * 2,
                        brushType: 'both',
                        textPosition: 'specific',
                        textX: curPoint.x,
                        textY: this._location.y - this._location.height / 4,
                        textAlign: 'center',
                        textBaseline: 'middle'
                    },
                    highlightStyle: {},
                    ondrift: this._ondrift,
                    ondragend: this._ondragend
                };

                this._handleShape = new IconShape(this._handleShape);
                this.shapeList.push(this._handleShape);
            },

            /**
             * 同步拖拽图形样式 
             */
            _syncHandleShape: function() {
                if (!this.timelineOption.show) {
                    return;
                }

                var timelineOption = this.timelineOption;
                var cpStyle = timelineOption.checkpointStyle;
                var curPoint = this._chainPoint[this.currentIndex];

                this._handleShape.style.text = cpStyle.label.show ? curPoint.name : '';
                this._handleShape.style.textFont = curPoint.textFont;

                this._handleShape.style.n = curPoint.n;
                if (cpStyle.symbol === 'auto') {
                    this._handleShape.style.iconType = curPoint.symbol != 'none' ? curPoint.symbol : 'diamond';
                } else {
                    this._handleShape.style.iconType = cpStyle.symbol;
                    if (cpStyle.symbol.match('star')) {
                        this._handleShape.style.n = (cpStyle.symbol.replace('star', '') - 0) || 5;
                        this._handleShape.style.iconType = 'star';
                    }
                }

                var symbolSize;
                if (cpStyle.symbolSize === 'auto') {
                    symbolSize = curPoint.symbolSize + 2;
                    symbolSize = symbolSize < 5 ? 5 : symbolSize;
                } else {
                    symbolSize = cpStyle.symbolSize - 0;
                }

                this._handleShape.style.color = cpStyle.color === 'auto' ? (curPoint.color ? curPoint.color : timelineOption.controlStyle.emphasis.color) : cpStyle.color;
                this._handleShape.style.textColor = cpStyle.label.textStyle.color === 'auto' ? this._handleShape.style.color : cpStyle.label.textStyle.color;
                this._handleShape.highlightStyle.strokeColor =
                    this._handleShape.style.strokeColor = cpStyle.borderColor === 'auto' ? (curPoint.borderColor ? curPoint.borderColor : '#fff') : cpStyle.borderColor;
                this._handleShape.style.lineWidth = cpStyle.borderWidth === 'auto' ? (curPoint.borderWidth ? curPoint.borderWidth : 0) : (cpStyle.borderWidth - 0);
                this._handleShape.highlightStyle.lineWidth = this._handleShape.style.lineWidth + 1;

                this.zr.animate(this._handleShape.id, 'style')
                    .when(
                        500, {
                            x: curPoint.x - symbolSize,
                            textX: curPoint.x,
                            y: this._location.y + this._location.height / 4 - symbolSize,
                            width: symbolSize * 2,
                            height: symbolSize * 2
                        }
                    )
                    .start('ExponentialOut');
            },

            _findChainIndex: function(x) {
                var chainPoint = this._chainPoint;
                var len = chainPoint.length;
                if (x <= chainPoint[0].x) {
                    return 0;
                } else if (x >= chainPoint[len - 1].x) {
                    return len - 1;
                }
                for (var i = 0; i < len - 1; i++) {
                    if (x >= chainPoint[i].x && x <= chainPoint[i + 1].x) {
                        // catch you！
                        return (Math.abs(x - chainPoint[i].x) < Math.abs(x - chainPoint[i + 1].x)) ? i : (i + 1);
                    }
                }
            },

            __onclick: function(param) {
                var x = zrEvent.getX(param.event);
                var newIndex = this._findChainIndex(x);
                if (newIndex === this.currentIndex) {
                    return true; // 啥事都没发生
                }

                this.currentIndex = newIndex;
                this.timelineOption.autoPlay && this.stop(); // 停止自动播放
                clearTimeout(this.playTicket);
                this._onFrame();
            },

            /**
             * 拖拽范围控制
             */
            __ondrift: function(shape, dx) {
                this.timelineOption.autoPlay && this.stop(); // 停止自动播放

                var chainPoint = this._chainPoint;
                var len = chainPoint.length;
                var newIndex;
                if (shape.style.x + dx <= chainPoint[0].x - chainPoint[0].symbolSize) {
                    shape.style.x = chainPoint[0].x - chainPoint[0].symbolSize;
                    newIndex = 0;
                } else if (shape.style.x + dx >= chainPoint[len - 1].x - chainPoint[len - 1].symbolSize) {
                    shape.style.x = chainPoint[len - 1].x - chainPoint[len - 1].symbolSize;
                    newIndex = len - 1;
                } else {
                    shape.style.x += dx;
                    newIndex = this._findChainIndex(shape.style.x);
                }
                var curPoint = chainPoint[newIndex];
                var symbolSize = curPoint.symbolSize + 2;
                shape.style.iconType = curPoint.symbol;
                shape.style.n = curPoint.n;
                shape.style.textX = shape.style.x + symbolSize / 2;
                shape.style.y = this._location.y + this._location.height / 4 - symbolSize;
                shape.style.width = symbolSize * 2;
                shape.style.height = symbolSize * 2;
                shape.style.text = curPoint.name;

                //console.log(newIndex)
                if (newIndex === this.currentIndex) {
                    return true; // 啥事都没发生
                }

                this.currentIndex = newIndex;
                if (this.timelineOption.realtime) {
                    clearTimeout(this.playTicket);
                    var self = this;
                    this.playTicket = setTimeout(function() {
                        self._setCurrentOption();
                    }, 200);
                }

                return true;
            },

            __ondragend: function() {
                this.isDragend = true;
            },

            /**
             * 数据项被拖拽出去
             */
            ondragend: function(param, status) {
                if (!this.isDragend || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }!this.timelineOption.realtime && this._setCurrentOption();

                // 别status = {}赋值啊！！
                status.dragOut = true;
                status.dragIn = true;
                status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍
                // 处理完拖拽事件后复位
                this.isDragend = false;
                this._syncHandleShape();
                return;
            },

            last: function() {
                this.timelineOption.autoPlay && this.stop(); // 停止自动播放

                this.currentIndex -= 1;
                if (this.currentIndex < 0) {
                    this.currentIndex = this.timelineOption.data.length - 1;
                }
                this._onFrame();

                return this.currentIndex;
            },

            next: function() {
                this.timelineOption.autoPlay && this.stop(); // 停止自动播放

                this.currentIndex += 1;
                if (this.currentIndex >= this.timelineOption.data.length) {
                    this.currentIndex = 0;
                }
                this._onFrame();

                return this.currentIndex;
            },

            play: function(targetIndex, autoPlay) {
                if (this._ctrPlayShape && this._ctrPlayShape.style.status != 'playing') {
                    this._ctrPlayShape.style.status = 'playing';
                    this.zr.modShape(this._ctrPlayShape.id);
                    this.zr.refreshNextFrame();
                }


                this.timelineOption.autoPlay = autoPlay != null ? autoPlay : true;

                if (!this.timelineOption.autoPlay) {
                    clearTimeout(this.playTicket);
                }

                this.currentIndex = targetIndex != null ? targetIndex : (this.currentIndex + 1);
                if (this.currentIndex >= this.timelineOption.data.length) {
                    this.currentIndex = 0;
                }
                this._onFrame();

                return this.currentIndex;
            },

            stop: function() {
                if (this._ctrPlayShape && this._ctrPlayShape.style.status != 'stop') {
                    this._ctrPlayShape.style.status = 'stop';
                    this.zr.modShape(this._ctrPlayShape.id);
                    this.zr.refreshNextFrame();
                }

                this.timelineOption.autoPlay = false;

                clearTimeout(this.playTicket);

                return this.currentIndex;
            },

            /**
             * 避免dataZoom带来两次refresh，不设refresh接口，resize重复一下buildshape逻辑 
             */
            resize: function() {
                if (this.timelineOption.show) {
                    this.clear();
                    this._buildShape();
                    this._syncHandleShape();
                }
            },

            setTheme: function(needRefresh) {
                this.timelineOption = this.reformOption(zrUtil.clone(this.option.timeline));
                // 通用字体设置
                this.timelineOption.label.textStyle = this.getTextStyle(
                    this.timelineOption.label.textStyle
                );
                this.timelineOption.checkpointStyle.label.textStyle = this.getTextStyle(
                    this.timelineOption.checkpointStyle.label.textStyle
                );
                if (!this.myChart.canvasSupported) {
                    // 不支持Canvas的强制关闭实时动画
                    this.timelineOption.realtime = false;
                }

                if (this.timelineOption.show && needRefresh) {
                    this.clear();
                    this._buildShape();
                    this._syncHandleShape();
                }
            },

            /**
             * 释放后实例不可用，重载基类方法
             */
            onbeforDispose: function() {
                clearTimeout(this.playTicket);
            }
        };

        function timelineControl(ctx, style) {
            var lineWidth = 2; //style.lineWidth;
            var x = style.x + lineWidth;
            var y = style.y + lineWidth + 2;
            var width = style.width - lineWidth;
            var height = style.height - lineWidth;


            var symbol = style.symbol;
            if (symbol === 'last') {
                ctx.moveTo(x + width - 2, y + height / 3);
                ctx.lineTo(x + width - 2, y);
                ctx.lineTo(x + 2, y + height / 2);
                ctx.lineTo(x + width - 2, y + height);
                ctx.lineTo(x + width - 2, y + height / 3 * 2);
                ctx.moveTo(x, y);
                ctx.lineTo(x, y);
            } else if (symbol === 'next') {
                ctx.moveTo(x + 2, y + height / 3);
                ctx.lineTo(x + 2, y);
                ctx.lineTo(x + width - 2, y + height / 2);
                ctx.lineTo(x + 2, y + height);
                ctx.lineTo(x + 2, y + height / 3 * 2);
                ctx.moveTo(x, y);
                ctx.lineTo(x, y);
            } else if (symbol === 'play') {
                if (style.status === 'stop') {
                    ctx.moveTo(x + 2, y);
                    ctx.lineTo(x + width - 2, y + height / 2);
                    ctx.lineTo(x + 2, y + height);
                    ctx.lineTo(x + 2, y);
                } else {
                    var delta = style.brushType === 'both' ? 2 : 3;
                    ctx.rect(x + 2, y, delta, height);
                    ctx.rect(x + width - delta - 2, y, delta, height);
                }
            } else if (symbol.match('image')) {
                var imageLocation = '';
                imageLocation = symbol.replace(
                    new RegExp('^image:\\/\\/'), ''
                );
                symbol = IconShape.prototype.iconLibrary.image;
                symbol(ctx, {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    image: imageLocation
                });
            }
        }
        IconShape.prototype.iconLibrary['timelineControl'] = timelineControl;

        zrUtil.inherits(Timeline, Base);

        require('../component').define('timeline', Timeline);

        return Timeline;
    });
    define('echarts/component/legend', ['require', './base', 'zrender/shape/Text', 'zrender/shape/Rectangle', 'zrender/shape/Sector', '../util/shape/Icon', '../util/shape/Candle', '../config', 'zrender/tool/util', 'zrender/tool/area', '../component'], function(require) {
        var Base = require('./base');

        // 图形依赖
        var TextShape = require('zrender/shape/Text');
        var RectangleShape = require('zrender/shape/Rectangle');
        var SectorShape = require('zrender/shape/Sector');
        //var BeziercurveShape = require('zrender/shape/Beziercurve');
        var IconShape = require('../util/shape/Icon');
        var CandleShape = require('../util/shape/Candle');

        var ecConfig = require('../config');
        // 图例
        ecConfig.legend = {
            zlevel: 0, // 一级层叠
            z: 4, // 二级层叠
            show: true,
            orient: 'horizontal', // 布局方式，默认为水平布局，可选为：
            // 'horizontal' ¦ 'vertical'
            x: 'center', // 水平安放位置，默认为全图居中，可选为：
            // 'center' ¦ 'left' ¦ 'right'
            // ¦ {number}（x坐标，单位px）
            y: 'top', // 垂直安放位置，默认为全图顶端，可选为：
            // 'top' ¦ 'bottom' ¦ 'center'
            // ¦ {number}（y坐标，单位px）
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc', // 图例边框颜色
            borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框）
            padding: 5, // 图例内边距，单位px，默认各方向内边距为5，
            // 接受数组分别设定上右下左边距，同css
            itemGap: 10, // 各个item之间的间隔，单位px，默认为10，
            // 横向布局时为水平间隔，纵向布局时为纵向间隔
            itemWidth: 20, // 图例图形宽度
            itemHeight: 14, // 图例图形高度
            textStyle: {
                color: '#333' // 图例文字颜色
            },
            selectedMode: true // 选择模式，默认开启图例开关
                // selected: null,         // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
                // data: [],               // 图例内容（详见legend.data，数组中每一项代表一个item
        };

        var zrUtil = require('zrender/tool/util');
        var zrArea = require('zrender/tool/area');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         */
        function Legend(ecTheme, messageCenter, zr, option, myChart) {
            if (!this.query(option, 'legend.data')) {
                console.error('option.legend.data has not been defined.');
                return;
            }

            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            self._legendSelected = function(param) {
                self.__legendSelected(param);
            };
            self._dispatchHoverLink = function(param) {
                return self.__dispatchHoverLink(param);
            };

            this._colorIndex = 0;
            this._colorMap = {};
            this._selectedMap = {};
            this._hasDataMap = {};

            this.refresh(option);
        }

        Legend.prototype = {
            type: ecConfig.COMPONENT_TYPE_LEGEND,
            _buildShape: function() {
                if (!this.legendOption.show) {
                    return;
                }
                // 图例元素组的位置参数，通过计算所得x, y, width, height
                this._itemGroupLocation = this._getItemGroupLocation();

                this._buildBackground();
                this._buildItem();

                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            /**
             * 构建所有图例元素
             */
            _buildItem: function() {
                var data = this.legendOption.data;
                var dataLength = data.length;
                var itemName;
                var itemType;
                var itemShape;
                var textShape;
                var textStyle = this.legendOption.textStyle;
                var dataTextStyle;
                var dataFont;
                var formattedName;

                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();
                var lastX = this._itemGroupLocation.x;
                var lastY = this._itemGroupLocation.y;
                var itemWidth = this.legendOption.itemWidth;
                var itemHeight = this.legendOption.itemHeight;
                var itemGap = this.legendOption.itemGap;
                var color;

                if (this.legendOption.orient === 'vertical' && this.legendOption.x === 'right') {
                    lastX = this._itemGroupLocation.x + this._itemGroupLocation.width - itemWidth;
                }

                for (var i = 0; i < dataLength; i++) {
                    dataTextStyle = zrUtil.merge(
                        data[i].textStyle || {},
                        textStyle
                    );
                    dataFont = this.getFont(dataTextStyle);

                    itemName = this._getName(data[i]);
                    formattedName = this._getFormatterName(itemName);
                    if (itemName === '') { // 别帮我代码优化
                        if (this.legendOption.orient === 'horizontal') {
                            lastX = this._itemGroupLocation.x;
                            lastY += itemHeight + itemGap;
                        } else {
                            this.legendOption.x === 'right' ? lastX -= this._itemGroupLocation.maxWidth + itemGap : lastX += this._itemGroupLocation.maxWidth + itemGap;
                            lastY = this._itemGroupLocation.y;
                        }
                        continue;
                    }
                    itemType = data[i].icon || this._getSomethingByName(itemName).type;

                    color = this.getColor(itemName);

                    if (this.legendOption.orient === 'horizontal') {
                        if (zrWidth - lastX < 200 // 最后200px做分行预判
                            && (itemWidth + 5 + zrArea.getTextWidth(formattedName, dataFont)
                                // 分行的最后一个不用算itemGap
                                + (i === dataLength - 1 || data[i + 1] === '' ? 0 : itemGap)
                            ) >= zrWidth - lastX
                        ) {
                            lastX = this._itemGroupLocation.x;
                            lastY += itemHeight + itemGap;
                        }
                    } else {
                        if (zrHeight - lastY < 200 // 最后200px做分行预判
                            && (itemHeight
                                // 分行的最后一个不用算itemGap
                                + (i === dataLength - 1 || data[i + 1] === '' ? 0 : itemGap)
                            ) >= zrHeight - lastY
                        ) {
                            this.legendOption.x === 'right' ? lastX -= this._itemGroupLocation.maxWidth + itemGap : lastX += this._itemGroupLocation.maxWidth + itemGap;
                            lastY = this._itemGroupLocation.y;
                        }
                    }

                    // 图形
                    itemShape = this._getItemShapeByType(
                        lastX, lastY,
                        itemWidth, itemHeight, (this._selectedMap[itemName] && this._hasDataMap[itemName] ? color : '#ccc'),
                        itemType,
                        color
                    );
                    itemShape._name = itemName;
                    itemShape = new IconShape(itemShape);

                    // 文字
                    textShape = {
                        // shape: 'text',
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        style: {
                            x: lastX + itemWidth + 5,
                            y: lastY + itemHeight / 2,
                            color: this._selectedMap[itemName] ? (dataTextStyle.color === 'auto' ? color : dataTextStyle.color) : '#ccc',
                            text: formattedName,
                            textFont: dataFont,
                            textBaseline: 'middle'
                        },
                        highlightStyle: {
                            color: color,
                            brushType: 'fill'
                        },
                        hoverable: !!this.legendOption.selectedMode,
                        clickable: !!this.legendOption.selectedMode
                    };

                    if (this.legendOption.orient === 'vertical' && this.legendOption.x === 'right') {
                        textShape.style.x -= (itemWidth + 10);
                        textShape.style.textAlign = 'right';
                    }

                    textShape._name = itemName;
                    textShape = new TextShape(textShape);

                    if (this.legendOption.selectedMode) {
                        itemShape.onclick = textShape.onclick = this._legendSelected;
                        itemShape.onmouseover = textShape.onmouseover = this._dispatchHoverLink;
                        itemShape.hoverConnect = textShape.id;
                        textShape.hoverConnect = itemShape.id;
                    }
                    this.shapeList.push(itemShape);
                    this.shapeList.push(textShape);

                    if (this.legendOption.orient === 'horizontal') {
                        lastX += itemWidth + 5 + zrArea.getTextWidth(formattedName, dataFont) + itemGap;
                    } else {
                        lastY += itemHeight + itemGap;
                    }
                }

                if (this.legendOption.orient === 'horizontal' && this.legendOption.x === 'center' && lastY != this._itemGroupLocation.y) {
                    // 多行橫排居中优化
                    this._mLineOptimize();
                }
            },

            _getName: function(data) {
                return typeof data.name != 'undefined' ? data.name : data;
            },

            _getFormatterName: function(itemName) {
                var formatter = this.legendOption.formatter;
                var formattedName;
                if (typeof formatter === 'function') {
                    formattedName = formatter.call(this.myChart, itemName);
                } else if (typeof formatter === 'string') {
                    formattedName = formatter.replace('{name}', itemName);
                } else {
                    formattedName = itemName;
                }
                return formattedName;
            },

            _getFormatterNameFromData: function(data) {
                var itemName = this._getName(data);
                return this._getFormatterName(itemName);
            },

            // 多行橫排居中优化
            _mLineOptimize: function() {
                var lineOffsetArray = []; // 每行宽度
                var lastX = this._itemGroupLocation.x;
                for (var i = 2, l = this.shapeList.length; i < l; i++) {
                    if (this.shapeList[i].style.x === lastX) {
                        lineOffsetArray.push(
                            (
                                this._itemGroupLocation.width - (
                                    this.shapeList[i - 1].style.x + zrArea.getTextWidth(
                                        this.shapeList[i - 1].style.text,
                                        this.shapeList[i - 1].style.textFont
                                    ) - lastX
                                )
                            ) / 2
                        );
                    } else if (i === l - 1) {
                        lineOffsetArray.push(
                            (
                                this._itemGroupLocation.width - (
                                    this.shapeList[i].style.x + zrArea.getTextWidth(
                                        this.shapeList[i].style.text,
                                        this.shapeList[i].style.textFont
                                    ) - lastX
                                )
                            ) / 2
                        );
                    }
                }
                var curLineIndex = -1;
                for (var i = 1, l = this.shapeList.length; i < l; i++) {
                    if (this.shapeList[i].style.x === lastX) {
                        curLineIndex++;
                    }
                    if (lineOffsetArray[curLineIndex] === 0) {
                        continue;
                    } else {
                        this.shapeList[i].style.x += lineOffsetArray[curLineIndex];
                    }
                }
            },

            _buildBackground: function() {
                var padding = this.reformCssArray(this.legendOption.padding);

                this.shapeList.push(new RectangleShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this._itemGroupLocation.x - padding[3],
                        y: this._itemGroupLocation.y - padding[0],
                        width: this._itemGroupLocation.width + padding[3] + padding[1],
                        height: this._itemGroupLocation.height + padding[0] + padding[2],
                        brushType: this.legendOption.borderWidth === 0 ? 'fill' : 'both',
                        color: this.legendOption.backgroundColor,
                        strokeColor: this.legendOption.borderColor,
                        lineWidth: this.legendOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算图例实体的位置坐标
             */
            _getItemGroupLocation: function() {
                var data = this.legendOption.data;
                var dataLength = data.length;
                var itemGap = this.legendOption.itemGap;
                var itemWidth = this.legendOption.itemWidth + 5; // 5px是图形和文字的间隔，不可配
                var itemHeight = this.legendOption.itemHeight;
                var textStyle = this.legendOption.textStyle;
                var font = this.getFont(textStyle);
                var totalWidth = 0;
                var totalHeight = 0;
                var padding = this.reformCssArray(this.legendOption.padding);
                var zrWidth = this.zr.getWidth() - padding[1] - padding[3];
                var zrHeight = this.zr.getHeight() - padding[0] - padding[2];

                var temp = 0; // 宽高计算，用于多行判断
                var maxWidth = 0; // 垂直布局有用
                if (this.legendOption.orient === 'horizontal') {
                    // 水平布局，计算总宽度
                    totalHeight = itemHeight;
                    for (var i = 0; i < dataLength; i++) {
                        if (this._getName(data[i]) === '') {
                            temp -= itemGap;
                            totalWidth = Math.max(totalWidth, temp);
                            totalHeight += itemHeight + itemGap;
                            temp = 0;
                            continue;
                        }
                        var tempTextWidth = zrArea.getTextWidth(
                            this._getFormatterNameFromData(data[i]),
                            data[i].textStyle ? this.getFont(zrUtil.merge(
                                data[i].textStyle || {},
                                textStyle
                            )) : font
                        );
                        if (temp + itemWidth + tempTextWidth + itemGap > zrWidth) {
                            // new line
                            temp -= itemGap; // 减去最后一个的itemGap
                            totalWidth = Math.max(totalWidth, temp);
                            totalHeight += itemHeight + itemGap;
                            temp = 0;
                        } else {
                            temp += itemWidth + tempTextWidth + itemGap;
                            totalWidth = Math.max(totalWidth, temp - itemGap);
                        }
                    }
                } else {
                    // 垂直布局，计算总高度
                    for (var i = 0; i < dataLength; i++) {
                        maxWidth = Math.max(
                            maxWidth,
                            zrArea.getTextWidth(
                                this._getFormatterNameFromData(data[i]),
                                data[i].textStyle ? this.getFont(zrUtil.merge(
                                    data[i].textStyle || {},
                                    textStyle
                                )) : font
                            )
                        );
                    }
                    maxWidth += itemWidth;
                    totalWidth = maxWidth;
                    for (var i = 0; i < dataLength; i++) {
                        if (this._getName(data[i]) === '') {
                            totalWidth += maxWidth + itemGap;
                            temp -= itemGap; // 减去最后一个的itemGap
                            totalHeight = Math.max(totalHeight, temp);
                            temp = 0;
                            continue;
                        }
                        if (temp + itemHeight + itemGap > zrHeight) {
                            // new line
                            totalWidth += maxWidth + itemGap;
                            temp -= itemGap; // 减去最后一个的itemGap
                            totalHeight = Math.max(totalHeight, temp);
                            temp = 0;
                        } else {
                            temp += itemHeight + itemGap;
                            totalHeight = Math.max(totalHeight, temp - itemGap);
                        }
                    }
                }

                zrWidth = this.zr.getWidth();
                zrHeight = this.zr.getHeight();
                var x;
                switch (this.legendOption.x) {
                    case 'center':
                        x = Math.floor((zrWidth - totalWidth) / 2);
                        break;
                    case 'left':
                        x = padding[3] + this.legendOption.borderWidth;
                        break;
                    case 'right':
                        x = zrWidth - totalWidth - padding[1] - padding[3] - this.legendOption.borderWidth * 2;
                        break;
                    default:
                        x = this.parsePercent(this.legendOption.x, zrWidth);
                        break;
                }

                var y;
                switch (this.legendOption.y) {
                    case 'top':
                        y = padding[0] + this.legendOption.borderWidth;
                        break;
                    case 'bottom':
                        y = zrHeight - totalHeight - padding[0] - padding[2] - this.legendOption.borderWidth * 2;
                        break;
                    case 'center':
                        y = Math.floor((zrHeight - totalHeight) / 2);
                        break;
                    default:
                        y = this.parsePercent(this.legendOption.y, zrHeight);
                        break;
                }

                return {
                    x: x,
                    y: y,
                    width: totalWidth,
                    height: totalHeight,
                    maxWidth: maxWidth
                };
            },

            /**
             * 根据名称返回series数据或data
             */
            _getSomethingByName: function(name) {
                var series = this.option.series;
                var data;
                for (var i = 0, l = series.length; i < l; i++) {
                    if (series[i].name === name) {
                        // 系列名称优先
                        return {
                            type: series[i].type,
                            series: series[i],
                            seriesIndex: i,
                            data: null,
                            dataIndex: -1
                        };
                    }

                    if (
                        series[i].type === ecConfig.CHART_TYPE_PIE || series[i].type === ecConfig.CHART_TYPE_RADAR || series[i].type === ecConfig.CHART_TYPE_CHORD || series[i].type === ecConfig.CHART_TYPE_FORCE || series[i].type === ecConfig.CHART_TYPE_FUNNEL || series[i].type === ecConfig.CHART_TYPE_TREEMAP
                    ) {
                        data = series[i].categories || series[i].data || series[i].nodes;

                        for (var j = 0, k = data.length; j < k; j++) {
                            if (data[j].name === name) {
                                return {
                                    type: series[i].type,
                                    series: series[i],
                                    seriesIndex: i,
                                    data: data[j],
                                    dataIndex: j
                                };
                            }
                        }
                    }
                }
                return {
                    type: 'bar',
                    series: null,
                    seriesIndex: -1,
                    data: null,
                    dataIndex: -1
                };
            },

            _getItemShapeByType: function(x, y, width, height, color, itemType, defaultColor) {
                var highlightColor = color === '#ccc' ? defaultColor : color;
                var itemShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        iconType: 'legendicon' + itemType,
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        color: color,
                        strokeColor: color,
                        lineWidth: 2
                    },
                    highlightStyle: {
                        color: highlightColor,
                        strokeColor: highlightColor,
                        lineWidth: 1
                    },
                    hoverable: this.legendOption.selectedMode,
                    clickable: this.legendOption.selectedMode
                };

                var imageLocation;
                if (itemType.match('image')) {
                    var imageLocation = itemType.replace(
                        new RegExp('^image:\\/\\/'), ''
                    );
                    itemType = 'image';
                }
                // 特殊设置
                switch (itemType) {
                    case 'line':
                        itemShape.style.brushType = 'stroke';
                        itemShape.highlightStyle.lineWidth = 3;
                        break;
                    case 'radar':
                    case 'venn':
                    case 'tree':
                    case 'treemap':
                    case 'scatter':
                        itemShape.highlightStyle.lineWidth = 3;
                        break;
                    case 'k':
                        itemShape.style.brushType = 'both';
                        itemShape.highlightStyle.lineWidth = 3;
                        itemShape.highlightStyle.color =
                            itemShape.style.color = this.deepQuery(
                                [this.ecTheme, ecConfig], 'k.itemStyle.normal.color'
                            ) || '#fff';
                        itemShape.style.strokeColor = color != '#ccc' ? (
                            this.deepQuery(
                                [this.ecTheme, ecConfig], 'k.itemStyle.normal.lineStyle.color'
                            ) || '#ff3200'
                        ) : color;
                        break;
                    case 'image':
                        itemShape.style.iconType = 'image';
                        itemShape.style.image = imageLocation;
                        if (color === '#ccc') {
                            itemShape.style.opacity = 0.5;
                        }
                        break;
                }
                return itemShape;
            },

            __legendSelected: function(param) {
                var itemName = param.target._name;
                if (this.legendOption.selectedMode === 'single') {
                    for (var k in this._selectedMap) {
                        this._selectedMap[k] = false;
                    }
                }
                this._selectedMap[itemName] = !this._selectedMap[itemName];
                this.messageCenter.dispatch(
                    ecConfig.EVENT.LEGEND_SELECTED,
                    param.event, {
                        selected: this._selectedMap,
                        target: itemName
                    },
                    this.myChart
                );
            },

            /**
             * 产生hover link事件 
             */
            __dispatchHoverLink: function(param) {
                this.messageCenter.dispatch(
                    ecConfig.EVENT.LEGEND_HOVERLINK,
                    param.event, {
                        target: param.target._name
                    },
                    this.myChart
                );
                return;
            },

            /**
             * 刷新
             */
            refresh: function(newOption) {
                if (newOption) {
                    this.option = newOption || this.option;
                    this.option.legend = this.reformOption(this.option.legend);
                    this.legendOption = this.option.legend;

                    var data = this.legendOption.data || [];
                    var itemName;
                    var something;
                    var color;
                    var queryTarget;
                    if (this.legendOption.selected) {
                        for (var k in this.legendOption.selected) {
                            this._selectedMap[k] = typeof this._selectedMap[k] != 'undefined' ? this._selectedMap[k] : this.legendOption.selected[k];
                        }
                    }
                    for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                        itemName = this._getName(data[i]);
                        if (itemName === '') {
                            continue;
                        }
                        something = this._getSomethingByName(itemName);
                        if (!something.series) {
                            this._hasDataMap[itemName] = false;
                        } else {
                            this._hasDataMap[itemName] = true;
                            if (something.data && (something.type === ecConfig.CHART_TYPE_PIE || something.type === ecConfig.CHART_TYPE_FORCE || something.type === ecConfig.CHART_TYPE_FUNNEL)) {
                                queryTarget = [something.data, something.series];
                            } else {
                                queryTarget = [something.series];
                            }

                            color = this.getItemStyleColor(
                                this.deepQuery(queryTarget, 'itemStyle.normal.color'),
                                something.seriesIndex,
                                something.dataIndex,
                                something.data
                            );
                            if (color && something.type != ecConfig.CHART_TYPE_K) {
                                this.setColor(itemName, color);
                            }
                            this._selectedMap[itemName] =
                                this._selectedMap[itemName] != null ? this._selectedMap[itemName] : true;
                        }
                    }
                }
                this.clear();
                this._buildShape();
            },

            getRelatedAmount: function(name) {
                var amount = 0;
                var series = this.option.series;
                var data;
                for (var i = 0, l = series.length; i < l; i++) {
                    if (series[i].name === name) {
                        // 系列名称优先
                        amount++;
                    }

                    if (
                        series[i].type === ecConfig.CHART_TYPE_PIE || series[i].type === ecConfig.CHART_TYPE_RADAR || series[i].type === ecConfig.CHART_TYPE_CHORD || series[i].type === ecConfig.CHART_TYPE_FORCE || series[i].type === ecConfig.CHART_TYPE_FUNNEL
                    ) {
                        data = series[i].type != ecConfig.CHART_TYPE_FORCE ? series[i].data // 饼图、雷达图、和弦图得查找里面的数据名字
                            : series[i].categories; // 力导布局查找categories配置
                        for (var j = 0, k = data.length; j < k; j++) {
                            if (data[j].name === name && data[j].value != '-') {
                                amount++;
                            }
                        }
                    }
                }
                return amount;
            },

            setColor: function(legendName, color) {
                this._colorMap[legendName] = color;
            },

            getColor: function(legendName) {
                if (!this._colorMap[legendName]) {
                    this._colorMap[legendName] = this.zr.getColor(this._colorIndex++);
                }
                return this._colorMap[legendName];
            },

            hasColor: function(legendName) {
                return this._colorMap[legendName] ? this._colorMap[legendName] : false;
            },

            add: function(name, color) {
                var data = this.legendOption.data;
                for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                    if (this._getName(data[i]) === name) {
                        // 已有就不重复加了
                        return;
                    }
                }
                this.legendOption.data.push(name);
                this.setColor(name, color);
                this._selectedMap[name] = true;
                this._hasDataMap[name] = true;
            },

            del: function(name) {
                var data = this.legendOption.data;
                for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                    if (this._getName(data[i]) === name) {
                        return this.legendOption.data.splice(i, 1);
                    }
                }
            },

            /**
             * 特殊图形元素回调设置
             * @param {Object} name
             * @param {Object} itemShape
             */
            getItemShape: function(name) {
                if (name == null) {
                    return;
                }
                var shape;
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    shape = this.shapeList[i];
                    if (shape._name === name && shape.type != 'text') {
                        return shape;
                    }
                }
            },

            /**
             * 特殊图形元素回调设置
             * @param {Object} name
             * @param {Object} itemShape
             */
            setItemShape: function(name, itemShape) {
                var shape;
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    shape = this.shapeList[i];
                    if (shape._name === name && shape.type != 'text') {
                        if (!this._selectedMap[name]) {
                            itemShape.style.color = '#ccc';
                            itemShape.style.strokeColor = '#ccc';
                        }
                        this.zr.modShape(shape.id, itemShape);
                    }
                }
            },

            isSelected: function(itemName) {
                if (typeof this._selectedMap[itemName] != 'undefined') {
                    return this._selectedMap[itemName];
                } else {
                    // 没在legend里定义的都为true啊~
                    return true;
                }
            },

            getSelectedMap: function() {
                return this._selectedMap;
            },

            setSelected: function(itemName, selectStatus) {
                if (this.legendOption.selectedMode === 'single') {
                    for (var k in this._selectedMap) {
                        this._selectedMap[k] = false;
                    }
                }
                this._selectedMap[itemName] = selectStatus;
                this.messageCenter.dispatch(
                    ecConfig.EVENT.LEGEND_SELECTED,
                    null, {
                        selected: this._selectedMap,
                        target: itemName
                    },
                    this.myChart
                );
            },

            /**
             * 图例选择
             */
            onlegendSelected: function(param, status) {
                var legendSelected = param.selected;
                for (var itemName in legendSelected) {
                    if (this._selectedMap[itemName] != legendSelected[itemName]) {
                        // 有一项不一致都需要重绘
                        status.needRefresh = true;
                    }
                    this._selectedMap[itemName] = legendSelected[itemName];
                }
                return;
            }
        };

        var legendIcon = {
            line: function(ctx, style) {
                var dy = style.height / 2;
                ctx.moveTo(style.x, style.y + dy);
                ctx.lineTo(style.x + style.width, style.y + dy);
            },

            pie: function(ctx, style) {
                var x = style.x;
                var y = style.y;
                var width = style.width;
                var height = style.height;
                SectorShape.prototype.buildPath(ctx, {
                    x: x + width / 2,
                    y: y + height + 2,
                    r: height,
                    r0: 6,
                    startAngle: 45,
                    endAngle: 135
                });
            },

            eventRiver: function(ctx, style) {
                var x = style.x;
                var y = style.y;
                var width = style.width;
                var height = style.height;
                ctx.moveTo(x, y + height);
                ctx.bezierCurveTo(
                    x + width, y + height, x, y + 4, x + width, y + 4
                );
                ctx.lineTo(x + width, y);
                ctx.bezierCurveTo(
                    x, y, x + width, y + height - 4, x, y + height - 4
                );
                ctx.lineTo(x, y + height);
            },

            k: function(ctx, style) {
                var x = style.x;
                var y = style.y;
                var width = style.width;
                var height = style.height;
                CandleShape.prototype.buildPath(ctx, {
                    x: x + width / 2,
                    y: [y + 1, y + 1, y + height - 6, y + height],
                    width: width - 6
                });
            },

            bar: function(ctx, style) {
                var x = style.x;
                var y = style.y + 1;
                var width = style.width;
                var height = style.height - 2;
                var r = 3;

                ctx.moveTo(x + r, y);
                ctx.lineTo(x + width - r, y);
                ctx.quadraticCurveTo(
                    x + width, y, x + width, y + r
                );
                ctx.lineTo(x + width, y + height - r);
                ctx.quadraticCurveTo(
                    x + width, y + height, x + width - r, y + height
                );
                ctx.lineTo(x + r, y + height);
                ctx.quadraticCurveTo(
                    x, y + height, x, y + height - r
                );
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
            },

            force: function(ctx, style) {
                IconShape.prototype.iconLibrary.circle(ctx, style);
            },

            radar: function(ctx, style) {
                var n = 6;
                var x = style.x + style.width / 2;
                var y = style.y + style.height / 2;
                var r = style.height / 2;

                var dStep = 2 * Math.PI / n;
                var deg = -Math.PI / 2;
                var xStart = x + r * Math.cos(deg);
                var yStart = y + r * Math.sin(deg);

                ctx.moveTo(xStart, yStart);
                deg += dStep;
                for (var i = 0, end = n - 1; i < end; i++) {
                    ctx.lineTo(x + r * Math.cos(deg), y + r * Math.sin(deg));
                    deg += dStep;
                }
                ctx.lineTo(xStart, yStart);
            }
        };
        legendIcon.chord = legendIcon.pie;
        legendIcon.map = legendIcon.bar;

        for (var k in legendIcon) {
            IconShape.prototype.iconLibrary['legendicon' + k] = legendIcon[k];
        }

        zrUtil.inherits(Legend, Base);

        require('../component').define('legend', Legend);

        return Legend;
    });
    define('zrender/shape/Image', ['require', './Base', '../tool/util'], function(require) {

        var Base = require('./Base');

        /**
         * @alias zrender/shape/Image
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var ZImage = function(options) {
            Base.call(this, options);
            /**
             * 图片绘制样式
             * @name module:zrender/shape/Image#style
             * @type {module:zrender/shape/Image~IImageStyle}
             */
            /**
             * 图片高亮绘制样式
             * @name module:zrender/shape/Image#highlightStyle
             * @type {module:zrender/shape/Image~IImageStyle}
             */
        };

        ZImage.prototype = {

            type: 'image',

            brush: function(ctx, isHighlight, refreshNextFrame) {
                var style = this.style || {};

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style, this.highlightStyle || {}
                    );
                }

                var image = style.image;
                var self = this;

                if (!this._imageCache) {
                    this._imageCache = {};
                }
                if (typeof(image) === 'string') {
                    var src = image;
                    if (this._imageCache[src]) {
                        image = this._imageCache[src];
                    } else {
                        image = new Image();
                        image.onload = function() {
                            image.onload = null;
                            self.modSelf();
                            refreshNextFrame();
                        };

                        image.src = src;
                        this._imageCache[src] = image;
                    }
                }
                if (image) {
                    // 图片已经加载完成
                    if (image.nodeName.toUpperCase() == 'IMG') {
                        if (window.ActiveXObject) {
                            if (image.readyState != 'complete') {
                                return;
                            }
                        } else {
                            if (!image.complete) {
                                return;
                            }
                        }
                    }
                    // Else is canvas
                    var width = style.width || image.width;
                    var height = style.height || image.height;
                    var x = style.x;
                    var y = style.y;
                    // 图片加载失败
                    if (!image.width || !image.height) {
                        return;
                    }

                    ctx.save();

                    this.doClip(ctx);

                    this.setContext(ctx, style);

                    // 设置transform
                    this.setTransform(ctx);

                    if (style.sWidth && style.sHeight) {
                        var sx = style.sx || 0;
                        var sy = style.sy || 0;
                        ctx.drawImage(
                            image,
                            sx, sy, style.sWidth, style.sHeight,
                            x, y, width, height
                        );
                    } else if (style.sx && style.sy) {
                        var sx = style.sx;
                        var sy = style.sy;
                        var sWidth = width - sx;
                        var sHeight = height - sy;
                        ctx.drawImage(
                            image,
                            sx, sy, sWidth, sHeight,
                            x, y, width, height
                        );
                    } else {
                        ctx.drawImage(image, x, y, width, height);
                    }
                    // 如果没设置宽和高的话自动根据图片宽高设置
                    if (!style.width) {
                        style.width = width;
                    }
                    if (!style.height) {
                        style.height = height;
                    }
                    if (!this.style.width) {
                        this.style.width = width;
                    }
                    if (!this.style.height) {
                        this.style.height = height;
                    }

                    this.drawText(ctx, style, this.style);

                    ctx.restore();
                }
            },

            /**
             * 计算返回图片的包围盒矩形
             * @param {module:zrender/shape/Image~IImageStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                return {
                    x: style.x,
                    y: style.y,
                    width: style.width,
                    height: style.height
                };
            },

            clearCache: function() {
                this._imageCache = {};
            }
        };

        require('../tool/util').inherits(ZImage, Base);
        return ZImage;
    });
    define('zrender/loadingEffect/Bubble', ['require', './Base', '../tool/util', '../tool/color', '../shape/Circle'], function(require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var CircleShape = require('../shape/Circle');

        function Bubble(options) {
            Base.call(this, options);
        }
        util.inherits(Bubble, Base);

        /**
         * 泡泡
         *
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Bubble.prototype._start = function(addShapeHandle, refreshHandle) {

            // 特效默认配置
            var options = util.merge(
                this.options, {
                    textStyle: {
                        color: '#888'
                    },
                    backgroundColor: 'rgba(250, 250, 250, 0.8)',
                    effect: {
                        n: 50,
                        lineWidth: 2,
                        brushType: 'stroke',
                        color: 'random',
                        timeInterval: 100
                    }
                }
            );

            var textShape = this.createTextShape(options.textStyle);
            var background = this.createBackgroundShape(options.backgroundColor);

            var effectOption = options.effect;
            var n = effectOption.n;
            var brushType = effectOption.brushType;
            var lineWidth = effectOption.lineWidth;

            var shapeList = [];
            var canvasWidth = this.canvasWidth;
            var canvasHeight = this.canvasHeight;

            // 初始化动画元素
            for (var i = 0; i < n; i++) {
                var color = effectOption.color == 'random' ? zrColor.alpha(zrColor.random(), 0.3) : effectOption.color;

                shapeList[i] = new CircleShape({
                    highlightStyle: {
                        x: Math.ceil(Math.random() * canvasWidth),
                        y: Math.ceil(Math.random() * canvasHeight),
                        r: Math.ceil(Math.random() * 40),
                        brushType: brushType,
                        color: color,
                        strokeColor: color,
                        lineWidth: lineWidth
                    },
                    animationY: Math.ceil(Math.random() * 20)
                });
            }

            return setInterval(
                function() {
                    addShapeHandle(background);

                    for (var i = 0; i < n; i++) {
                        var style = shapeList[i].highlightStyle;

                        if (style.y - shapeList[i].animationY + style.r <= 0) {
                            shapeList[i].highlightStyle.y = canvasHeight + style.r;
                            shapeList[i].highlightStyle.x = Math.ceil(
                                Math.random() * canvasWidth
                            );
                        }
                        shapeList[i].highlightStyle.y -=
                            shapeList[i].animationY;

                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return Bubble;
    });
    define('zrender/loadingEffect/Bar', ['require', './Base', '../tool/util', '../tool/color', '../shape/Rectangle'], function(require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var RectangleShape = require('../shape/Rectangle');

        function Bar(options) {
            Base.call(this, options);
        }
        util.inherits(Bar, Base);


        /**
         * 进度条
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Bar.prototype._start = function(addShapeHandle, refreshHandle) {
            // 特效默认配置
            var options = util.merge(
                this.options, {
                    textStyle: {
                        color: '#888'
                    },
                    backgroundColor: 'rgba(250, 250, 250, 0.8)',
                    effectOption: {
                        x: 0,
                        y: this.canvasHeight / 2 - 30,
                        width: this.canvasWidth,
                        height: 5,
                        brushType: 'fill',
                        timeInterval: 100
                    }
                }
            );

            var textShape = this.createTextShape(options.textStyle);
            var background = this.createBackgroundShape(options.backgroundColor);

            var effectOption = options.effectOption;

            // 初始化动画元素
            var barShape = new RectangleShape({
                highlightStyle: util.clone(effectOption)
            });

            barShape.highlightStyle.color =
                effectOption.color || zrColor.getLinearGradient(
                    effectOption.x,
                    effectOption.y,
                    effectOption.x + effectOption.width,
                    effectOption.y + effectOption.height, [
                        [0, '#ff6400'],
                        [0.5, '#ffe100'],
                        [1, '#b1ff00']
                    ]
                );

            if (options.progress != null) {
                // 指定进度
                addShapeHandle(background);

                barShape.highlightStyle.width =
                    this.adjust(options.progress, [0, 1]) * options.effectOption.width;

                addShapeHandle(barShape);
                addShapeHandle(textShape);

                refreshHandle();
                return;
            } else {
                // 循环显示
                barShape.highlightStyle.width = 0;
                return setInterval(
                    function() {
                        addShapeHandle(background);

                        if (barShape.highlightStyle.width < effectOption.width) {
                            barShape.highlightStyle.width += 8;
                        } else {
                            barShape.highlightStyle.width = 0;
                        }
                        addShapeHandle(barShape);
                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            }
        };

        return Bar;
    });
    define('zrender/loadingEffect/DynamicLine', ['require', './Base', '../tool/util', '../tool/color', '../shape/Line'], function(require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var LineShape = require('../shape/Line');

        function DynamicLine(options) {
            Base.call(this, options);
        }
        util.inherits(DynamicLine, Base);


        /**
         * 动态线
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        DynamicLine.prototype._start = function(addShapeHandle, refreshHandle) {
            // 特效默认配置
            var options = util.merge(
                this.options, {
                    textStyle: {
                        color: '#fff'
                    },
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    effectOption: {
                        n: 30,
                        lineWidth: 1,
                        color: 'random',
                        timeInterval: 100
                    }
                }
            );

            var textShape = this.createTextShape(options.textStyle);
            var background = this.createBackgroundShape(options.backgroundColor);

            var effectOption = options.effectOption;
            var n = effectOption.n;
            var lineWidth = effectOption.lineWidth;

            var shapeList = [];
            var canvasWidth = this.canvasWidth;
            var canvasHeight = this.canvasHeight;

            // 初始化动画元素
            for (var i = 0; i < n; i++) {
                var xStart = -Math.ceil(Math.random() * 1000);
                var len = Math.ceil(Math.random() * 400);
                var pos = Math.ceil(Math.random() * canvasHeight);

                var color = effectOption.color == 'random' ? zrColor.random() : effectOption.color;

                shapeList[i] = new LineShape({
                    highlightStyle: {
                        xStart: xStart,
                        yStart: pos,
                        xEnd: xStart + len,
                        yEnd: pos,
                        strokeColor: color,
                        lineWidth: lineWidth
                    },
                    animationX: Math.ceil(Math.random() * 100),
                    len: len
                });
            }

            return setInterval(
                function() {
                    addShapeHandle(background);

                    for (var i = 0; i < n; i++) {
                        var style = shapeList[i].highlightStyle;

                        if (style.xStart >= canvasWidth) {

                            shapeList[i].len = Math.ceil(Math.random() * 400);
                            style.xStart = -400;
                            style.xEnd = -400 + shapeList[i].len;
                            style.yStart = Math.ceil(Math.random() * canvasHeight);
                            style.yEnd = style.yStart;
                        }

                        style.xStart += shapeList[i].animationX;
                        style.xEnd += shapeList[i].animationX;

                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return DynamicLine;
    });
    define('zrender/loadingEffect/Spin', ['require', './Base', '../tool/util', '../tool/color', '../tool/area', '../shape/Sector'], function(require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var zrArea = require('../tool/area');
        var SectorShape = require('../shape/Sector');

        function Spin(options) {
            Base.call(this, options);
        }
        util.inherits(Spin, Base);

        /**
         * 旋转
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Spin.prototype._start = function(addShapeHandle, refreshHandle) {
            var options = util.merge(
                this.options, {
                    textStyle: {
                        color: '#fff',
                        textAlign: 'start'
                    },
                    backgroundColor: 'rgba(0, 0, 0, 0.8)'
                }
            );
            var textShape = this.createTextShape(options.textStyle);

            var textGap = 10;
            var textWidth = zrArea.getTextWidth(
                textShape.highlightStyle.text, textShape.highlightStyle.textFont
            );
            var textHeight = zrArea.getTextHeight(
                textShape.highlightStyle.text, textShape.highlightStyle.textFont
            );

            // 特效默认配置
            var effectOption = util.merge(
                this.options.effect || {}, {
                    r0: 9,
                    r: 15,
                    n: 18,
                    color: '#fff',
                    timeInterval: 100
                }
            );

            var location = this.getLocation(
                this.options.textStyle,
                textWidth + textGap + effectOption.r * 2,
                Math.max(effectOption.r * 2, textHeight)
            );
            effectOption.x = location.x + effectOption.r;
            effectOption.y = textShape.highlightStyle.y = location.y + location.height / 2;
            textShape.highlightStyle.x = effectOption.x + effectOption.r + textGap;

            var background = this.createBackgroundShape(options.backgroundColor);
            var n = effectOption.n;
            var x = effectOption.x;
            var y = effectOption.y;
            var r0 = effectOption.r0;
            var r = effectOption.r;
            var color = effectOption.color;

            // 初始化动画元素
            var shapeList = [];
            var preAngle = Math.round(180 / n);
            for (var i = 0; i < n; i++) {
                shapeList[i] = new SectorShape({
                    highlightStyle: {
                        x: x,
                        y: y,
                        r0: r0,
                        r: r,
                        startAngle: preAngle * i * 2,
                        endAngle: preAngle * i * 2 + preAngle,
                        color: zrColor.alpha(color, (i + 1) / n),
                        brushType: 'fill'
                    }
                });
            }

            var pos = [0, x, y];

            return setInterval(
                function() {
                    addShapeHandle(background);
                    pos[0] -= 0.3;
                    for (var i = 0; i < n; i++) {
                        shapeList[i].rotation = pos;
                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return Spin;
    });
    define('echarts/component/tooltip', ['require', './base', '../util/shape/Cross', 'zrender/shape/Line', 'zrender/shape/Rectangle', '../config', '../util/ecData', 'zrender/config', 'zrender/tool/event', 'zrender/tool/area', 'zrender/tool/color', 'zrender/tool/util', 'zrender/shape/Base', '../component'], function(require) {
        var Base = require('./base');

        // 图形依赖
        var CrossShape = require('../util/shape/Cross');
        var LineShape = require('zrender/shape/Line');
        var RectangleShape = require('zrender/shape/Rectangle');
        var rectangleInstance = new RectangleShape({});

        var ecConfig = require('../config');
        // 提示框
        ecConfig.tooltip = {
            zlevel: 1, // 一级层叠，频繁变化的tooltip指示器在pc上独立一层
            z: 8, // 二级层叠
            show: true,
            showContent: true, // tooltip主体内容
            trigger: 'item', // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'
            // position: null          // 位置 {Array} | {Function}
            // formatter: null         // 内容格式器：{string}（Template） ¦ {Function}
            islandFormatter: '{a} <br/>{b} : {c}', // 数据孤岛内容格式器
            showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms
            hideDelay: 100, // 隐藏延迟，单位ms
            transitionDuration: 0.4, // 动画变换时间，单位s
            enterable: false,
            backgroundColor: 'rgba(0,0,0,0.7)', // 提示背景颜色，默认为透明度为0.7的黑色
            borderColor: '#333', // 提示边框颜色
            borderRadius: 4, // 提示边框圆角，单位px，默认为4
            borderWidth: 0, // 提示边框线宽，单位px，默认为0（无边框）
            padding: 5, // 提示内边距，单位px，默认各方向内边距为5，
            // 接受数组分别设定上右下左边距，同css
            axisPointer: { // 坐标轴指示器，坐标轴触发有效
                type: 'line', // 默认为直线，可选为：'line' | 'shadow' | 'cross'
                lineStyle: { // 直线指示器样式设置
                    color: '#48b',
                    width: 2,
                    type: 'solid'
                },
                crossStyle: {
                    color: '#1e90ff',
                    width: 1,
                    type: 'dashed'
                },
                shadowStyle: { // 阴影指示器样式设置
                    color: 'rgba(150,150,150,0.3)', // 阴影颜色
                    width: 'auto', // 阴影大小
                    type: 'default'
                }
            },
            textStyle: {
                color: '#fff'
            }
        };

        var ecData = require('../util/ecData');
        var zrConfig = require('zrender/config');
        var zrEvent = require('zrender/tool/event');
        var zrArea = require('zrender/tool/area');
        var zrColor = require('zrender/tool/color');
        var zrUtil = require('zrender/tool/util');
        var zrShapeBase = require('zrender/shape/Base');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 提示框参数
         * @param {HtmlElement} dom 目标对象
         * @param {ECharts} myChart 当前图表实例
         */
        function Tooltip(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.dom = myChart.dom;

            var self = this;
            self._onmousemove = function(param) {
                return self.__onmousemove(param);
            };
            self._onglobalout = function(param) {
                return self.__onglobalout(param);
            };

            this.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
            this.zr.on(zrConfig.EVENT.GLOBALOUT, self._onglobalout);

            self._hide = function(param) {
                return self.__hide(param);
            };
            self._tryShow = function(param) {
                return self.__tryShow(param);
            };
            self._refixed = function(param) {
                return self.__refixed(param);
            };

            self._setContent = function(ticket, res) {
                return self.__setContent(ticket, res);
            };

            this._tDom = this._tDom || document.createElement('div');
            // 避免拖拽时页面选中的尴尬
            this._tDom.onselectstart = function() {
                return false;
            };
            this._tDom.onmouseover = function() {
                self._mousein = true;
            };
            this._tDom.onmouseout = function() {
                self._mousein = false;
            };
            this._tDom.className = 'echarts-tooltip';
            this._tDom.style.position = 'absolute'; // 不是多余的，别删！
            this.hasAppend = false;

            this._axisLineShape && this.zr.delShape(this._axisLineShape.id);
            this._axisLineShape = new LineShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                invisible: true,
                hoverable: false
            });
            this.shapeList.push(this._axisLineShape);
            this.zr.addShape(this._axisLineShape);

            this._axisShadowShape && this.zr.delShape(this._axisShadowShape.id);
            this._axisShadowShape = new LineShape({
                zlevel: this.getZlevelBase(),
                z: 1, // grid上，chart下
                invisible: true,
                hoverable: false
            });
            this.shapeList.push(this._axisShadowShape);
            this.zr.addShape(this._axisShadowShape);

            this._axisCrossShape && this.zr.delShape(this._axisCrossShape.id);
            this._axisCrossShape = new CrossShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                invisible: true,
                hoverable: false
            });
            this.shapeList.push(this._axisCrossShape);
            this.zr.addShape(this._axisCrossShape);

            this.showing = false;
            this.refresh(option);
        }

        Tooltip.prototype = {
            type: ecConfig.COMPONENT_TYPE_TOOLTIP,
            // 通用样式
            _gCssText: 'position:absolute;display:block;border-style:solid;white-space:nowrap;',
            /**
             * 根据配置设置dom样式
             */
            _style: function(opt) {
                if (!opt) {
                    return '';
                }
                var cssText = [];
                if (opt.transitionDuration) {
                    var transitionText = 'left ' + opt.transitionDuration + 's,' + 'top ' + opt.transitionDuration + 's';
                    cssText.push(
                        'transition:' + transitionText
                    );
                    cssText.push(
                        '-moz-transition:' + transitionText
                    );
                    cssText.push(
                        '-webkit-transition:' + transitionText
                    );
                    cssText.push(
                        '-o-transition:' + transitionText
                    );
                }

                if (opt.backgroundColor) {
                    // for sb ie~
                    cssText.push(
                        'background-Color:' + zrColor.toHex(
                            opt.backgroundColor
                        )
                    );
                    cssText.push('filter:alpha(opacity=70)');
                    cssText.push('background-Color:' + opt.backgroundColor);
                }

                if (opt.borderWidth != null) {
                    cssText.push('border-width:' + opt.borderWidth + 'px');
                }

                if (opt.borderColor != null) {
                    cssText.push('border-color:' + opt.borderColor);
                }

                if (opt.borderRadius != null) {
                    cssText.push(
                        'border-radius:' + opt.borderRadius + 'px'
                    );
                    cssText.push(
                        '-moz-border-radius:' + opt.borderRadius + 'px'
                    );
                    cssText.push(
                        '-webkit-border-radius:' + opt.borderRadius + 'px'
                    );
                    cssText.push(
                        '-o-border-radius:' + opt.borderRadius + 'px'
                    );
                }

                var textStyle = opt.textStyle;
                if (textStyle) {
                    textStyle.color && cssText.push('color:' + textStyle.color);
                    textStyle.decoration && cssText.push(
                        'text-decoration:' + textStyle.decoration
                    );
                    textStyle.align && cssText.push(
                        'text-align:' + textStyle.align
                    );
                    textStyle.fontFamily && cssText.push(
                        'font-family:' + textStyle.fontFamily
                    );
                    textStyle.fontSize && cssText.push(
                        'font-size:' + textStyle.fontSize + 'px'
                    );
                    textStyle.fontSize && cssText.push(
                        'line-height:' + Math.round(textStyle.fontSize * 3 / 2) + 'px'
                    );
                    textStyle.fontStyle && cssText.push(
                        'font-style:' + textStyle.fontStyle
                    );
                    textStyle.fontWeight && cssText.push(
                        'font-weight:' + textStyle.fontWeight
                    );
                }


                var padding = opt.padding;
                if (padding != null) {
                    padding = this.reformCssArray(padding);
                    cssText.push(
                        'padding:' + padding[0] + 'px ' + padding[1] + 'px ' + padding[2] + 'px ' + padding[3] + 'px'
                    );
                }

                cssText = cssText.join(';') + ';';

                return cssText;
            },

            __hide: function() {
                this._lastDataIndex = -1;
                this._lastSeriesIndex = -1;
                this._lastItemTriggerId = -1;
                if (this._tDom) {
                    this._tDom.style.display = 'none';
                }
                var needRefresh = false;
                if (!this._axisLineShape.invisible) {
                    this._axisLineShape.invisible = true;
                    this.zr.modShape(this._axisLineShape.id);
                    needRefresh = true;
                }
                if (!this._axisShadowShape.invisible) {
                    this._axisShadowShape.invisible = true;
                    this.zr.modShape(this._axisShadowShape.id);
                    needRefresh = true;
                }
                if (!this._axisCrossShape.invisible) {
                    this._axisCrossShape.invisible = true;
                    this.zr.modShape(this._axisCrossShape.id);
                    needRefresh = true;
                }
                if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                    this._lastTipShape = false;
                    this.shapeList.length = 2;
                }
                needRefresh && this.zr.refreshNextFrame();
                this.showing = false;
            },

            _show: function(position, x, y, specialCssText) {
                var domHeight = this._tDom.offsetHeight;
                var domWidth = this._tDom.offsetWidth;
                if (position) {
                    if (typeof position === 'function') {
                        position = position([x, y]);
                    }
                    if (position instanceof Array) {
                        x = position[0];
                        y = position[1];
                    }
                }
                if (x + domWidth > this._zrWidth) {
                    // 太靠右
                    //x = this._zrWidth - domWidth;
                    x -= (domWidth + 40);
                }
                if (y + domHeight > this._zrHeight) {
                    // 太靠下
                    //y = this._zrHeight - domHeight;
                    y -= (domHeight - 20);
                }
                if (y < 20) {
                    y = 0;
                }
                this._tDom.style.cssText = this._gCssText + this._defaultCssText + (specialCssText ? specialCssText : '') + 'left:' + x + 'px;top:' + y + 'px;';

                if (domHeight < 10 || domWidth < 10) {
                    // this._zrWidth - x < 100 || this._zrHeight - y < 100
                    setTimeout(this._refixed, 20);
                }
                this.showing = true;
            },

            __refixed: function() {
                if (this._tDom) {
                    var cssText = '';
                    var domHeight = this._tDom.offsetHeight;
                    var domWidth = this._tDom.offsetWidth;
                    if (this._tDom.offsetLeft + domWidth > this._zrWidth) {
                        cssText += 'left:' + (this._zrWidth - domWidth - 20) + 'px;';
                    }
                    if (this._tDom.offsetTop + domHeight > this._zrHeight) {
                        cssText += 'top:' + (this._zrHeight - domHeight - 10) + 'px;';
                    }
                    if (cssText !== '') {
                        this._tDom.style.cssText += cssText;
                    }
                }
            },

            __tryShow: function() {
                var needShow;
                var trigger;
                if (!this._curTarget) {
                    // 坐标轴事件
                    this._findPolarTrigger() || this._findAxisTrigger();
                } else {
                    // 数据项事件
                    if (this._curTarget._type === 'island' && this.option.tooltip.show) {
                        this._showItemTrigger();
                        return;
                    }
                    var serie = ecData.get(this._curTarget, 'series');
                    var data = ecData.get(this._curTarget, 'data');
                    needShow = this.deepQuery(
                        [data, serie, this.option],
                        'tooltip.show'
                    );
                    if (serie == null || data == null || !needShow) {
                        // 不响应tooltip的数据对象延时隐藏
                        clearTimeout(this._hidingTicket);
                        clearTimeout(this._showingTicket);
                        this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                    } else {
                        trigger = this.deepQuery(
                            [data, serie, this.option],
                            'tooltip.trigger'
                        );

                        trigger === 'axis' ? this._showAxisTrigger(
                            serie.xAxisIndex, serie.yAxisIndex,
                            ecData.get(this._curTarget, 'dataIndex')
                        ) : this._showItemTrigger();
                    }
                }
            },

            /**
             * 直角系 
             */
            _findAxisTrigger: function() {
                if (!this.component.xAxis || !this.component.yAxis) {
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                    return;
                }
                var series = this.option.series;
                var xAxisIndex;
                var yAxisIndex;
                for (var i = 0, l = series.length; i < l; i++) {
                    // 找到第一个axis触发tooltip的系列
                    if (this.deepQuery([series[i], this.option], 'tooltip.trigger') === 'axis') {
                        xAxisIndex = series[i].xAxisIndex || 0;
                        yAxisIndex = series[i].yAxisIndex || 0;
                        if (this.component.xAxis.getAxis(xAxisIndex) && this.component.xAxis.getAxis(xAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                            // 横轴为类目轴
                            this._showAxisTrigger(xAxisIndex, yAxisIndex,
                                this._getNearestDataIndex(
                                    'x', this.component.xAxis.getAxis(xAxisIndex)
                                )
                            );
                            return;
                        } else if (this.component.yAxis.getAxis(yAxisIndex) && this.component.yAxis.getAxis(yAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                            // 纵轴为类目轴
                            this._showAxisTrigger(xAxisIndex, yAxisIndex,
                                this._getNearestDataIndex(
                                    'y', this.component.yAxis.getAxis(yAxisIndex)
                                )
                            );
                            return;
                        } else {
                            // 双数值轴
                            this._showAxisTrigger(xAxisIndex, yAxisIndex, -1);
                            return;
                        }
                    }
                }
                if (this.option.tooltip.axisPointer.type === 'cross') {
                    this._showAxisTrigger(-1, -1, -1);
                }
            },

            /**
             * 极坐标 
             */
            _findPolarTrigger: function() {
                if (!this.component.polar) {
                    return false;
                }
                var x = zrEvent.getX(this._event);
                var y = zrEvent.getY(this._event);
                var polarIndex = this.component.polar.getNearestIndex([x, y]);
                var valueIndex;
                if (polarIndex) {
                    valueIndex = polarIndex.valueIndex;
                    polarIndex = polarIndex.polarIndex;
                } else {
                    polarIndex = -1;
                }

                if (polarIndex != -1) {
                    return this._showPolarTrigger(polarIndex, valueIndex);
                }

                return false;
            },

            /**
             * 根据坐标轴事件带的属性获取最近的axisDataIndex
             */
            _getNearestDataIndex: function(direction, categoryAxis) {
                var dataIndex = -1;
                var x = zrEvent.getX(this._event);
                var y = zrEvent.getY(this._event);
                if (direction === 'x') {
                    // 横轴为类目轴
                    var left;
                    var right;
                    var xEnd = this.component.grid.getXend();
                    var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                    while (curCoord < xEnd) {
                        right = curCoord;
                        if (curCoord <= x) {
                            left = curCoord;
                        } else {
                            break;
                        }
                        curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                    }
                    if (dataIndex <= 0) {
                        dataIndex = 0;
                    } else if (x - left <= right - x) {
                        dataIndex -= 1;
                    } else {
                        // 离右边近，看是否为最后一个
                        if (categoryAxis.getNameByIndex(dataIndex) == null) {
                            dataIndex -= 1;
                        }
                    }
                    return dataIndex;
                } else {
                    // 纵轴为类目轴
                    var top;
                    var bottom;
                    var yStart = this.component.grid.getY();
                    var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                    while (curCoord > yStart) {
                        top = curCoord;
                        if (curCoord >= y) {
                            bottom = curCoord;
                        } else {
                            break;
                        }
                        curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                    }

                    if (dataIndex <= 0) {
                        dataIndex = 0;
                    } else if (y - top >= bottom - y) {
                        dataIndex -= 1;
                    } else {
                        // 离上方边近，看是否为最后一个
                        if (categoryAxis.getNameByIndex(dataIndex) == null) {
                            dataIndex -= 1;
                        }
                    }
                    return dataIndex;
                }
                return -1;
            },

            /**
             * 直角系 
             */
            _showAxisTrigger: function(xAxisIndex, yAxisIndex, dataIndex) {
                !this._event.connectTrigger && this.messageCenter.dispatch(
                    ecConfig.EVENT.TOOLTIP_IN_GRID,
                    this._event,
                    null,
                    this.myChart
                );
                if (this.component.xAxis == null || this.component.yAxis == null || xAxisIndex == null || yAxisIndex == null
                    // || dataIndex < 0
                ) {
                    // 不响应tooltip的数据对象延时隐藏
                    clearTimeout(this._hidingTicket);
                    clearTimeout(this._showingTicket);
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                    return;
                }
                var series = this.option.series;
                var seriesArray = [];
                var seriesIndex = [];
                var categoryAxis;

                var formatter;
                var position;
                var showContent;
                var specialCssText = '';
                if (this.option.tooltip.trigger === 'axis') {
                    if (!this.option.tooltip.show) {
                        return;
                    }
                    formatter = this.option.tooltip.formatter;
                    position = this.option.tooltip.position;
                }

                var axisLayout = xAxisIndex != -1 && this.component.xAxis.getAxis(xAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY ? 'xAxis' // 横轴为类目轴，找到所有用这条横轴并且axis触发的系列数据
                    : yAxisIndex != -1 && this.component.yAxis.getAxis(yAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY ? 'yAxis' // 纵轴为类目轴，找到所有用这条纵轴并且axis触发的系列数据
                    : false;
                var x;
                var y;
                if (axisLayout) {
                    var axisIndex = axisLayout == 'xAxis' ? xAxisIndex : yAxisIndex;
                    categoryAxis = this.component[axisLayout].getAxis(axisIndex);
                    for (var i = 0, l = series.length; i < l; i++) {
                        if (!this._isSelected(series[i].name)) {
                            continue;
                        }
                        if (series[i][axisLayout + 'Index'] === axisIndex && this.deepQuery([series[i], this.option], 'tooltip.trigger') === 'axis') {
                            showContent = this.query(series[i], 'tooltip.showContent') || showContent;
                            formatter = this.query(series[i], 'tooltip.formatter') || formatter;
                            position = this.query(series[i], 'tooltip.position') || position;

                            specialCssText += this._style(this.query(series[i], 'tooltip'));
                            if (series[i].stack != null && axisLayout == 'xAxis') {
                                seriesArray.unshift(series[i]);
                                seriesIndex.unshift(i);
                            } else {
                                seriesArray.push(series[i]);
                                seriesIndex.push(i);
                            }
                        }
                    }

                    // 寻找高亮元素
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.TOOLTIP_HOVER,
                        this._event, {
                            seriesIndex: seriesIndex,
                            dataIndex: dataIndex
                        },
                        this.myChart
                    );

                    var rect;
                    if (axisLayout == 'xAxis') {
                        x = this.subPixelOptimize(
                            categoryAxis.getCoordByIndex(dataIndex),
                            this._axisLineWidth
                        );
                        y = zrEvent.getY(this._event);
                        rect = [
                            x, this.component.grid.getY(),
                            x, this.component.grid.getYend()
                        ];
                    } else {
                        x = zrEvent.getX(this._event);
                        y = this.subPixelOptimize(
                            categoryAxis.getCoordByIndex(dataIndex),
                            this._axisLineWidth
                        );
                        rect = [
                            this.component.grid.getX(), y,
                            this.component.grid.getXend(), y
                        ];
                    }
                    this._styleAxisPointer(
                        seriesArray,
                        rect[0], rect[1], rect[2], rect[3],
                        categoryAxis.getGap(), x, y
                    );
                } else {
                    // 双数值轴
                    x = zrEvent.getX(this._event);
                    y = zrEvent.getY(this._event);
                    this._styleAxisPointer(
                        series,
                        this.component.grid.getX(), y,
                        this.component.grid.getXend(), y,
                        0, x, y
                    );
                    if (dataIndex >= 0) {
                        this._showItemTrigger(true);
                    } else {
                        clearTimeout(this._hidingTicket);
                        clearTimeout(this._showingTicket);
                        this._tDom.style.display = 'none';
                    }
                }

                if (seriesArray.length > 0) {
                    // 复位item trigger和axis trigger间短距离来回变换时的不响应
                    this._lastItemTriggerId = -1;
                    // 相同dataIndex seriesIndex时不再触发内容更新
                    if (this._lastDataIndex != dataIndex || this._lastSeriesIndex != seriesIndex[0]) {
                        this._lastDataIndex = dataIndex;
                        this._lastSeriesIndex = seriesIndex[0];
                        var data;
                        var value;
                        if (typeof formatter === 'function') {
                            var params = [];
                            for (var i = 0, l = seriesArray.length; i < l; i++) {
                                data = seriesArray[i].data[dataIndex];
                                value = this.getDataFromOption(data, '-');

                                params.push({
                                    seriesIndex: seriesIndex[i],
                                    seriesName: seriesArray[i].name || '',
                                    series: seriesArray[i],
                                    dataIndex: dataIndex,
                                    data: data,
                                    name: categoryAxis.getNameByIndex(dataIndex),
                                    value: value,
                                    // 向下兼容
                                    0: seriesArray[i].name || '',
                                    1: categoryAxis.getNameByIndex(dataIndex),
                                    2: value,
                                    3: data
                                });
                            }
                            this._curTicket = 'axis:' + dataIndex;
                            this._tDom.innerHTML = formatter.call(
                                this.myChart, params, this._curTicket, this._setContent
                            );
                        } else if (typeof formatter === 'string') {
                            this._curTicket = NaN;
                            formatter = formatter.replace('{a}', '{a0}')
                                .replace('{b}', '{b0}')
                                .replace('{c}', '{c0}');
                            for (var i = 0, l = seriesArray.length; i < l; i++) {
                                formatter = formatter.replace(
                                    '{a' + i + '}',
                                    this._encodeHTML(seriesArray[i].name || '')
                                );
                                formatter = formatter.replace(
                                    '{b' + i + '}',
                                    this._encodeHTML(categoryAxis.getNameByIndex(dataIndex))
                                );
                                data = seriesArray[i].data[dataIndex];
                                data = this.getDataFromOption(data, '-');
                                formatter = formatter.replace(
                                    '{c' + i + '}',
                                    data instanceof Array ? data : this.numAddCommas(data)
                                );
                            }
                            this._tDom.innerHTML = formatter;
                        } else {
                            this._curTicket = NaN;
                            formatter = this._encodeHTML(
                                categoryAxis.getNameByIndex(dataIndex)
                            );

                            for (var i = 0, l = seriesArray.length; i < l; i++) {
                                formatter += '<br/>' + this._encodeHTML(seriesArray[i].name || '') + ' : ';
                                data = seriesArray[i].data[dataIndex];
                                data = this.getDataFromOption(data, '-');
                                formatter += data instanceof Array ? data : this.numAddCommas(data);
                            }
                            this._tDom.innerHTML = formatter;
                        }
                    }

                    // don't modify, just false, showContent == undefined == true
                    if (showContent === false || !this.option.tooltip.showContent) {
                        // 只用tooltip的行为，不显示主体
                        return;
                    }

                    if (!this.hasAppend) {
                        this._tDom.style.left = this._zrWidth / 2 + 'px';
                        this._tDom.style.top = this._zrHeight / 2 + 'px';
                        this.dom.firstChild.appendChild(this._tDom);
                        this.hasAppend = true;
                    }
                    this._show(position, x + 10, y + 10, specialCssText);
                }
            },

            /**
             * 极坐标 
             */
            _showPolarTrigger: function(polarIndex, dataIndex) {
                if (this.component.polar == null || polarIndex == null || dataIndex == null || dataIndex < 0) {
                    return false;
                }
                var series = this.option.series;
                var seriesArray = [];
                var seriesIndex = [];

                var formatter;
                var position;
                var showContent;
                var specialCssText = '';
                if (this.option.tooltip.trigger === 'axis') {
                    if (!this.option.tooltip.show) {
                        return false;
                    }
                    formatter = this.option.tooltip.formatter;
                    position = this.option.tooltip.position;
                }
                var indicatorName = this.option.polar[polarIndex].indicator[dataIndex].text;

                // 找到所有用这个极坐标并且axis触发的系列数据
                for (var i = 0, l = series.length; i < l; i++) {
                    if (!this._isSelected(series[i].name)) {
                        continue;
                    }
                    if (series[i].polarIndex === polarIndex && this.deepQuery([series[i], this.option], 'tooltip.trigger') === 'axis') {
                        showContent = this.query(series[i], 'tooltip.showContent') || showContent;
                        formatter = this.query(series[i], 'tooltip.formatter') || formatter;
                        position = this.query(series[i], 'tooltip.position') || position;
                        specialCssText += this._style(this.query(series[i], 'tooltip'));
                        seriesArray.push(series[i]);
                        seriesIndex.push(i);
                    }
                }
                if (seriesArray.length > 0) {
                    var polarData;
                    var data;
                    var value;
                    var params = [];

                    for (var i = 0, l = seriesArray.length; i < l; i++) {
                        polarData = seriesArray[i].data;
                        for (var j = 0, k = polarData.length; j < k; j++) {
                            data = polarData[j];
                            if (!this._isSelected(data.name)) {
                                continue;
                            }
                            data = data != null ? data : {
                                name: '',
                                value: {
                                    dataIndex: '-'
                                }
                            };
                            value = this.getDataFromOption(data.value[dataIndex]);
                            params.push({
                                seriesIndex: seriesIndex[i],
                                seriesName: seriesArray[i].name || '',
                                series: seriesArray[i],
                                dataIndex: dataIndex,
                                data: data,
                                name: data.name,
                                indicator: indicatorName,
                                value: value,
                                // 向下兼容
                                0: seriesArray[i].name || '',
                                1: data.name,
                                2: value,
                                3: indicatorName
                            });
                        }
                    }
                    if (params.length <= 0) {
                        return;
                    }
                    // 复位item trigger和axis trigger间短距离来回变换时的不响应
                    this._lastItemTriggerId = -1;

                    // 相同dataIndex seriesIndex时不再触发内容更新
                    if (this._lastDataIndex != dataIndex || this._lastSeriesIndex != seriesIndex[0]) {
                        this._lastDataIndex = dataIndex;
                        this._lastSeriesIndex = seriesIndex[0];
                        if (typeof formatter === 'function') {
                            this._curTicket = 'axis:' + dataIndex;
                            this._tDom.innerHTML = formatter.call(
                                this.myChart, params, this._curTicket, this._setContent
                            );
                        } else if (typeof formatter === 'string') {
                            formatter = formatter.replace('{a}', '{a0}')
                                .replace('{b}', '{b0}')
                                .replace('{c}', '{c0}')
                                .replace('{d}', '{d0}');
                            for (var i = 0, l = params.length; i < l; i++) {
                                formatter = formatter.replace(
                                    '{a' + i + '}',
                                    this._encodeHTML(params[i].seriesName)
                                );
                                formatter = formatter.replace(
                                    '{b' + i + '}',
                                    this._encodeHTML(params[i].name)
                                );
                                formatter = formatter.replace(
                                    '{c' + i + '}',
                                    this.numAddCommas(params[i].value)
                                );
                                formatter = formatter.replace(
                                    '{d' + i + '}',
                                    this._encodeHTML(params[i].indicator)
                                );
                            }
                            this._tDom.innerHTML = formatter;
                        } else {
                            formatter = this._encodeHTML(params[0].name) + '<br/>' + this._encodeHTML(params[0].indicator) + ' : ' + this.numAddCommas(params[0].value);
                            for (var i = 1, l = params.length; i < l; i++) {
                                formatter += '<br/>' + this._encodeHTML(params[i].name) + '<br/>';
                                formatter += this._encodeHTML(params[i].indicator) + ' : ' + this.numAddCommas(params[i].value);
                            }
                            this._tDom.innerHTML = formatter;
                        }
                    }

                    // don't modify, just false, showContent == undefined == true
                    if (showContent === false || !this.option.tooltip.showContent) {
                        // 只用tooltip的行为，不显示主体
                        return;
                    }

                    if (!this.hasAppend) {
                        this._tDom.style.left = this._zrWidth / 2 + 'px';
                        this._tDom.style.top = this._zrHeight / 2 + 'px';
                        this.dom.firstChild.appendChild(this._tDom);
                        this.hasAppend = true;
                    }
                    this._show(
                        position,
                        zrEvent.getX(this._event),
                        zrEvent.getY(this._event),
                        specialCssText
                    );
                    return true;
                }
            },

            /**
             * @parma {boolean} axisTrigger 
             */
            _showItemTrigger: function(axisTrigger) {
                if (!this._curTarget) {
                    return;
                }
                var serie = ecData.get(this._curTarget, 'series');
                var seriesIndex = ecData.get(this._curTarget, 'seriesIndex');
                var data = ecData.get(this._curTarget, 'data');
                var dataIndex = ecData.get(this._curTarget, 'dataIndex');
                var name = ecData.get(this._curTarget, 'name');
                var value = ecData.get(this._curTarget, 'value');
                var special = ecData.get(this._curTarget, 'special');
                var special2 = ecData.get(this._curTarget, 'special2');
                var queryTarget = [data, serie, this.option];
                // 从低优先级往上找到trigger为item的formatter和样式
                var formatter;
                var position;
                var showContent;
                var specialCssText = '';
                if (this._curTarget._type != 'island') {
                    // 全局
                    var trigger = axisTrigger ? 'axis' : 'item';
                    if (this.option.tooltip.trigger === trigger) {
                        formatter = this.option.tooltip.formatter;
                        position = this.option.tooltip.position;
                    }
                    // 系列
                    if (this.query(serie, 'tooltip.trigger') === trigger) {
                        showContent = this.query(serie, 'tooltip.showContent') || showContent;
                        formatter = this.query(serie, 'tooltip.formatter') || formatter;
                        position = this.query(serie, 'tooltip.position') || position;
                        specialCssText += this._style(this.query(serie, 'tooltip'));
                    }
                    // 数据项
                    showContent = this.query(data, 'tooltip.showContent') || showContent;
                    formatter = this.query(data, 'tooltip.formatter') || formatter;
                    position = this.query(data, 'tooltip.position') || position;
                    specialCssText += this._style(this.query(data, 'tooltip'));
                } else {
                    this._lastItemTriggerId = NaN;
                    showContent = this.deepQuery(queryTarget, 'tooltip.showContent');
                    formatter = this.deepQuery(queryTarget, 'tooltip.islandFormatter');
                    position = this.deepQuery(queryTarget, 'tooltip.islandPosition');
                }

                // 复位item trigger和axis trigger间短距离来回变换时的不响应
                this._lastDataIndex = -1;
                this._lastSeriesIndex = -1;

                // 相同dataIndex seriesIndex时不再触发内容更新
                if (this._lastItemTriggerId !== this._curTarget.id) {
                    this._lastItemTriggerId = this._curTarget.id;
                    if (typeof formatter === 'function') {
                        this._curTicket = (serie.name || '') + ':' + dataIndex;
                        this._tDom.innerHTML = formatter.call(
                            this.myChart, {
                                seriesIndex: seriesIndex,
                                seriesName: serie.name || '',
                                series: serie,
                                dataIndex: dataIndex,
                                data: data,
                                name: name,
                                value: value,
                                percent: special, // 饼图
                                indicator: special, // 雷达图
                                value2: special2,
                                indicator2: special2,
                                // 向下兼容
                                0: serie.name || '',
                                1: name,
                                2: value,
                                3: special,
                                4: special2,
                                5: data,
                                6: seriesIndex,
                                7: dataIndex
                            },
                            this._curTicket,
                            this._setContent
                        );
                    } else if (typeof formatter === 'string') {
                        this._curTicket = NaN;
                        formatter = formatter.replace('{a}', '{a0}')
                            .replace('{b}', '{b0}')
                            .replace('{c}', '{c0}');
                        formatter = formatter.replace('{a0}', this._encodeHTML(serie.name || ''))
                            .replace('{b0}', this._encodeHTML(name))
                            .replace(
                                '{c0}',
                                value instanceof Array ? value : this.numAddCommas(value)
                            );

                        formatter = formatter.replace('{d}', '{d0}')
                            .replace('{d0}', special || '');
                        formatter = formatter.replace('{e}', '{e0}')
                            .replace(
                                '{e0}',
                                ecData.get(this._curTarget, 'special2') || ''
                            );

                        this._tDom.innerHTML = formatter;
                    } else {
                        this._curTicket = NaN;
                        if (serie.type === ecConfig.CHART_TYPE_RADAR && special) {
                            this._tDom.innerHTML = this._itemFormatter.radar.call(
                                this, serie, name, value, special
                            );
                        }
                        // chord 处理暂时跟 force 一样
                        // else if (serie.type === ecConfig.CHART_TYPE_CHORD) {
                        //     this._tDom.innerHTML = this._itemFormatter.chord.call(
                        //         this, serie, name, value, special, special2
                        //     );
                        // }
                        else if (serie.type === ecConfig.CHART_TYPE_EVENTRIVER) {
                            this._tDom.innerHTML = this._itemFormatter.eventRiver.call(
                                this, serie, name, value, data
                            );
                        } else {
                            this._tDom.innerHTML = '' + (serie.name != null ? (this._encodeHTML(serie.name) + '<br/>') : '') + (name === '' ? '' : (this._encodeHTML(name) + ' : ')) + (value instanceof Array ? value : this.numAddCommas(value));
                        }
                    }
                }

                var x = zrEvent.getX(this._event);
                var y = zrEvent.getY(this._event);
                if (this.deepQuery(queryTarget, 'tooltip.axisPointer.show') && this.component.grid) {
                    this._styleAxisPointer(
                        [serie],
                        this.component.grid.getX(), y,
                        this.component.grid.getXend(), y,
                        0, x, y
                    );
                } else {
                    this._hide();
                }

                // don't modify, just false, showContent == undefined == true
                if (showContent === false || !this.option.tooltip.showContent) {
                    // 只用tooltip的行为，不显示主体
                    return;
                }

                if (!this.hasAppend) {
                    this._tDom.style.left = this._zrWidth / 2 + 'px';
                    this._tDom.style.top = this._zrHeight / 2 + 'px';
                    this.dom.firstChild.appendChild(this._tDom);
                    this.hasAppend = true;
                }

                this._show(position, x + 20, y - 20, specialCssText);
            },

            _itemFormatter: {
                radar: function(serie, name, value, indicator) {
                    var html = '';
                    html += this._encodeHTML(name === '' ? (serie.name || '') : name);
                    html += html === '' ? '' : '<br />';
                    for (var i = 0; i < indicator.length; i++) {
                        html += this._encodeHTML(indicator[i].text) + ' : ' + this.numAddCommas(value[i]) + '<br />';
                    }
                    return html;
                },
                chord: function(serie, name, value, special, special2) {
                    if (special2 == null) {
                        // 外环上
                        return this._encodeHTML(name) + ' (' + this.numAddCommas(value) + ')';
                    } else {
                        var name1 = this._encodeHTML(name);
                        var name2 = this._encodeHTML(special);
                        // 内部弦上
                        return '' + (serie.name != null ? (this._encodeHTML(serie.name) + '<br/>') : '') + name1 + ' -> ' + name2 + ' (' + this.numAddCommas(value) + ')' + '<br />' + name2 + ' -> ' + name1 + ' (' + this.numAddCommas(special2) + ')';
                    }
                },
                eventRiver: function(serie, name, value, data) {
                    var html = '';
                    html += this._encodeHTML(serie.name === '' ? '' : (serie.name + ' : '));
                    html += this._encodeHTML(name);
                    html += html === '' ? '' : '<br />';
                    data = data.evolution;
                    for (var i = 0, l = data.length; i < l; i++) {
                        html += '<div style="padding-top:5px;">';
                        if (!data[i].detail) {
                            continue;
                        }
                        if (data[i].detail.img) {
                            html += '<img src="' + data[i].detail.img + '" style="float:left;width:40px;height:40px;">';
                        }
                        html += '<div style="margin-left:45px;">' + data[i].time + '<br/>';
                        html += '<a href="' + data[i].detail.link + '" target="_blank">';
                        html += data[i].detail.text + '</a></div>';
                        html += '</div>';
                    }
                    return html;
                }
            },

            /**
             * 设置坐标轴指示器样式 
             */
            _styleAxisPointer: function(seriesArray, xStart, yStart, xEnd, yEnd, gap, x, y) {
                if (seriesArray.length > 0) {
                    var queryTarget;
                    var curType;
                    var axisPointer = this.option.tooltip.axisPointer;
                    var pointType = axisPointer.type;
                    var style = {
                        line: {},
                        cross: {},
                        shadow: {}
                    };
                    for (var pType in style) {
                        style[pType].color = axisPointer[pType + 'Style'].color;
                        style[pType].width = axisPointer[pType + 'Style'].width;
                        style[pType].type = axisPointer[pType + 'Style'].type;
                    }
                    for (var i = 0, l = seriesArray.length; i < l; i++) {
                        //if (this.deepQuery([seriesArray[i], this.option], 'tooltip.trigger') === 'axis') {
                        queryTarget = seriesArray[i];
                        curType = this.query(queryTarget, 'tooltip.axisPointer.type');
                        pointType = curType || pointType;
                        if (curType) {
                            style[curType].color = this.query(
                                queryTarget,
                                'tooltip.axisPointer.' + curType + 'Style.color'
                            ) || style[curType].color;
                            style[curType].width = this.query(
                                queryTarget,
                                'tooltip.axisPointer.' + curType + 'Style.width'
                            ) || style[curType].width;
                            style[curType].type = this.query(
                                queryTarget,
                                'tooltip.axisPointer.' + curType + 'Style.type'
                            ) || style[curType].type;
                        }
                        //}
                    }

                    if (pointType === 'line') {
                        var lineWidth = style.line.width;
                        var isVertical = xStart == xEnd;
                        this._axisLineShape.style = {
                            xStart: isVertical ? this.subPixelOptimize(xStart, lineWidth) : xStart,
                            yStart: isVertical ? yStart : this.subPixelOptimize(yStart, lineWidth),
                            xEnd: isVertical ? this.subPixelOptimize(xEnd, lineWidth) : xEnd,
                            yEnd: isVertical ? yEnd : this.subPixelOptimize(yEnd, lineWidth),
                            strokeColor: style.line.color,
                            lineWidth: lineWidth,
                            lineType: style.line.type
                        };
                        this._axisLineShape.invisible = false;
                        this.zr.modShape(this._axisLineShape.id);
                    } else if (pointType === 'cross') {
                        var crossWidth = style.cross.width;
                        this._axisCrossShape.style = {
                            brushType: 'stroke',
                            rect: this.component.grid.getArea(),
                            x: this.subPixelOptimize(x, crossWidth),
                            y: this.subPixelOptimize(y, crossWidth),
                            text: ('( ' + this.component.xAxis.getAxis(0).getValueFromCoord(x) + ' , ' + this.component.yAxis.getAxis(0).getValueFromCoord(y) + ' )').replace('  , ', ' ').replace(' ,  ', ' '),
                            textPosition: 'specific',
                            strokeColor: style.cross.color,
                            lineWidth: crossWidth,
                            lineType: style.cross.type
                        };
                        if (this.component.grid.getXend() - x > 100) { // 右侧有空间
                            this._axisCrossShape.style.textAlign = 'left';
                            this._axisCrossShape.style.textX = x + 10;
                        } else {
                            this._axisCrossShape.style.textAlign = 'right';
                            this._axisCrossShape.style.textX = x - 10;
                        }
                        if (y - this.component.grid.getY() > 50) { // 上方有空间
                            this._axisCrossShape.style.textBaseline = 'bottom';
                            this._axisCrossShape.style.textY = y - 10;
                        } else {
                            this._axisCrossShape.style.textBaseline = 'top';
                            this._axisCrossShape.style.textY = y + 10;
                        }
                        this._axisCrossShape.invisible = false;
                        this.zr.modShape(this._axisCrossShape.id);
                    } else if (pointType === 'shadow') {
                        if (style.shadow.width == null || style.shadow.width === 'auto' || isNaN(style.shadow.width)) {
                            style.shadow.width = gap;
                        }
                        if (xStart === xEnd) {
                            // 纵向
                            if (Math.abs(this.component.grid.getX() - xStart) < 2) {
                                // 最左边
                                style.shadow.width /= 2;
                                xStart = xEnd = xEnd + style.shadow.width / 2;
                            } else if (Math.abs(this.component.grid.getXend() - xStart) < 2) {
                                // 最右边
                                style.shadow.width /= 2;
                                xStart = xEnd = xEnd - style.shadow.width / 2;
                            }
                        } else if (yStart === yEnd) {
                            // 横向
                            if (Math.abs(this.component.grid.getY() - yStart) < 2) {
                                // 最上边
                                style.shadow.width /= 2;
                                yStart = yEnd = yEnd + style.shadow.width / 2;
                            } else if (Math.abs(this.component.grid.getYend() - yStart) < 2) {
                                // 最右边
                                style.shadow.width /= 2;
                                yStart = yEnd = yEnd - style.shadow.width / 2;
                            }
                        }
                        this._axisShadowShape.style = {
                            xStart: xStart,
                            yStart: yStart,
                            xEnd: xEnd,
                            yEnd: yEnd,
                            strokeColor: style.shadow.color,
                            lineWidth: style.shadow.width
                        };
                        this._axisShadowShape.invisible = false;
                        this.zr.modShape(this._axisShadowShape.id);
                    }
                    this.zr.refreshNextFrame();
                }
            },

            __onmousemove: function(param) {
                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                if (this._mousein && this._enterable) {
                    return;
                }
                var target = param.target;
                var mx = zrEvent.getX(param.event);
                var my = zrEvent.getY(param.event);
                if (!target) {
                    // 判断是否落到直角系里，axis触发的tooltip
                    this._curTarget = false;
                    this._event = param.event;
                    // this._event._target = this._event.target || this._event.toElement;
                    this._event.zrenderX = mx;
                    this._event.zrenderY = my;
                    if (this._needAxisTrigger && this.component.grid && zrArea.isInside(rectangleInstance, this.component.grid.getArea(), mx, my)) {
                        this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                    } else if (this._needAxisTrigger && this.component.polar && this.component.polar.isInside([mx, my]) != -1) {
                        this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                    } else {
                        !this._event.connectTrigger && this.messageCenter.dispatch(
                            ecConfig.EVENT.TOOLTIP_OUT_GRID,
                            this._event,
                            null,
                            this.myChart
                        );
                        this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                    }
                } else {
                    this._curTarget = target;
                    this._event = param.event;
                    // this._event._target = this._event.target || this._event.toElement;
                    this._event.zrenderX = mx;
                    this._event.zrenderY = my;
                    var polarIndex;
                    if (this._needAxisTrigger && this.component.polar && (polarIndex = this.component.polar.isInside([mx, my])) != -1) {
                        // 看用这个polar的系列数据是否是axis触发，如果是设置_curTarget为nul
                        var series = this.option.series;
                        for (var i = 0, l = series.length; i < l; i++) {
                            if (series[i].polarIndex === polarIndex && this.deepQuery(
                                    [series[i], this.option], 'tooltip.trigger'
                                ) === 'axis') {
                                this._curTarget = null;
                                break;
                            }
                        }

                    }
                    this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                }
            },

            /**
             * zrender事件响应：鼠标离开绘图区域
             */
            __onglobalout: function() {
                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                this._hidingTicket = setTimeout(this._hide, this._hideDelay);
            },

            /**
             * 异步回调填充内容
             */
            __setContent: function(ticket, content) {
                if (!this._tDom) {
                    return;
                }
                if (ticket === this._curTicket) {
                    this._tDom.innerHTML = content;
                }

                setTimeout(this._refixed, 20);
            },

            ontooltipHover: function(param, tipShape) {
                if (!this._lastTipShape // 不存在或者存在但dataIndex发生变化才需要重绘
                    || (this._lastTipShape && this._lastTipShape.dataIndex != param.dataIndex)
                ) {
                    if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                        this.zr.delShape(this._lastTipShape.tipShape);
                        this.shapeList.length = 2;
                    }
                    for (var i = 0, l = tipShape.length; i < l; i++) {
                        tipShape[i].zlevel = this.getZlevelBase();
                        tipShape[i].z = this.getZBase();

                        tipShape[i].style = zrShapeBase.prototype.getHighlightStyle(
                            tipShape[i].style,
                            tipShape[i].highlightStyle
                        );
                        tipShape[i].draggable = false;
                        tipShape[i].hoverable = false;
                        tipShape[i].clickable = false;
                        tipShape[i].ondragend = null;
                        tipShape[i].ondragover = null;
                        tipShape[i].ondrop = null;
                        this.shapeList.push(tipShape[i]);
                        this.zr.addShape(tipShape[i]);
                    }
                    this._lastTipShape = {
                        dataIndex: param.dataIndex,
                        tipShape: tipShape
                    };
                }
            },

            ondragend: function() {
                this._hide();
            },

            /**
             * 图例选择
             */
            onlegendSelected: function(param) {
                this._selectedMap = param.selected;
            },

            _setSelectedMap: function() {
                if (this.component.legend) {
                    this._selectedMap = zrUtil.clone(this.component.legend.getSelectedMap());
                } else {
                    this._selectedMap = {};
                }
            },

            _isSelected: function(itemName) {
                if (this._selectedMap[itemName] != null) {
                    return this._selectedMap[itemName];
                } else {
                    return true; // 没在legend里定义的都为true啊~
                }
            },

            /**
             * 模拟tooltip hover方法
             * {object} params  参数
             *          {seriesIndex: 0, seriesName:'', dataInex:0} line、bar、scatter、k、radar
             *          {seriesIndex: 0, seriesName:'', name:''} map、pie、chord
             */
            showTip: function(params) {
                if (!params) {
                    return;
                }

                var seriesIndex;
                var series = this.option.series;
                if (params.seriesIndex != null) {
                    seriesIndex = params.seriesIndex;
                } else {
                    var seriesName = params.seriesName;
                    for (var i = 0, l = series.length; i < l; i++) {
                        if (series[i].name === seriesName) {
                            seriesIndex = i;
                            break;
                        }
                    }
                }

                var serie = series[seriesIndex];
                if (serie == null) {
                    return;
                }
                var chart = this.myChart.chart[serie.type];
                var isAxisTrigger = this.deepQuery(
                    [serie, this.option], 'tooltip.trigger'
                ) === 'axis';

                if (!chart) {
                    return;
                }

                if (isAxisTrigger) {
                    // axis trigger
                    var dataIndex = params.dataIndex;
                    switch (chart.type) {
                        case ecConfig.CHART_TYPE_LINE:
                        case ecConfig.CHART_TYPE_BAR:
                        case ecConfig.CHART_TYPE_K:
                        case ecConfig.CHART_TYPE_RADAR:
                            if (this.component.polar == null || serie.data[0].value.length <= dataIndex) {
                                return;
                            }
                            var polarIndex = serie.polarIndex || 0;
                            var vector = this.component.polar.getVector(
                                polarIndex, dataIndex, 'max'
                            );
                            this._event = {
                                zrenderX: vector[0],
                                zrenderY: vector[1]
                            };
                            this._showPolarTrigger(
                                polarIndex,
                                dataIndex
                            );
                            break;
                    }
                } else {
                    // item trigger
                    var shapeList = chart.shapeList;
                    var x;
                    var y;
                    switch (chart.type) {
                        case ecConfig.CHART_TYPE_LINE:
                        case ecConfig.CHART_TYPE_BAR:
                        case ecConfig.CHART_TYPE_K:
                        case ecConfig.CHART_TYPE_TREEMAP:
                        case ecConfig.CHART_TYPE_SCATTER:
                            var dataIndex = params.dataIndex;
                            for (var i = 0, l = shapeList.length; i < l; i++) {
                                if (shapeList[i]._mark == null && ecData.get(shapeList[i], 'seriesIndex') == seriesIndex && ecData.get(shapeList[i], 'dataIndex') == dataIndex) {
                                    this._curTarget = shapeList[i];
                                    x = shapeList[i].style.x;
                                    y = chart.type != ecConfig.CHART_TYPE_K ? shapeList[i].style.y : shapeList[i].style.y[0];
                                    break;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_RADAR:
                            var dataIndex = params.dataIndex;
                            for (var i = 0, l = shapeList.length; i < l; i++) {
                                if (shapeList[i].type === 'polygon' && ecData.get(shapeList[i], 'seriesIndex') == seriesIndex && ecData.get(shapeList[i], 'dataIndex') == dataIndex) {
                                    this._curTarget = shapeList[i];
                                    var vector = this.component.polar.getCenter(
                                        serie.polarIndex || 0
                                    );
                                    x = vector[0];
                                    y = vector[1];
                                    break;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_PIE:
                            var name = params.name;
                            for (var i = 0, l = shapeList.length; i < l; i++) {
                                if (shapeList[i].type === 'sector' && ecData.get(shapeList[i], 'seriesIndex') == seriesIndex && ecData.get(shapeList[i], 'name') == name) {
                                    this._curTarget = shapeList[i];
                                    var style = this._curTarget.style;
                                    var midAngle = (style.startAngle + style.endAngle) / 2 * Math.PI / 180;
                                    x = this._curTarget.style.x + Math.cos(midAngle) * style.r / 1.5;
                                    y = this._curTarget.style.y - Math.sin(midAngle) * style.r / 1.5;
                                    break;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_MAP:
                            var name = params.name;
                            var mapType = serie.mapType;
                            for (var i = 0, l = shapeList.length; i < l; i++) {
                                if (shapeList[i].type === 'text' && shapeList[i]._mapType === mapType && shapeList[i].style._name === name) {
                                    this._curTarget = shapeList[i];
                                    x = this._curTarget.style.x + this._curTarget.position[0];
                                    y = this._curTarget.style.y + this._curTarget.position[1];
                                    break;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_CHORD:
                            var name = params.name;
                            for (var i = 0, l = shapeList.length; i < l; i++) {
                                if (shapeList[i].type === 'sector' && ecData.get(shapeList[i], 'name') == name) {
                                    this._curTarget = shapeList[i];
                                    var style = this._curTarget.style;
                                    var midAngle = (style.startAngle + style.endAngle) / 2 * Math.PI / 180;
                                    x = this._curTarget.style.x + Math.cos(midAngle) * (style.r - 2);
                                    y = this._curTarget.style.y - Math.sin(midAngle) * (style.r - 2);
                                    this.zr.trigger(
                                        zrConfig.EVENT.MOUSEMOVE, {
                                            zrenderX: x,
                                            zrenderY: y
                                        }
                                    );
                                    return;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_FORCE:
                            var name = params.name;
                            for (var i = 0, l = shapeList.length; i < l; i++) {
                                if (shapeList[i].type === 'circle' && ecData.get(shapeList[i], 'name') == name) {
                                    this._curTarget = shapeList[i];
                                    x = this._curTarget.position[0];
                                    y = this._curTarget.position[1];
                                    break;
                                }
                            }
                            break;
                    }
                    if (x != null && y != null) {
                        this._event = {
                            zrenderX: x,
                            zrenderY: y
                        };
                        this.zr.addHoverShape(this._curTarget);
                        this.zr.refreshHover();
                        this._showItemTrigger();
                    }
                }
            },

            /**
             * 关闭，公开接口 
             */
            hideTip: function() {
                this._hide();
            },

            /**
             * 刷新
             */
            refresh: function(newOption) {
                // this._selectedMap;
                // this._defaultCssText;    // css样式缓存
                // this._needAxisTrigger;   // 坐标轴触发
                // this._curTarget;
                // this._event;
                // this._curTicket;         // 异步回调标识，用来区分多个请求

                // 缓存一些高宽数据
                this._zrHeight = this.zr.getHeight();
                this._zrWidth = this.zr.getWidth();

                if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                }
                this._lastTipShape = false;
                this.shapeList.length = 2;

                this._lastDataIndex = -1;
                this._lastSeriesIndex = -1;
                this._lastItemTriggerId = -1;

                if (newOption) {
                    this.option = newOption;
                    this.option.tooltip = this.reformOption(this.option.tooltip);

                    this.option.tooltip.textStyle = zrUtil.merge(
                        this.option.tooltip.textStyle,
                        this.ecTheme.textStyle
                    );
                    this._needAxisTrigger = false;
                    if (this.option.tooltip.trigger === 'axis') {
                        this._needAxisTrigger = true;
                    }

                    var series = this.option.series;
                    for (var i = 0, l = series.length; i < l; i++) {
                        if (this.query(series[i], 'tooltip.trigger') === 'axis') {
                            this._needAxisTrigger = true;
                            break;
                        }
                    }
                    // this._hidingTicket;
                    // this._showingTicket;
                    this._showDelay = this.option.tooltip.showDelay; // 显示延迟
                    this._hideDelay = this.option.tooltip.hideDelay; // 隐藏延迟
                    this._defaultCssText = this._style(this.option.tooltip);

                    this._setSelectedMap();
                    this._axisLineWidth = this.option.tooltip.axisPointer.lineStyle.width;
                    this._enterable = this.option.tooltip.enterable;

                    if (!this._enterable && this._tDom.className.indexOf(zrConfig.elementClassName) < 0) {
                        this._tDom.className += ' ' + zrConfig.elementClassName;
                    }
                }
                if (this.showing) {
                    var self = this;
                    setTimeout(function() {
                        self.zr.trigger(zrConfig.EVENT.MOUSEMOVE, self.zr.handler._event);
                    }, 50);
                }
            },

            /**
             * 释放后实例不可用，重载基类方法
             */
            onbeforDispose: function() {
                if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                }
                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
                this.zr.un(zrConfig.EVENT.GLOBALOUT, this._onglobalout);

                if (this.hasAppend && !!this.dom.firstChild) {
                    this.dom.firstChild.removeChild(this._tDom);
                }
                this._tDom = null;
            },

            /**
             * html转码的方法
             */
            _encodeHTML: function(source) {
                return String(source)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }
        };

        zrUtil.inherits(Tooltip, Base);

        require('../component').define('tooltip', Tooltip);

        return Tooltip;
    });
    define('zrender/loadingEffect/Ring', ['require', './Base', '../tool/util', '../tool/color', '../shape/Ring', '../shape/Sector'], function(require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrColor = require('../tool/color');
        var RingShape = require('../shape/Ring');
        var SectorShape = require('../shape/Sector');

        function Ring(options) {
            Base.call(this, options);
        }
        util.inherits(Ring, Base);


        /**
         * 圆环
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Ring.prototype._start = function(addShapeHandle, refreshHandle) {

            // 特效默认配置
            var options = util.merge(
                this.options, {
                    textStyle: {
                        color: '#07a'
                    },
                    backgroundColor: 'rgba(250, 250, 250, 0.8)',
                    effect: {
                        x: this.canvasWidth / 2,
                        y: this.canvasHeight / 2,
                        r0: 60,
                        r: 100,
                        color: '#bbdcff',
                        brushType: 'fill',
                        textPosition: 'inside',
                        textFont: 'normal 30px verdana',
                        textColor: 'rgba(30, 144, 255, 0.6)',
                        timeInterval: 100
                    }
                }
            );

            var effectOption = options.effect;

            var textStyle = options.textStyle;
            if (textStyle.x == null) {
                textStyle.x = effectOption.x;
            }
            if (textStyle.y == null) {
                textStyle.y = (effectOption.y + (effectOption.r0 + effectOption.r) / 2 - 5);
            }

            var textShape = this.createTextShape(options.textStyle);
            var background = this.createBackgroundShape(options.backgroundColor);

            var x = effectOption.x;
            var y = effectOption.y;
            var r0 = effectOption.r0 + 6;
            var r = effectOption.r - 6;
            var color = effectOption.color;
            var darkColor = zrColor.lift(color, 0.1);

            var shapeRing = new RingShape({
                highlightStyle: util.clone(effectOption)
            });

            // 初始化动画元素
            var shapeList = [];
            var clolrList = zrColor.getGradientColors(
                ['#ff6400', '#ffe100', '#97ff00'], 25
            );
            var preAngle = 15;
            var endAngle = 240;

            for (var i = 0; i < 16; i++) {
                shapeList.push(new SectorShape({
                    highlightStyle: {
                        x: x,
                        y: y,
                        r0: r0,
                        r: r,
                        startAngle: endAngle - preAngle,
                        endAngle: endAngle,
                        brushType: 'fill',
                        color: darkColor
                    },
                    _color: zrColor.getLinearGradient(
                        x + r0 * Math.cos(endAngle, true),
                        y - r0 * Math.sin(endAngle, true),
                        x + r0 * Math.cos(endAngle - preAngle, true),
                        y - r0 * Math.sin(endAngle - preAngle, true), [
                            [0, clolrList[i * 2]],
                            [1, clolrList[i * 2 + 1]]
                        ]
                    )
                }));
                endAngle -= preAngle;
            }
            endAngle = 360;
            for (var i = 0; i < 4; i++) {
                shapeList.push(new SectorShape({
                    highlightStyle: {
                        x: x,
                        y: y,
                        r0: r0,
                        r: r,
                        startAngle: endAngle - preAngle,
                        endAngle: endAngle,
                        brushType: 'fill',
                        color: darkColor
                    },
                    _color: zrColor.getLinearGradient(
                        x + r0 * Math.cos(endAngle, true),
                        y - r0 * Math.sin(endAngle, true),
                        x + r0 * Math.cos(endAngle - preAngle, true),
                        y - r0 * Math.sin(endAngle - preAngle, true), [
                            [0, clolrList[i * 2 + 32]],
                            [1, clolrList[i * 2 + 33]]
                        ]
                    )
                }));
                endAngle -= preAngle;
            }

            var n = 0;
            if (options.progress != null) {
                // 指定进度
                addShapeHandle(background);

                n = this.adjust(options.progress, [0, 1]).toFixed(2) * 100 / 5;
                shapeRing.highlightStyle.text = n * 5 + '%';
                addShapeHandle(shapeRing);

                for (var i = 0; i < 20; i++) {
                    shapeList[i].highlightStyle.color = i < n ? shapeList[i]._color : darkColor;
                    addShapeHandle(shapeList[i]);
                }

                addShapeHandle(textShape);
                refreshHandle();
                return;
            }

            // 循环显示
            return setInterval(
                function() {
                    addShapeHandle(background);

                    n += n >= 20 ? -20 : 1;

                    // shapeRing.highlightStyle.text = n * 5 + '%';
                    addShapeHandle(shapeRing);

                    for (var i = 0; i < 20; i++) {
                        shapeList[i].highlightStyle.color = i < n ? shapeList[i]._color : darkColor;
                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return Ring;
    });
    define('zrender/loadingEffect/Whirling', ['require', './Base', '../tool/util', '../tool/area', '../shape/Ring', '../shape/Droplet', '../shape/Circle'], function(require) {
        var Base = require('./Base');
        var util = require('../tool/util');
        var zrArea = require('../tool/area');
        var RingShape = require('../shape/Ring');
        var DropletShape = require('../shape/Droplet');
        var CircleShape = require('../shape/Circle');

        function Whirling(options) {
            Base.call(this, options);
        }
        util.inherits(Whirling, Base);

        /**
         * 旋转水滴
         * 
         * @param {Object} addShapeHandle
         * @param {Object} refreshHandle
         */
        Whirling.prototype._start = function(addShapeHandle, refreshHandle) {
            var options = util.merge(
                this.options, {
                    textStyle: {
                        color: '#888',
                        textAlign: 'start'
                    },
                    backgroundColor: 'rgba(250, 250, 250, 0.8)'
                }
            );
            var textShape = this.createTextShape(options.textStyle);

            var textGap = 10;
            var textWidth = zrArea.getTextWidth(
                textShape.highlightStyle.text, textShape.highlightStyle.textFont
            );
            var textHeight = zrArea.getTextHeight(
                textShape.highlightStyle.text, textShape.highlightStyle.textFont
            );

            // 特效默认配置
            var effectOption = util.merge(
                this.options.effect || {}, {
                    r: 18,
                    colorIn: '#fff',
                    colorOut: '#555',
                    colorWhirl: '#6cf',
                    timeInterval: 50
                }
            );

            var location = this.getLocation(
                this.options.textStyle,
                textWidth + textGap + effectOption.r * 2,
                Math.max(effectOption.r * 2, textHeight)
            );
            effectOption.x = location.x + effectOption.r;
            effectOption.y = textShape.highlightStyle.y = location.y + location.height / 2;
            textShape.highlightStyle.x = effectOption.x + effectOption.r + textGap;

            var background = this.createBackgroundShape(options.backgroundColor);
            // 初始化动画元素
            var droplet = new DropletShape({
                highlightStyle: {
                    a: Math.round(effectOption.r / 2),
                    b: Math.round(effectOption.r - effectOption.r / 6),
                    brushType: 'fill',
                    color: effectOption.colorWhirl
                }
            });
            var circleIn = new CircleShape({
                highlightStyle: {
                    r: Math.round(effectOption.r / 6),
                    brushType: 'fill',
                    color: effectOption.colorIn
                }
            });
            var circleOut = new RingShape({
                highlightStyle: {
                    r0: Math.round(effectOption.r - effectOption.r / 3),
                    r: effectOption.r,
                    brushType: 'fill',
                    color: effectOption.colorOut
                }
            });

            var pos = [0, effectOption.x, effectOption.y];

            droplet.highlightStyle.x = circleIn.highlightStyle.x = circleOut.highlightStyle.x = pos[1];
            droplet.highlightStyle.y = circleIn.highlightStyle.y = circleOut.highlightStyle.y = pos[2];

            return setInterval(
                function() {
                    addShapeHandle(background);
                    addShapeHandle(circleOut);
                    pos[0] -= 0.3;
                    droplet.rotation = pos;
                    addShapeHandle(droplet);
                    addShapeHandle(circleIn);
                    addShapeHandle(textShape);
                    refreshHandle();
                },
                effectOption.timeInterval
            );
        };

        return Whirling;
    });
    define('echarts/theme/macarons', [], function() {

        var theme = {
            // 默认色板
            color: [
                '#2ec7c9', '#b6a2de', '#5ab1ef', '#ffb980', '#d87a80',
                '#8d98b3', '#e5cf0d', '#97b552', '#95706d', '#dc69aa',
                '#07a2a4', '#9a7fd1', '#588dd5', '#f5994e', '#c05050',
                '#59678c', '#c9ab00', '#7eb00a', '#6f5553', '#c14089'
            ],

            // 图表标题
            title: {
                textStyle: {
                    fontWeight: 'normal',
                    color: '#008acd' // 主标题文字颜色
                }
            },

            // 值域
            dataRange: {
                itemWidth: 15,
                color: ['#5ab1ef', '#e0ffff']
            },

            // 工具箱
            toolbox: {
                color: ['#1e90ff', '#1e90ff', '#1e90ff', '#1e90ff'],
                effectiveColor: '#ff4500'
            },

            // 提示框
            tooltip: {
                backgroundColor: 'rgba(50,50,50,0.5)', // 提示背景颜色，默认为透明度为0.7的黑色
                axisPointer: { // 坐标轴指示器，坐标轴触发有效
                    type: 'line', // 默认为直线，可选为：'line' | 'shadow'
                    lineStyle: { // 直线指示器样式设置
                        color: '#008acd'
                    },
                    crossStyle: {
                        color: '#008acd'
                    },
                    shadowStyle: { // 阴影指示器样式设置
                        color: 'rgba(200,200,200,0.2)'
                    }
                }
            },

            // 区域缩放控制器
            dataZoom: {
                dataBackgroundColor: '#efefff', // 数据背景颜色
                fillerColor: 'rgba(182,162,222,0.2)', // 填充颜色
                handleColor: '#008acd' // 手柄颜色
            },

            // 网格
            grid: {
                borderColor: '#eee'
            },

            // 类目轴
            categoryAxis: {
                axisLine: { // 坐标轴线
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: '#008acd'
                    }
                },
                splitLine: { // 分隔线
                    lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式
                        color: ['#eee']
                    }
                }
            },

            // 数值型坐标轴默认参数
            valueAxis: {
                axisLine: { // 坐标轴线
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: '#008acd'
                    }
                },
                splitArea: {
                    show: true,
                    areaStyle: {
                        color: ['rgba(250,250,250,0.1)', 'rgba(200,200,200,0.1)']
                    }
                },
                splitLine: { // 分隔线
                    lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式
                        color: ['#eee']
                    }
                }
            },

            polar: {
                axisLine: { // 坐标轴线
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: '#ddd'
                    }
                },
                splitArea: {
                    show: true,
                    areaStyle: {
                        color: ['rgba(250,250,250,0.2)', 'rgba(200,200,200,0.2)']
                    }
                },
                splitLine: {
                    lineStyle: {
                        color: '#ddd'
                    }
                }
            },

            timeline: {
                lineStyle: {
                    color: '#008acd'
                },
                controlStyle: {
                    normal: {
                        color: '#008acd'
                    },
                    emphasis: {
                        color: '#008acd'
                    }
                },
                symbol: 'emptyCircle',
                symbolSize: 3
            },

            // 柱形图默认参数
            bar: {
                itemStyle: {
                    normal: {
                        barBorderRadius: 5
                    },
                    emphasis: {
                        barBorderRadius: 5
                    }
                }
            },

            // 折线图默认参数
            line: {
                smooth: true,
                symbol: 'emptyCircle', // 拐点图形类型
                symbolSize: 3 // 拐点图形大小
            },

            // K线图默认参数
            k: {
                itemStyle: {
                    normal: {
                        color: '#d87a80', // 阳线填充颜色
                        color0: '#2ec7c9', // 阴线填充颜色
                        lineStyle: {
                            color: '#d87a80', // 阳线边框颜色
                            color0: '#2ec7c9' // 阴线边框颜色
                        }
                    }
                }
            },

            // 散点图默认参数
            scatter: {
                symbol: 'circle', // 图形类型
                symbolSize: 4 // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
            },

            // 雷达图默认参数
            radar: {
                symbol: 'emptyCircle', // 图形类型
                symbolSize: 3
                    //symbol: null,         // 拐点图形类型
                    //symbolRotate : null,  // 图形旋转控制
            },

            map: {
                itemStyle: {
                    normal: {
                        areaStyle: {
                            color: '#ddd'
                        },
                        label: {
                            textStyle: {
                                color: '#d87a80'
                            }
                        }
                    },
                    emphasis: { // 也是选中样式
                        areaStyle: {
                            color: '#fe994e'
                        }
                    }
                }
            },

            force: {
                itemStyle: {
                    normal: {
                        linkStyle: {
                            color: '#1e90ff'
                        }
                    }
                }
            },

            chord: {
                itemStyle: {
                    normal: {
                        borderWidth: 1,
                        borderColor: 'rgba(128, 128, 128, 0.5)',
                        chordStyle: {
                            lineStyle: {
                                color: 'rgba(128, 128, 128, 0.5)'
                            }
                        }
                    },
                    emphasis: {
                        borderWidth: 1,
                        borderColor: 'rgba(128, 128, 128, 0.5)',
                        chordStyle: {
                            lineStyle: {
                                color: 'rgba(128, 128, 128, 0.5)'
                            }
                        }
                    }
                }
            },

            gauge: {
                axisLine: { // 坐标轴线
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: [
                            [0.2, '#2ec7c9'],
                            [0.8, '#5ab1ef'],
                            [1, '#d87a80']
                        ],
                        width: 10
                    }
                },
                axisTick: { // 坐标轴小标记
                    splitNumber: 10, // 每份split细分多少段
                    length: 15, // 属性length控制线长
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: 'auto'
                    }
                },
                splitLine: { // 分隔线
                    length: 22, // 属性length控制线长
                    lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式
                        color: 'auto'
                    }
                },
                pointer: {
                    width: 5
                }
            },

            textStyle: {
                fontFamily: '微软雅黑, Arial, Verdana, sans-serif'
            }
        };

        return theme;
    });
    define('echarts/theme/infographic', [], function() {

        var theme = {
            // 默认色板
            color: [
                '#C1232B', '#B5C334', '#FCCE10', '#E87C25', '#27727B',
                '#FE8463', '#9BCA63', '#FAD860', '#F3A43B', '#60C0DD',
                '#D7504B', '#C6E579', '#F4E001', '#F0805A', '#26C0C0'
            ],

            // 图表标题
            title: {
                textStyle: {
                    fontWeight: 'normal',
                    color: '#27727B' // 主标题文字颜色
                }
            },

            // 值域
            dataRange: {
                x: 'right',
                y: 'center',
                itemWidth: 5,
                itemHeight: 25,
                color: ['#C1232B', '#FCCE10']
            },

            toolbox: {
                color: [
                    '#C1232B', '#B5C334', '#FCCE10', '#E87C25', '#27727B',
                    '#FE8463', '#9BCA63', '#FAD860', '#F3A43B', '#60C0DD'
                ],
                effectiveColor: '#ff4500'
            },

            // 提示框
            tooltip: {
                backgroundColor: 'rgba(50,50,50,0.5)', // 提示背景颜色，默认为透明度为0.7的黑色
                axisPointer: { // 坐标轴指示器，坐标轴触发有效
                    type: 'line', // 默认为直线，可选为：'line' | 'shadow'
                    lineStyle: { // 直线指示器样式设置
                        color: '#27727B',
                        type: 'dashed'
                    },
                    crossStyle: {
                        color: '#27727B'
                    },
                    shadowStyle: { // 阴影指示器样式设置
                        color: 'rgba(200,200,200,0.3)'
                    }
                }
            },

            // 区域缩放控制器
            dataZoom: {
                dataBackgroundColor: 'rgba(181,195,52,0.3)', // 数据背景颜色
                fillerColor: 'rgba(181,195,52,0.2)', // 填充颜色
                handleColor: '#27727B' // 手柄颜色
            },

            // 网格
            grid: {
                borderWidth: 0
            },

            // 类目轴
            categoryAxis: {
                axisLine: { // 坐标轴线
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: '#27727B'
                    }
                },
                splitLine: { // 分隔线
                    show: false
                }
            },

            // 数值型坐标轴默认参数
            valueAxis: {
                axisLine: { // 坐标轴线
                    show: false
                },
                splitArea: {
                    show: false
                },
                splitLine: { // 分隔线
                    lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式
                        color: ['#ccc'],
                        type: 'dashed'
                    }
                }
            },

            polar: {
                axisLine: { // 坐标轴线
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: '#ddd'
                    }
                },
                splitArea: {
                    show: true,
                    areaStyle: {
                        color: ['rgba(250,250,250,0.2)', 'rgba(200,200,200,0.2)']
                    }
                },
                splitLine: {
                    lineStyle: {
                        color: '#ddd'
                    }
                }
            },

            timeline: {
                lineStyle: {
                    color: '#27727B'
                },
                controlStyle: {
                    normal: {
                        color: '#27727B'
                    },
                    emphasis: {
                        color: '#27727B'
                    }
                },
                symbol: 'emptyCircle',
                symbolSize: 3
            },

            // 折线图默认参数
            line: {
                itemStyle: {
                    normal: {
                        borderWidth: 2,
                        borderColor: '#fff',
                        lineStyle: {
                            width: 3
                        }
                    },
                    emphasis: {
                        borderWidth: 0
                    }
                },
                symbol: 'circle', // 拐点图形类型
                symbolSize: 3.5 // 拐点图形大小
            },

            // K线图默认参数
            k: {
                itemStyle: {
                    normal: {
                        color: '#C1232B', // 阳线填充颜色
                        color0: '#B5C334', // 阴线填充颜色
                        lineStyle: {
                            width: 1,
                            color: '#C1232B', // 阳线边框颜色
                            color0: '#B5C334' // 阴线边框颜色
                        }
                    }
                }
            },

            // 散点图默认参数
            scatter: {
                itemStyle: {
                    normal: {
                        borderWidth: 1,
                        borderColor: 'rgba(200,200,200,0.5)'
                    },
                    emphasis: {
                        borderWidth: 0
                    }
                },
                symbol: 'star4', // 图形类型
                symbolSize: 4 // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
            },

            // 雷达图默认参数
            radar: {
                symbol: 'emptyCircle', // 图形类型
                symbolSize: 3
                    //symbol: null,         // 拐点图形类型
                    //symbolRotate : null,  // 图形旋转控制
            },

            map: {
                itemStyle: {
                    normal: {
                        areaStyle: {
                            color: '#ddd'
                        },
                        label: {
                            textStyle: {
                                color: '#C1232B'
                            }
                        }
                    },
                    emphasis: { // 也是选中样式
                        areaStyle: {
                            color: '#fe994e'
                        },
                        label: {
                            textStyle: {
                                color: 'rgb(100,0,0)'
                            }
                        }
                    }
                }
            },

            force: {
                itemStyle: {
                    normal: {
                        linkStyle: {
                            color: '#27727B'
                        }
                    }
                }
            },

            chord: {
                itemStyle: {
                    normal: {
                        borderWidth: 1,
                        borderColor: 'rgba(128, 128, 128, 0.5)',
                        chordStyle: {
                            lineStyle: {
                                color: 'rgba(128, 128, 128, 0.5)'
                            }
                        }
                    },
                    emphasis: {
                        borderWidth: 1,
                        borderColor: 'rgba(128, 128, 128, 0.5)',
                        chordStyle: {
                            lineStyle: {
                                color: 'rgba(128, 128, 128, 0.5)'
                            }
                        }
                    }
                }
            },

            gauge: {
                center: ['50%', '80%'],
                radius: '100%',
                startAngle: 180,
                endAngle: 0,
                axisLine: { // 坐标轴线
                    show: true, // 默认显示，属性show控制显示与否
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: [
                            [0.2, '#B5C334'],
                            [0.8, '#27727B'],
                            [1, '#C1232B']
                        ],
                        width: '40%'
                    }
                },
                axisTick: { // 坐标轴小标记
                    splitNumber: 2, // 每份split细分多少段
                    length: 5, // 属性length控制线长
                    lineStyle: { // 属性lineStyle控制线条样式
                        color: '#fff'
                    }
                },
                axisLabel: { // 坐标轴文本标签，详见axis.axisLabel
                    textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: '#fff',
                        fontWeight: 'bolder'
                    }
                },
                splitLine: { // 分隔线
                    length: '5%', // 属性length控制线长
                    lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式
                        color: '#fff'
                    }
                },
                pointer: {
                    width: '40%',
                    length: '80%',
                    color: '#fff'
                },
                title: {
                    offsetCenter: [0, -20], // x, y，单位px
                    textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: 'auto',
                        fontSize: 20
                    }
                },
                detail: {
                    offsetCenter: [0, 0], // x, y，单位px
                    textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: 'auto',
                        fontSize: 40
                    }
                }
            },

            textStyle: {
                fontFamily: '微软雅黑, Arial, Verdana, sans-serif'
            }
        };

        return theme;
    });
    define('echarts/chart/base', ['require', 'zrender/shape/Image', '../util/shape/Icon', '../util/shape/MarkLine', '../util/shape/Symbol', 'zrender/shape/Polyline', 'zrender/shape/ShapeBundle', '../config', '../util/ecData', '../util/ecAnimation', '../util/ecEffect', '../util/accMath', '../component/base', '../layout/EdgeBundling', 'zrender/tool/util', 'zrender/tool/area'], function(require) {
        // 图形依赖
        var ImageShape = require('zrender/shape/Image');
        var IconShape = require('../util/shape/Icon');
        var MarkLineShape = require('../util/shape/MarkLine');
        var SymbolShape = require('../util/shape/Symbol');
        var PolylineShape = require('zrender/shape/Polyline');
        var ShapeBundle = require('zrender/shape/ShapeBundle');

        var ecConfig = require('../config');
        var ecData = require('../util/ecData');
        var ecAnimation = require('../util/ecAnimation');
        var ecEffect = require('../util/ecEffect');
        var accMath = require('../util/accMath');
        var ComponentBase = require('../component/base');
        var EdgeBundling = require('../layout/EdgeBundling');

        var zrUtil = require('zrender/tool/util');
        var zrArea = require('zrender/tool/area');

        // Some utility functions
        function isCoordAvailable(coord) {
            return coord.x != null && coord.y != null;
        }

        function Base(ecTheme, messageCenter, zr, option, myChart) {

            ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            this.selectedMap = {};
            this.lastShapeList = [];
            this.shapeHandler = {
                onclick: function() {
                    self.isClick = true;
                },

                ondragover: function(param) {
                    // 返回触发可计算特性的图形提示
                    var calculableShape = param.target;
                    calculableShape.highlightStyle = calculableShape.highlightStyle || {};

                    // 备份特出特性
                    var highlightStyle = calculableShape.highlightStyle;
                    var brushType = highlightStyle.brushTyep;
                    var strokeColor = highlightStyle.strokeColor;
                    var lineWidth = highlightStyle.lineWidth;

                    highlightStyle.brushType = 'stroke';
                    highlightStyle.strokeColor = self.ecTheme.calculableColor || ecConfig.calculableColor;
                    highlightStyle.lineWidth = calculableShape.type === 'icon' ? 30 : 10;

                    self.zr.addHoverShape(calculableShape);

                    setTimeout(function() {
                        // 复位
                        if (highlightStyle) {
                            highlightStyle.brushType = brushType;
                            highlightStyle.strokeColor = strokeColor;
                            highlightStyle.lineWidth = lineWidth;
                        }
                    }, 20);
                },

                ondrop: function(param) {
                    // 排除一些非数据的拖拽进入
                    if (ecData.get(param.dragged, 'data') != null) {
                        self.isDrop = true;
                    }
                },

                ondragend: function() {
                    self.isDragend = true;
                }
            };
        }

        /**
         * 基类方法
         */
        Base.prototype = {
            /**
             * 图形拖拽特性 
             */
            setCalculable: function(shape) {
                shape.dragEnableTime = this.ecTheme.DRAG_ENABLE_TIME || ecConfig.DRAG_ENABLE_TIME;
                shape.ondragover = this.shapeHandler.ondragover;
                shape.ondragend = this.shapeHandler.ondragend;
                shape.ondrop = this.shapeHandler.ondrop;
                return shape;
            },

            /**
             * 数据项被拖拽进来
             */
            ondrop: function(param, status) {
                if (!this.isDrop || !param.target || status.dragIn) {
                    // 没有在当前实例上发生拖拽行为或者已经被认领了则直接返回
                    return;
                }
                var target = param.target; // 拖拽安放目标
                var dragged = param.dragged; // 当前被拖拽的图形对象

                var seriesIndex = ecData.get(target, 'seriesIndex');
                var dataIndex = ecData.get(target, 'dataIndex');

                var series = this.series;
                var data;
                var legend = this.component.legend;
                if (dataIndex === -1) {
                    // 落到calculableCase上，数据被拖拽进某个饼图|雷达|漏斗，增加数据
                    if (ecData.get(dragged, 'seriesIndex') == seriesIndex) {
                        // 自己拖拽到自己
                        status.dragOut = status.dragIn = status.needRefresh = true;
                        this.isDrop = false;
                        return;
                    }

                    data = {
                        value: ecData.get(dragged, 'value'),
                        name: ecData.get(dragged, 'name')
                    };

                    // 修饼图数值不为负值
                    if (this.type === ecConfig.CHART_TYPE_PIE && data.value < 0) {
                        data.value = 0;
                    }

                    var hasFind = false;
                    var sData = series[seriesIndex].data;
                    for (var i = 0, l = sData.length; i < l; i++) {
                        if (sData[i].name === data.name && sData[i].value === '-') {
                            series[seriesIndex].data[i].value = data.value;
                            hasFind = true;
                        }
                    }!hasFind && series[seriesIndex].data.push(data);

                    legend && legend.add(
                        data.name,
                        dragged.style.color || dragged.style.strokeColor
                    );
                } else {
                    // 落到数据item上，数据被拖拽到某个数据项上，数据修改
                    data = series[seriesIndex].data[dataIndex] || '-';
                    if (data.value != null) {
                        if (data.value != '-') {
                            series[seriesIndex].data[dataIndex].value =
                                accMath.accAdd(
                                    series[seriesIndex].data[dataIndex].value,
                                    ecData.get(dragged, 'value')
                                );
                        } else {
                            series[seriesIndex].data[dataIndex].value =
                                ecData.get(dragged, 'value');
                        }

                        if (this.type === ecConfig.CHART_TYPE_FUNNEL || this.type === ecConfig.CHART_TYPE_PIE) {
                            legend && legend.getRelatedAmount(data.name) === 1 && this.component.legend.del(data.name);
                            data.name += this.option.nameConnector + ecData.get(dragged, 'name');
                            legend && legend.add(
                                data.name,
                                dragged.style.color || dragged.style.strokeColor
                            );
                        }
                    } else {
                        if (data != '-') {
                            series[seriesIndex].data[dataIndex] =
                                accMath.accAdd(
                                    series[seriesIndex].data[dataIndex],
                                    ecData.get(dragged, 'value')
                                );
                        } else {
                            series[seriesIndex].data[dataIndex] =
                                ecData.get(dragged, 'value');
                        }
                    }
                }

                // 别status = {}赋值啊！！
                status.dragIn = status.dragIn || true;

                // 处理完拖拽事件后复位
                this.isDrop = false;

                var self = this;
                setTimeout(function() {
                    self.zr.trigger('mousemove', param.event);
                }, 300);

                return;
            },

            /**
             * 数据项被拖拽出去
             */
            ondragend: function(param, status) {
                if (!this.isDragend || !param.target || status.dragOut) {
                    // 没有在当前实例上发生拖拽行为或者已经被认领了则直接返回
                    return;
                }
                var target = param.target; // 被拖拽图形元素

                var seriesIndex = ecData.get(target, 'seriesIndex');
                var dataIndex = ecData.get(target, 'dataIndex');

                var series = this.series;

                // 删除被拖拽走的数据
                if (series[seriesIndex].data[dataIndex].value != null) {
                    series[seriesIndex].data[dataIndex].value = '-';
                    // 清理可能有且唯一的legend data
                    var name = series[seriesIndex].data[dataIndex].name;
                    var legend = this.component.legend;
                    if (legend && legend.getRelatedAmount(name) === 0) {
                        legend.del(name);
                    }
                } else {
                    series[seriesIndex].data[dataIndex] = '-';
                }

                // 别status = {}赋值啊！！
                status.dragOut = true;
                status.needRefresh = true;

                // 处理完拖拽事件后复位
                this.isDragend = false;

                return;
            },

            /**
             * 图例选择
             */
            onlegendSelected: function(param, status) {
                var legendSelected = param.selected;
                for (var itemName in this.selectedMap) {
                    if (this.selectedMap[itemName] != legendSelected[itemName]) {
                        // 有一项不一致都需要重绘
                        status.needRefresh = true;
                    }
                    this.selectedMap[itemName] = legendSelected[itemName];
                }
                return;
            },

            /**
             * 折线图、柱形图公用方法
             */
            _buildPosition: function() {
                this._symbol = this.option.symbolList;
                this._sIndex2ShapeMap = {}; // series拐点图形类型，seriesIndex索引到shape type
                this._sIndex2ColorMap = {}; // series默认颜色索引，seriesIndex索引到color

                this.selectedMap = {};
                this.xMarkMap = {};

                var series = this.series;
                // 水平垂直双向series索引 ，position索引到seriesIndex
                var _position2sIndexMap = {
                    top: [],
                    bottom: [],
                    left: [],
                    right: [],
                    other: []
                };
                var xAxisIndex;
                var yAxisIndex;
                var xAxis;
                var yAxis;
                for (var i = 0, l = series.length; i < l; i++) {
                    if (series[i].type === this.type) {
                        series[i] = this.reformOption(series[i]);
                        this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                        xAxisIndex = series[i].xAxisIndex;
                        yAxisIndex = series[i].yAxisIndex;
                        xAxis = this.component.xAxis.getAxis(xAxisIndex);
                        yAxis = this.component.yAxis.getAxis(yAxisIndex);
                        if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                            _position2sIndexMap[xAxis.getPosition()].push(i);
                        } else if (yAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                            _position2sIndexMap[yAxis.getPosition()].push(i);
                        } else {
                            _position2sIndexMap.other.push(i);
                        }
                    }
                }
                // console.log(_position2sIndexMap);
                for (var position in _position2sIndexMap) {
                    if (_position2sIndexMap[position].length > 0) {
                        this._buildSinglePosition(
                            position, _position2sIndexMap[position]
                        );
                    }
                }

                this.addShapeList();
            },

            /**
             * 构建单个方向上的折线图、柱形图公用方法
             *
             * @param {number} seriesIndex 系列索引
             */
            _buildSinglePosition: function(position, seriesArray) {
                var mapData = this._mapData(seriesArray);
                var locationMap = mapData.locationMap;
                var maxDataLength = mapData.maxDataLength;

                if (maxDataLength === 0 || locationMap.length === 0) {
                    return;
                }
                switch (position) {
                    case 'bottom':
                    case 'top':
                        this._buildHorizontal(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                        break;
                    case 'left':
                    case 'right':
                        this._buildVertical(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                        break;
                    case 'other':
                        this._buildOther(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                        break;
                }

                for (var i = 0, l = seriesArray.length; i < l; i++) {
                    this.buildMark(seriesArray[i]);
                }
            },

            /**
             * 数据整形，折线图、柱形图公用方法
             * 数组位置映射到系列索引
             */
            _mapData: function(seriesArray) {
                var series = this.series;
                var serie; // 临时映射变量
                var dataIndex = 0; // 堆积数据所在位置映射
                var stackMap = {}; // 堆积数据位置映射，堆积组在二维中的第几项
                var magicStackKey = '__kener__stack__'; // 堆积命名，非堆积数据安单一堆积处理
                var stackKey; // 临时映射变量
                var serieName; // 临时映射变量
                var legend = this.component.legend;
                var locationMap = []; // 需要返回的东西：数组位置映射到系列索引
                var maxDataLength = 0; // 需要返回的东西：最大数据长度
                var iconShape;
                // 计算需要显示的个数和分配位置并记在下面这个结构里
                for (var i = 0, l = seriesArray.length; i < l; i++) {
                    serie = series[seriesArray[i]];
                    serieName = serie.name;

                    this._sIndex2ShapeMap[seriesArray[i]] = this._sIndex2ShapeMap[seriesArray[i]] || this.query(serie, 'symbol') || this._symbol[i % this._symbol.length];

                    if (legend) {
                        this.selectedMap[serieName] = legend.isSelected(serieName);

                        this._sIndex2ColorMap[seriesArray[i]] = legend.getColor(serieName);

                        iconShape = legend.getItemShape(serieName);
                        if (iconShape) {
                            // 回调legend，换一个更形象的icon
                            var style = iconShape.style;
                            if (this.type == ecConfig.CHART_TYPE_LINE) {
                                style.iconType = 'legendLineIcon';
                                style.symbol = this._sIndex2ShapeMap[seriesArray[i]];
                            } else if (serie.itemStyle.normal.barBorderWidth > 0) {
                                var highlightStyle = iconShape.highlightStyle;
                                style.brushType = 'both';
                                style.x += 1;
                                style.y += 1;
                                style.width -= 2;
                                style.height -= 2;
                                style.strokeColor = highlightStyle.strokeColor = serie.itemStyle.normal.barBorderColor;
                                highlightStyle.lineWidth = 3;
                            }

                            legend.setItemShape(serieName, iconShape);
                        }
                    } else {
                        this.selectedMap[serieName] = true;
                        this._sIndex2ColorMap[seriesArray[i]] = this.zr.getColor(seriesArray[i]);
                    }

                    if (this.selectedMap[serieName]) {
                        stackKey = serie.stack || (magicStackKey + seriesArray[i]);
                        if (stackMap[stackKey] == null) {
                            stackMap[stackKey] = dataIndex;
                            locationMap[dataIndex] = [seriesArray[i]];
                            dataIndex++;
                        } else {
                            // 已经分配了位置就推进去就行
                            locationMap[stackMap[stackKey]].push(seriesArray[i]);
                        }
                    }
                    // 兼职帮算一下最大长度
                    maxDataLength = Math.max(maxDataLength, serie.data.length);
                }
                /* 调试输出
                var s = '';
                for (var i = 0, l = maxDataLength; i < l; i++) {
                    s = '[';
                    for (var j = 0, k = locationMap.length; j < k; j++) {
                        s +='['
                        for (var m = 0, n = locationMap[j].length - 1; m < n; m++) {
                            s += series[locationMap[j][m]].data[i] + ','
                        }
                        s += series[locationMap[j][locationMap[j].length - 1]]
                             .data[i];
                        s += ']'
                    }
                    s += ']';
                    console.log(s);
                }
                console.log(locationMap)
                */

                return {
                    locationMap: locationMap,
                    maxDataLength: maxDataLength
                };
            },

            _calculMarkMapXY: function(xMarkMap, locationMap, xy) {
                var series = this.series;
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        var seriesIndex = locationMap[j][m];
                        var valueIndex = xy == 'xy' ? 0 : '';
                        var grid = this.component.grid;
                        var tarMark = xMarkMap[seriesIndex];

                        if (xy.indexOf('x') != '-1') {
                            if (tarMark['counter' + valueIndex] > 0) {
                                tarMark['average' + valueIndex] =
                                    tarMark['sum' + valueIndex] / tarMark['counter' + valueIndex];
                            }

                            var x = this.component.xAxis.getAxis(series[seriesIndex].xAxisIndex || 0)
                                .getCoord(tarMark['average' + valueIndex]);
                            tarMark['averageLine' + valueIndex] = [
                                [x, grid.getYend()],
                                [x, grid.getY()]
                            ];
                            tarMark['minLine' + valueIndex] = [
                                [tarMark['minX' + valueIndex], grid.getYend()],
                                [tarMark['minX' + valueIndex], grid.getY()]
                            ];
                            tarMark['maxLine' + valueIndex] = [
                                [tarMark['maxX' + valueIndex], grid.getYend()],
                                [tarMark['maxX' + valueIndex], grid.getY()]
                            ];

                            tarMark.isHorizontal = false;
                        }

                        valueIndex = xy == 'xy' ? 1 : '';
                        if (xy.indexOf('y') != '-1') {
                            if (tarMark['counter' + valueIndex] > 0) {
                                tarMark['average' + valueIndex] =
                                    tarMark['sum' + valueIndex] / tarMark['counter' + valueIndex];
                            }
                            var y = this.component.yAxis.getAxis(series[seriesIndex].yAxisIndex || 0)
                                .getCoord(tarMark['average' + valueIndex]);
                            tarMark['averageLine' + valueIndex] = [
                                [grid.getX(), y],
                                [grid.getXend(), y]
                            ];
                            tarMark['minLine' + valueIndex] = [
                                [grid.getX(), tarMark['minY' + valueIndex]],
                                [grid.getXend(), tarMark['minY' + valueIndex]]
                            ];
                            tarMark['maxLine' + valueIndex] = [
                                [grid.getX(), tarMark['maxY' + valueIndex]],
                                [grid.getXend(), tarMark['maxY' + valueIndex]]
                            ];

                            tarMark.isHorizontal = true;
                        }
                    }
                }
            },

            /**
             * 添加文本 
             */
            addLabel: function(tarShape, serie, data, name, orient) {
                // 多级控制
                var queryTarget = [data, serie];
                var nLabel = this.deepMerge(queryTarget, 'itemStyle.normal.label');
                var eLabel = this.deepMerge(queryTarget, 'itemStyle.emphasis.label');

                var nTextStyle = nLabel.textStyle || {};
                var eTextStyle = eLabel.textStyle || {};

                if (nLabel.show) {
                    var style = tarShape.style;
                    style.text = this._getLabelText(
                        serie, data, name, 'normal'
                    );
                    style.textPosition = nLabel.position == null ? (orient === 'horizontal' ? 'right' : 'top') : nLabel.position;
                    style.textColor = nTextStyle.color;
                    style.textFont = this.getFont(nTextStyle);
                    style.textAlign = nTextStyle.align;
                    style.textBaseline = nTextStyle.baseline;
                }
                if (eLabel.show) {
                    var highlightStyle = tarShape.highlightStyle;
                    highlightStyle.text = this._getLabelText(
                        serie, data, name, 'emphasis'
                    );
                    highlightStyle.textPosition = nLabel.show ? tarShape.style.textPosition : (eLabel.position == null ? (orient === 'horizontal' ? 'right' : 'top') : eLabel.position);
                    highlightStyle.textColor = eTextStyle.color;
                    highlightStyle.textFont = this.getFont(eTextStyle);
                    highlightStyle.textAlign = eTextStyle.align;
                    highlightStyle.textBaseline = eTextStyle.baseline;
                }

                return tarShape;
            },

            /**
             * 根据lable.format计算label text
             */
            _getLabelText: function(serie, data, name, status) {
                var formatter = this.deepQuery(
                    [data, serie],
                    'itemStyle.' + status + '.label.formatter'
                );
                if (!formatter && status === 'emphasis') {
                    // emphasis时需要看看normal下是否有formatter
                    formatter = this.deepQuery(
                        [data, serie],
                        'itemStyle.normal.label.formatter'
                    );
                }

                var value = this.getDataFromOption(data, '-');

                if (formatter) {
                    if (typeof formatter === 'function') {
                        return formatter.call(
                            this.myChart, {
                                seriesName: serie.name,
                                series: serie,
                                name: name,
                                value: value,
                                data: data,
                                status: status
                            }
                        );
                    } else if (typeof formatter === 'string') {
                        formatter = formatter.replace('{a}', '{a0}')
                            .replace('{b}', '{b0}')
                            .replace('{c}', '{c0}')
                            .replace('{a0}', serie.name)
                            .replace('{b0}', name)
                            .replace('{c0}', this.numAddCommas(value));

                        return formatter;
                    }
                } else {
                    if (value instanceof Array) {
                        return value[2] != null ? this.numAddCommas(value[2]) : (value[0] + ' , ' + value[1]);
                    } else {
                        return this.numAddCommas(value);
                    }
                }
            },

            /**
             * 标线标注 
             */
            buildMark: function(seriesIndex) {
                var serie = this.series[seriesIndex];
                if (this.selectedMap[serie.name]) {
                    serie.markLine && this._buildMarkLine(seriesIndex);
                    serie.markPoint && this._buildMarkPoint(seriesIndex);
                }
            },

            /**
             * 标注逻辑
             */
            _buildMarkPoint: function(seriesIndex) {
                var attachStyle = (this.markAttachStyle || {})[seriesIndex];
                var serie = this.series[seriesIndex];
                var mpData;
                var pos;
                var markPoint = zrUtil.clone(serie.markPoint);
                for (var i = 0, l = markPoint.data.length; i < l; i++) {
                    mpData = markPoint.data[i];
                    pos = this.getMarkCoord(seriesIndex, mpData);
                    mpData.x = mpData.x != null ? mpData.x : pos[0];
                    mpData.y = mpData.y != null ? mpData.y : pos[1];
                    if (mpData.type && (mpData.type === 'max' || mpData.type === 'min')) {
                        // 特殊值内置支持
                        mpData.value = pos[3];
                        mpData.name = mpData.name || mpData.type;
                        mpData.symbolSize = mpData.symbolSize || (zrArea.getTextWidth(pos[3], this.getFont()) / 2 + 5);
                    }
                }

                var shapeList = this._markPoint(seriesIndex, markPoint);

                for (var i = 0, l = shapeList.length; i < l; i++) {
                    var tarShape = shapeList[i];
                    tarShape.zlevel = serie.zlevel;
                    tarShape.z = serie.z + 1;
                    for (var key in attachStyle) {
                        tarShape[key] = zrUtil.clone(attachStyle[key]);
                    }
                    this.shapeList.push(tarShape);
                }
                // 个别特殊图表需要自己addShape
                if (this.type === ecConfig.CHART_TYPE_FORCE || this.type === ecConfig.CHART_TYPE_CHORD) {
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        this.zr.addShape(shapeList[i]);
                    }
                }
            },

            /**
             * 标线逻辑
             */
            _buildMarkLine: function(seriesIndex) {
                var attachStyle = (this.markAttachStyle || {})[seriesIndex];
                var serie = this.series[seriesIndex];
                var pos;
                var markLine = zrUtil.clone(serie.markLine);
                for (var i = 0, l = markLine.data.length; i < l; i++) {
                    var mlData = markLine.data[i];
                    if (mlData.type && (mlData.type === 'max' || mlData.type === 'min' || mlData.type === 'average')) {
                        // 特殊值内置支持
                        pos = this.getMarkCoord(seriesIndex, mlData);
                        markLine.data[i] = [zrUtil.clone(mlData), {}];
                        markLine.data[i][0].name = mlData.name || mlData.type;
                        markLine.data[i][0].value = mlData.type !== 'average' ? pos[3] : +pos[3].toFixed(
                            markLine.precision != null ? markLine.precision : this.deepQuery(
                                [this.ecTheme, ecConfig],
                                'markLine.precision'
                            )
                        );
                        pos = pos[2];
                        mlData = [{}, {}];
                    } else {
                        pos = [
                            this.getMarkCoord(seriesIndex, mlData[0]),
                            this.getMarkCoord(seriesIndex, mlData[1])
                        ];
                    }
                    if (pos == null || pos[0] == null || pos[1] == null) {
                        // 不在显示区域内
                        continue;
                    }
                    markLine.data[i][0].x = mlData[0].x != null ? mlData[0].x : pos[0][0];
                    markLine.data[i][0].y = mlData[0].y != null ? mlData[0].y : pos[0][1];
                    markLine.data[i][1].x = mlData[1].x != null ? mlData[1].x : pos[1][0];
                    markLine.data[i][1].y = mlData[1].y != null ? mlData[1].y : pos[1][1];
                }

                var shapeList = this._markLine(seriesIndex, markLine);

                var isLarge = markLine.large;

                if (isLarge) {
                    var shapeBundle = new ShapeBundle({
                        style: {
                            shapeList: shapeList
                        }
                    });
                    var firstShape = shapeList[0];
                    if (firstShape) {
                        zrUtil.merge(shapeBundle.style, firstShape.style);
                        zrUtil.merge(shapeBundle.highlightStyle = {}, firstShape.highlightStyle);
                        shapeBundle.style.brushType = 'stroke';
                        shapeBundle.zlevel = serie.zlevel;
                        shapeBundle.z = serie.z + 1;
                        shapeBundle.hoverable = false;
                        for (var key in attachStyle) {
                            shapeBundle[key] = zrUtil.clone(attachStyle[key]);
                        }
                    }
                    this.shapeList.push(shapeBundle);
                    this.zr.addShape(shapeBundle);

                    shapeBundle._mark = 'largeLine';
                    var effect = markLine.effect;
                    if (effect.show) {
                        shapeBundle.effect = effect;
                    }
                } else {
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        var tarShape = shapeList[i];
                        tarShape.zlevel = serie.zlevel;
                        tarShape.z = serie.z + 1;
                        for (var key in attachStyle) {
                            tarShape[key] = zrUtil.clone(attachStyle[key]);
                        }
                        this.shapeList.push(tarShape);
                    }
                    // 个别特殊图表需要自己addShape
                    if (this.type === ecConfig.CHART_TYPE_FORCE || this.type === ecConfig.CHART_TYPE_CHORD) {
                        for (var i = 0, l = shapeList.length; i < l; i++) {
                            this.zr.addShape(shapeList[i]);
                        }
                    }
                }
            },

            /**
             * 标注多级控制构造
             */
            _markPoint: function(seriesIndex, mpOption) {
                var serie = this.series[seriesIndex];
                var component = this.component;
                zrUtil.merge(
                    zrUtil.merge(
                        mpOption,
                        zrUtil.clone(this.ecTheme.markPoint || {})
                    ),
                    zrUtil.clone(ecConfig.markPoint)
                );

                mpOption.name = serie.name;

                var pList = [];
                var data = mpOption.data;
                var itemShape;

                var dataRange = component.dataRange;
                var legend = component.legend;
                var color;
                var value;
                var queryTarget;
                var nColor;
                var eColor;
                var effect;
                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();

                if (!mpOption.large) {
                    for (var i = 0, l = data.length; i < l; i++) {
                        if (data[i].x == null || data[i].y == null) {
                            continue;
                        }
                        value = data[i].value != null ? data[i].value : '';
                        // 图例
                        if (legend) {
                            color = legend.getColor(serie.name);
                        }
                        // 值域
                        if (dataRange) {
                            color = isNaN(value) ? color : dataRange.getColor(value);

                            queryTarget = [data[i], mpOption];
                            nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color') || color;
                            eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color') || nColor;
                            // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                            if (nColor == null && eColor == null) {
                                continue;
                            }
                        }

                        color = color == null ? this.zr.getColor(seriesIndex) : color;

                        // 标准化一些参数
                        data[i].tooltip = data[i].tooltip || mpOption.tooltip || {
                            trigger: 'item'
                        }; // tooltip.trigger指定为item
                        data[i].name = data[i].name != null ? data[i].name : '';
                        data[i].value = value;

                        // 复用getSymbolShape
                        itemShape = this.getSymbolShape(
                            mpOption, seriesIndex, // 系列 
                            data[i], i, data[i].name, // 数据
                            this.parsePercent(data[i].x, zrWidth), // 坐标
                            this.parsePercent(data[i].y, zrHeight), // 坐标
                            'pin', color, // 默认symbol和color
                            'rgba(0,0,0,0)',
                            'horizontal' // 走向，用于默认文字定位
                        );
                        itemShape._mark = 'point';

                        effect = this.deepMerge(
                            [data[i], mpOption],
                            'effect'
                        );
                        if (effect.show) {
                            itemShape.effect = effect;
                        }

                        if (serie.type === ecConfig.CHART_TYPE_MAP) {
                            itemShape._geo = this.getMarkGeo(data[i]);
                        }

                        // 重新pack一下数据
                        ecData.pack(
                            itemShape,
                            serie, seriesIndex,
                            data[i], i,
                            data[i].name,
                            value
                        );
                        pList.push(itemShape);
                    }
                } else {
                    // 大规模MarkPoint
                    itemShape = this.getLargeMarkPointShape(seriesIndex, mpOption);
                    itemShape._mark = 'largePoint';
                    itemShape && pList.push(itemShape);
                }
                return pList;
            },

            /**
             * 标线多级控制构造
             */
            _markLine: (function() {
                function normalizeOptionValue(mlOption, key) {
                    mlOption[key] = mlOption[key] instanceof Array ? mlOption[key].length > 1 ? mlOption[key] : [mlOption[key][0], mlOption[key][0]] : [mlOption[key], mlOption[key]];
                }

                return function(seriesIndex, mlOption) {
                    var serie = this.series[seriesIndex];
                    var component = this.component;
                    var dataRange = component.dataRange;
                    var legend = component.legend;

                    zrUtil.merge(
                        zrUtil.merge(
                            mlOption,
                            zrUtil.clone(this.ecTheme.markLine || {})
                        ),
                        zrUtil.clone(ecConfig.markLine)
                    );

                    var defaultColor = legend ? legend.getColor(serie.name) : this.zr.getColor(seriesIndex);

                    // 标准化一些同时支持Array和String的参数
                    normalizeOptionValue(mlOption, 'symbol');
                    normalizeOptionValue(mlOption, 'symbolSize');
                    normalizeOptionValue(mlOption, 'symbolRotate');

                    // Normalize and filter data
                    var data = mlOption.data;
                    var edges = [];
                    var zrWidth = this.zr.getWidth();
                    var zrHeight = this.zr.getHeight();
                    for (var i = 0; i < data.length; i++) {
                        var mlData = data[i];
                        if (isCoordAvailable(mlData[0]) && isCoordAvailable(mlData[1])) {
                            // 组装一个mergeData
                            var mergeData = this.deepMerge(mlData);
                            var queryTarget = [mergeData, mlOption];
                            var color = defaultColor;
                            var value = mergeData.value != null ? mergeData.value : '';
                            // 值域
                            if (dataRange) {
                                color = isNaN(value) ? color : dataRange.getColor(value);

                                var nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color') || color;
                                var eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color') || nColor;
                                // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                                if (nColor == null && eColor == null) {
                                    continue;
                                }
                            }
                            // 标准化一些参数
                            mlData[0].tooltip = mergeData.tooltip || mlOption.tooltip || {
                                trigger: 'item'
                            }; // tooltip.trigger指定为item
                            mlData[0].name = mlData[0].name || '';
                            mlData[1].name = mlData[1].name || '';
                            mlData[0].value = value;

                            edges.push({
                                points: [
                                    [this.parsePercent(mlData[0].x, zrWidth),
                                        this.parsePercent(mlData[0].y, zrHeight)
                                    ],
                                    [this.parsePercent(mlData[1].x, zrWidth),
                                        this.parsePercent(mlData[1].y, zrHeight)
                                    ]
                                ],
                                rawData: mlData,
                                color: color
                            });
                        }
                    }

                    var enableBundling = this.query(mlOption, 'bundling.enable');
                    if (enableBundling) {
                        var edgeBundling = new EdgeBundling();
                        edgeBundling.maxTurningAngle = this.query(
                            mlOption, 'bundling.maxTurningAngle'
                        ) / 180 * Math.PI;
                        edges = edgeBundling.run(edges);
                    }

                    mlOption.name = serie.name;

                    var shapeList = [];

                    for (var i = 0, l = edges.length; i < l; i++) {
                        var edge = edges[i];
                        var rawEdge = edge.rawEdge || edge;
                        var mlData = rawEdge.rawData;
                        var value = mlData.value != null ? mlData.value : '';

                        var itemShape = this.getMarkLineShape(
                            mlOption,
                            seriesIndex,
                            mlData,
                            i,
                            edge.points,
                            enableBundling,
                            rawEdge.color
                        );
                        itemShape._mark = 'line';

                        var effect = this.deepMerge(
                            [mlData[0], mlData[1], mlOption],
                            'effect'
                        );
                        if (effect.show) {
                            itemShape.effect = effect;
                            itemShape.effect.large = mlOption.large;
                        }

                        if (serie.type === ecConfig.CHART_TYPE_MAP) {
                            itemShape._geo = [
                                this.getMarkGeo(mlData[0]),
                                this.getMarkGeo(mlData[1])
                            ];
                        }

                        // 重新pack一下数据
                        ecData.pack(
                            itemShape,
                            serie, seriesIndex,
                            mlData[0], i,
                            mlData[0].name
                            // 不要帮我代码规范
                            + (mlData[1].name !== '' ? (' > ' + mlData[1].name) : ''),
                            value
                        );
                        shapeList.push(itemShape);
                    }

                    return shapeList;
                };
            })(),

            getMarkCoord: function() {
                // 无转换位置
                return [0, 0];
            },

            /**
             * symbol构造器 
             */
            getSymbolShape: function(
                serie, seriesIndex, // 系列 
                data, dataIndex, name, // 数据
                x, y, // 坐标
                symbol, color, // 默认symbol和color，来自legend或dataRange全局分配
                emptyColor, // 折线的emptySymbol用白色填充
                orient // 走向，用于默认文字定位
            ) {
                var queryTarget = [data, serie];
                var value = this.getDataFromOption(data, '-');

                symbol = this.deepQuery(queryTarget, 'symbol') || symbol;
                var symbolSize = this.deepQuery(queryTarget, 'symbolSize');
                symbolSize = typeof symbolSize === 'function' ? symbolSize(value) : symbolSize;
                if (typeof symbolSize === 'number') {
                    symbolSize = [symbolSize, symbolSize];
                }
                var symbolRotate = this.deepQuery(queryTarget, 'symbolRotate');

                var normal = this.deepMerge(
                    queryTarget,
                    'itemStyle.normal'
                );
                var emphasis = this.deepMerge(
                    queryTarget,
                    'itemStyle.emphasis'
                );
                var nBorderWidth = normal.borderWidth != null ? normal.borderWidth : (normal.lineStyle && normal.lineStyle.width);
                if (nBorderWidth == null) {
                    nBorderWidth = symbol.match('empty') ? 2 : 0;
                }
                var eBorderWidth = emphasis.borderWidth != null ? emphasis.borderWidth : (emphasis.lineStyle && emphasis.lineStyle.width);
                if (eBorderWidth == null) {
                    eBorderWidth = nBorderWidth + 2;
                }

                var nColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);
                var eColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);

                var width = symbolSize[0];
                var height = symbolSize[1];
                var itemShape = new IconShape({
                    style: {
                        iconType: symbol.replace('empty', '').toLowerCase(),
                        x: x - width,
                        y: y - height,
                        width: width * 2,
                        height: height * 2,
                        brushType: 'both',
                        color: symbol.match('empty') ? emptyColor : (nColor || color),
                        strokeColor: normal.borderColor || nColor || color,
                        lineWidth: nBorderWidth
                    },
                    highlightStyle: {
                        color: symbol.match('empty') ? emptyColor : (eColor || nColor || color),
                        strokeColor: emphasis.borderColor || normal.borderColor || eColor || nColor || color,
                        lineWidth: eBorderWidth
                    },
                    clickable: this.deepQuery(queryTarget, 'clickable')
                });

                if (symbol.match('image')) {
                    itemShape.style.image = symbol.replace(new RegExp('^image:\\/\\/'), '');
                    itemShape = new ImageShape({
                        style: itemShape.style,
                        highlightStyle: itemShape.highlightStyle,
                        clickable: this.deepQuery(queryTarget, 'clickable')
                    });
                }

                if (symbolRotate != null) {
                    itemShape.rotation = [
                        symbolRotate * Math.PI / 180, x, y
                    ];
                }

                if (symbol.match('star')) {
                    itemShape.style.iconType = 'star';
                    itemShape.style.n =
                        (symbol.replace('empty', '').replace('star', '') - 0) || 5;
                }

                if (symbol === 'none') {
                    itemShape.invisible = true;
                    itemShape.hoverable = false;
                }

                /*
                if (this.deepQuery([data, serie, option], 'calculable')) {
                    this.setCalculable(itemShape);
                    itemShape.draggable = true;
                }
                */

                itemShape = this.addLabel(
                    itemShape,
                    serie, data, name,
                    orient
                );

                if (symbol.match('empty')) {
                    if (itemShape.style.textColor == null) {
                        itemShape.style.textColor = itemShape.style.strokeColor;
                    }
                    if (itemShape.highlightStyle.textColor == null) {
                        itemShape.highlightStyle.textColor =
                            itemShape.highlightStyle.strokeColor;
                    }
                }

                ecData.pack(
                    itemShape,
                    serie, seriesIndex,
                    data, dataIndex,
                    name
                );

                itemShape._x = x;
                itemShape._y = y;

                itemShape._dataIndex = dataIndex;
                itemShape._seriesIndex = seriesIndex;

                return itemShape;
            },

            /**
             * 标线构造器 
             */
            getMarkLineShape: function(
                mlOption, // 系列 
                seriesIndex, // 系列索引
                data, // 数据
                dataIndex, // 数据索引
                points, // 坐标点
                bundling, // 是否边捆绑过
                color // 默认color，来自legend或dataRange全局分配
            ) {
                var value0 = data[0].value != null ? data[0].value : '-';
                var value1 = data[1].value != null ? data[1].value : '-';
                var symbol = [
                    data[0].symbol || mlOption.symbol[0],
                    data[1].symbol || mlOption.symbol[1]
                ];
                var symbolSize = [
                    data[0].symbolSize || mlOption.symbolSize[0],
                    data[1].symbolSize || mlOption.symbolSize[1]
                ];
                symbolSize[0] = typeof symbolSize[0] === 'function' ? symbolSize[0](value0) : symbolSize[0];
                symbolSize[1] = typeof symbolSize[1] === 'function' ? symbolSize[1](value1) : symbolSize[1];
                var symbolRotate = [
                    this.query(data[0], 'symbolRotate') || mlOption.symbolRotate[0],
                    this.query(data[1], 'symbolRotate') || mlOption.symbolRotate[1]
                ];
                //console.log(symbol, symbolSize, symbolRotate);

                var queryTarget = [data[0], data[1], mlOption];
                var normal = this.deepMerge(
                    queryTarget,
                    'itemStyle.normal'
                );
                normal.color = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);
                var emphasis = this.deepMerge(
                    queryTarget,
                    'itemStyle.emphasis'
                );
                emphasis.color = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);

                var nlineStyle = normal.lineStyle;
                var elineStyle = emphasis.lineStyle;

                var nBorderWidth = nlineStyle.width;
                if (nBorderWidth == null) {
                    nBorderWidth = normal.borderWidth;
                }
                var eBorderWidth = elineStyle.width;
                if (eBorderWidth == null) {
                    eBorderWidth = emphasis.borderWidth != null ? emphasis.borderWidth : (nBorderWidth + 2);
                }
                var smoothness = this.deepQuery(queryTarget, 'smoothness');
                if (!this.deepQuery(queryTarget, 'smooth')) {
                    smoothness = 0;
                }

                var ShapeCtor = bundling ? PolylineShape : MarkLineShape;
                var itemShape = new ShapeCtor({
                    style: {
                        symbol: symbol,
                        symbolSize: symbolSize,
                        symbolRotate: symbolRotate,
                        // data: [data[0].name,data[1].name],
                        brushType: 'both',
                        lineType: nlineStyle.type,
                        shadowColor: nlineStyle.shadowColor || nlineStyle.color || normal.borderColor || normal.color || color,
                        shadowBlur: nlineStyle.shadowBlur,
                        shadowOffsetX: nlineStyle.shadowOffsetX,
                        shadowOffsetY: nlineStyle.shadowOffsetY,
                        color: normal.color || color,
                        strokeColor: nlineStyle.color || normal.borderColor || normal.color || color,
                        lineWidth: nBorderWidth,
                        symbolBorderColor: normal.borderColor || normal.color || color,
                        symbolBorder: normal.borderWidth
                    },
                    highlightStyle: {
                        shadowColor: elineStyle.shadowColor,
                        shadowBlur: elineStyle.shadowBlur,
                        shadowOffsetX: elineStyle.shadowOffsetX,
                        shadowOffsetY: elineStyle.shadowOffsetY,
                        color: emphasis.color || normal.color || color,
                        strokeColor: elineStyle.color || nlineStyle.color || emphasis.borderColor || normal.borderColor || emphasis.color || normal.color || color,
                        lineWidth: eBorderWidth,
                        symbolBorderColor: emphasis.borderColor || normal.borderColor || emphasis.color || normal.color || color,
                        symbolBorder: emphasis.borderWidth == null ? (normal.borderWidth + 2) : (emphasis.borderWidth)
                    },
                    clickable: this.deepQuery(queryTarget, 'clickable')
                });
                var shapeStyle = itemShape.style;
                if (bundling) {
                    shapeStyle.pointList = points;
                    shapeStyle.smooth = smoothness;
                } else {
                    shapeStyle.xStart = points[0][0];
                    shapeStyle.yStart = points[0][1];
                    shapeStyle.xEnd = points[1][0];
                    shapeStyle.yEnd = points[1][1];
                    shapeStyle.curveness = smoothness;
                    itemShape.updatePoints(itemShape.style);
                }

                itemShape = this.addLabel(
                    itemShape,
                    mlOption,
                    data[0],
                    data[0].name + ' : ' + data[1].name
                );

                return itemShape;
            },

            /**
             * 大规模标注构造器 
             */
            getLargeMarkPointShape: function(seriesIndex, mpOption) {
                var serie = this.series[seriesIndex];
                var component = this.component;
                var data = mpOption.data;
                var itemShape;

                var dataRange = component.dataRange;
                var legend = component.legend;
                var color;
                var value;
                var queryTarget = [data[0], mpOption];
                var nColor;
                var eColor;
                var effect;

                // 图例
                if (legend) {
                    color = legend.getColor(serie.name);
                }
                // 值域
                if (dataRange) {
                    value = data[0].value != null ? data[0].value : '';
                    color = isNaN(value) ? color : dataRange.getColor(value);

                    nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color') || color;
                    eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color') || nColor;
                    // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                    if (nColor == null && eColor == null) {
                        return;
                    }
                }
                color = this.deepMerge(queryTarget, 'itemStyle.normal').color || color;

                var symbol = this.deepQuery(queryTarget, 'symbol') || 'circle';
                symbol = symbol.replace('empty', '').replace(/\d/g, '');

                effect = this.deepMerge(
                    [data[0], mpOption],
                    'effect'
                );

                var devicePixelRatio = window.devicePixelRatio || 1;

                //console.log(data)
                itemShape = new SymbolShape({
                    style: {
                        pointList: data,
                        color: color,
                        strokeColor: color,
                        shadowColor: effect.shadowColor || color,
                        shadowBlur: (effect.shadowBlur != null ? effect.shadowBlur : 8) * devicePixelRatio,
                        size: this.deepQuery(queryTarget, 'symbolSize'),
                        iconType: symbol,
                        brushType: 'fill',
                        lineWidth: 1
                    },
                    draggable: false,
                    hoverable: false
                });

                if (effect.show) {
                    itemShape.effect = effect;
                }

                return itemShape;
            },

            backupShapeList: function() {
                if (this.shapeList && this.shapeList.length > 0) {
                    this.lastShapeList = this.shapeList;
                    this.shapeList = [];
                } else {
                    this.lastShapeList = [];
                }
            },

            addShapeList: function() {
                var maxLenth = this.option.animationThreshold / (this.canvasSupported ? 2 : 4);
                var lastShapeList = this.lastShapeList;
                var shapeList = this.shapeList;
                var isUpdate = lastShapeList.length > 0;
                var duration = isUpdate ? this.query(this.option, 'animationDurationUpdate') : this.query(this.option, 'animationDuration');
                var easing = this.query(this.option, 'animationEasing');
                var delay;
                var key;
                var oldMap = {};
                var newMap = {};
                if (this.option.animation && !this.option.renderAsImage && shapeList.length < maxLenth && !this.motionlessOnce) {
                    // 通过已有的shape做动画过渡
                    for (var i = 0, l = lastShapeList.length; i < l; i++) {
                        key = this._getAnimationKey(lastShapeList[i]);
                        if (key.match('undefined')) {
                            this.zr.delShape(lastShapeList[i].id); // 非关键元素直接删除
                        } else {
                            key += lastShapeList[i].type;
                            // https://github.com/ecomfe/echarts/issues/1219#issuecomment-71987602
                            // 响应中断可能产生的重复元素
                            if (oldMap[key]) {
                                this.zr.delShape(lastShapeList[i].id);
                            } else {
                                oldMap[key] = lastShapeList[i];
                            }
                        }
                    }
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        key = this._getAnimationKey(shapeList[i]);
                        if (key.match('undefined')) {
                            this.zr.addShape(shapeList[i]); // 非关键元素直接添加
                        } else {
                            key += shapeList[i].type;
                            newMap[key] = shapeList[i];
                        }
                    }

                    for (key in oldMap) {
                        if (!newMap[key]) {
                            // 新的没有 删除
                            this.zr.delShape(oldMap[key].id);
                        }
                    }
                    for (key in newMap) {
                        if (oldMap[key]) {
                            // 新旧都有 动画过渡
                            this.zr.delShape(oldMap[key].id);
                            this._animateMod(
                                oldMap[key], newMap[key], duration, easing, 0, isUpdate
                            );
                        } else {
                            // 新有旧没有  添加并动画过渡
                            //this._animateAdd(newMap[key], duration, easing);
                            delay = (this.type == ecConfig.CHART_TYPE_LINE || this.type == ecConfig.CHART_TYPE_RADAR) && key.indexOf('icon') !== 0 ? duration / 2 : 0;
                            this._animateMod(
                                false, newMap[key], duration, easing, delay, isUpdate
                            );
                        }
                    }
                    this.zr.refresh();
                    this.animationEffect();
                } else {
                    this.motionlessOnce = false;
                    // clear old
                    this.zr.delShape(lastShapeList);
                    // 直接添加
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        this.zr.addShape(shapeList[i]);
                    }
                }
            },

            _getAnimationKey: function(shape) {
                if (this.type != ecConfig.CHART_TYPE_MAP && this.type != ecConfig.CHART_TYPE_TREEMAP && this.type != ecConfig.CHART_TYPE_VENN && this.type != ecConfig.CHART_TYPE_TREE) {
                    return ecData.get(shape, 'seriesIndex') + '_' + ecData.get(shape, 'dataIndex') + (shape._mark ? shape._mark : '') + (this.type === ecConfig.CHART_TYPE_RADAR ? ecData.get(shape, 'special') : '');
                } else {
                    return ecData.get(shape, 'seriesIndex') + '_' + ecData.get(shape, 'dataIndex') + (shape._mark ? shape._mark : 'undefined');
                }
            },

            /**
             * 动画过渡 
             */
            _animateMod: function(oldShape, newShape, duration, easing, delay, isUpdate) {
                switch (newShape.type) {
                    case 'polyline':
                    case 'half-smooth-polygon':
                        ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case 'rectangle':
                        ecAnimation.rectangle(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case 'image':
                    case 'icon':
                        ecAnimation.icon(this.zr, oldShape, newShape, duration, easing, delay);
                        break;
                    case 'candle':
                        if (!isUpdate) {
                            ecAnimation.candle(this.zr, oldShape, newShape, duration, easing);
                        } else {
                            this.zr.addShape(newShape);
                        }
                        break;
                    case 'ring':
                    case 'sector':
                    case 'circle':
                        if (!isUpdate) {
                            // 进入动画，加旋转
                            ecAnimation.ring(
                                this.zr,
                                oldShape,
                                newShape,
                                duration + ((ecData.get(newShape, 'dataIndex') || 0) % 20 * 100),
                                easing
                            );
                        } else if (newShape.type === 'sector') {
                            ecAnimation.sector(this.zr, oldShape, newShape, duration, easing);
                        } else {
                            this.zr.addShape(newShape);
                        }
                        break;
                    case 'text':
                        ecAnimation.text(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case 'polygon':
                        if (!isUpdate) {
                            ecAnimation.polygon(this.zr, oldShape, newShape, duration, easing);
                        } else {
                            ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                        }
                        break;
                    case 'ribbon':
                        ecAnimation.ribbon(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case 'gauge-pointer':
                        ecAnimation.gaugePointer(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case 'mark-line':
                        ecAnimation.markline(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case 'bezier-curve':
                    case 'line':
                        ecAnimation.line(this.zr, oldShape, newShape, duration, easing);
                        break;
                    default:
                        this.zr.addShape(newShape);
                        break;
                }
            },

            /**
             * 标注动画
             * @param {number} duration 时长
             * @param {string=} easing 缓动效果
             * @param {Array=} shapeList 指定特效对象，不指定默认使用this.shapeList
             */
            animationMark: function(duration, easing, shapeList) {
                var shapeList = shapeList || this.shapeList;
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    if (!shapeList[i]._mark) {
                        continue;
                    }
                    this._animateMod(false, shapeList[i], duration, easing, 0, true);
                }
                this.animationEffect(shapeList);
            },

            /**
             * 特效动画
             * @param {Array=} shapeList 指定特效对象，不知道默认使用this.shapeList
             */
            animationEffect: function(shapeList) {
                !shapeList && this.clearEffectShape();
                shapeList = shapeList || this.shapeList;
                if (shapeList == null) {
                    return;
                }
                var zlevel = ecConfig.EFFECT_ZLEVEL;
                if (this.canvasSupported) {
                    this.zr.modLayer(
                        zlevel, {
                            motionBlur: true,
                            lastFrameAlpha: this.option.effectBlendAlpha || ecConfig.effectBlendAlpha
                        }
                    );
                }
                var shape;
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    shape = shapeList[i];
                    if (!(shape._mark && shape.effect && shape.effect.show && ecEffect[shape._mark])) {
                        continue;
                    }
                    ecEffect[shape._mark](this.zr, this.effectList, shape, zlevel);
                    this.effectList[this.effectList.length - 1]._mark = shape._mark;
                }
            },

            clearEffectShape: function(clearMotionBlur) {
                var effectList = this.effectList;
                if (this.zr && effectList && effectList.length > 0) {
                    clearMotionBlur && this.zr.modLayer(
                        ecConfig.EFFECT_ZLEVEL, {
                            motionBlur: false
                        }
                    );
                    this.zr.delShape(effectList);

                    // 手动清除不会被 zr 自动清除的动画控制器
                    for (var i = 0; i < effectList.length; i++) {
                        if (effectList[i].effectAnimator) {
                            effectList[i].effectAnimator.stop();
                        }
                    }
                }
                this.effectList = [];
            },

            /**
             * 动态标线标注添加
             * @param {number} seriesIndex 系列索引
             * @param {Object} markData 标线标注对象，支持多个
             * @param {string} markType 标线标注类型
             */
            addMark: function(seriesIndex, markData, markType) {
                var serie = this.series[seriesIndex];
                if (this.selectedMap[serie.name]) {
                    var duration = this.query(this.option, 'animationDurationUpdate');
                    var easing = this.query(this.option, 'animationEasing');
                    // 备份，复用_buildMarkX
                    var oriMarkData = serie[markType].data;
                    var lastLength = this.shapeList.length;

                    serie[markType].data = markData.data;
                    this['_build' + markType.replace('m', 'M')](seriesIndex);
                    if (this.option.animation && !this.option.renderAsImage) {
                        // animationMark就会addShape
                        this.animationMark(duration, easing, this.shapeList.slice(lastLength));
                    } else {
                        for (var i = lastLength, l = this.shapeList.length; i < l; i++) {
                            this.zr.addShape(this.shapeList[i]);
                        }
                        this.zr.refreshNextFrame();
                    }
                    // 还原，复用_buildMarkX
                    serie[markType].data = oriMarkData;
                }
            },

            /**
             * 动态标线标注删除
             * @param {number} seriesIndex 系列索引
             * @param {string} markName 标线标注名称
             * @param {string} markType 标线标注类型
             */
            delMark: function(seriesIndex, markName, markType) {
                markType = markType.replace('mark', '').replace('large', '').toLowerCase();
                var serie = this.series[seriesIndex];
                if (this.selectedMap[serie.name]) {
                    var needRefresh = false;
                    var shapeList = [this.shapeList, this.effectList];
                    var len = 2;
                    while (len--) {
                        for (var i = 0, l = shapeList[len].length; i < l; i++) {
                            if (shapeList[len][i]._mark == markType && ecData.get(shapeList[len][i], 'seriesIndex') == seriesIndex && ecData.get(shapeList[len][i], 'name') == markName) {
                                this.zr.delShape(shapeList[len][i].id);
                                shapeList[len].splice(i, 1);
                                needRefresh = true;
                                break;
                            }
                        }
                    }

                    needRefresh && this.zr.refreshNextFrame();
                }
            }
        };

        zrUtil.inherits(Base, ComponentBase);

        return Base;
    });
    define('zrender/shape/Path', ['require', './Base', './util/PathProxy', '../tool/util'], function(require) {

        var Base = require('./Base');
        var PathProxy = require('./util/PathProxy');
        var PathSegment = PathProxy.PathSegment;

        var vMag = function(v) {
            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
        };
        var vRatio = function(u, v) {
            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
        };
        var vAngle = function(u, v) {
            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
        };
        /**
         * @alias module:zrender/shape/Path
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Path = function(options) {
            Base.call(this, options);
            /**
             * Path绘制样式
             * @name module:zrender/shape/Path#style
             * @type {module:zrender/shape/Path~IPathStyle}
             */
            /**
             * Path高亮绘制样式
             * @name module:zrender/shape/Path#highlightStyle
             * @type {module:zrender/shape/Path~IPathStyle}
             */
        };

        Path.prototype = {
            type: 'path',

            buildPathArray: function(data, x, y) {
                if (!data) {
                    return [];
                }

                // 平移
                x = x || 0;
                y = y || 0;
                // command string
                var cs = data;

                // command chars
                var cc = [
                    'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
                    'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
                ];

                cs = cs.replace(/-/g, ' -');
                cs = cs.replace(/  /g, ' ');
                cs = cs.replace(/ /g, ',');
                cs = cs.replace(/,,/g, ',');

                var n;
                // create pipes so that we can split the data
                for (n = 0; n < cc.length; n++) {
                    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
                }

                // create array
                var arr = cs.split('|');
                var ca = [];
                // init context point
                var cpx = 0;
                var cpy = 0;
                for (n = 1; n < arr.length; n++) {
                    var str = arr[n];
                    var c = str.charAt(0);
                    str = str.slice(1);
                    str = str.replace(new RegExp('e,-', 'g'), 'e-');

                    var p = str.split(',');
                    if (p.length > 0 && p[0] === '') {
                        p.shift();
                    }

                    for (var i = 0; i < p.length; i++) {
                        p[i] = parseFloat(p[i]);
                    }
                    while (p.length > 0) {
                        if (isNaN(p[0])) {
                            break;
                        }
                        var cmd = null;
                        var points = [];

                        var ctlPtx;
                        var ctlPty;
                        var prevCmd;

                        var rx;
                        var ry;
                        var psi;
                        var fa;
                        var fs;

                        var x1 = cpx;
                        var y1 = cpy;

                        // convert l, H, h, V, and v to L
                        switch (c) {
                            case 'l':
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'L':
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case 'm':
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'M';
                                points.push(cpx, cpy);
                                c = 'l';
                                break;
                            case 'M':
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = 'M';
                                points.push(cpx, cpy);
                                c = 'L';
                                break;

                            case 'h':
                                cpx += p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'H':
                                cpx = p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'v':
                                cpy += p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'V':
                                cpy = p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'C':
                                points.push(p.shift(), p.shift(), p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case 'c':
                                points.push(
                                    cpx + p.shift(), cpy + p.shift(),
                                    cpx + p.shift(), cpy + p.shift()
                                );
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'C';
                                points.push(cpx, cpy);
                                break;
                            case 'S':
                                ctlPtx = cpx;
                                ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === 'C') {
                                    ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                    ctlPty = cpy + (cpy - prevCmd.points[3]);
                                }
                                points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = 'C';
                                points.push(cpx, cpy);
                                break;
                            case 's':
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === 'C') {
                                    ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                    ctlPty = cpy + (cpy - prevCmd.points[3]);
                                }
                                points.push(
                                    ctlPtx, ctlPty,
                                    cpx + p.shift(), cpy + p.shift()
                                );
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'C';
                                points.push(cpx, cpy);
                                break;
                            case 'Q':
                                points.push(p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case 'q':
                                points.push(cpx + p.shift(), cpy + p.shift());
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'Q';
                                points.push(cpx, cpy);
                                break;
                            case 'T':
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === 'Q') {
                                    ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                    ctlPty = cpy + (cpy - prevCmd.points[1]);
                                }
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = 'Q';
                                points.push(ctlPtx, ctlPty, cpx, cpy);
                                break;
                            case 't':
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === 'Q') {
                                    ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                    ctlPty = cpy + (cpy - prevCmd.points[1]);
                                }
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'Q';
                                points.push(ctlPtx, ctlPty, cpx, cpy);
                                break;
                            case 'A':
                                rx = p.shift();
                                ry = p.shift();
                                psi = p.shift();
                                fa = p.shift();
                                fs = p.shift();

                                x1 = cpx, y1 = cpy;
                                cpx = p.shift(), cpy = p.shift();
                                cmd = 'A';
                                points = this._convertPoint(
                                    x1, y1, cpx, cpy, fa, fs, rx, ry, psi
                                );
                                break;
                            case 'a':
                                rx = p.shift();
                                ry = p.shift();
                                psi = p.shift();
                                fa = p.shift();
                                fs = p.shift();

                                x1 = cpx, y1 = cpy;
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'A';
                                points = this._convertPoint(
                                    x1, y1, cpx, cpy, fa, fs, rx, ry, psi
                                );
                                break;
                        }

                        // 平移变换
                        for (var j = 0, l = points.length; j < l; j += 2) {
                            points[j] += x;
                            points[j + 1] += y;
                        }
                        ca.push(new PathSegment(
                            cmd || c, points
                        ));
                    }

                    if (c === 'z' || c === 'Z') {
                        ca.push(new PathSegment('z', []));
                    }
                }

                return ca;
            },

            _convertPoint: function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
                var psi = psiDeg * (Math.PI / 180.0);
                var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
                var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

                var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

                if (lambda > 1) {
                    rx *= Math.sqrt(lambda);
                    ry *= Math.sqrt(lambda);
                }

                var f = Math.sqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp)));

                if (fa === fs) {
                    f *= -1;
                }
                if (isNaN(f)) {
                    f = 0;
                }

                var cxp = f * rx * yp / ry;
                var cyp = f * -ry * xp / rx;

                var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
                var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

                var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
                var u = [(xp - cxp) / rx, (yp - cyp) / ry];
                var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
                var dTheta = vAngle(u, v);

                if (vRatio(u, v) <= -1) {
                    dTheta = Math.PI;
                }
                if (vRatio(u, v) >= 1) {
                    dTheta = 0;
                }
                if (fs === 0 && dTheta > 0) {
                    dTheta = dTheta - 2 * Math.PI;
                }
                if (fs === 1 && dTheta < 0) {
                    dTheta = dTheta + 2 * Math.PI;
                }
                return [cx, cy, rx, ry, theta, dTheta, psi, fs];
            },

            /**
             * 创建路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Path~IPathStyle} style
             */
            buildPath: function(ctx, style) {
                var path = style.path;

                // 平移坐标
                var x = style.x || 0;
                var y = style.y || 0;

                style.pathArray = style.pathArray || this.buildPathArray(path, x, y);
                var pathArray = style.pathArray;

                // 记录边界点，用于判断inside
                var pointList = style.pointList = [];
                var singlePointList = [];
                for (var i = 0, l = pathArray.length; i < l; i++) {
                    if (pathArray[i].command.toUpperCase() == 'M') {
                        singlePointList.length > 0 && pointList.push(singlePointList);
                        singlePointList = [];
                    }
                    var p = pathArray[i].points;
                    for (var j = 0, k = p.length; j < k; j += 2) {
                        singlePointList.push([p[j], p[j + 1]]);
                    }
                }
                singlePointList.length > 0 && pointList.push(singlePointList);

                for (var i = 0, l = pathArray.length; i < l; i++) {
                    var c = pathArray[i].command;
                    var p = pathArray[i].points;
                    switch (c) {
                        case 'L':
                            ctx.lineTo(p[0], p[1]);
                            break;
                        case 'M':
                            ctx.moveTo(p[0], p[1]);
                            break;
                        case 'C':
                            ctx.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                            break;
                        case 'Q':
                            ctx.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                            break;
                        case 'A':
                            var cx = p[0];
                            var cy = p[1];
                            var rx = p[2];
                            var ry = p[3];
                            var theta = p[4];
                            var dTheta = p[5];
                            var psi = p[6];
                            var fs = p[7];
                            var r = (rx > ry) ? rx : ry;
                            var scaleX = (rx > ry) ? 1 : rx / ry;
                            var scaleY = (rx > ry) ? ry / rx : 1;

                            ctx.translate(cx, cy);
                            ctx.rotate(psi);
                            ctx.scale(scaleX, scaleY);
                            ctx.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                            ctx.scale(1 / scaleX, 1 / scaleY);
                            ctx.rotate(-psi);
                            ctx.translate(-cx, -cy);
                            break;
                        case 'z':
                            ctx.closePath();
                            break;
                    }
                }

                return;
            },

            /**
             * 计算返回Path包围盒矩形。
             * @param {module:zrender/shape/Path~IPathStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }

                var minX = Number.MAX_VALUE;
                var maxX = Number.MIN_VALUE;

                var minY = Number.MAX_VALUE;
                var maxY = Number.MIN_VALUE;

                // 平移坐标
                var x = style.x || 0;
                var y = style.y || 0;

                var pathArray = style.pathArray || this.buildPathArray(style.path);
                for (var i = 0; i < pathArray.length; i++) {
                    var p = pathArray[i].points;

                    for (var j = 0; j < p.length; j++) {
                        if (j % 2 === 0) {
                            if (p[j] + x < minX) {
                                minX = p[j];
                            }
                            if (p[j] + x > maxX) {
                                maxX = p[j];
                            }
                        } else {
                            if (p[j] + y < minY) {
                                minY = p[j];
                            }
                            if (p[j] + y > maxY) {
                                maxY = p[j];
                            }
                        }
                    }
                }

                var rect;
                if (minX === Number.MAX_VALUE || maxX === Number.MIN_VALUE || minY === Number.MAX_VALUE || maxY === Number.MIN_VALUE) {
                    rect = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                } else {
                    rect = {
                        x: Math.round(minX - lineWidth / 2),
                        y: Math.round(minY - lineWidth / 2),
                        width: maxX - minX + lineWidth,
                        height: maxY - minY + lineWidth
                    };
                }
                style.__rect = rect;
                return rect;
            }
        };

        require('../tool/util').inherits(Path, Base);
        return Path;
    });
    define('zrender/shape/Line', ['require', './Base', './util/dashedLineTo', '../tool/util'], function(require) {
        var Base = require('./Base');
        var dashedLineTo = require('./util/dashedLineTo');

        /**
         * @alias module:zrender/shape/Line
         * @param {Object} options
         * @constructor
         * @extends module:zrender/shape/Base
         */
        var Line = function(options) {
            this.brushTypeOnly = 'stroke'; // 线条只能描边，填充后果自负
            this.textPosition = 'end';
            Base.call(this, options);

            /**
             * 直线绘制样式
             * @name module:zrender/shape/Line#style
             * @type {module:zrender/shape/Line~ILineStyle}
             */
            /**
             * 直线高亮绘制样式
             * @name module:zrender/shape/Line#highlightStyle
             * @type {module:zrender/shape/Line~ILineStyle}
             */
        };

        Line.prototype = {
            type: 'line',

            /**
             * 创建线条路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Line~ILineStyle} style
             */
            buildPath: function(ctx, style) {
                if (!style.lineType || style.lineType == 'solid') {
                    // 默认为实线
                    ctx.moveTo(style.xStart, style.yStart);
                    ctx.lineTo(style.xEnd, style.yEnd);
                } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                    var dashLength = (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                    dashedLineTo(
                        ctx,
                        style.xStart, style.yStart,
                        style.xEnd, style.yEnd,
                        dashLength
                    );
                }
            },

            /**
             * 计算返回线条的包围盒矩形
             * @param {module:zrender/shape/Line~ILineStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth = style.lineWidth || 1;
                style.__rect = {
                    x: Math.min(style.xStart, style.xEnd) - lineWidth,
                    y: Math.min(style.yStart, style.yEnd) - lineWidth,
                    width: Math.abs(style.xStart - style.xEnd) + lineWidth,
                    height: Math.abs(style.yStart - style.yEnd) + lineWidth
                };

                return style.__rect;
            }
        };

        require('../tool/util').inherits(Line, Base);
        return Line;
    });
    define('zrender/shape/Circle', ['require', './Base', '../tool/util'], function(require) {
        'use strict';

        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Circle
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Circle = function(options) {
            Base.call(this, options);
            /**
             * 圆形绘制样式
             * @name module:zrender/shape/Circle#style
             * @type {module:zrender/shape/Circle~ICircleStyle}
             */
            /**
             * 圆形高亮绘制样式
             * @name module:zrender/shape/Circle#highlightStyle
             * @type {module:zrender/shape/Circle~ICircleStyle}
             */
        };

        Circle.prototype = {
            type: 'circle',
            /**
             * 创建圆形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Circle~ICircleStyle} style
             */
            buildPath: function(ctx, style) {
                // Better stroking in ShapeBundle
                ctx.moveTo(style.x + style.r, style.y);
                ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);
                return;
            },

            /**
             * 计算返回圆形的包围盒矩形
             * @param {module:zrender/shape/Circle~ICircleStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x: Math.round(style.x - style.r - lineWidth / 2),
                    y: Math.round(style.y - style.r - lineWidth / 2),
                    width: style.r * 2 + lineWidth,
                    height: style.r * 2 + lineWidth
                };

                return style.__rect;
            }
        };

        require('../tool/util').inherits(Circle, Base);
        return Circle;
    });
    define('zrender/shape/Ellipse', ['require', './Base', '../tool/util'], function(require) {
        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Ellipse
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Ellipse = function(options) {
            Base.call(this, options);
            /**
             * 椭圆绘制样式
             * @name module:zrender/shape/Ellipse#style
             * @type {module:zrender/shape/Ellipse~IEllipseStyle}
             */
            /**
             * 椭圆高亮绘制样式
             * @name module:zrender/shape/Ellipse#highlightStyle
             * @type {module:zrender/shape/Ellipse~IEllipseStyle}
             */
        };

        Ellipse.prototype = {
            type: 'ellipse',

            /**
             * 构建椭圆的Path
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Ellipse~IEllipseStyle} style
             */
            buildPath: function(ctx, style) {
                var k = 0.5522848;
                var x = style.x;
                var y = style.y;
                var a = style.a;
                var b = style.b;
                var ox = a * k; // 水平控制点偏移量
                var oy = b * k; // 垂直控制点偏移量
                // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
                ctx.moveTo(x - a, y);
                ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
                ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
                ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
                ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
                ctx.closePath();
            },

            /**
            /**
             * 计算返回椭圆包围盒矩形。
             * @param {module:zrender/shape/Ellipse~IEllipseStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x: Math.round(style.x - style.a - lineWidth / 2),
                    y: Math.round(style.y - style.b - lineWidth / 2),
                    width: style.a * 2 + lineWidth,
                    height: style.b * 2 + lineWidth
                };

                return style.__rect;
            }
        };

        require('../tool/util').inherits(Ellipse, Base);
        return Ellipse;
    });
    define('zrender/shape/Polygon', ['require', './Base', './util/smoothSpline', './util/smoothBezier', './util/dashedLineTo', '../tool/util'], function(require) {
        var Base = require('./Base');
        var smoothSpline = require('./util/smoothSpline');
        var smoothBezier = require('./util/smoothBezier');
        var dashedLineTo = require('./util/dashedLineTo');

        /**
         * @alias module:zrender/shape/Polygon
         * @param {Object} options
         * @constructor
         * @extends module:zrender/shape/Base
         */
        var Polygon = function(options) {
            Base.call(this, options);
            /**
             * 多边形绘制样式
             * @name module:zrender/shape/Polygon#style
             * @type {module:zrender/shape/Polygon~IPolygonStyle}
             */
            /**
             * 多边形高亮绘制样式
             * @name module:zrender/shape/Polygon#highlightStyle
             * @type {module:zrender/shape/Polygon~IPolygonStyle}
             */
        };

        Polygon.prototype = {
            type: 'polygon',

            /**
             * 创建多边形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Polygon~IPolygonStyle} style
             */
            buildPath: function(ctx, style) {
                // 虽然能重用brokenLine，但底层图形基于性能考虑，重复代码减少调用吧
                var pointList = style.pointList;
                // 开始点和结束点重复
                /*
                var start = pointList[0];
                var end = pointList[pointList.length-1];

                if (start && end) {
                    if (start[0] == end[0] &&
                        start[1] == end[1]) {
                        // 移除最后一个点
                        pointList.pop();
                    }
                }
                */

                if (pointList.length < 2) {
                    // 少于2个点就不画了~
                    return;
                }

                if (style.smooth && style.smooth !== 'spline') {
                    var controlPoints = smoothBezier(
                        pointList, style.smooth, true, style.smoothConstraint
                    );

                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    var cp1;
                    var cp2;
                    var p;
                    var len = pointList.length;
                    for (var i = 0; i < len; i++) {
                        cp1 = controlPoints[i * 2];
                        cp2 = controlPoints[i * 2 + 1];
                        p = pointList[(i + 1) % len];
                        ctx.bezierCurveTo(
                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                        );
                    }
                } else {
                    if (style.smooth === 'spline') {
                        pointList = smoothSpline(pointList, true);
                    }

                    if (!style.lineType || style.lineType == 'solid') {
                        // 默认为实线
                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        for (var i = 1, l = pointList.length; i < l; i++) {
                            ctx.lineTo(pointList[i][0], pointList[i][1]);
                        }
                        ctx.lineTo(pointList[0][0], pointList[0][1]);
                    } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                        var dashLength =
                            style._dashLength || (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                        style._dashLength = dashLength;
                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        for (var i = 1, l = pointList.length; i < l; i++) {
                            dashedLineTo(
                                ctx,
                                pointList[i - 1][0], pointList[i - 1][1],
                                pointList[i][0], pointList[i][1],
                                dashLength
                            );
                        }
                        dashedLineTo(
                            ctx,
                            pointList[pointList.length - 1][0],
                            pointList[pointList.length - 1][1],
                            pointList[0][0],
                            pointList[0][1],
                            dashLength
                        );
                    }
                }

                ctx.closePath();
                return;
            },

            /**
             * 计算返回多边形包围盒矩阵
             * @param {module:zrender/shape/Polygon~IPolygonStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var minX = Number.MAX_VALUE;
                var maxX = Number.MIN_VALUE;
                var minY = Number.MAX_VALUE;
                var maxY = Number.MIN_VALUE;

                var pointList = style.pointList;
                for (var i = 0, l = pointList.length; i < l; i++) {
                    if (pointList[i][0] < minX) {
                        minX = pointList[i][0];
                    }
                    if (pointList[i][0] > maxX) {
                        maxX = pointList[i][0];
                    }
                    if (pointList[i][1] < minY) {
                        minY = pointList[i][1];
                    }
                    if (pointList[i][1] > maxY) {
                        maxY = pointList[i][1];
                    }
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }

                style.__rect = {
                    x: Math.round(minX - lineWidth / 2),
                    y: Math.round(minY - lineWidth / 2),
                    width: maxX - minX + lineWidth,
                    height: maxY - minY + lineWidth
                };
                return style.__rect;
            }
        };

        require('../tool/util').inherits(Polygon, Base);
        return Polygon;
    });
    define('echarts/component/roamController', ['require', './base', 'zrender/shape/Rectangle', 'zrender/shape/Sector', 'zrender/shape/Circle', '../config', 'zrender/tool/util', 'zrender/tool/color', 'zrender/tool/event', '../component'], function(require) {
        var Base = require('./base');

        // 图形依赖
        var RectangleShape = require('zrender/shape/Rectangle');
        var SectorShape = require('zrender/shape/Sector');
        var CircleShape = require('zrender/shape/Circle');

        var ecConfig = require('../config');
        ecConfig.roamController = {
            zlevel: 0, // 一级层叠
            z: 4, // 二级层叠
            show: true,
            x: 'left', // 水平安放位置，默认为全图左对齐，可选为：
            // 'center' ¦ 'left' ¦ 'right'
            // ¦ {number}（x坐标，单位px）
            y: 'top', // 垂直安放位置，默认为全图顶端，可选为：
            // 'top' ¦ 'bottom' ¦ 'center'
            // ¦ {number}（y坐标，单位px）
            width: 80,
            height: 120,
            backgroundColor: 'rgba(0,0,0,0)',
            borderColor: '#ccc', // 图例边框颜色
            borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框）
            padding: 5, // 图例内边距，单位px，默认各方向内边距为5，
            // 接受数组分别设定上右下左边距，同css
            handleColor: '#6495ed',
            fillerColor: '#fff',
            step: 15, // 移动幅度
            mapTypeControl: null
        };

        var zrUtil = require('zrender/tool/util');
        var zrColor = require('zrender/tool/color');
        var zrEvent = require('zrender/tool/event');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         */
        function RoamController(ecTheme, messageCenter, zr, option, myChart) {
            this.rcOption = {};

            if (!option.roamController || !option.roamController.show) {
                return;
            }
            if (!option.roamController.mapTypeControl) {
                console.error('option.roamController.mapTypeControl has not been defined.');
                return;
            }

            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.rcOption = option.roamController;

            var self = this;
            this._drictionMouseDown = function(params) {
                return self.__drictionMouseDown(params);
            };
            this._drictionMouseUp = function(params) {
                return self.__drictionMouseUp(params);
            };
            this._drictionMouseMove = function(params) {
                return self.__drictionMouseMove(params);
            };
            this._drictionMouseOut = function(params) {
                return self.__drictionMouseOut(params);
            };
            this._scaleHandler = function(params) {
                return self.__scaleHandler(params);
            };
            this.refresh(option);
        }

        RoamController.prototype = {
            type: ecConfig.COMPONENT_TYPE_ROAMCONTROLLER,
            _buildShape: function() {
                if (!this.rcOption.show) {
                    return;
                }
                // 元素组的位置参数，通过计算所得x, y, width, height
                this._itemGroupLocation = this._getItemGroupLocation();

                this._buildBackground();
                this._buildItem();

                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            /**
             * 构建所有漫游控制器元素
             */
            _buildItem: function() {
                this.shapeList.push(this._getDirectionShape('up'));
                this.shapeList.push(this._getDirectionShape('down'));
                this.shapeList.push(this._getDirectionShape('left'));
                this.shapeList.push(this._getDirectionShape('right'));
                this.shapeList.push(this._getScaleShape('scaleUp'));
                this.shapeList.push(this._getScaleShape('scaleDown'));
            },

            _getDirectionShape: function(direction) {
                var r = this._itemGroupLocation.r;
                var x = this._itemGroupLocation.x + r;
                var y = this._itemGroupLocation.y + r;

                var sectorShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: x, // 圆心横坐标
                        y: y, // 圆心纵坐标
                        r: r, // 圆环外半径
                        startAngle: -45,
                        endAngle: 45,
                        color: this.rcOption.handleColor,
                        text: '>',
                        textX: x + r / 2 + 4,
                        textY: y - 0.5,
                        textAlign: 'center',
                        textBaseline: 'middle',
                        textPosition: 'specific',
                        textColor: this.rcOption.fillerColor,
                        textFont: Math.floor(r / 2) + 'px arial'
                    },
                    highlightStyle: {
                        color: zrColor.lift(this.rcOption.handleColor, -0.2),
                        brushType: 'fill'
                    },
                    clickable: true
                };
                switch (direction) {
                    case 'up':
                        sectorShape.rotation = [Math.PI / 2, x, y];
                        break;
                    case 'left':
                        sectorShape.rotation = [Math.PI, x, y];
                        break;
                    case 'down':
                        sectorShape.rotation = [-Math.PI / 2, x, y];
                        break;
                }

                sectorShape = new SectorShape(sectorShape);
                sectorShape._roamType = direction;
                sectorShape.onmousedown = this._drictionMouseDown;
                sectorShape.onmouseup = this._drictionMouseUp;
                sectorShape.onmousemove = this._drictionMouseMove;
                sectorShape.onmouseout = this._drictionMouseOut;

                return sectorShape;
            },

            _getScaleShape: function(text) {
                var width = this._itemGroupLocation.width;
                var height = this._itemGroupLocation.height - width;
                height = height < 0 ? 20 : height; // 确保height不为负

                var r = Math.min(width / 2 - 5, height) / 2;
                var x = this._itemGroupLocation.x + (text === 'scaleDown' ? (width - r) : r);
                var y = this._itemGroupLocation.y + this._itemGroupLocation.height - r;

                var scaleShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: x,
                        y: y,
                        r: r,
                        color: this.rcOption.handleColor,
                        text: text === 'scaleDown' ? '-' : '+',
                        textX: x,
                        textY: y - 2,
                        textAlign: 'center',
                        textBaseline: 'middle',
                        textPosition: 'specific',
                        textColor: this.rcOption.fillerColor,
                        textFont: Math.floor(r) + 'px verdana'
                    },
                    highlightStyle: {
                        color: zrColor.lift(this.rcOption.handleColor, -0.2),
                        brushType: 'fill'
                    },
                    clickable: true
                };

                scaleShape = new CircleShape(scaleShape);
                scaleShape._roamType = text;
                scaleShape.onmousedown = this._scaleHandler;

                return scaleShape;
            },

            _buildBackground: function() {
                var padding = this.reformCssArray(this.rcOption.padding);

                this.shapeList.push(new RectangleShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this._itemGroupLocation.x - padding[3],
                        y: this._itemGroupLocation.y - padding[0],
                        width: this._itemGroupLocation.width + padding[3] + padding[1],
                        height: this._itemGroupLocation.height + padding[0] + padding[2],
                        brushType: this.rcOption.borderWidth === 0 ? 'fill' : 'both',
                        color: this.rcOption.backgroundColor,
                        strokeColor: this.rcOption.borderColor,
                        lineWidth: this.rcOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算漫游控制器实体的位置坐标
             */
            _getItemGroupLocation: function() {
                var padding = this.reformCssArray(this.rcOption.padding);
                var width = this.rcOption.width;
                var height = this.rcOption.height;

                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();
                var x;
                switch (this.rcOption.x) {
                    case 'center':
                        x = Math.floor((zrWidth - width) / 2);
                        break;
                    case 'left':
                        x = padding[3] + this.rcOption.borderWidth;
                        break;
                    case 'right':
                        x = zrWidth - width - padding[1] - padding[3] - this.rcOption.borderWidth * 2;
                        break;
                    default:
                        x = this.parsePercent(this.rcOption.x, zrWidth);
                        break;
                }

                var y;
                switch (this.rcOption.y) {
                    case 'top':
                        y = padding[0] + this.rcOption.borderWidth;
                        break;
                    case 'bottom':
                        y = zrHeight - height - padding[0] - padding[2] - this.rcOption.borderWidth * 2;
                        break;
                    case 'center':
                        y = Math.floor((zrHeight - height) / 2);
                        break;
                    default:
                        y = this.parsePercent(this.rcOption.y, zrHeight);
                        break;
                }

                return {
                    x: x,
                    y: y,
                    r: width / 2,
                    width: width,
                    height: height
                };
            },

            __drictionMouseDown: function(params) {
                this.mousedown = true;
                this._drictionHandlerOn(params);
            },

            __drictionMouseUp: function(params) {
                this.mousedown = false;
                this._drictionHandlerOff(params);
            },

            __drictionMouseMove: function(params) {
                if (this.mousedown) {
                    this._drictionHandlerOn(params);
                }
            },

            __drictionMouseOut: function(params) {
                this._drictionHandlerOff(params);
            },

            _drictionHandlerOn: function(params) {
                this._dispatchEvent(params.event, params.target._roamType);
                clearInterval(this.dircetionTimer);
                var self = this;
                this.dircetionTimer = setInterval(function() {
                    self._dispatchEvent(params.event, params.target._roamType);
                }, 100);
                zrEvent.stop(params.event);
            },

            _drictionHandlerOff: function(params) {
                clearInterval(this.dircetionTimer);
            },

            __scaleHandler: function(params) {
                this._dispatchEvent(params.event, params.target._roamType);
                zrEvent.stop(params.event);
            },

            _dispatchEvent: function(event, roamType) {
                this.messageCenter.dispatch(
                    ecConfig.EVENT.ROAMCONTROLLER,
                    event, {
                        roamType: roamType,
                        mapTypeControl: this.rcOption.mapTypeControl,
                        step: this.rcOption.step
                    },
                    this.myChart
                );
            },
            /**
             * 刷新
             */
            refresh: function(newOption) {
                if (newOption) {
                    this.option = newOption || this.option;
                    this.option.roamController = this.reformOption(this.option.roamController);
                    this.rcOption = this.option.roamController;
                }
                this.clear();
                this._buildShape();
            }
        };


        zrUtil.inherits(RoamController, Base);

        require('../component').define('roamController', RoamController);

        return RoamController;
    });
    define('echarts/util/mapData/params', ['require'], function(require) {
        function decode(json) {
            if (!json.UTF8Encoding) {
                return json;
            }
            var features = json.features;

            for (var f = 0; f < features.length; f++) {
                var feature = features[f];
                var coordinates = feature.geometry.coordinates;
                var encodeOffsets = feature.geometry.encodeOffsets;

                for (var c = 0; c < coordinates.length; c++) {
                    var coordinate = coordinates[c];

                    if (feature.geometry.type === 'Polygon') {
                        coordinates[c] = decodePolygon(
                            coordinate,
                            encodeOffsets[c]
                        );
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        for (var c2 = 0; c2 < coordinate.length; c2++) {
                            var polygon = coordinate[c2];
                            coordinate[c2] = decodePolygon(
                                polygon,
                                encodeOffsets[c][c2]
                            );
                        }
                    }
                }
            }
            // Has been decoded
            json.UTF8Encoding = false;
            return json;
        }

        function decodePolygon(coordinate, encodeOffsets) {
            var result = [];
            var prevX = encodeOffsets[0];
            var prevY = encodeOffsets[1];

            for (var i = 0; i < coordinate.length; i += 2) {
                var x = coordinate.charCodeAt(i) - 64;
                var y = coordinate.charCodeAt(i + 1) - 64;
                // ZigZag decoding
                x = (x >> 1) ^ (-(x & 1));
                y = (y >> 1) ^ (-(y & 1));
                // Delta deocding
                x += prevX;
                y += prevY;

                prevX = x;
                prevY = y;
                // Dequantize
                result.push([x / 1024, y / 1024]);
            }

            return result;
        }

        var mapParams = {
            'none': {
                getGeoJson: function(callback) {
                    callback({
                        type: 'FeatureCollection',
                        features: [{
                            type: 'Feature',
                            geometry: {
                                coordinates: [],
                                encodeOffsets: [],
                                type: 'Polygon'
                            },
                            properties: {

                            }
                        }]
                    });
                }
            },
            'world': {
                getGeoJson: function(callback) {
                    require(['./geoJson/world_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            'china': {
                getGeoJson: function(callback) {
                    require(['./geoJson/china_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '南海诸岛': {
                textCoord: [126, 25],
                getPath: function(leftTop, scale) {
                    // scale.x: width  = 10.51 : 64
                    var pList = [
                        [
                            [0, 3.5],
                            [7, 11.2],
                            [15, 11.9],
                            [30, 7],
                            [42, 0.7],
                            [52, 0.7],
                            [56, 7.7],
                            [59, 0.7],
                            [64, 0.7],
                            [64, 0],
                            [5, 0],
                            [0, 3.5]
                        ],
                        [
                            [13, 16.1],
                            [19, 14.7],
                            [16, 21.7],
                            [11, 23.1],
                            [13, 16.1]
                        ],
                        [
                            [12, 32.2],
                            [14, 38.5],
                            [15, 38.5],
                            [13, 32.2],
                            [12, 32.2]
                        ],
                        [
                            [16, 47.6],
                            [12, 53.2],
                            [13, 53.2],
                            [18, 47.6],
                            [16, 47.6]
                        ],
                        [
                            [6, 64.4],
                            [8, 70],
                            [9, 70],
                            [8, 64.4],
                            [6, 64.4]
                        ],
                        [
                            [23, 82.6],
                            [29, 79.8],
                            [30, 79.8],
                            [25, 82.6],
                            [23, 82.6]
                        ],
                        [
                            [37, 70.7],
                            [43, 62.3],
                            [44, 62.3],
                            [39, 70.7],
                            [37, 70.7]
                        ],
                        [
                            [48, 51.1],
                            [51, 45.5],
                            [53, 45.5],
                            [50, 51.1],
                            [48, 51.1]
                        ],
                        [
                            [51, 35],
                            [51, 28.7],
                            [53, 28.7],
                            [53, 35],
                            [51, 35]
                        ],
                        [
                            [52, 22.4],
                            [55, 17.5],
                            [56, 17.5],
                            [53, 22.4],
                            [52, 22.4]
                        ],
                        [
                            [58, 12.6],
                            [62, 7],
                            [63, 7],
                            [60, 12.6],
                            [58, 12.6]
                        ],
                        [
                            [0, 3.5],
                            [0, 93.1],
                            [64, 93.1],
                            [64, 0],
                            [63, 0],
                            [63, 92.4],
                            [1, 92.4],
                            [1, 3.5],
                            [0, 3.5]
                        ]
                    ];
                    var str = '';
                    var left = leftTop[0];
                    var top = leftTop[1];
                    for (var i = 0, l = pList.length; i < l; i++) {
                        str += 'M ' + ((pList[i][0][0] * scale + left).toFixed(2) - 0) + ' ' + ((pList[i][0][1] * scale + top).toFixed(2) - 0) + ' ';
                        for (var j = 1, k = pList[i].length; j < k; j++) {
                            str += 'L ' + ((pList[i][j][0] * scale + left).toFixed(2) - 0) + ' ' + ((pList[i][j][1] * scale + top).toFixed(2) - 0) + ' ';
                        }
                    }
                    return str + ' Z';
                }
            },
            '新疆': {
                getGeoJson: function(callback) {
                    require(['./geoJson/xin_jiang_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '西藏': {
                getGeoJson: function(callback) {
                    require(['./geoJson/xi_zang_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '内蒙古': {
                getGeoJson: function(callback) {
                    require(['./geoJson/nei_meng_gu_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '青海': {
                getGeoJson: function(callback) {
                    require(['./geoJson/qing_hai_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '四川': {
                getGeoJson: function(callback) {
                    require(['./geoJson/si_chuan_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '黑龙江': {
                getGeoJson: function(callback) {
                    require(['./geoJson/hei_long_jiang_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '甘肃': {
                getGeoJson: function(callback) {
                    require(['./geoJson/gan_su_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '云南': {
                getGeoJson: function(callback) {
                    require(['./geoJson/yun_nan_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '广西': {
                getGeoJson: function(callback) {
                    require(['./geoJson/guang_xi_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '湖南': {
                getGeoJson: function(callback) {
                    require(['./geoJson/hu_nan_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '陕西': {
                getGeoJson: function(callback) {
                    require(['./geoJson/shan_xi_1_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '广东': {
                getGeoJson: function(callback) {
                    require(['./geoJson/guang_dong_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '吉林': {
                getGeoJson: function(callback) {
                    require(['./geoJson/ji_lin_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '河北': {
                getGeoJson: function(callback) {
                    require(['./geoJson/he_bei_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '湖北': {
                getGeoJson: function(callback) {
                    require(['./geoJson/hu_bei_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '贵州': {
                getGeoJson: function(callback) {
                    require(['./geoJson/gui_zhou_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '山东': {
                getGeoJson: function(callback) {
                    require(['./geoJson/shan_dong_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '江西': {
                getGeoJson: function(callback) {
                    require(['./geoJson/jiang_xi_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '河南': {
                getGeoJson: function(callback) {
                    require(['./geoJson/he_nan_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '辽宁': {
                getGeoJson: function(callback) {
                    require(['./geoJson/liao_ning_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '山西': {
                getGeoJson: function(callback) {
                    require(['./geoJson/shan_xi_2_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '安徽': {
                getGeoJson: function(callback) {
                    require(['./geoJson/an_hui_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '福建': {
                getGeoJson: function(callback) {
                    require(['./geoJson/fu_jian_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '浙江': {
                getGeoJson: function(callback) {
                    require(['./geoJson/zhe_jiang_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '江苏': {
                getGeoJson: function(callback) {
                    require(['./geoJson/jiang_su_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '重庆': {
                getGeoJson: function(callback) {
                    require(['./geoJson/chong_qing_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '宁夏': {
                getGeoJson: function(callback) {
                    require(['./geoJson/ning_xia_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '海南': {
                getGeoJson: function(callback) {
                    require(['./geoJson/hai_nan_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '台湾': {
                getGeoJson: function(callback) {
                    require(['./geoJson/tai_wan_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '北京': {
                getGeoJson: function(callback) {
                    require(['./geoJson/bei_jing_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '天津': {
                getGeoJson: function(callback) {
                    require(['./geoJson/tian_jin_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '上海': {
                getGeoJson: function(callback) {
                    require(['./geoJson/shang_hai_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '香港': {
                getGeoJson: function(callback) {
                    require(['./geoJson/xiang_gang_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            },
            '澳门': {
                getGeoJson: function(callback) {
                    require(['./geoJson/ao_men_geo'], function(md) {
                        callback(decode(md));
                    });
                }
            }
        };

        return {
            decode: decode,
            params: mapParams
        };
    });
    define('echarts/layer/heatmap', ['require'], function(require) {
        var defaultOptions = {
            blurSize: 30,

            // gradientColors is either shaped of ['blue', 'cyan', 'lime', 'yellow', 'red']
            // or [{
            //    offset: 0.2,
            //    color: 'blue'
            // }, {
            //    offset 0.8,
            //    color: 'cyan'
            // }]
            gradientColors: ['blue', 'cyan', 'lime', 'yellow', 'red'],
            minAlpha: 0.05,
            valueScale: 1,
            opacity: 1
        };

        var BRUSH_SIZE = 20;
        var GRADIENT_LEVELS = 256;

        /**
         * Heatmap Chart
         *
         * @class
         * @param {Object} opt options
         */
        function Heatmap(opt) {
            this.option = opt;
            if (opt) {
                for (var i in defaultOptions) {
                    if (opt[i] !== undefined) {
                        this.option[i] = opt[i];
                    } else {
                        this.option[i] = defaultOptions[i];
                    }
                }
            } else {
                this.option = defaultOptions;
            }
        }

        Heatmap.prototype = {
            /**
             * Renders Heatmap and returns the rendered canvas
             * @param {Array} [x, y, value] array of data
             * @param {number} canvas width
             * @param {number} canvas height
             * @return {Object} rendered canvas
             */
            getCanvas: function(data, width, height) {
                var brush = this._getBrush();
                var gradient = this._getGradient();
                var r = BRUSH_SIZE + this.option.blurSize;

                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                var ctx = canvas.getContext('2d');

                var len = data.length;
                for (var i = 0; i < len; ++i) {
                    var p = data[i];
                    var x = p[0];
                    var y = p[1];
                    var value = p[2];

                    // calculate alpha using value
                    var alpha = Math.min(1, Math.max(value * this.option.valueScale || this.option.minAlpha, this.option.minAlpha));

                    // draw with the circle brush with alpha
                    ctx.globalAlpha = alpha;
                    ctx.drawImage(brush, x - r, y - r);
                }

                // colorize the canvas using alpha value and set with gradient
                var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var pixels = imageData.data;
                var len = pixels.length / 4;
                while (len--) {
                    var id = len * 4 + 3;
                    var alpha = pixels[id] / 256;
                    var colorOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1));
                    pixels[id - 3] = gradient[colorOffset * 4]; // red
                    pixels[id - 2] = gradient[colorOffset * 4 + 1]; // green
                    pixels[id - 1] = gradient[colorOffset * 4 + 2]; // blue
                    pixels[id] *= this.option.opacity; // alpha
                }
                ctx.putImageData(imageData, 0, 0);

                return canvas;
            },

            /**
             * get canvas of a black circle brush used for canvas to draw later
             * @private
             * @returns {Object} circle brush canvas
             */
            _getBrush: function() {
                if (!this._brushCanvas) {
                    this._brushCanvas = document.createElement('canvas');

                    // set brush size
                    var r = BRUSH_SIZE + this.option.blurSize;
                    var d = r * 2;
                    this._brushCanvas.width = d;
                    this._brushCanvas.height = d;

                    var ctx = this._brushCanvas.getContext('2d');

                    // in order to render shadow without the distinct circle,
                    // draw the distinct circle in an invisible place,
                    // and use shadowOffset to draw shadow in the center of the canvas
                    ctx.shadowOffsetX = d;
                    ctx.shadowBlur = this.option.blurSize;
                    // draw the shadow in black, and use alpha and shadow blur to generate
                    // color in color map
                    ctx.shadowColor = 'black';

                    // draw circle in the left to the canvas
                    ctx.beginPath();
                    ctx.arc(-r, r, BRUSH_SIZE, 0, Math.PI * 2, true);
                    ctx.closePath();
                    ctx.fill();
                }
                return this._brushCanvas;
            },

            /**
             * get gradient color map
             * @private
             * @returns {array} gradient color pixels
             */
            _getGradient: function() {
                if (!this._gradientPixels) {
                    var levels = GRADIENT_LEVELS;
                    var canvas = document.createElement('canvas');
                    canvas.width = 1;
                    canvas.height = levels;
                    var ctx = canvas.getContext('2d');

                    // add color to gradient stops
                    var gradient = ctx.createLinearGradient(0, 0, 0, levels);
                    var len = this.option.gradientColors.length;
                    for (var i = 0; i < len; ++i) {
                        if (typeof this.option.gradientColors[i] === 'string') {
                            gradient.addColorStop((i + 1) / len,
                                this.option.gradientColors[i]);
                        } else {
                            gradient.addColorStop(this.option.gradientColors[i].offset,
                                this.option.gradientColors[i].color);
                        }
                    }

                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 1, levels);
                    this._gradientPixels = ctx.getImageData(0, 0, 1, levels).data;
                }
                return this._gradientPixels;
            }
        };

        return Heatmap;
    });
    define('echarts/util/mapData/geoCoord', [], function() {
        return {
            'Russia': [100, 60],
            'United States of America': [-99, 38]
        };
    });
    define('echarts/util/mapData/textFixed', [], function() {
        // fix = [xFixed, yFixed, scale]
        // textX += fix[0];
        // textY += fix[1];
        return {
            //'南海诸岛' : [32, 83],
            // 全国
            '广东': [0, -10],
            '香港': [10, 10],
            '澳门': [-10, 18],
            '黑龙江': [0, 20],
            //'北京': [-10, 0],
            '天津': [5, 5],
            // 广东
            '深圳市': [-35, 0],
            // 云南
            '红河哈尼族彝族自治州': [0, 20],
            '楚雄彝族自治州': [-5, 15],
            // 新疆
            '石河子市': [-5, 5],
            '五家渠市': [0, -10],
            '昌吉回族自治州': [10, 10],
            // 海南
            '昌江黎族自治县': [0, 20],
            '陵水黎族自治县': [0, 20],
            '东方市': [0, 20],
            // 陕西
            '渭南市': [0, 20]
        };
    });
    define('echarts/util/projection/svg', ['require', 'zrender/shape/Path'], function(require) {

        var PathShape = require('zrender/shape/Path');

        function toFloat(str) {
            return parseFloat(str || 0);
        }

        function getBbox(root) {
            var svgNode = root.firstChild;
            // Find the svg node
            while (!(svgNode.nodeName.toLowerCase() == 'svg' && svgNode.nodeType == 1)) {
                svgNode = svgNode.nextSibling;
            }

            var x = toFloat(svgNode.getAttribute('x'));
            var y = toFloat(svgNode.getAttribute('y'));
            var width = toFloat(svgNode.getAttribute('width'));
            var height = toFloat(svgNode.getAttribute('height'));
            return {
                left: x,
                top: y,
                width: width,
                height: height
            };
        }

        function geoJson2Path(root, transform) {
            var scale = [transform.scale.x, transform.scale.y];
            var elList = [];

            function _getShape(root) {
                var tagName = root.tagName;
                if (shapeBuilders[tagName]) {
                    var obj = shapeBuilders[tagName](root, scale);

                    if (obj) {
                        // Common attributes
                        obj.scale = scale;
                        obj.properties = {
                            name: root.getAttribute('name') || ''
                        };
                        obj.id = root.id;
                        extendCommonAttributes(obj, root);

                        elList.push(obj);
                    }
                }
                var shapes = root.childNodes;
                for (var i = 0, len = shapes.length; i < len; i++) {
                    _getShape(shapes[i]);
                }
            }
            _getShape(root);
            return elList;
        }

        /**
         * 平面坐标转经纬度
         * @param {Array} p
         */
        function pos2geo(obj, p) {
            var point = p instanceof Array ? [p[0] * 1, p[1] * 1] : [p.x * 1, p.y * 1];
            return [point[0] / obj.scale.x, point[1] / obj.scale.y];
        }

        /**
         * 经纬度转平面坐标
         * @param {Array | Object} p
         */
        function geo2pos(obj, p) {
            var point = p instanceof Array ? [p[0] * 1, p[1] * 1] : [p.x * 1, p.y * 1];
            return [point[0] * obj.scale.x, point[1] * obj.scale.y];
        }

        function trim(str) {
            return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        }

        function extendCommonAttributes(obj, xmlNode) {

            var color = xmlNode.getAttribute('fill');
            var strokeColor = xmlNode.getAttribute('stroke');
            var lineWidth = xmlNode.getAttribute('stroke-width');
            var opacity = xmlNode.getAttribute('opacity');

            if (color && color != 'none') {
                obj.color = color;
                if (strokeColor) {
                    obj.brushType = 'both';
                    obj.strokeColor = strokeColor;
                } else {
                    obj.brushType = 'fill';
                }
            } else if (strokeColor && strokeColor != 'none') {
                obj.strokeColor = strokeColor;
                obj.brushType = 'stroke';
            }
            if (lineWidth && lineWidth != 'none') {
                obj.lineWidth = parseFloat(lineWidth);
            }
            if (opacity && opacity != 'none') {
                obj.opacity = parseFloat(opacity);
            }
        }

        function parsePoints(str) {
            var list = trim(str).replace(/,/g, ' ').split(/\s+/);
            var points = [];

            for (var i = 0; i < list.length;) {
                var x = parseFloat(list[i++]);
                var y = parseFloat(list[i++]);
                points.push([x, y]);
            }
            return points;
        }

        // Regular svg shapes
        var shapeBuilders = {
            path: function(xmlNode, scale) {
                var path = xmlNode.getAttribute('d');
                var rect = PathShape.prototype.getRect({
                    path: path
                });
                return {
                    shapeType: 'path',
                    path: path,
                    cp: [
                        (rect.x + rect.width / 2) * scale[0], (rect.y + rect.height / 2) * scale[1]
                    ]
                };
            },

            rect: function(xmlNode, scale) {
                var x = toFloat(xmlNode.getAttribute('x'));
                var y = toFloat(xmlNode.getAttribute('y'));
                var width = toFloat(xmlNode.getAttribute('width'));
                var height = toFloat(xmlNode.getAttribute('height'));

                return {
                    shapeType: 'rectangle',
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    cp: [
                        (x + width / 2) * scale[0], (y + height / 2) * scale[1]
                    ]
                };
            },

            line: function(xmlNode, scale) {
                var x1 = toFloat(xmlNode.getAttribute('x1'));
                var y1 = toFloat(xmlNode.getAttribute('y1'));
                var x2 = toFloat(xmlNode.getAttribute('x2'));
                var y2 = toFloat(xmlNode.getAttribute('y2'));

                return {
                    shapeType: 'line',
                    xStart: x1,
                    yStart: y1,
                    xEnd: x2,
                    yEnd: y2,
                    cp: [
                        (x1 + x2) * 0.5 * scale[0], (y1 + y2) * 0.5 * scale[1]
                    ]
                };
            },

            circle: function(xmlNode, scale) {
                var cx = toFloat(xmlNode.getAttribute('cx'));
                var cy = toFloat(xmlNode.getAttribute('cy'));
                var r = toFloat(xmlNode.getAttribute('r'));

                return {
                    shapeType: 'circle',
                    x: cx,
                    y: cy,
                    r: r,
                    cp: [
                        cx * scale[0],
                        cy * scale[1]
                    ]
                };
            },

            ellipse: function(xmlNode, scale) {
                var cx = parseFloat(xmlNode.getAttribute('cx') || 0);
                var cy = parseFloat(xmlNode.getAttribute('cy') || 0);
                var rx = parseFloat(xmlNode.getAttribute('rx') || 0);
                var ry = parseFloat(xmlNode.getAttribute('ry') || 0);

                return {
                    shapeType: 'ellipse',
                    x: cx,
                    y: cy,
                    a: rx,
                    b: ry,
                    cp: [
                        cx * scale[0],
                        cy * scale[1]
                    ]
                };
            },

            polygon: function(xmlNode, scale) {
                var points = xmlNode.getAttribute('points');
                var min = [Infinity, Infinity];
                var max = [-Infinity, -Infinity];
                if (points) {
                    points = parsePoints(points);

                    for (var i = 0; i < points.length; i++) {
                        var p = points[i];

                        min[0] = Math.min(p[0], min[0]);
                        min[1] = Math.min(p[1], min[1]);

                        max[0] = Math.max(p[0], max[0]);
                        max[1] = Math.max(p[1], max[1]);

                    }
                    return {
                        shapeType: 'polygon',
                        pointList: points,
                        cp: [
                            (min[0] + max[0]) / 2 * scale[0], (min[1] + max[1]) / 2 * scale[0]
                        ]
                    };
                }
            },

            polyline: function(xmlNode, scale) {
                var obj = shapeBuilders.polygon(xmlNode, scale);
                return obj;
            }
        };

        return {
            getBbox: getBbox,
            geoJson2Path: geoJson2Path,
            pos2geo: pos2geo,
            geo2pos: geo2pos
        };
    });
    define('echarts/util/projection/normal', [], function() {
        function getBbox(json, specialArea) {
            specialArea = specialArea || {};
            if (!json.srcSize) {
                parseSrcSize(json, specialArea);
            }

            return json.srcSize;
        }

        function parseSrcSize(json, specialArea) {
            specialArea = specialArea || {};
            convertorParse.xmin = 360;
            convertorParse.xmax = -360;
            convertorParse.ymin = 180;
            convertorParse.ymax = -180;

            var shapes = json.features;
            var geometries;
            var shape;
            for (var i = 0, len = shapes.length; i < len; i++) {
                shape = shapes[i];
                if (shape.properties.name && specialArea[shape.properties.name]) {
                    continue;
                }

                switch (shape.type) {
                    case 'Feature':
                        convertorParse[shape.geometry.type](shape.geometry.coordinates);
                        break;
                    case 'GeometryCollection':
                        geometries = shape.geometries;
                        for (var j = 0, len2 = geometries.length; j < len2; j++) {
                            convertorParse[geometries[j].type](
                                geometries[j].coordinates
                            );
                        }
                        break;
                }
            }

            json.srcSize = {
                left: convertorParse.xmin.toFixed(4) * 1,
                top: convertorParse.ymin.toFixed(4) * 1,
                width: (convertorParse.xmax - convertorParse.xmin).toFixed(4) * 1,
                height: (convertorParse.ymax - convertorParse.ymin).toFixed(4) * 1
            };

            return json;
        }

        var convertor = {
            //调整俄罗斯东部到地图右侧与俄罗斯相连
            formatPoint: function(p) {
                return [
                    ((p[0] < -168.5 && p[1] > 63.8) ? p[0] + 360 : p[0]) + 168.5,
                    90 - p[1]
                ];
            },
            makePoint: function(p) {
                var self = this;
                var point = self.formatPoint(p);
                // for cp
                if (self._bbox.xmin > p[0]) {
                    self._bbox.xmin = p[0];
                }
                if (self._bbox.xmax < p[0]) {
                    self._bbox.xmax = p[0];
                }
                if (self._bbox.ymin > p[1]) {
                    self._bbox.ymin = p[1];
                }
                if (self._bbox.ymax < p[1]) {
                    self._bbox.ymax = p[1];
                }
                var x = (point[0] - convertor.offset.x) * convertor.scale.x + convertor.offset.left;
                var y = (point[1] - convertor.offset.y) * convertor.scale.y + convertor.offset.top;
                return [x, y];
            },
            Point: function(coordinates) {
                coordinates = this.makePoint(coordinates);
                return coordinates.join(',');
            },
            LineString: function(coordinates) {
                var str = '';
                var point;
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    point = convertor.makePoint(coordinates[i]);
                    if (i === 0) {
                        str = 'M' + point.join(',');
                    } else {
                        str = str + 'L' + point.join(',');
                    }
                }
                return str;
            },
            Polygon: function(coordinates) {
                var str = '';
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    str = str + convertor.LineString(coordinates[i]) + 'z';
                }
                return str;
            },
            MultiPoint: function(coordinates) {
                var arr = [];
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    arr.push(convertor.Point(coordinates[i]));
                }
                return arr;
            },
            MultiLineString: function(coordinates) {
                var str = '';
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    str += convertor.LineString(coordinates[i]);
                }
                return str;
            },
            MultiPolygon: function(coordinates) {
                var str = '';
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    str += convertor.Polygon(coordinates[i]);
                }
                return str;
            }
        };

        var convertorParse = {
            formatPoint: convertor.formatPoint,

            makePoint: function(p) {
                var self = this;
                var point = self.formatPoint(p);
                var x = point[0];
                var y = point[1];
                if (self.xmin > x) {
                    self.xmin = x;
                }
                if (self.xmax < x) {
                    self.xmax = x;
                }
                if (self.ymin > y) {
                    self.ymin = y;
                }
                if (self.ymax < y) {
                    self.ymax = y;
                }
            },
            Point: function(coordinates) {
                this.makePoint(coordinates);
            },
            LineString: function(coordinates) {
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    this.makePoint(coordinates[i]);
                }
            },
            Polygon: function(coordinates) {
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    this.LineString(coordinates[i]);
                }
            },
            MultiPoint: function(coordinates) {
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    this.Point(coordinates[i]);
                }
            },
            MultiLineString: function(coordinates) {
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    this.LineString(coordinates[i]);
                }
            },
            MultiPolygon: function(coordinates) {
                for (var i = 0, len = coordinates.length; i < len; i++) {
                    this.Polygon(coordinates[i]);
                }
            }
        };

        function geoJson2Path(json, transform, specialArea) {
            specialArea = specialArea || {};
            convertor.scale = null;
            convertor.offset = null;

            if (!json.srcSize) {
                parseSrcSize(json, specialArea);
            }

            transform.offset = {
                x: json.srcSize.left,
                y: json.srcSize.top,
                left: transform.OffsetLeft || 0,
                top: transform.OffsetTop || 0
            };

            convertor.scale = transform.scale;
            convertor.offset = transform.offset;

            var shapes = json.features;
            var geometries;
            var pathArray = [];
            var val;
            var shape;
            for (var i = 0, len = shapes.length; i < len; i++) {
                shape = shapes[i];
                if (shape.properties.name && specialArea[shape.properties.name]) {
                    // 忽略specialArea
                    continue;
                }
                if (shape.type == 'Feature') {
                    pushApath(shape.geometry, shape);
                } else if (shape.type == 'GeometryCollection') {
                    geometries = shape.geometries;
                    for (var j = 0, len2 = geometries.length; j < len2; j++) {
                        val = geometries[j];
                        pushApath(val, val);
                    }
                }
            }

            var shapeType;
            var shapeCoordinates;
            var str;

            function pushApath(gm, shape) {
                shapeType = gm.type;
                shapeCoordinates = gm.coordinates;
                convertor._bbox = {
                    xmin: 360,
                    xmax: -360,
                    ymin: 180,
                    ymax: -180
                };
                str = convertor[shapeType](shapeCoordinates);
                pathArray.push({
                    // type: shapeType,
                    path: str,
                    cp: shape.properties.cp ? convertor.makePoint(shape.properties.cp) : convertor.makePoint([
                        (convertor._bbox.xmin + convertor._bbox.xmax) / 2, (convertor._bbox.ymin + convertor._bbox.ymax) / 2
                    ]),
                    properties: shape.properties,
                    id: shape.id
                });
            }

            return pathArray;
        }

        /**
         * 平面坐标转经纬度
         * @param {Array} p
         */
        function pos2geo(obj, p) {
            var x;
            var y;
            if (p instanceof Array) {
                x = p[0] * 1;
                y = p[1] * 1;
            } else {
                x = p.x * 1;
                y = p.y * 1;
            }

            x = x / obj.scale.x + obj.offset.x - 168.5;
            x = x > 180 ? x - 360 : x;
            y = 90 - (y / obj.scale.y + obj.offset.y);
            return [x, y];
        }

        /**
         * 经纬度转平面坐标
         * @param {Array | Object} p
         */
        function geo2pos(obj, p) {
            convertor.offset = obj.offset;
            convertor.scale = obj.scale;
            return p instanceof Array ? convertor.makePoint([p[0] * 1, p[1] * 1]) : convertor.makePoint([p.x * 1, p.y * 1]);
        }

        return {
            getBbox: getBbox,
            geoJson2Path: geoJson2Path,
            pos2geo: pos2geo,
            geo2pos: geo2pos
        };
    });
    define('echarts/util/ecQuery', ['require', 'zrender/tool/util'], function(require) {
        var zrUtil = require('zrender/tool/util');

        /**
         * 获取嵌套选项的基础方法
         * 返回optionTarget中位于optionLocation上的值，如果没有定义，则返回undefined
         */
        function query(optionTarget, optionLocation) {
            if (typeof optionTarget == 'undefined') {
                return;
            }

            if (!optionLocation) {
                return optionTarget;
            }

            optionLocation = optionLocation.split('.');
            var length = optionLocation.length;
            var curIdx = 0;
            while (curIdx < length) {
                optionTarget = optionTarget[optionLocation[curIdx]];
                if (typeof optionTarget == 'undefined') {
                    return;
                }
                curIdx++;
            }

            return optionTarget;
        }

        /**
         * 获取多级控制嵌套属性的基础方法
         * 返回ctrList中优先级最高（最靠前）的非undefined属性，ctrList中均无定义则返回undefined
         */
        function deepQuery(ctrList, optionLocation) {
            var finalOption;
            for (var i = 0, l = ctrList.length; i < l; i++) {
                finalOption = query(ctrList[i], optionLocation);
                if (typeof finalOption != 'undefined') {
                    return finalOption;
                }
            }
        }

        /**
         * 获取多级控制嵌套属性的基础方法
         * 根据ctrList中优先级合并产出目标属性
         */
        function deepMerge(ctrList, optionLocation) {
            var finalOption;
            var len = ctrList.length;
            while (len--) {
                var tempOption = query(ctrList[len], optionLocation);
                if (typeof tempOption != 'undefined') {
                    if (typeof finalOption == 'undefined') {
                        finalOption = zrUtil.clone(tempOption);
                    } else {
                        zrUtil.merge(
                            finalOption, tempOption, true
                        );
                    }
                }
            }

            return finalOption;
        }

        return {
            query: query,
            deepQuery: deepQuery,
            deepMerge: deepMerge
        };
    });
    define('echarts/util/shape/Icon', ['require', 'zrender/tool/util', 'zrender/shape/Star', 'zrender/shape/Heart', 'zrender/shape/Droplet', 'zrender/shape/Image', 'zrender/shape/Base'], function(require) {
        var zrUtil = require('zrender/tool/util');

        function _iconMark(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;
            ctx.moveTo(x, y + style.height);
            ctx.lineTo(x + 5 * dx, y + 14 * dy);
            ctx.lineTo(x + style.width, y + 3 * dy);
            ctx.lineTo(x + 13 * dx, y);
            ctx.lineTo(x + 2 * dx, y + 11 * dy);
            ctx.lineTo(x, y + style.height);

            ctx.moveTo(x + 6 * dx, y + 10 * dy);
            ctx.lineTo(x + 14 * dx, y + 2 * dy);

            ctx.moveTo(x + 10 * dx, y + 13 * dy);
            ctx.lineTo(x + style.width, y + 13 * dy);

            ctx.moveTo(x + 13 * dx, y + 10 * dy);
            ctx.lineTo(x + 13 * dx, y + style.height);
        }

        function _iconMarkUndo(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;
            ctx.moveTo(x, y + style.height);
            ctx.lineTo(x + 5 * dx, y + 14 * dy);
            ctx.lineTo(x + style.width, y + 3 * dy);
            ctx.lineTo(x + 13 * dx, y);
            ctx.lineTo(x + 2 * dx, y + 11 * dy);
            ctx.lineTo(x, y + style.height);

            ctx.moveTo(x + 6 * dx, y + 10 * dy);
            ctx.lineTo(x + 14 * dx, y + 2 * dy);

            ctx.moveTo(x + 10 * dx, y + 13 * dy);
            ctx.lineTo(x + style.width, y + 13 * dy);
        }

        function _iconMarkClear(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(x + 4 * dx, y + 15 * dy);
            ctx.lineTo(x + 9 * dx, y + 13 * dy);
            ctx.lineTo(x + 14 * dx, y + 8 * dy);
            ctx.lineTo(x + 11 * dx, y + 5 * dy);
            ctx.lineTo(x + 6 * dx, y + 10 * dy);
            ctx.lineTo(x + 4 * dx, y + 15 * dy);

            ctx.moveTo(x + 5 * dx, y);
            ctx.lineTo(x + 11 * dx, y);
            ctx.moveTo(x + 5 * dx, y + dy);
            ctx.lineTo(x + 11 * dx, y + dy);
            ctx.moveTo(x, y + 2 * dy);
            ctx.lineTo(x + style.width, y + 2 * dy);

            ctx.moveTo(x, y + 5 * dy);
            ctx.lineTo(x + 3 * dx, y + style.height);
            ctx.lineTo(x + 13 * dx, y + style.height);
            ctx.lineTo(x + style.width, y + 5 * dy);
        }

        function _iconDataZoom(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(x, y + 3 * dy);
            ctx.lineTo(x + 6 * dx, y + 3 * dy);

            ctx.moveTo(x + 3 * dx, y);
            ctx.lineTo(x + 3 * dx, y + 6 * dy);

            ctx.moveTo(x + 3 * dx, y + 8 * dy);
            ctx.lineTo(x + 3 * dx, y + style.height);
            ctx.lineTo(x + style.width, y + style.height);
            ctx.lineTo(x + style.width, y + 3 * dy);
            ctx.lineTo(x + 8 * dx, y + 3 * dy);
        }

        function _iconDataZoomReset(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(x + 6 * dx, y);
            ctx.lineTo(x + 2 * dx, y + 3 * dy);
            ctx.lineTo(x + 6 * dx, y + 6 * dy);

            ctx.moveTo(x + 2 * dx, y + 3 * dy);
            ctx.lineTo(x + 14 * dx, y + 3 * dy);
            ctx.lineTo(x + 14 * dx, y + 11 * dy);

            ctx.moveTo(x + 2 * dx, y + 5 * dy);
            ctx.lineTo(x + 2 * dx, y + 13 * dy);
            ctx.lineTo(x + 14 * dx, y + 13 * dy);

            ctx.moveTo(x + 10 * dx, y + 10 * dy);
            ctx.lineTo(x + 14 * dx, y + 13 * dy);
            ctx.lineTo(x + 10 * dx, y + style.height);
        }

        function _iconRestore(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;
            var r = style.width / 2;

            ctx.lineWidth = 1.5;

            ctx.arc(x + r, y + r, r - dx, 0, Math.PI * 2 / 3);
            ctx.moveTo(x + 3 * dx, y + style.height);
            ctx.lineTo(x + 0 * dx, y + 12 * dy);
            ctx.lineTo(x + 5 * dx, y + 11 * dy);

            ctx.moveTo(x, y + 8 * dy);
            ctx.arc(x + r, y + r, r - dx, Math.PI, Math.PI * 5 / 3);
            ctx.moveTo(x + 13 * dx, y);
            ctx.lineTo(x + style.width, y + 4 * dy);
            ctx.lineTo(x + 11 * dx, y + 5 * dy);
        }

        function _iconLineChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(x, y);
            ctx.lineTo(x, y + style.height);
            ctx.lineTo(x + style.width, y + style.height);

            ctx.moveTo(x + 2 * dx, y + 14 * dy);
            ctx.lineTo(x + 7 * dx, y + 6 * dy);
            ctx.lineTo(x + 11 * dx, y + 11 * dy);
            ctx.lineTo(x + 15 * dx, y + 2 * dy);
        }

        function _iconBarChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(x, y);
            ctx.lineTo(x, y + style.height);
            ctx.lineTo(x + style.width, y + style.height);

            ctx.moveTo(x + 3 * dx, y + 14 * dy);
            ctx.lineTo(x + 3 * dx, y + 6 * dy);
            ctx.lineTo(x + 4 * dx, y + 6 * dy);
            ctx.lineTo(x + 4 * dx, y + 14 * dy);
            ctx.moveTo(x + 7 * dx, y + 14 * dy);
            ctx.lineTo(x + 7 * dx, y + 2 * dy);
            ctx.lineTo(x + 8 * dx, y + 2 * dy);
            ctx.lineTo(x + 8 * dx, y + 14 * dy);
            ctx.moveTo(x + 11 * dx, y + 14 * dy);
            ctx.lineTo(x + 11 * dx, y + 9 * dy);
            ctx.lineTo(x + 12 * dx, y + 9 * dy);
            ctx.lineTo(x + 12 * dx, y + 14 * dy);
        }

        function _iconPieChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width - 2;
            var height = style.height - 2;
            var r = Math.min(width, height) / 2;
            y += 2;
            ctx.moveTo(x + r + 3, y + r - 3);
            ctx.arc(x + r + 3, y + r - 3, r - 1, 0, -Math.PI / 2, true);
            ctx.lineTo(x + r + 3, y + r - 3);

            ctx.moveTo(x + r, y);
            ctx.lineTo(x + r, y + r);
            ctx.arc(x + r, y + r, r, -Math.PI / 2, Math.PI * 2, true);
            ctx.lineTo(x + r, y + r);
            ctx.lineWidth = 1.5;
        }

        function _iconFunnelChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;
            y -= dy;
            ctx.moveTo(x + 1 * dx, y + 2 * dy);
            ctx.lineTo(x + 15 * dx, y + 2 * dy);
            ctx.lineTo(x + 14 * dx, y + 3 * dy);
            ctx.lineTo(x + 2 * dx, y + 3 * dy);

            ctx.moveTo(x + 3 * dx, y + 6 * dy);
            ctx.lineTo(x + 13 * dx, y + 6 * dy);
            ctx.lineTo(x + 12 * dx, y + 7 * dy);
            ctx.lineTo(x + 4 * dx, y + 7 * dy);

            ctx.moveTo(x + 5 * dx, y + 10 * dy);
            ctx.lineTo(x + 11 * dx, y + 10 * dy);
            ctx.lineTo(x + 10 * dx, y + 11 * dy);
            ctx.lineTo(x + 6 * dx, y + 11 * dy);

            ctx.moveTo(x + 7 * dx, y + 14 * dy);
            ctx.lineTo(x + 9 * dx, y + 14 * dy);
            ctx.lineTo(x + 8 * dx, y + 15 * dy);
            ctx.lineTo(x + 7 * dx, y + 15 * dy);
        }

        function _iconForceChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            var dx = width / 16;
            var dy = height / 16;
            var r = Math.min(dx, dy) * 2;

            ctx.moveTo(x + dx + r, y + dy + r);
            ctx.arc(x + dx, y + dy, r, Math.PI / 4, Math.PI * 3);

            ctx.lineTo(x + 7 * dx - r, y + 6 * dy - r);
            ctx.arc(x + 7 * dx, y + 6 * dy, r, Math.PI / 4 * 5, Math.PI * 4);
            ctx.arc(x + 7 * dx, y + 6 * dy, r / 2, Math.PI / 4 * 5, Math.PI * 4);

            ctx.moveTo(x + 7 * dx - r / 2, y + 6 * dy + r);
            ctx.lineTo(x + dx + r, y + 14 * dy - r);
            ctx.arc(x + dx, y + 14 * dy, r, -Math.PI / 4, Math.PI * 2);

            ctx.moveTo(x + 7 * dx + r / 2, y + 6 * dy);
            ctx.lineTo(x + 14 * dx - r, y + 10 * dy - r / 2);
            ctx.moveTo(x + 16 * dx, y + 10 * dy);
            ctx.arc(x + 14 * dx, y + 10 * dy, r, 0, Math.PI * 3);
            ctx.lineWidth = 1.5;
        }

        function _iconChordChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            var r = Math.min(width, height) / 2;

            ctx.moveTo(x + width, y + height / 2);
            ctx.arc(x + r, y + r, r, 0, Math.PI * 2);

            ctx.arc(x + r, y, r, Math.PI / 4, Math.PI / 5 * 4);
            ctx.arc(x, y + r, r, -Math.PI / 3, Math.PI / 3);
            ctx.arc(x + width, y + height, r, Math.PI, Math.PI / 2 * 3);
            ctx.lineWidth = 1.5;
        }

        function _iconStackChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            var dy = Math.round(height / 3);
            var delta = Math.round((dy - 2) / 2);
            var len = 3;
            while (len--) {
                ctx.rect(x, y + dy * len + delta, width, 2);
            }
        }

        function _iconTiledChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            var dx = Math.round(width / 3);
            var delta = Math.round((dx - 2) / 2);
            var len = 3;
            while (len--) {
                ctx.rect(x + dx * len + delta, y, 2, height);
            }
        }

        function _iconDataView(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;

            ctx.moveTo(x + dx, y);
            ctx.lineTo(x + dx, y + style.height);
            ctx.lineTo(x + 15 * dx, y + style.height);
            ctx.lineTo(x + 15 * dx, y);
            ctx.lineTo(x + dx, y);

            ctx.moveTo(x + 3 * dx, y + 3 * dx);
            ctx.lineTo(x + 13 * dx, y + 3 * dx);

            ctx.moveTo(x + 3 * dx, y + 6 * dx);
            ctx.lineTo(x + 13 * dx, y + 6 * dx);

            ctx.moveTo(x + 3 * dx, y + 9 * dx);
            ctx.lineTo(x + 13 * dx, y + 9 * dx);

            ctx.moveTo(x + 3 * dx, y + 12 * dx);
            ctx.lineTo(x + 9 * dx, y + 12 * dx);
        }

        function _iconSave(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(x, y);
            ctx.lineTo(x, y + style.height);
            ctx.lineTo(x + style.width, y + style.height);
            ctx.lineTo(x + style.width, y);
            ctx.lineTo(x, y);

            ctx.moveTo(x + 4 * dx, y);
            ctx.lineTo(x + 4 * dx, y + 8 * dy);
            ctx.lineTo(x + 12 * dx, y + 8 * dy);
            ctx.lineTo(x + 12 * dx, y);

            ctx.moveTo(x + 6 * dx, y + 11 * dy);
            ctx.lineTo(x + 6 * dx, y + 13 * dy);
            ctx.lineTo(x + 10 * dx, y + 13 * dy);
            ctx.lineTo(x + 10 * dx, y + 11 * dy);
            ctx.lineTo(x + 6 * dx, y + 11 * dy);
        }

        function _iconCross(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            ctx.moveTo(x, y + height / 2);
            ctx.lineTo(x + width, y + height / 2);

            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width / 2, y + height);
        }

        function _iconCircle(ctx, style) {
            var width = style.width / 2;
            var height = style.height / 2;
            var r = Math.min(width, height);
            ctx.moveTo(
                style.x + width + r,
                style.y + height
            );
            ctx.arc(
                style.x + width,
                style.y + height,
                r,
                0,
                Math.PI * 2
            );
            ctx.closePath();
        }

        function _iconRectangle(ctx, style) {
            ctx.rect(style.x, style.y, style.width, style.height);
            ctx.closePath();
        }

        function _iconTriangle(ctx, style) {
            var width = style.width / 2;
            var height = style.height / 2;
            var x = style.x + width;
            var y = style.y + height;
            var symbolSize = Math.min(width, height);
            ctx.moveTo(x, y - symbolSize);
            ctx.lineTo(x + symbolSize, y + symbolSize);
            ctx.lineTo(x - symbolSize, y + symbolSize);
            ctx.lineTo(x, y - symbolSize);
            ctx.closePath();
        }

        function _iconDiamond(ctx, style) {
            var width = style.width / 2;
            var height = style.height / 2;
            var x = style.x + width;
            var y = style.y + height;
            var symbolSize = Math.min(width, height);
            ctx.moveTo(x, y - symbolSize);
            ctx.lineTo(x + symbolSize, y);
            ctx.lineTo(x, y + symbolSize);
            ctx.lineTo(x - symbolSize, y);
            ctx.lineTo(x, y - symbolSize);
            ctx.closePath();
        }

        function _iconArrow(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            ctx.moveTo(x + 8 * dx, y);
            ctx.lineTo(x + dx, y + style.height);
            ctx.lineTo(x + 8 * dx, y + style.height / 4 * 3);
            ctx.lineTo(x + 15 * dx, y + style.height);
            ctx.lineTo(x + 8 * dx, y);
            ctx.closePath();
        }

        function _iconStar(ctx, style) {
            var StarShape = require('zrender/shape/Star');
            var width = style.width / 2;
            var height = style.height / 2;
            StarShape.prototype.buildPath(ctx, {
                x: style.x + width,
                y: style.y + height,
                r: Math.min(width, height),
                n: style.n || 5
            });
        }

        function _iconHeart(ctx, style) {
            var HeartShape = require('zrender/shape/Heart');
            HeartShape.prototype.buildPath(ctx, {
                x: style.x + style.width / 2,
                y: style.y + style.height * 0.2,
                a: style.width / 2,
                b: style.height * 0.8
            });
        }

        function _iconDroplet(ctx, style) {
            var DropletShape = require('zrender/shape/Droplet');
            DropletShape.prototype.buildPath(ctx, {
                x: style.x + style.width * 0.5,
                y: style.y + style.height * 0.5,
                a: style.width * 0.5,
                b: style.height * 0.8
            });
        }

        function _iconPin(ctx, style) {
            var x = style.x;
            var y = style.y - style.height / 2 * 1.5;
            var width = style.width / 2;
            var height = style.height / 2;
            var r = Math.min(width, height);
            ctx.arc(
                x + width,
                y + height,
                r,
                Math.PI / 5 * 4,
                Math.PI / 5
            );
            ctx.lineTo(x + width, y + height + r * 1.5);
            ctx.closePath();
        }

        function _iconImage(ctx, style, refreshNextFrame) {
            var ImageShape = require('zrender/shape/Image');
            this._imageShape = this._imageShape || new ImageShape({
                style: {}
            });
            for (var name in style) {
                this._imageShape.style[name] = style[name];
            }
            this._imageShape.brush(ctx, false, refreshNextFrame);
        }

        var Base = require('zrender/shape/Base');

        function Icon(options) {
            Base.call(this, options);
        }

        Icon.prototype = {
            type: 'icon',
            iconLibrary: {
                mark: _iconMark,
                markUndo: _iconMarkUndo,
                markClear: _iconMarkClear,
                dataZoom: _iconDataZoom,
                dataZoomReset: _iconDataZoomReset,
                restore: _iconRestore,
                lineChart: _iconLineChart,
                barChart: _iconBarChart,
                pieChart: _iconPieChart,
                funnelChart: _iconFunnelChart,
                forceChart: _iconForceChart,
                chordChart: _iconChordChart,
                stackChart: _iconStackChart,
                tiledChart: _iconTiledChart,
                dataView: _iconDataView,
                saveAsImage: _iconSave,

                cross: _iconCross,
                circle: _iconCircle,
                rectangle: _iconRectangle,
                triangle: _iconTriangle,
                diamond: _iconDiamond,
                arrow: _iconArrow,
                star: _iconStar,
                heart: _iconHeart,
                droplet: _iconDroplet,
                pin: _iconPin,
                image: _iconImage
            },
            brush: function(ctx, isHighlight, refreshNextFrame) {
                var style = isHighlight ? this.highlightStyle : this.style;
                style = style || {};
                var iconType = style.iconType || this.style.iconType;
                if (iconType === 'image') {
                    var ImageShape = require('zrender/shape/Image');
                    ImageShape.prototype.brush.call(this, ctx, isHighlight, refreshNextFrame);

                } else {

                    var style = this.beforeBrush(ctx, isHighlight);

                    ctx.beginPath();
                    this.buildPath(ctx, style, refreshNextFrame);

                    switch (style.brushType) {
                        /* jshint ignore:start */
                        case 'both':
                            ctx.fill();
                        case 'stroke':
                            style.lineWidth > 0 && ctx.stroke();
                            break;
                            /* jshint ignore:end */
                        default:
                            ctx.fill();
                    }

                    this.drawText(ctx, style, this.style);

                    this.afterBrush(ctx);
                }
            },
            /**
             * 创建矩形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style, refreshNextFrame) {
                if (this.iconLibrary[style.iconType]) {
                    this.iconLibrary[style.iconType].call(this, ctx, style, refreshNextFrame);
                } else {
                    ctx.moveTo(style.x, style.y);
                    ctx.lineTo(style.x + style.width, style.y);
                    ctx.lineTo(style.x + style.width, style.y + style.height);
                    ctx.lineTo(style.x, style.y + style.height);
                    ctx.lineTo(style.x, style.y);
                    ctx.closePath();
                }

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                // pin比较特殊，让尖端在目标x,y上
                style.__rect = {
                    x: Math.round(style.x),
                    y: Math.round(style.y - (style.iconType == 'pin' ? (style.height / 2 * 1.5) : 0)),
                    width: style.width,
                    height: style.height * (
                        style.iconType === 'pin' ? 1.25 : 1
                    )
                };

                return style.__rect;
            },

            isCover: function(x, y) {
                var originPos = this.transformCoordToLocal(x, y);
                x = originPos[0];
                y = originPos[1];

                // 快速预判并保留判断矩形
                var rect = this.style.__rect;
                if (!rect) {
                    rect = this.style.__rect = this.getRect(this.style);
                }
                // 提高交互体验，太小的图形包围盒四向扩大4px
                var delta = (rect.height < 8 || rect.width < 8) ? 4 : 0;
                return x >= rect.x - delta && x <= (rect.x + rect.width + delta) && y >= rect.y - delta && y <= (rect.y + rect.height + delta);
            }
        };

        zrUtil.inherits(Icon, Base);

        return Icon;
    });
    define('echarts/util/number', [], function() {
        function _trim(str) {
            return str.replace(/^\s+/, '').replace(/\s+$/, '');
        }

        /**
         * 百分比计算
         */
        function parsePercent(value, maxValue) {
            if (typeof value === 'string') {
                if (_trim(value).match(/%$/)) {
                    return parseFloat(value) / 100 * maxValue;
                }

                return parseFloat(value);
            }

            return value;
        }

        /**
         * 获取中心坐标
         */
        function parseCenter(zr, center) {
            return [
                parsePercent(center[0], zr.getWidth()),
                parsePercent(center[1], zr.getHeight())
            ];
        }

        /**
         * 获取自适应半径
         */
        function parseRadius(zr, radius) {
            // 传数组实现环形图，[内半径，外半径]，传单个则默认为外半径为
            if (!(radius instanceof Array)) {
                radius = [0, radius];
            }
            var zrSize = Math.min(zr.getWidth(), zr.getHeight()) / 2;
            return [
                parsePercent(radius[0], zrSize),
                parsePercent(radius[1], zrSize)
            ];
        }

        /**
         * 每三位默认加,格式化
         */
        function addCommas(x) {
            if (isNaN(x)) {
                return '-';
            }
            x = (x + '').split('.');
            return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? ('.' + x[1]) : '');
        }

        /**
         * 获取数字的小数位数
         * @param {number} val
         */

        // It is much faster than methods converting number to string as follows 
        //      var tmp = val.toString();
        //      return tmp.length - 1 - tmp.indexOf('.');
        // especially when precision is low
        function getPrecision(val) {
            var e = 1;
            var count = 0;
            while (Math.round(val * e) / e !== val) {
                e *= 10;
                count++;
            }
            return count;
        }

        return {
            parsePercent: parsePercent,
            parseCenter: parseCenter,
            parseRadius: parseRadius,
            addCommas: addCommas,
            getPrecision: getPrecision
        };
    });
    define('echarts/util/shape/MarkLine', ['require', 'zrender/shape/Base', './Icon', 'zrender/shape/Line', 'zrender/shape/BezierCurve', 'zrender/tool/area', 'zrender/shape/util/dashedLineTo', 'zrender/tool/util', 'zrender/tool/curve'], function(require) {
        var Base = require('zrender/shape/Base');
        var IconShape = require('./Icon');
        var LineShape = require('zrender/shape/Line');
        var lineInstance = new LineShape({});
        var CurveShape = require('zrender/shape/BezierCurve');
        var curveInstance = new CurveShape({});

        var area = require('zrender/tool/area');
        var dashedLineTo = require('zrender/shape/util/dashedLineTo');
        var zrUtil = require('zrender/tool/util');
        var curveTool = require('zrender/tool/curve');

        function MarkLine(options) {
            Base.call(this, options);

            if (this.style.curveness > 0) {
                this.updatePoints(this.style);
            }
            if (this.highlightStyle.curveness > 0) {
                this.updatePoints(this.highlightStyle);
            }
        }

        MarkLine.prototype = {
            type: 'mark-line',
            /**
             * 画刷
             * @param ctx 画布句柄
             * @param isHighlight   是否为高亮状态
             * @param updateCallback 让painter更新视图，base.brush没用，需要的话重载brush
             */
            brush: function(ctx, isHighlight) {
                var style = this.style;

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style,
                        this.highlightStyle || {}
                    );
                }

                ctx.save();
                this.setContext(ctx, style);

                // 设置transform
                this.setTransform(ctx);

                ctx.save();
                ctx.beginPath();
                this.buildPath(ctx, style);
                ctx.stroke();
                ctx.restore();

                this.brushSymbol(ctx, style, 0);
                this.brushSymbol(ctx, style, 1);

                this.drawText(ctx, style, this.style);

                ctx.restore();
            },

            /**
             * 创建线条路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var lineType = style.lineType || 'solid';

                ctx.moveTo(style.xStart, style.yStart);
                if (style.curveness > 0) {
                    // FIXME Bezier 在少部分浏览器上暂时不支持虚线
                    var lineDash = null;
                    switch (lineType) {
                        case 'dashed':
                            lineDash = [5, 5];
                            break;
                        case 'dotted':
                            lineDash = [1, 1];
                            break;
                    }
                    if (lineDash && ctx.setLineDash) {
                        ctx.setLineDash(lineDash);
                    }

                    ctx.quadraticCurveTo(
                        style.cpX1, style.cpY1, style.xEnd, style.yEnd
                    );
                } else {
                    if (lineType == 'solid') {
                        ctx.lineTo(style.xEnd, style.yEnd);
                    } else {
                        var dashLength = (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                        dashedLineTo(
                            ctx, style.xStart, style.yStart,
                            style.xEnd, style.yEnd, dashLength
                        );
                    }
                }
            },

            /**
             * Update cpX1 and cpY1 according to curveniss
             * @param  {Object} style
             */
            updatePoints: function(style) {
                var curveness = style.curveness || 0;
                var inv = 1;

                var x0 = style.xStart;
                var y0 = style.yStart;
                var x2 = style.xEnd;
                var y2 = style.yEnd;
                var x1 = (x0 + x2) / 2 - inv * (y0 - y2) * curveness;
                var y1 = (y0 + y2) / 2 - inv * (x2 - x0) * curveness;

                style.cpX1 = x1;
                style.cpY1 = y1;
            },

            /**
             * 标线始末标注
             */
            brushSymbol: function(ctx, style, idx) {
                if (style.symbol[idx] == 'none') {
                    return;
                }
                ctx.save();
                ctx.beginPath();

                ctx.lineWidth = style.symbolBorder;
                ctx.strokeStyle = style.symbolBorderColor;
                // symbol
                var symbol = style.symbol[idx].replace('empty', '')
                    .toLowerCase();
                if (style.symbol[idx].match('empty')) {
                    ctx.fillStyle = '#fff'; //'rgba(0, 0, 0, 0)';
                }

                // symbolRotate
                var x0 = style.xStart;
                var y0 = style.yStart;
                var x2 = style.xEnd;
                var y2 = style.yEnd;
                var x = idx === 0 ? x0 : x2;
                var y = idx === 0 ? y0 : y2;
                var curveness = style.curveness || 0;
                var rotate = style.symbolRotate[idx] != null ? (style.symbolRotate[idx] - 0) : 0;
                rotate = rotate / 180 * Math.PI;

                if (symbol == 'arrow' && rotate === 0) {
                    if (curveness === 0) {
                        var sign = idx === 0 ? -1 : 1;
                        rotate = Math.PI / 2 + Math.atan2(
                            sign * (y2 - y0), sign * (x2 - x0)
                        );
                    } else {
                        var x1 = style.cpX1;
                        var y1 = style.cpY1;

                        var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
                        var dx = quadraticDerivativeAt(x0, x1, x2, idx);
                        var dy = quadraticDerivativeAt(y0, y1, y2, idx);

                        rotate = Math.PI / 2 + Math.atan2(dy, dx);
                    }
                }

                ctx.translate(x, y);

                if (rotate !== 0) {
                    ctx.rotate(rotate);
                }

                // symbolSize
                var symbolSize = style.symbolSize[idx];
                IconShape.prototype.buildPath(ctx, {
                    x: -symbolSize,
                    y: -symbolSize,
                    width: symbolSize * 2,
                    height: symbolSize * 2,
                    iconType: symbol
                });

                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                style.curveness > 0 ? curveInstance.getRect(style) : lineInstance.getRect(style);
                return style.__rect;
            },

            isCover: function(x, y) {
                var originPos = this.transformCoordToLocal(x, y);
                x = originPos[0];
                y = originPos[1];

                // 快速预判并保留判断矩形
                if (this.isCoverRect(x, y)) {
                    // 矩形内
                    return this.style.curveness > 0 ? area.isInside(curveInstance, this.style, x, y) : area.isInside(lineInstance, this.style, x, y);
                }

                return false;
            }
        };

        zrUtil.inherits(MarkLine, Base);

        return MarkLine;
    });
    define('echarts/util/shape/Symbol', ['require', 'zrender/shape/Base', 'zrender/shape/Polygon', 'zrender/tool/util', './normalIsCover'], function(require) {
        var Base = require('zrender/shape/Base');
        var PolygonShape = require('zrender/shape/Polygon');
        var polygonInstance = new PolygonShape({});
        var zrUtil = require('zrender/tool/util');

        function Symbol(options) {
            Base.call(this, options);
        }

        Symbol.prototype = {
            type: 'symbol',
            /**
             * 创建矩形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var pointList = style.pointList;
                var len = pointList.length;
                if (len === 0) {
                    return;
                }

                var subSize = 10000;
                var subSetLength = Math.ceil(len / subSize);
                var sub;
                var subLen;
                var isArray = pointList[0] instanceof Array;
                var size = style.size ? style.size : 2;
                var curSize = size;
                var halfSize = size / 2;
                var PI2 = Math.PI * 2;
                var percent;
                var x;
                var y;
                for (var j = 0; j < subSetLength; j++) {
                    ctx.beginPath();
                    sub = j * subSize;
                    subLen = sub + subSize;
                    subLen = subLen > len ? len : subLen;
                    for (var i = sub; i < subLen; i++) {
                        if (style.random) {
                            percent = style['randomMap' + (i % 20)] / 100;
                            curSize = size * percent * percent;
                            halfSize = curSize / 2;
                        }
                        if (isArray) {
                            x = pointList[i][0];
                            y = pointList[i][1];
                        } else {
                            x = pointList[i].x;
                            y = pointList[i].y;
                        }
                        if (curSize < 3) {
                            // 小于3像素视觉误差
                            ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                        } else {
                            // 大于3像素才考虑图形
                            switch (style.iconType) {
                                case 'circle':
                                    ctx.moveTo(x, y);
                                    ctx.arc(x, y, halfSize, 0, PI2, true);
                                    break;
                                case 'diamond':
                                    ctx.moveTo(x, y - halfSize);
                                    ctx.lineTo(x + halfSize / 3, y - halfSize / 3);
                                    ctx.lineTo(x + halfSize, y);
                                    ctx.lineTo(x + halfSize / 3, y + halfSize / 3);
                                    ctx.lineTo(x, y + halfSize);
                                    ctx.lineTo(x - halfSize / 3, y + halfSize / 3);
                                    ctx.lineTo(x - halfSize, y);
                                    ctx.lineTo(x - halfSize / 3, y - halfSize / 3);
                                    ctx.lineTo(x, y - halfSize);
                                    break;
                                default:
                                    ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                            }
                        }
                    }
                    ctx.closePath();
                    if (j < (subSetLength - 1)) {
                        switch (style.brushType) {
                            case 'both':
                                ctx.fill();
                                style.lineWidth > 0 && ctx.stroke(); // js hint -_-"
                                break;
                            case 'stroke':
                                style.lineWidth > 0 && ctx.stroke();
                                break;
                            default:
                                ctx.fill();
                        }
                    }
                }
            },

            /* 像素模式
            buildPath : function (ctx, style) {
                var pointList = style.pointList;
                var rect = this.getRect(style);
                var ratio = window.devicePixelRatio || 1;
                // console.log(rect)
                // var ti = new Date();
                // bbox取整
                rect = {
                    x : Math.floor(rect.x),
                    y : Math.floor(rect.y),
                    width : Math.floor(rect.width),
                    height : Math.floor(rect.height)
                };
                var pixels = ctx.getImageData(
                    rect.x * ratio, rect.y * ratio,
                    rect.width * ratio, rect.height * ratio
                );
                var data = pixels.data;
                var idx;
                var zrColor = require('zrender/tool/color');
                var color = zrColor.toArray(style.color);
                var r = color[0];
                var g = color[1];
                var b = color[2];
                var width = rect.width;

                for (var i = 1, l = pointList.length; i < l; i++) {
                    idx = ((Math.floor(pointList[i][0]) - rect.x) * ratio
                           + (Math.floor(pointList[i][1])- rect.y) * width * ratio * ratio
                          ) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
                ctx.putImageData(pixels, rect.x * ratio, rect.y * ratio);
                // console.log(new Date() - ti);
                return;
            },
            */

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                return style.__rect || polygonInstance.getRect(style);
            },

            isCover: require('./normalIsCover')
        };

        zrUtil.inherits(Symbol, Base);

        return Symbol;
    });
    define('zrender/shape/Polyline', ['require', './Base', './util/smoothSpline', './util/smoothBezier', './util/dashedLineTo', './Polygon', '../tool/util'], function(require) {
        var Base = require('./Base');
        var smoothSpline = require('./util/smoothSpline');
        var smoothBezier = require('./util/smoothBezier');
        var dashedLineTo = require('./util/dashedLineTo');

        /**
         * @alias module:zrender/shape/Polyline
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Polyline = function(options) {
            this.brushTypeOnly = 'stroke'; // 线条只能描边，填充后果自负
            this.textPosition = 'end';
            Base.call(this, options);
            /**
             * 贝赛尔曲线绘制样式
             * @name module:zrender/shape/Polyline#style
             * @type {module:zrender/shape/Polyline~IPolylineStyle}
             */
            /**
             * 贝赛尔曲线高亮绘制样式
             * @name module:zrender/shape/Polyline#highlightStyle
             * @type {module:zrender/shape/Polyline~IPolylineStyle}
             */
        };

        Polyline.prototype = {
            type: 'polyline',

            /**
             * 创建多边形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Polyline~IPolylineStyle} style
             */
            buildPath: function(ctx, style) {
                var pointList = style.pointList;
                if (pointList.length < 2) {
                    // 少于2个点就不画了~
                    return;
                }

                var len = Math.min(
                    style.pointList.length,
                    Math.round(style.pointListLength || style.pointList.length)
                );

                if (style.smooth && style.smooth !== 'spline') {
                    if (!style.controlPointList) {
                        this.updateControlPoints(style);
                    }
                    var controlPointList = style.controlPointList;

                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    var cp1;
                    var cp2;
                    var p;
                    for (var i = 0; i < len - 1; i++) {
                        cp1 = controlPointList[i * 2];
                        cp2 = controlPointList[i * 2 + 1];
                        p = pointList[i + 1];
                        ctx.bezierCurveTo(
                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                        );
                    }
                } else {
                    if (style.smooth === 'spline') {
                        pointList = smoothSpline(pointList);
                        len = pointList.length;
                    }
                    if (!style.lineType || style.lineType == 'solid') {
                        // 默认为实线
                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        for (var i = 1; i < len; i++) {
                            ctx.lineTo(pointList[i][0], pointList[i][1]);
                        }
                    } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                        var dashLength = (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        for (var i = 1; i < len; i++) {
                            dashedLineTo(
                                ctx,
                                pointList[i - 1][0], pointList[i - 1][1],
                                pointList[i][0], pointList[i][1],
                                dashLength
                            );
                        }
                    }
                }
                return;
            },

            updateControlPoints: function(style) {
                style.controlPointList = smoothBezier(
                    style.pointList, style.smooth, false, style.smoothConstraint
                );
            },

            /**
             * 计算返回折线包围盒矩形。
             * @param {IZRenderBezierCurveStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                return require('./Polygon').prototype.getRect(style);
            }
        };

        require('../tool/util').inherits(Polyline, Base);
        return Polyline;
    });
    define('zrender/shape/ShapeBundle', ['require', './Base', '../tool/util'], function(require) {

        var Base = require('./Base');

        var ShapeBundle = function(options) {
            Base.call(this, options);
            /**
             * ShapeBundle绘制样式
             * @name module:zrender/shape/ShapeBundle#style
             * @type {module:zrender/shape/ShapeBundle~IShapeBundleStyle}
             */
            /**
             * ShapeBundle高亮绘制样式
             * @name module:zrender/shape/ShapeBundle#highlightStyle
             * @type {module:zrender/shape/ShapeBundle~IShapeBundleStyle}
             */
        };

        ShapeBundle.prototype = {

            constructor: ShapeBundle,

            type: 'shape-bundle',

            brush: function(ctx, isHighlight) {
                var style = this.beforeBrush(ctx, isHighlight);

                ctx.beginPath();
                for (var i = 0; i < style.shapeList.length; i++) {
                    var subShape = style.shapeList[i];
                    var subShapeStyle = subShape.style;
                    if (isHighlight) {
                        subShapeStyle = subShape.getHighlightStyle(
                            subShapeStyle,
                            subShape.highlightStyle || {},
                            subShape.brushTypeOnly
                        );
                    }
                    subShape.buildPath(ctx, subShapeStyle);
                }
                switch (style.brushType) {
                    /* jshint ignore:start */
                    case 'both':
                        ctx.fill();
                    case 'stroke':
                        style.lineWidth > 0 && ctx.stroke();
                        break;
                        /* jshint ignore:end */
                    default:
                        ctx.fill();
                }

                this.drawText(ctx, style, this.style);

                this.afterBrush(ctx);
            },

            /**
             * 计算返回多边形包围盒矩阵
             * @param {module:zrender/shape/Polygon~IShapeBundleStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }
                var minX = Infinity;
                var maxX = -Infinity;
                var minY = Infinity;
                var maxY = -Infinity;
                for (var i = 0; i < style.shapeList.length; i++) {
                    var subShape = style.shapeList[i];
                    // TODO Highlight style ?
                    var subRect = subShape.getRect(subShape.style);

                    var minX = Math.min(subRect.x, minX);
                    var minY = Math.min(subRect.y, minY);
                    var maxX = Math.max(subRect.x + subRect.width, maxX);
                    var maxY = Math.max(subRect.y + subRect.height, maxY);
                }

                style.__rect = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };

                return style.__rect;
            },

            isCover: function(x, y) {
                var originPos = this.transformCoordToLocal(x, y);
                x = originPos[0];
                y = originPos[1];

                if (this.isCoverRect(x, y)) {
                    for (var i = 0; i < this.style.shapeList.length; i++) {
                        var subShape = this.style.shapeList[i];
                        if (subShape.isCover(x, y)) {
                            return true;
                        }
                    }
                }

                return false;
            }
        };

        require('../tool/util').inherits(ShapeBundle, Base);
        return ShapeBundle;
    });
    define('echarts/util/ecEffect', ['require', '../util/ecData', 'zrender/shape/Circle', 'zrender/shape/Image', 'zrender/tool/curve', '../util/shape/Icon', '../util/shape/Symbol', 'zrender/shape/ShapeBundle', 'zrender/shape/Polyline', 'zrender/tool/vector', 'zrender/tool/env'], function(require) {
        var ecData = require('../util/ecData');

        var CircleShape = require('zrender/shape/Circle');
        var ImageShape = require('zrender/shape/Image');
        var curveTool = require('zrender/tool/curve');
        var IconShape = require('../util/shape/Icon');
        var SymbolShape = require('../util/shape/Symbol');
        var ShapeBundle = require('zrender/shape/ShapeBundle');
        var Polyline = require('zrender/shape/Polyline');
        var vec2 = require('zrender/tool/vector');

        var canvasSupported = require('zrender/tool/env').canvasSupported;

        function point(zr, effectList, shape, zlevel) {
            var effect = shape.effect;
            var color = effect.color || shape.style.strokeColor || shape.style.color;
            var shadowColor = effect.shadowColor || color;
            var size = effect.scaleSize;
            var distance = effect.bounceDistance;
            var shadowBlur = typeof effect.shadowBlur != 'undefined' ? effect.shadowBlur : size;

            var effectShape;
            if (shape.type !== 'image') {
                effectShape = new IconShape({
                    zlevel: zlevel,
                    style: {
                        brushType: 'stroke',
                        iconType: shape.style.iconType != 'droplet' ? shape.style.iconType : 'circle',
                        x: shadowBlur + 1, // 线宽
                        y: shadowBlur + 1,
                        n: shape.style.n,
                        width: shape.style._width * size,
                        height: shape.style._height * size,
                        lineWidth: 1,
                        strokeColor: color,
                        shadowColor: shadowColor,
                        shadowBlur: shadowBlur
                    },
                    draggable: false,
                    hoverable: false
                });
                if (shape.style.iconType == 'pin') {
                    effectShape.style.y += effectShape.style.height / 2 * 1.5;
                }

                if (canvasSupported) { // 提高性能，换成image
                    effectShape.style.image = zr.shapeToImage(
                        effectShape,
                        effectShape.style.width + shadowBlur * 2 + 2,
                        effectShape.style.height + shadowBlur * 2 + 2
                    ).style.image;

                    effectShape = new ImageShape({
                        zlevel: effectShape.zlevel,
                        style: effectShape.style,
                        draggable: false,
                        hoverable: false
                    });
                }
            } else {
                effectShape = new ImageShape({
                    zlevel: zlevel,
                    style: shape.style,
                    draggable: false,
                    hoverable: false
                });
            }

            ecData.clone(shape, effectShape);

            // 改变坐标，不能移到前面
            effectShape.position = shape.position;
            effectList.push(effectShape);
            zr.addShape(effectShape);

            var devicePixelRatio = shape.type !== 'image' ? (window.devicePixelRatio || 1) : 1;
            var offset = (effectShape.style.width / devicePixelRatio - shape.style._width) / 2;
            effectShape.style.x = shape.style._x - offset;
            effectShape.style.y = shape.style._y - offset;

            if (shape.style.iconType == 'pin') {
                effectShape.style.y -= shape.style.height / 2 * 1.5;
            }

            var duration = (effect.period + Math.random() * 10) * 100;

            zr.modShape(
                shape.id, {
                    invisible: true
                }
            );

            var centerX = effectShape.style.x + (effectShape.style.width) / 2 / devicePixelRatio;
            var centerY = effectShape.style.y + (effectShape.style.height) / 2 / devicePixelRatio;

            if (effect.type === 'scale') {
                // 放大效果
                zr.modShape(
                    effectShape.id, {
                        scale: [0.1, 0.1, centerX, centerY]
                    }
                );

                zr.animate(effectShape.id, '', effect.loop)
                    .when(
                        duration, {
                            scale: [1, 1, centerX, centerY]
                        }
                    )
                    .done(function() {
                        shape.effect.show = false;
                        zr.delShape(effectShape.id);
                    })
                    .start();
            } else {
                zr.animate(effectShape.id, 'style', effect.loop)
                    .when(
                        duration, {
                            y: effectShape.style.y - distance
                        }
                    )
                    .when(
                        duration * 2, {
                            y: effectShape.style.y
                        }
                    )
                    .done(function() {
                        shape.effect.show = false;
                        zr.delShape(effectShape.id);
                    })
                    .start();
            }

        }

        function largePoint(zr, effectList, shape, zlevel) {
            var effect = shape.effect;
            var color = effect.color || shape.style.strokeColor || shape.style.color;
            var size = effect.scaleSize;
            var shadowColor = effect.shadowColor || color;
            var shadowBlur = typeof effect.shadowBlur != 'undefined' ? effect.shadowBlur : (size * 2);
            var devicePixelRatio = window.devicePixelRatio || 1;
            var effectShape = new SymbolShape({
                zlevel: zlevel,
                position: shape.position,
                scale: shape.scale,
                style: {
                    pointList: shape.style.pointList,
                    iconType: shape.style.iconType,
                    color: color,
                    strokeColor: color,
                    shadowColor: shadowColor,
                    shadowBlur: shadowBlur * devicePixelRatio,
                    random: true,
                    brushType: 'fill',
                    lineWidth: 1,
                    size: shape.style.size
                },
                draggable: false,
                hoverable: false
            });

            effectList.push(effectShape);
            zr.addShape(effectShape);
            zr.modShape(
                shape.id, {
                    invisible: true
                }
            );

            var duration = Math.round(effect.period * 100);
            var clip1 = {};
            var clip2 = {};
            for (var i = 0; i < 20; i++) {
                effectShape.style['randomMap' + i] = 0;
                clip1 = {};
                clip1['randomMap' + i] = 100;
                clip2 = {};
                clip2['randomMap' + i] = 0;
                effectShape.style['randomMap' + i] = Math.random() * 100;
                zr.animate(effectShape.id, 'style', true)
                    .when(duration, clip1)
                    .when(duration * 2, clip2)
                    .when(duration * 3, clip1)
                    .when(duration * 4, clip1)
                    .delay(Math.random() * duration * i)
                    //.delay(duration / 15 * (15 - i + 1))
                    .start();

            }
        }

        function line(zr, effectList, shape, zlevel, isLarge) {
            var effect = shape.effect;
            var shapeStyle = shape.style;
            var color = effect.color || shapeStyle.strokeColor || shapeStyle.color;
            var shadowColor = effect.shadowColor || shapeStyle.strokeColor || color;
            var size = shapeStyle.lineWidth * effect.scaleSize;
            var shadowBlur = typeof effect.shadowBlur != 'undefined' ? effect.shadowBlur : size;

            var effectShape = new CircleShape({
                zlevel: zlevel,
                style: {
                    x: shadowBlur,
                    y: shadowBlur,
                    r: size,
                    color: color,
                    shadowColor: shadowColor,
                    shadowBlur: shadowBlur
                },
                hoverable: false
            });

            var offset = 0;
            if (canvasSupported && !isLarge) { // 提高性能，换成image
                var zlevel = effectShape.zlevel;
                effectShape = zr.shapeToImage(
                    effectShape, (size + shadowBlur) * 2, (size + shadowBlur) * 2
                );
                effectShape.zlevel = zlevel;
                effectShape.hoverable = false;

                offset = shadowBlur;
            }

            if (!isLarge) {
                ecData.clone(shape, effectShape);
                // 改变坐标， 不能移到前面
                effectShape.position = shape.position;
                effectList.push(effectShape);
                zr.addShape(effectShape);
            }

            var effectDone = function() {
                if (!isLarge) {
                    shape.effect.show = false;
                    zr.delShape(effectShape.id);
                }
                effectShape.effectAnimator = null;
            };

            if (shape instanceof Polyline) {
                var distanceList = [0];
                var totalDist = 0;
                var pointList = shapeStyle.pointList;
                var controlPointList = shapeStyle.controlPointList;
                for (var i = 1; i < pointList.length; i++) {
                    if (controlPointList) {
                        var cp1 = controlPointList[(i - 1) * 2];
                        var cp2 = controlPointList[(i - 1) * 2 + 1];
                        totalDist += vec2.dist(pointList[i - 1], cp1) + vec2.dist(cp1, cp2) + vec2.dist(cp2, pointList[i]);
                    } else {
                        totalDist += vec2.dist(pointList[i - 1], pointList[i]);
                    }
                    distanceList.push(totalDist);
                }
                obj = {
                    p: 0
                };
                var animator = zr.animation.animate(obj, {
                    loop: effect.loop
                });

                for (var i = 0; i < distanceList.length; i++) {
                    animator.when(distanceList[i] * effect.period, {
                        p: i
                    });
                }
                animator.during(function() {
                        var i = Math.floor(obj.p);
                        var x, y;
                        if (i == pointList.length - 1) {
                            x = pointList[i][0];
                            y = pointList[i][1];
                        } else {
                            var t = obj.p - i;
                            var p0 = pointList[i];
                            var p1 = pointList[i + 1];
                            if (controlPointList) {
                                var cp1 = controlPointList[i * 2];
                                var cp2 = controlPointList[i * 2 + 1];
                                var list = [p0, p1, cp1, cp2];
                                var isgo = true;
                                list.forEach(function(value, index) {
                                    if (!value) {
                                        isgo = false;
                                    }
                                });
                                if (isgo) {
                                    x = curveTool.cubicAt(
                                        p0[0], cp1[0], cp2[0], p1[0], t
                                    );
                                    y = curveTool.cubicAt(
                                        p0[1], cp1[1], cp2[1], p1[1], t
                                    );
                                }

                            } else {
                                var list = [p0, p1];
                                var isgo = true;
                                list.forEach(function(value, index) {
                                    if (!value) {
                                        isgo = false;
                                    }
                                });
                                if (isgo) {
                                    x = (p1[0] - p0[0]) * t + p0[0];
                                    y = (p1[1] - p0[1]) * t + p0[1];
                                }
                            }
                        }
                        effectShape.style.x = x;
                        effectShape.style.y = y;
                        if (!isLarge) {
                            zr.modShape(effectShape);
                        }
                    })
                    .done(effectDone)
                    .start();

                animator.duration = totalDist * effect.period;

                effectShape.effectAnimator = animator;
            } else {
                var x0 = shapeStyle.xStart - offset;
                var y0 = shapeStyle.yStart - offset;
                var x2 = shapeStyle.xEnd - offset;
                var y2 = shapeStyle.yEnd - offset;
                effectShape.style.x = x0;
                effectShape.style.y = y0;

                var distance = (x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0);
                var duration = Math.round(Math.sqrt(Math.round(
                    distance * effect.period * effect.period
                )));

                if (shape.style.curveness > 0) {
                    var x1 = shapeStyle.cpX1 - offset;
                    var y1 = shapeStyle.cpY1 - offset;
                    effectShape.effectAnimator = zr.animation.animate(effectShape, {
                            loop: effect.loop
                        })
                        .when(duration, {
                            p: 1
                        })
                        .during(function(target, t) {
                            effectShape.style.x = curveTool.quadraticAt(
                                x0, x1, x2, t
                            );
                            effectShape.style.y = curveTool.quadraticAt(
                                y0, y1, y2, t
                            );
                            if (!isLarge) {
                                zr.modShape(effectShape);
                            }
                        })
                        .done(effectDone)
                        .start();
                } else {
                    // 不用 zr.animate，因为在用 ShapeBundle 的时候单个 effectShape 不会
                    // 被加到 zrender 中
                    effectShape.effectAnimator = zr.animation.animate(effectShape.style, {
                            loop: effect.loop
                        })
                        .when(duration, {
                            x: x2,
                            y: y2
                        })
                        .during(function() {
                            if (!isLarge) {
                                zr.modShape(effectShape);
                            }
                        })
                        .done(effectDone)
                        .start();
                }
                effectShape.effectAnimator.duration = duration;
            }
            return effectShape;
        }

        function largeLine(zr, effectList, shape, zlevel) {
            var effectShape = new ShapeBundle({
                style: {
                    shapeList: []
                },
                zlevel: zlevel,
                hoverable: false
            });
            var shapeList = shape.style.shapeList;
            var effect = shape.effect;
            effectShape.position = shape.position;

            var maxDuration = 0;
            var subEffectAnimators = [];
            for (var i = 0; i < shapeList.length; i++) {
                shapeList[i].effect = effect;
                var subEffectShape = line(zr, null, shapeList[i], zlevel, true);
                var subEffectAnimator = subEffectShape.effectAnimator;
                effectShape.style.shapeList.push(subEffectShape);
                if (subEffectAnimator.duration > maxDuration) {
                    maxDuration = subEffectAnimator.duration;
                }
                if (i === 0) {
                    effectShape.style.color = subEffectShape.style.color;
                    effectShape.style.shadowBlur = subEffectShape.style.shadowBlur;
                    effectShape.style.shadowColor = subEffectShape.style.shadowColor;
                }
                subEffectAnimators.push(subEffectAnimator);
            }
            effectList.push(effectShape);
            zr.addShape(effectShape);

            var clearAllAnimators = function() {
                for (var i = 0; i < subEffectAnimators.length; i++) {
                    subEffectAnimators[i].stop();
                }
            };
            if (maxDuration) {
                effectShape.__dummy = 0;
                // Proxy animator
                var animator = zr.animate(effectShape.id, '', effect.loop)
                    .when(maxDuration, {
                        __dummy: 1
                    })
                    .during(function() {
                        zr.modShape(effectShape);
                    })
                    .done(function() {
                        shape.effect.show = false;
                        zr.delShape(effectShape.id);
                    })
                    .start();
                var oldStop = animator.stop;

                animator.stop = function() {
                    clearAllAnimators();
                    oldStop.call(this);
                };
            }
        }

        return {
            point: point,
            largePoint: largePoint,
            line: line,
            largeLine: largeLine
        };
    });
    define('echarts/layout/EdgeBundling', ['require', '../data/KDTree', 'zrender/tool/vector'], function(require) {

        var KDTree = require('../data/KDTree');
        var vec2 = require('zrender/tool/vector');
        var v2Create = vec2.create;
        var v2DistSquare = vec2.distSquare;
        var v2Dist = vec2.dist;
        var v2Copy = vec2.copy;
        var v2Clone = vec2.clone;

        function squaredDistance(a, b) {
            a = a.array;
            b = b.array;

            var x = b[0] - a[0];
            var y = b[1] - a[1];
            var z = b[2] - a[2];
            var w = b[3] - a[3];

            return x * x + y * y + z * z + w * w;
        }

        function CoarsenedEdge(group) {
            this.points = [
                group.mp0, group.mp1
            ];

            this.group = group;
        }

        function Edge(edge) {
            var points = edge.points;
            // Sort on y
            if (
                points[0][1] < points[1][1]
                // If coarsened edge is flipped, the final composition of meet point
                // will be unordered
                || edge instanceof CoarsenedEdge
            ) {
                this.array = [points[0][0], points[0][1], points[1][0], points[1][1]];
                this._startPoint = points[0];
                this._endPoint = points[1];
            } else {
                this.array = [points[1][0], points[1][1], points[0][0], points[0][1]];
                this._startPoint = points[1];
                this._endPoint = points[0];
            }

            this.ink = v2Dist(points[0], points[1]);

            this.edge = edge;

            this.group = null;
        }

        Edge.prototype.getStartPoint = function() {
            return this._startPoint;
        };

        Edge.prototype.getEndPoint = function() {
            return this._endPoint;
        };

        function BundledEdgeGroup() {

            this.edgeList = [];

            this.mp0 = v2Create();
            this.mp1 = v2Create();

            this.ink = 0;
        }

        BundledEdgeGroup.prototype.addEdge = function(edge) {
            edge.group = this;
            this.edgeList.push(edge);
        };

        BundledEdgeGroup.prototype.removeEdge = function(edge) {
            edge.group = null;
            this.edgeList.splice(this.edgeList.indexOf(edge), 1);
        };

        /**
         * @constructor
         * @alias module:echarts/layout/EdgeBundling
         */
        function EdgeBundling() {
            this.maxNearestEdge = 6;
            this.maxTurningAngle = Math.PI / 4;
            this.maxIteration = 20;
        }

        EdgeBundling.prototype = {

            constructor: EdgeBundling,

            run: function(rawEdges) {
                var res = this._iterate(rawEdges);
                var nIterate = 0;
                while (nIterate++ < this.maxIteration) {
                    var coarsenedEdges = [];
                    for (var i = 0; i < res.groups.length; i++) {
                        coarsenedEdges.push(new CoarsenedEdge(res.groups[i]));
                    }
                    var newRes = this._iterate(coarsenedEdges);
                    if (newRes.savedInk <= 0) {
                        break;
                    } else {
                        res = newRes;
                    }
                }

                // Get new edges
                var newEdges = [];

                function pointApproxEqual(p0, p1) {
                    // Use Float32Array may affect the precision
                    return v2DistSquare(p0, p1) < 1e-10;
                }
                // Clone all points to make sure all points in edge will not reference to the same array
                // And clean the duplicate points
                function cleanEdgePoints(edgePoints, rawEdgePoints) {
                    var res = [];
                    var off = 0;
                    for (var i = 0; i < edgePoints.length; i++) {
                        if (!(off > 0 && pointApproxEqual(edgePoints[i], res[off - 1]))) {
                            res[off++] = v2Clone(edgePoints[i]);
                        }
                    }
                    // Edge has been reversed
                    if (rawEdgePoints[0] && !pointApproxEqual(res[0], rawEdgePoints[0])) {
                        res = res.reverse();
                    }
                    return res;
                }

                var buildNewEdges = function(groups, fromEdgePoints) {
                    var newEdgePoints;
                    for (var i = 0; i < groups.length; i++) {
                        var group = groups[i];
                        if (
                            group.edgeList[0] && (group.edgeList[0].edge instanceof CoarsenedEdge)
                        ) {
                            var newGroups = [];
                            for (var j = 0; j < group.edgeList.length; j++) {
                                newGroups.push(group.edgeList[j].edge.group);
                            }
                            if (!fromEdgePoints) {
                                newEdgePoints = [];
                            } else {
                                newEdgePoints = fromEdgePoints.slice();
                            }
                            newEdgePoints.unshift(group.mp0);
                            newEdgePoints.push(group.mp1);
                            buildNewEdges(newGroups, newEdgePoints);
                        } else {
                            // console.log(group.edgeList.length);
                            for (var j = 0; j < group.edgeList.length; j++) {
                                var edge = group.edgeList[j];
                                if (!fromEdgePoints) {
                                    newEdgePoints = [];
                                } else {
                                    newEdgePoints = fromEdgePoints.slice();
                                }
                                newEdgePoints.unshift(group.mp0);
                                newEdgePoints.push(group.mp1);
                                newEdgePoints.unshift(edge.getStartPoint());
                                newEdgePoints.push(edge.getEndPoint());
                                newEdges.push({
                                    points: cleanEdgePoints(newEdgePoints, edge.edge.points),
                                    rawEdge: edge.edge
                                });
                            }
                        }
                    }
                };

                buildNewEdges(res.groups);

                return newEdges;
            },

            _iterate: function(rawEdges) {
                var edges = [];
                var groups = [];
                var totalSavedInk = 0;
                for (var i = 0; i < rawEdges.length; i++) {
                    var edge = new Edge(rawEdges[i]);
                    edges.push(edge);
                }

                var tree = new KDTree(edges, 4);

                var nearests = [];

                var _mp0 = v2Create();
                var _mp1 = v2Create();
                var _newGroupInk = 0;
                var mp0 = v2Create();
                var mp1 = v2Create();
                var newGroupInk = 0;
                for (var i = 0; i < edges.length; i++) {
                    var edge = edges[i];
                    if (edge.group) {
                        // Edge have been groupped
                        continue;
                    }
                    tree.nearestN(
                        edge, this.maxNearestEdge,
                        squaredDistance, nearests
                    );
                    var maxSavedInk = 0;
                    var mostSavingInkEdge = null;
                    var lastCheckedGroup = null;
                    for (var j = 0; j < nearests.length; j++) {
                        var nearest = nearests[j];
                        var savedInk = 0;
                        if (nearest.group) {
                            if (nearest.group !== lastCheckedGroup) {
                                lastCheckedGroup = nearest.group;
                                _newGroupInk = this._calculateGroupEdgeInk(
                                    nearest.group, edge, _mp0, _mp1
                                );
                                savedInk = nearest.group.ink + edge.ink - _newGroupInk;
                            }
                        } else {
                            _newGroupInk = this._calculateEdgeEdgeInk(
                                edge, nearest, _mp0, _mp1
                            );
                            savedInk = nearest.ink + edge.ink - _newGroupInk;
                        }
                        if (savedInk > maxSavedInk) {
                            maxSavedInk = savedInk;
                            mostSavingInkEdge = nearest;
                            v2Copy(mp1, _mp1);
                            v2Copy(mp0, _mp0);
                            newGroupInk = _newGroupInk;
                        }
                    }
                    if (mostSavingInkEdge) {
                        totalSavedInk += maxSavedInk;
                        var group;
                        if (!mostSavingInkEdge.group) {
                            group = new BundledEdgeGroup();
                            groups.push(group);
                            group.addEdge(mostSavingInkEdge);
                        }
                        group = mostSavingInkEdge.group;
                        // Use the meet point and group ink calculated before
                        v2Copy(group.mp0, mp0);
                        v2Copy(group.mp1, mp1);
                        group.ink = newGroupInk;
                        mostSavingInkEdge.group.addEdge(edge);
                    } else {
                        var group = new BundledEdgeGroup();
                        groups.push(group);
                        v2Copy(group.mp0, edge.getStartPoint());
                        v2Copy(group.mp1, edge.getEndPoint());
                        group.ink = edge.ink;
                        group.addEdge(edge);
                    }
                }

                return {
                    groups: groups,
                    edges: edges,
                    savedInk: totalSavedInk
                };
            },

            _calculateEdgeEdgeInk: (function() {
                var startPointSet = [];
                var endPointSet = [];
                return function(e0, e1, mp0, mp1) {
                    startPointSet[0] = e0.getStartPoint();
                    startPointSet[1] = e1.getStartPoint();
                    endPointSet[0] = e0.getEndPoint();
                    endPointSet[1] = e1.getEndPoint();

                    this._calculateMeetPoints(
                        startPointSet, endPointSet, mp0, mp1
                    );
                    var ink = v2Dist(startPointSet[0], mp0) + v2Dist(mp0, mp1) + v2Dist(mp1, endPointSet[0]) + v2Dist(startPointSet[1], mp0) + v2Dist(mp1, endPointSet[1]);

                    return ink;
                };
            })(),

            _calculateGroupEdgeInk: function(group, edgeTryAdd, mp0, mp1) {
                var startPointSet = [];
                var endPointSet = [];
                for (var i = 0; i < group.edgeList.length; i++) {
                    var edge = group.edgeList[i];
                    startPointSet.push(edge.getStartPoint());
                    endPointSet.push(edge.getEndPoint());
                }
                startPointSet.push(edgeTryAdd.getStartPoint());
                endPointSet.push(edgeTryAdd.getEndPoint());

                this._calculateMeetPoints(
                    startPointSet, endPointSet, mp0, mp1
                );

                var ink = v2Dist(mp0, mp1);
                for (var i = 0; i < startPointSet.length; i++) {
                    ink += v2Dist(startPointSet[i], mp0) + v2Dist(endPointSet[i], mp1);
                }

                return ink;
            },

            /**
             * Calculating the meet points
             * @method
             * @param {Array} startPointSet Start points set of bundled edges
             * @param {Array} endPointSet End points set of bundled edges
             * @param {Array.<number>} mp0 Output meet point 0
             * @param {Array.<number>} mp1 Output meet point 1
             */
            _calculateMeetPoints: (function() {
                var cp0 = v2Create();
                var cp1 = v2Create();
                return function(startPointSet, endPointSet, mp0, mp1) {
                    vec2.set(cp0, 0, 0);
                    vec2.set(cp1, 0, 0);
                    var len = startPointSet.length;
                    // Calculate the centroid of start points set
                    for (var i = 0; i < len; i++) {
                        vec2.add(cp0, cp0, startPointSet[i]);
                    }
                    vec2.scale(cp0, cp0, 1 / len);

                    // Calculate the centroid of end points set
                    len = endPointSet.length;
                    for (var i = 0; i < len; i++) {
                        vec2.add(cp1, cp1, endPointSet[i]);
                    }
                    vec2.scale(cp1, cp1, 1 / len);

                    this._limitTurningAngle(
                        startPointSet, cp0, cp1, mp0
                    );
                    this._limitTurningAngle(
                        endPointSet, cp1, cp0, mp1
                    );
                };
            })(),

            _limitTurningAngle: (function() {
                var v10 = v2Create();
                var vTmp = v2Create();
                var project = v2Create();
                var tmpOut = v2Create();
                return function(pointSet, p0, p1, out) {
                    // Limit the max turning angle
                    var maxTurningAngleCos = Math.cos(this.maxTurningAngle);
                    var maxTurningAngleTan = Math.tan(this.maxTurningAngle);

                    vec2.sub(v10, p0, p1);
                    vec2.normalize(v10, v10);

                    // Simply copy the centroid point if no need to turn the angle
                    vec2.copy(out, p0);

                    var maxMovement = 0;
                    for (var i = 0; i < pointSet.length; i++) {
                        var p = pointSet[i];
                        vec2.sub(vTmp, p, p0);
                        var len = vec2.len(vTmp);
                        vec2.scale(vTmp, vTmp, 1 / len);
                        var turningAngleCos = vec2.dot(vTmp, v10);
                        // Turning angle is to large
                        if (turningAngleCos < maxTurningAngleCos) {
                            // Calculat p's project point on vector p1-p0 
                            // and distance to the vector
                            vec2.scaleAndAdd(
                                project, p0, v10, len * turningAngleCos
                            );
                            var distance = v2Dist(project, p);

                            // Use the max turning angle to calculate the new meet point
                            var d = distance / maxTurningAngleTan;
                            vec2.scaleAndAdd(tmpOut, project, v10, -d);

                            var movement = v2DistSquare(tmpOut, p0);
                            if (movement > maxMovement) {
                                maxMovement = movement;
                                vec2.copy(out, tmpOut);
                            }
                        }
                    }
                };
            })()
        };

        return EdgeBundling;
    });
    define('echarts/util/accMath', [], function() {
        // 除法函数，用来得到精确的除法结果 
        // 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 
        // 调用：accDiv(arg1,arg2) 
        // 返回值：arg1除以arg2的精确结果
        function accDiv(arg1, arg2) {
            var s1 = arg1.toString();
            var s2 = arg2.toString();
            var m = 0;
            try {
                m = s2.split('.')[1].length;
            } catch (e) {}
            try {
                m -= s1.split('.')[1].length;
            } catch (e) {}

            return (s1.replace('.', '') - 0) / (s2.replace('.', '') - 0) * Math.pow(10, m);
        }

        // 乘法函数，用来得到精确的乘法结果
        // 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 
        // 调用：accMul(arg1,arg2) 
        // 返回值：arg1乘以arg2的精确结果
        function accMul(arg1, arg2) {
            var s1 = arg1.toString();
            var s2 = arg2.toString();
            var m = 0;
            try {
                m += s1.split('.')[1].length;
            } catch (e) {}
            try {
                m += s2.split('.')[1].length;
            } catch (e) {}

            return (s1.replace('.', '') - 0) * (s2.replace('.', '') - 0) / Math.pow(10, m);
        }

        // 加法函数，用来得到精确的加法结果 
        // 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 
        // 调用：accAdd(arg1,arg2) 
        // 返回值：arg1加上arg2的精确结果 
        function accAdd(arg1, arg2) {
            var r1 = 0;
            var r2 = 0;
            try {
                r1 = arg1.toString().split('.')[1].length;
            } catch (e) {}
            try {
                r2 = arg2.toString().split('.')[1].length;
            } catch (e) {}

            var m = Math.pow(10, Math.max(r1, r2));
            return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
        }

        //减法函数，用来得到精确的减法结果 
        //说明：javascript的减法结果会有误差，在两个浮点数减法的时候会比较明显。这个函数返回较为精确的减法结果。 
        //调用：accSub(arg1,arg2) 
        //返回值：arg1减法arg2的精确结果 
        function accSub(arg1, arg2) {
            return accAdd(arg1, -arg2);
        }

        return {
            accDiv: accDiv,
            accMul: accMul,
            accAdd: accAdd,
            accSub: accSub
        };
    });
    define('zrender/shape/Base', ['require', '../tool/matrix', '../tool/guid', '../tool/util', '../tool/log', '../mixin/Transformable', '../mixin/Eventful', '../tool/area', '../tool/color'], function(require) {
        var vmlCanvasManager = window['G_vmlCanvasManager'];

        var matrix = require('../tool/matrix');
        var guid = require('../tool/guid');
        var util = require('../tool/util');
        var log = require('../tool/log');

        var Transformable = require('../mixin/Transformable');
        var Eventful = require('../mixin/Eventful');

        function _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {
            if (textFont) {
                ctx.font = textFont;
            }
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var rect = _getTextRect(
                text, x, y, textFont, textAlign, textBaseline
            );

            text = (text + '').split('\n');
            var lineHeight = require('../tool/area').getTextHeight('国', textFont);

            switch (textBaseline) {
                case 'top':
                    y = rect.y;
                    break;
                case 'bottom':
                    y = rect.y + lineHeight;
                    break;
                default:
                    y = rect.y + lineHeight / 2;
            }

            for (var i = 0, l = text.length; i < l; i++) {
                ctx.fillText(text[i], x, y);
                y += lineHeight;
            }
        }

        /**
         * 返回矩形区域，用于局部刷新和文字定位
         * @inner
         * @param {string} text
         * @param {number} x
         * @param {number} y
         * @param {string} textFont
         * @param {string} textAlign
         * @param {string} textBaseline
         */
        function _getTextRect(text, x, y, textFont, textAlign, textBaseline) {
            var area = require('../tool/area');
            var width = area.getTextWidth(text, textFont);
            var lineHeight = area.getTextHeight('国', textFont);

            text = (text + '').split('\n');

            switch (textAlign) {
                case 'end':
                case 'right':
                    x -= width;
                    break;
                case 'center':
                    x -= (width / 2);
                    break;
            }

            switch (textBaseline) {
                case 'top':
                    break;
                case 'bottom':
                    y -= lineHeight * text.length;
                    break;
                default:
                    y -= lineHeight * text.length / 2;
            }

            return {
                x: x,
                y: y,
                width: width,
                height: lineHeight * text.length
            };
        }

        /**
         * @alias module:zrender/shape/Base
         * @constructor
         * @extends module:zrender/mixin/Transformable
         * @extends module:zrender/mixin/Eventful
         * @param {Object} options 关于shape的配置项，可以是shape的自有属性，也可以是自定义的属性。
         */
        var Base = function(options) {

            options = options || {};

            /**
             * Shape id, 全局唯一
             * @type {string}
             */
            this.id = options.id || guid();

            for (var key in options) {
                this[key] = options[key];
            }

            /**
             * 基础绘制样式
             * @type {module:zrender/shape/Base~IBaseShapeStyle}
             */
            this.style = this.style || {};

            /**
             * 高亮样式
             * @type {module:zrender/shape/Base~IBaseShapeStyle}
             */
            this.highlightStyle = this.highlightStyle || null;

            /**
             * 父节点
             * @readonly
             * @type {module:zrender/Group}
             * @default null
             */
            this.parent = null;

            this.__dirty = true;

            this.__clipShapes = [];

            Transformable.call(this);
            Eventful.call(this);
        };
        /**
         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
         * @name module:zrender/shape/Base#invisible
         * @type {boolean}
         * @default false
         */
        Base.prototype.invisible = false;

        /**
         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
         * @name module:zrender/shape/Base#ignore
         * @type {boolean}
         * @default false
         */
        Base.prototype.ignore = false;

        /**
         * z层level，决定绘画在哪层canvas中
         * @name module:zrender/shape/Base#zlevel
         * @type {number}
         * @default 0
         */
        Base.prototype.zlevel = 0;

        /**
         * 是否可拖拽
         * @name module:zrender/shape/Base#draggable
         * @type {boolean}
         * @default false
         */
        Base.prototype.draggable = false;

        /**
         * 是否可点击
         * @name module:zrender/shape/Base#clickable
         * @type {boolean}
         * @default false
         */
        Base.prototype.clickable = false;

        /**
         * 是否可以hover
         * @name module:zrender/shape/Base#hoverable
         * @type {boolean}
         * @default true
         */
        Base.prototype.hoverable = true;

        /**
         * z值，跟zlevel一样影响shape绘制的前后顺序，z值大的shape会覆盖在z值小的上面，
         * 但是并不会创建新的canvas，所以优先级低于zlevel，而且频繁改动的开销比zlevel小很多。
         * 
         * @name module:zrender/shape/Base#z
         * @type {number}
         * @default 0
         */
        Base.prototype.z = 0;

        /**
         * 绘制图形
         * 
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} [isHighlight=false] 是否使用高亮属性
         * @param {Function} [updateCallback]
         *        需要异步加载资源的shape可以通过这个callback(e), 
         *        让painter更新视图，base.brush没用，需要的话重载brush
         */
        Base.prototype.brush = function(ctx, isHighlight) {

            var style = this.beforeBrush(ctx, isHighlight);

            ctx.beginPath();
            this.buildPath(ctx, style);

            switch (style.brushType) {
                /* jshint ignore:start */
                case 'both':
                    ctx.fill();
                case 'stroke':
                    style.lineWidth > 0 && ctx.stroke();
                    break;
                    /* jshint ignore:end */
                default:
                    ctx.fill();
            }

            this.drawText(ctx, style, this.style);

            this.afterBrush(ctx);
        };

        /**
         * 具体绘制操作前的一些公共操作
         * @param {CanvasRenderingContext2D} ctx
         * @param {boolean} [isHighlight=false] 是否使用高亮属性
         * @return {Object} 处理后的样式
         */
        Base.prototype.beforeBrush = function(ctx, isHighlight) {
            var style = this.style;

            if (this.brushTypeOnly) {
                style.brushType = this.brushTypeOnly;
            }

            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(
                    style,
                    this.highlightStyle || {},
                    this.brushTypeOnly
                );
            }

            if (this.brushTypeOnly == 'stroke') {
                style.strokeColor = style.strokeColor || style.color;
            }

            ctx.save();

            this.doClip(ctx);

            this.setContext(ctx, style);

            // 设置transform
            this.setTransform(ctx);

            return style;
        };

        /**
         * 绘制后的处理
         * @param {CanvasRenderingContext2D} ctx
         */
        Base.prototype.afterBrush = function(ctx) {
            ctx.restore();
        };

        var STYLE_CTX_MAP = [
            ['color', 'fillStyle'],
            ['strokeColor', 'strokeStyle'],
            ['opacity', 'globalAlpha'],
            ['lineCap', 'lineCap'],
            ['lineJoin', 'lineJoin'],
            ['miterLimit', 'miterLimit'],
            ['lineWidth', 'lineWidth'],
            ['shadowBlur', 'shadowBlur'],
            ['shadowColor', 'shadowColor'],
            ['shadowOffsetX', 'shadowOffsetX'],
            ['shadowOffsetY', 'shadowOffsetY']
        ];

        /**
         * 设置 fillStyle, strokeStyle, shadow 等通用绘制样式
         * @param {CanvasRenderingContext2D} ctx
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style
         */
        Base.prototype.setContext = function(ctx, style) {
            for (var i = 0, len = STYLE_CTX_MAP.length; i < len; i++) {
                var styleProp = STYLE_CTX_MAP[i][0];
                var styleValue = style[styleProp];
                var ctxProp = STYLE_CTX_MAP[i][1];

                if (typeof styleValue != 'undefined') {
                    ctx[ctxProp] = styleValue;
                }
            }
        };

        var clipShapeInvTransform = matrix.create();
        Base.prototype.doClip = function(ctx) {
            if (this.__clipShapes && !vmlCanvasManager) {
                for (var i = 0; i < this.__clipShapes.length; i++) {
                    var clipShape = this.__clipShapes[i];
                    if (clipShape.needTransform) {
                        var m = clipShape.transform;
                        matrix.invert(clipShapeInvTransform, m);
                        ctx.transform(
                            m[0], m[1],
                            m[2], m[3],
                            m[4], m[5]
                        );
                    }
                    ctx.beginPath();
                    clipShape.buildPath(ctx, clipShape.style);
                    ctx.clip();
                    // Transform back
                    if (clipShape.needTransform) {
                        var m = clipShapeInvTransform;
                        ctx.transform(
                            m[0], m[1],
                            m[2], m[3],
                            m[4], m[5]
                        );
                    }
                }
            }
        };

        /**
         * 根据默认样式扩展高亮样式
         * 
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style 默认样式
         * @param {module:zrender/shape/Base~IBaseShapeStyle} highlightStyle 高亮样式
         * @param {string} brushTypeOnly
         */
        Base.prototype.getHighlightStyle = function(style, highlightStyle, brushTypeOnly) {
            var newStyle = {};
            for (var k in style) {
                newStyle[k] = style[k];
            }

            var color = require('../tool/color');
            var highlightColor = color.getHighlightColor();
            // 根据highlightStyle扩展
            if (style.brushType != 'stroke') {
                // 带填充则用高亮色加粗边线
                newStyle.strokeColor = highlightColor;
                newStyle.lineWidth = (style.lineWidth || 1) + this.getHighlightZoom();
                newStyle.brushType = 'both';
            } else {
                if (brushTypeOnly != 'stroke') {
                    // 描边型的则用原色加工高亮
                    newStyle.strokeColor = highlightColor;
                    newStyle.lineWidth = (style.lineWidth || 1) + this.getHighlightZoom();
                } else {
                    // 线型的则用原色加工高亮
                    newStyle.strokeColor = highlightStyle.strokeColor || color.mix(
                        style.strokeColor,
                        color.toRGB(highlightColor)
                    );
                }
            }

            // 可自定义覆盖默认值
            for (var k in highlightStyle) {
                if (typeof highlightStyle[k] != 'undefined') {
                    newStyle[k] = highlightStyle[k];
                }
            }

            return newStyle;
        };

        // 高亮放大效果参数
        // 当前统一设置为6，如有需要差异设置，通过this.type判断实例类型
        Base.prototype.getHighlightZoom = function() {
            return this.type != 'text' ? 6 : 2;
        };

        /**
         * 移动位置
         * @param {number} dx 横坐标变化
         * @param {number} dy 纵坐标变化
         */
        Base.prototype.drift = function(dx, dy) {
            this.position[0] += dx;
            this.position[1] += dy;
        };

        /**
         * 构建绘制的Path
         * @param {CanvasRenderingContext2D} ctx
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style
         */
        Base.prototype.buildPath = function(ctx, style) {
            log('buildPath not implemented in ' + this.type);
        };

        /**
         * 计算返回包围盒矩形
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style
         * @return {module:zrender/shape/Base~IBoundingRect}
         */
        Base.prototype.getRect = function(style) {
            log('getRect not implemented in ' + this.type);
        };

        /**
         * 判断鼠标位置是否在图形内
         * @param {number} x
         * @param {number} y
         * @return {boolean}
         */
        Base.prototype.isCover = function(x, y) {
            var originPos = this.transformCoordToLocal(x, y);
            x = originPos[0];
            y = originPos[1];

            // 快速预判并保留判断矩形
            if (this.isCoverRect(x, y)) {
                // 矩形内
                return require('../tool/area').isInside(this, this.style, x, y);
            }

            return false;
        };

        Base.prototype.isCoverRect = function(x, y) {
            // 快速预判并保留判断矩形
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }
            return x >= rect.x && x <= (rect.x + rect.width) && y >= rect.y && y <= (rect.y + rect.height);
        };

        /**
         * 绘制附加文本
         * @param {CanvasRenderingContext2D} ctx
         * @param {module:zrender/shape/Base~IBaseShapeStyle} style 样式
         * @param {module:zrender/shape/Base~IBaseShapeStyle} normalStyle 默认样式，用于定位文字显示
         */
        Base.prototype.drawText = function(ctx, style, normalStyle) {
            if (typeof(style.text) == 'undefined' || style.text === false) {
                return;
            }
            // 字体颜色策略
            var textColor = style.textColor || style.color || style.strokeColor;
            ctx.fillStyle = textColor;

            // 文本与图形间空白间隙
            var dd = 10;
            var al; // 文本水平对齐
            var bl; // 文本垂直对齐
            var tx; // 文本横坐标
            var ty; // 文本纵坐标

            var textPosition = style.textPosition // 用户定义
                || this.textPosition // shape默认
                || 'top'; // 全局默认

            switch (textPosition) {
                case 'inside':
                case 'top':
                case 'bottom':
                case 'left':
                case 'right':
                    if (this.getRect) {
                        var rect = (normalStyle || style).__rect || this.getRect(normalStyle || style);

                        switch (textPosition) {
                            case 'inside':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y + rect.height / 2;
                                al = 'center';
                                bl = 'middle';
                                if (style.brushType != 'stroke' && textColor == style.color) {
                                    ctx.fillStyle = '#fff';
                                }
                                break;
                            case 'left':
                                tx = rect.x - dd;
                                ty = rect.y + rect.height / 2;
                                al = 'end';
                                bl = 'middle';
                                break;
                            case 'right':
                                tx = rect.x + rect.width + dd;
                                ty = rect.y + rect.height / 2;
                                al = 'start';
                                bl = 'middle';
                                break;
                            case 'top':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y - dd;
                                al = 'center';
                                bl = 'bottom';
                                break;
                            case 'bottom':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y + rect.height + dd;
                                al = 'center';
                                bl = 'top';
                                break;
                        }
                    }
                    break;
                case 'start':
                case 'end':
                    var pointList = style.pointList || [
                        [style.xStart || 0, style.yStart || 0],
                        [style.xEnd || 0, style.yEnd || 0]
                    ];
                    var length = pointList.length;
                    if (length < 2) {
                        // 少于2个点就不画了~
                        return;
                    }
                    var xStart;
                    var xEnd;
                    var yStart;
                    var yEnd;
                    switch (textPosition) {
                        case 'start':
                            xStart = pointList[1][0];
                            xEnd = pointList[0][0];
                            yStart = pointList[1][1];
                            yEnd = pointList[0][1];
                            break;
                        case 'end':
                            xStart = pointList[length - 2][0];
                            xEnd = pointList[length - 1][0];
                            yStart = pointList[length - 2][1];
                            yEnd = pointList[length - 1][1];
                            break;
                    }
                    tx = xEnd;
                    ty = yEnd;

                    var angle = Math.atan((yStart - yEnd) / (xEnd - xStart)) / Math.PI * 180;
                    if ((xEnd - xStart) < 0) {
                        angle += 180;
                    } else if ((yStart - yEnd) < 0) {
                        angle += 360;
                    }

                    dd = 5;
                    if (angle >= 30 && angle <= 150) {
                        al = 'center';
                        bl = 'bottom';
                        ty -= dd;
                    } else if (angle > 150 && angle < 210) {
                        al = 'right';
                        bl = 'middle';
                        tx -= dd;
                    } else if (angle >= 210 && angle <= 330) {
                        al = 'center';
                        bl = 'top';
                        ty += dd;
                    } else {
                        al = 'left';
                        bl = 'middle';
                        tx += dd;
                    }
                    break;
                case 'specific':
                    tx = style.textX || 0;
                    ty = style.textY || 0;
                    al = 'start';
                    bl = 'middle';
                    break;
            }

            if (tx != null && ty != null) {
                _fillText(
                    ctx,
                    style.text,
                    tx, ty,
                    style.textFont,
                    style.textAlign || al,
                    style.textBaseline || bl
                );
            }
        };

        Base.prototype.modSelf = function() {
            this.__dirty = true;
            if (this.style) {
                this.style.__rect = null;
            }
            if (this.highlightStyle) {
                this.highlightStyle.__rect = null;
            }
        };

        /**
         * 图形是否会触发事件
         * @return {boolean}
         */
        // TODO, 通过 bind 绑定的事件
        Base.prototype.isSilent = function() {
            return !(
                this.hoverable || this.draggable || this.clickable || this.onmousemove || this.onmouseover || this.onmouseout || this.onmousedown || this.onmouseup || this.onclick || this.ondragenter || this.ondragover || this.ondragleave || this.ondrop
            );
        };

        util.merge(Base.prototype, Transformable.prototype, true);
        util.merge(Base.prototype, Eventful.prototype, true);

        return Base;
    });
    define('zrender/dep/excanvas', ['require'], function(require) {

        // Only add this code if we do not already have a canvas implementation
        if (!document.createElement('canvas').getContext) {

            (function() {

                // alias some functions to make (compiled) code shorter
                var m = Math;
                var mr = m.round;
                var ms = m.sin;
                var mc = m.cos;
                var abs = m.abs;
                var sqrt = m.sqrt;

                // this is used for sub pixel precision
                var Z = 10;
                var Z2 = Z / 2;

                var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];

                /**
                 * This funtion is assigned to the <canvas> elements as element.getContext().
                 * @this {HTMLElement}
                 * @return {CanvasRenderingContext2D_}
                 */
                function getContext() {
                    return this.context_ ||
                        (this.context_ = new CanvasRenderingContext2D_(this));
                }

                var slice = Array.prototype.slice;

                /**
                 * Binds a function to an object. The returned function will always use the
                 * passed in {@code obj} as {@code this}.
                 *
                 * Example:
                 *
                 *   g = bind(f, obj, a, b)
                 *   g(c, d) // will do f.call(obj, a, b, c, d)
                 *
                 * @param {Function} f The function to bind the object to
                 * @param {Object} obj The object that should act as this when the function
                 *     is called
                 * @param {*} var_args Rest arguments that will be used as the initial
                 *     arguments when the function is called
                 * @return {Function} A new function that has bound this
                 */
                function bind(f, obj, var_args) {
                    var a = slice.call(arguments, 2);
                    return function() {
                        return f.apply(obj, a.concat(slice.call(arguments)));
                    };
                }

                function encodeHtmlAttribute(s) {
                    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
                }

                function addNamespace(doc, prefix, urn) {
                    if (!doc.namespaces[prefix]) {
                        doc.namespaces.add(prefix, urn, '#default#VML');
                    }
                }

                function addNamespacesAndStylesheet(doc) {
                    addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');
                    addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');

                    // Setup default CSS.  Only add one style sheet per document
                    if (!doc.styleSheets['ex_canvas_']) {
                        var ss = doc.createStyleSheet();
                        ss.owningElement.id = 'ex_canvas_';
                        ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
                            // default size is 300x150 in Gecko and Opera
                            'text-align:left;width:300px;height:150px}';
                    }
                }

                // Add namespaces and stylesheet at startup.
                addNamespacesAndStylesheet(document);

                var G_vmlCanvasManager_ = {
                    init: function(opt_doc) {
                        var doc = opt_doc || document;
                        // Create a dummy element so that IE will allow canvas elements to be
                        // recognized.
                        doc.createElement('canvas');
                        doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
                    },

                    init_: function(doc) {
                        // find all canvas elements
                        var els = doc.getElementsByTagName('canvas');
                        for (var i = 0; i < els.length; i++) {
                            this.initElement(els[i]);
                        }
                    },

                    /**
                     * Public initializes a canvas element so that it can be used as canvas
                     * element from now on. This is called automatically before the page is
                     * loaded but if you are creating elements using createElement you need to
                     * make sure this is called on the element.
                     * @param {HTMLElement} el The canvas element to initialize.
                     * @return {HTMLElement} the element that was created.
                     */
                    initElement: function(el) {
                        if (!el.getContext) {
                            el.getContext = getContext;

                            // Add namespaces and stylesheet to document of the element.
                            addNamespacesAndStylesheet(el.ownerDocument);

                            // Remove fallback content. There is no way to hide text nodes so we
                            // just remove all childNodes. We could hide all elements and remove
                            // text nodes but who really cares about the fallback content.
                            el.innerHTML = '';

                            // do not use inline function because that will leak memory
                            el.attachEvent('onpropertychange', onPropertyChange);
                            el.attachEvent('onresize', onResize);

                            var attrs = el.attributes;
                            if (attrs.width && attrs.width.specified) {
                                // TODO: use runtimeStyle and coordsize
                                // el.getContext().setWidth_(attrs.width.nodeValue);
                                el.style.width = attrs.width.nodeValue + 'px';
                            } else {
                                el.width = el.clientWidth;
                            }
                            if (attrs.height && attrs.height.specified) {
                                // TODO: use runtimeStyle and coordsize
                                // el.getContext().setHeight_(attrs.height.nodeValue);
                                el.style.height = attrs.height.nodeValue + 'px';
                            } else {
                                el.height = el.clientHeight;
                            }
                            //el.getContext().setCoordsize_()
                        }
                        return el;
                    }
                };

                function onPropertyChange(e) {
                    var el = e.srcElement;

                    switch (e.propertyName) {
                        case 'width':
                            el.getContext().clearRect();
                            el.style.width = el.attributes.width.nodeValue + 'px';
                            // In IE8 this does not trigger onresize.
                            el.firstChild.style.width = el.clientWidth + 'px';
                            break;
                        case 'height':
                            el.getContext().clearRect();
                            el.style.height = el.attributes.height.nodeValue + 'px';
                            el.firstChild.style.height = el.clientHeight + 'px';
                            break;
                    }
                }

                function onResize(e) {
                    var el = e.srcElement;
                    if (el.firstChild) {
                        el.firstChild.style.width = el.clientWidth + 'px';
                        el.firstChild.style.height = el.clientHeight + 'px';
                    }
                }

                G_vmlCanvasManager_.init();

                // precompute "00" to "FF"
                var decToHex = [];
                for (var i = 0; i < 16; i++) {
                    for (var j = 0; j < 16; j++) {
                        decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
                    }
                }

                function createMatrixIdentity() {
                    return [
                        [1, 0, 0],
                        [0, 1, 0],
                        [0, 0, 1]
                    ];
                }

                function matrixMultiply(m1, m2) {
                    var result = createMatrixIdentity();

                    for (var x = 0; x < 3; x++) {
                        for (var y = 0; y < 3; y++) {
                            var sum = 0;

                            for (var z = 0; z < 3; z++) {
                                sum += m1[x][z] * m2[z][y];
                            }

                            result[x][y] = sum;
                        }
                    }
                    return result;
                }

                function copyState(o1, o2) {
                    o2.fillStyle = o1.fillStyle;
                    o2.lineCap = o1.lineCap;
                    o2.lineJoin = o1.lineJoin;
                    o2.lineWidth = o1.lineWidth;
                    o2.miterLimit = o1.miterLimit;
                    o2.shadowBlur = o1.shadowBlur;
                    o2.shadowColor = o1.shadowColor;
                    o2.shadowOffsetX = o1.shadowOffsetX;
                    o2.shadowOffsetY = o1.shadowOffsetY;
                    o2.strokeStyle = o1.strokeStyle;
                    o2.globalAlpha = o1.globalAlpha;
                    o2.font = o1.font;
                    o2.textAlign = o1.textAlign;
                    o2.textBaseline = o1.textBaseline;
                    o2.scaleX_ = o1.scaleX_;
                    o2.scaleY_ = o1.scaleY_;
                    o2.lineScale_ = o1.lineScale_;
                }

                var colorData = {
                    aliceblue: '#F0F8FF',
                    antiquewhite: '#FAEBD7',
                    aquamarine: '#7FFFD4',
                    azure: '#F0FFFF',
                    beige: '#F5F5DC',
                    bisque: '#FFE4C4',
                    black: '#000000',
                    blanchedalmond: '#FFEBCD',
                    blueviolet: '#8A2BE2',
                    brown: '#A52A2A',
                    burlywood: '#DEB887',
                    cadetblue: '#5F9EA0',
                    chartreuse: '#7FFF00',
                    chocolate: '#D2691E',
                    coral: '#FF7F50',
                    cornflowerblue: '#6495ED',
                    cornsilk: '#FFF8DC',
                    crimson: '#DC143C',
                    cyan: '#00FFFF',
                    darkblue: '#00008B',
                    darkcyan: '#008B8B',
                    darkgoldenrod: '#B8860B',
                    darkgray: '#A9A9A9',
                    darkgreen: '#006400',
                    darkgrey: '#A9A9A9',
                    darkkhaki: '#BDB76B',
                    darkmagenta: '#8B008B',
                    darkolivegreen: '#556B2F',
                    darkorange: '#FF8C00',
                    darkorchid: '#9932CC',
                    darkred: '#8B0000',
                    darksalmon: '#E9967A',
                    darkseagreen: '#8FBC8F',
                    darkslateblue: '#483D8B',
                    darkslategray: '#2F4F4F',
                    darkslategrey: '#2F4F4F',
                    darkturquoise: '#00CED1',
                    darkviolet: '#9400D3',
                    deeppink: '#FF1493',
                    deepskyblue: '#00BFFF',
                    dimgray: '#696969',
                    dimgrey: '#696969',
                    dodgerblue: '#1E90FF',
                    firebrick: '#B22222',
                    floralwhite: '#FFFAF0',
                    forestgreen: '#228B22',
                    gainsboro: '#DCDCDC',
                    ghostwhite: '#F8F8FF',
                    gold: '#FFD700',
                    goldenrod: '#DAA520',
                    grey: '#808080',
                    greenyellow: '#ADFF2F',
                    honeydew: '#F0FFF0',
                    hotpink: '#FF69B4',
                    indianred: '#CD5C5C',
                    indigo: '#4B0082',
                    ivory: '#FFFFF0',
                    khaki: '#F0E68C',
                    lavender: '#E6E6FA',
                    lavenderblush: '#FFF0F5',
                    lawngreen: '#7CFC00',
                    lemonchiffon: '#FFFACD',
                    lightblue: '#ADD8E6',
                    lightcoral: '#F08080',
                    lightcyan: '#E0FFFF',
                    lightgoldenrodyellow: '#FAFAD2',
                    lightgreen: '#90EE90',
                    lightgrey: '#D3D3D3',
                    lightpink: '#FFB6C1',
                    lightsalmon: '#FFA07A',
                    lightseagreen: '#20B2AA',
                    lightskyblue: '#87CEFA',
                    lightslategray: '#778899',
                    lightslategrey: '#778899',
                    lightsteelblue: '#B0C4DE',
                    lightyellow: '#FFFFE0',
                    limegreen: '#32CD32',
                    linen: '#FAF0E6',
                    magenta: '#FF00FF',
                    mediumaquamarine: '#66CDAA',
                    mediumblue: '#0000CD',
                    mediumorchid: '#BA55D3',
                    mediumpurple: '#9370DB',
                    mediumseagreen: '#3CB371',
                    mediumslateblue: '#7B68EE',
                    mediumspringgreen: '#00FA9A',
                    mediumturquoise: '#48D1CC',
                    mediumvioletred: '#C71585',
                    midnightblue: '#191970',
                    mintcream: '#F5FFFA',
                    mistyrose: '#FFE4E1',
                    moccasin: '#FFE4B5',
                    navajowhite: '#FFDEAD',
                    oldlace: '#FDF5E6',
                    olivedrab: '#6B8E23',
                    orange: '#FFA500',
                    orangered: '#FF4500',
                    orchid: '#DA70D6',
                    palegoldenrod: '#EEE8AA',
                    palegreen: '#98FB98',
                    paleturquoise: '#AFEEEE',
                    palevioletred: '#DB7093',
                    papayawhip: '#FFEFD5',
                    peachpuff: '#FFDAB9',
                    peru: '#CD853F',
                    pink: '#FFC0CB',
                    plum: '#DDA0DD',
                    powderblue: '#B0E0E6',
                    rosybrown: '#BC8F8F',
                    royalblue: '#4169E1',
                    saddlebrown: '#8B4513',
                    salmon: '#FA8072',
                    sandybrown: '#F4A460',
                    seagreen: '#2E8B57',
                    seashell: '#FFF5EE',
                    sienna: '#A0522D',
                    skyblue: '#87CEEB',
                    slateblue: '#6A5ACD',
                    slategray: '#708090',
                    slategrey: '#708090',
                    snow: '#FFFAFA',
                    springgreen: '#00FF7F',
                    steelblue: '#4682B4',
                    tan: '#D2B48C',
                    thistle: '#D8BFD8',
                    tomato: '#FF6347',
                    turquoise: '#40E0D0',
                    violet: '#EE82EE',
                    wheat: '#F5DEB3',
                    whitesmoke: '#F5F5F5',
                    yellowgreen: '#9ACD32'
                };


                function getRgbHslContent(styleString) {
                    var start = styleString.indexOf('(', 3);
                    var end = styleString.indexOf(')', start + 1);
                    var parts = styleString.substring(start + 1, end).split(',');
                    // add alpha if needed
                    if (parts.length != 4 || styleString.charAt(3) != 'a') {
                        parts[3] = 1;
                    }
                    return parts;
                }

                function percent(s) {
                    return parseFloat(s) / 100;
                }

                function clamp(v, min, max) {
                    return Math.min(max, Math.max(min, v));
                }

                function hslToRgb(parts) {
                    var r, g, b, h, s, l;
                    h = parseFloat(parts[0]) / 360 % 360;
                    if (h < 0)
                        h++;
                    s = clamp(percent(parts[1]), 0, 1);
                    l = clamp(percent(parts[2]), 0, 1);
                    if (s == 0) {
                        r = g = b = l; // achromatic
                    } else {
                        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        var p = 2 * l - q;
                        r = hueToRgb(p, q, h + 1 / 3);
                        g = hueToRgb(p, q, h);
                        b = hueToRgb(p, q, h - 1 / 3);
                    }

                    return '#' + decToHex[Math.floor(r * 255)] +
                        decToHex[Math.floor(g * 255)] +
                        decToHex[Math.floor(b * 255)];
                }

                function hueToRgb(m1, m2, h) {
                    if (h < 0)
                        h++;
                    if (h > 1)
                        h--;

                    if (6 * h < 1)
                        return m1 + (m2 - m1) * 6 * h;
                    else if (2 * h < 1)
                        return m2;
                    else if (3 * h < 2)
                        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
                    else
                        return m1;
                }

                var processStyleCache = {};

                function processStyle(styleString) {
                    if (styleString in processStyleCache) {
                        return processStyleCache[styleString];
                    }

                    var str, alpha = 1;

                    styleString = String(styleString);
                    if (styleString.charAt(0) == '#') {
                        str = styleString;
                    } else if (/^rgb/.test(styleString)) {
                        var parts = getRgbHslContent(styleString);
                        var str = '#',
                            n;
                        for (var i = 0; i < 3; i++) {
                            if (parts[i].indexOf('%') != -1) {
                                n = Math.floor(percent(parts[i]) * 255);
                            } else {
                                n = +parts[i];
                            }
                            str += decToHex[clamp(n, 0, 255)];
                        }
                        alpha = +parts[3];
                    } else if (/^hsl/.test(styleString)) {
                        var parts = getRgbHslContent(styleString);
                        str = hslToRgb(parts);
                        alpha = parts[3];
                    } else {
                        str = colorData[styleString] || styleString;
                    }
                    return processStyleCache[styleString] = {
                        color: str,
                        alpha: alpha
                    };
                }

                var DEFAULT_STYLE = {
                    style: 'normal',
                    variant: 'normal',
                    weight: 'normal',
                    size: 12, //10
                    family: '微软雅黑' //'sans-serif'
                };

                // Internal text style cache
                var fontStyleCache = {};

                function processFontStyle(styleString) {
                    if (fontStyleCache[styleString]) {
                        return fontStyleCache[styleString];
                    }

                    var el = document.createElement('div');
                    var style = el.style;
                    var fontFamily;
                    try {
                        style.font = styleString;
                        fontFamily = style.fontFamily.split(',')[0];
                    } catch (ex) {
                        // Ignore failures to set to invalid font.
                    }

                    return fontStyleCache[styleString] = {
                        style: style.fontStyle || DEFAULT_STYLE.style,
                        variant: style.fontVariant || DEFAULT_STYLE.variant,
                        weight: style.fontWeight || DEFAULT_STYLE.weight,
                        size: style.fontSize || DEFAULT_STYLE.size,
                        family: fontFamily || DEFAULT_STYLE.family
                    };
                }

                function getComputedStyle(style, element) {
                    var computedStyle = {};

                    for (var p in style) {
                        computedStyle[p] = style[p];
                    }

                    // Compute the size
                    var canvasFontSize = parseFloat(element.currentStyle.fontSize),
                        fontSize = parseFloat(style.size);

                    if (typeof style.size == 'number') {
                        computedStyle.size = style.size;
                    } else if (style.size.indexOf('px') != -1) {
                        computedStyle.size = fontSize;
                    } else if (style.size.indexOf('em') != -1) {
                        computedStyle.size = canvasFontSize * fontSize;
                    } else if (style.size.indexOf('%') != -1) {
                        computedStyle.size = (canvasFontSize / 100) * fontSize;
                    } else if (style.size.indexOf('pt') != -1) {
                        computedStyle.size = fontSize / .75;
                    } else {
                        computedStyle.size = canvasFontSize;
                    }

                    // Different scaling between normal text and VML text. This was found using
                    // trial and error to get the same size as non VML text.
                    //computedStyle.size *= 0.981;

                    return computedStyle;
                }

                function buildStyle(style) {
                    return style.style + ' ' + style.variant + ' ' + style.weight + ' ' +
                        style.size + "px '" + style.family + "'";
                }

                var lineCapMap = {
                    'butt': 'flat',
                    'round': 'round'
                };

                function processLineCap(lineCap) {
                    return lineCapMap[lineCap] || 'square';
                }

                /**
                 * This class implements CanvasRenderingContext2D interface as described by
                 * the WHATWG.
                 * @param {HTMLElement} canvasElement The element that the 2D context should
                 * be associated with
                 */
                function CanvasRenderingContext2D_(canvasElement) {
                    this.m_ = createMatrixIdentity();

                    this.mStack_ = [];
                    this.aStack_ = [];
                    this.currentPath_ = [];

                    // Canvas context properties
                    this.strokeStyle = '#000';
                    this.fillStyle = '#000';

                    this.lineWidth = 1;
                    this.lineJoin = 'miter';
                    this.lineCap = 'butt';
                    this.miterLimit = Z * 1;
                    this.globalAlpha = 1;
                    // this.font = '10px sans-serif';
                    this.font = '12px 微软雅黑'; // 决定还是改这吧，影响代价最小
                    this.textAlign = 'left';
                    this.textBaseline = 'alphabetic';
                    this.canvas = canvasElement;

                    var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' +
                        canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';
                    var el = canvasElement.ownerDocument.createElement('div');
                    el.style.cssText = cssText;
                    canvasElement.appendChild(el);

                    var overlayEl = el.cloneNode(false);
                    // Use a non transparent background.
                    overlayEl.style.backgroundColor = '#fff'; //red, I don't know why, it work! 
                    overlayEl.style.filter = 'alpha(opacity=0)';
                    canvasElement.appendChild(overlayEl);

                    this.element_ = el;
                    this.scaleX_ = 1;
                    this.scaleY_ = 1;
                    this.lineScale_ = 1;
                }

                var contextPrototype = CanvasRenderingContext2D_.prototype;
                contextPrototype.clearRect = function() {
                    if (this.textMeasureEl_) {
                        this.textMeasureEl_.removeNode(true);
                        this.textMeasureEl_ = null;
                    }
                    this.element_.innerHTML = '';
                };

                contextPrototype.beginPath = function() {
                    // TODO: Branch current matrix so that save/restore has no effect
                    //       as per safari docs.
                    this.currentPath_ = [];
                };

                contextPrototype.moveTo = function(aX, aY) {
                    var p = getCoords(this, aX, aY);
                    this.currentPath_.push({
                        type: 'moveTo',
                        x: p.x,
                        y: p.y
                    });
                    this.currentX_ = p.x;
                    this.currentY_ = p.y;
                };

                contextPrototype.lineTo = function(aX, aY) {
                    var p = getCoords(this, aX, aY);
                    this.currentPath_.push({
                        type: 'lineTo',
                        x: p.x,
                        y: p.y
                    });

                    this.currentX_ = p.x;
                    this.currentY_ = p.y;
                };

                contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                    aCP2x, aCP2y,
                    aX, aY) {
                    var p = getCoords(this, aX, aY);
                    var cp1 = getCoords(this, aCP1x, aCP1y);
                    var cp2 = getCoords(this, aCP2x, aCP2y);
                    bezierCurveTo(this, cp1, cp2, p);
                };

                // Helper function that takes the already fixed cordinates.
                function bezierCurveTo(self, cp1, cp2, p) {
                    self.currentPath_.push({
                        type: 'bezierCurveTo',
                        cp1x: cp1.x,
                        cp1y: cp1.y,
                        cp2x: cp2.x,
                        cp2y: cp2.y,
                        x: p.x,
                        y: p.y
                    });
                    self.currentX_ = p.x;
                    self.currentY_ = p.y;
                }

                contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
                    // the following is lifted almost directly from
                    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

                    var cp = getCoords(this, aCPx, aCPy);
                    var p = getCoords(this, aX, aY);

                    var cp1 = {
                        x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
                        y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
                    };
                    var cp2 = {
                        x: cp1.x + (p.x - this.currentX_) / 3.0,
                        y: cp1.y + (p.y - this.currentY_) / 3.0
                    };

                    bezierCurveTo(this, cp1, cp2, p);
                };

                contextPrototype.arc = function(aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise) {
                    aRadius *= Z;
                    var arcType = aClockwise ? 'at' : 'wa';

                    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
                    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

                    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
                    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

                    // IE won't render arches drawn counter clockwise if xStart == xEnd.
                    if (xStart == xEnd && !aClockwise) {
                        xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                        // that can be represented in binary
                    }

                    var p = getCoords(this, aX, aY);
                    var pStart = getCoords(this, xStart, yStart);
                    var pEnd = getCoords(this, xEnd, yEnd);

                    this.currentPath_.push({
                        type: arcType,
                        x: p.x,
                        y: p.y,
                        radius: aRadius,
                        xStart: pStart.x,
                        yStart: pStart.y,
                        xEnd: pEnd.x,
                        yEnd: pEnd.y
                    });

                };

                contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                };

                contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
                    var oldPath = this.currentPath_;
                    this.beginPath();

                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                    this.stroke();

                    this.currentPath_ = oldPath;
                };

                contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
                    var oldPath = this.currentPath_;
                    this.beginPath();

                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                    this.fill();

                    this.currentPath_ = oldPath;
                };

                contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
                    var gradient = new CanvasGradient_('gradient');
                    gradient.x0_ = aX0;
                    gradient.y0_ = aY0;
                    gradient.x1_ = aX1;
                    gradient.y1_ = aY1;
                    return gradient;
                };

                contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                    aX1, aY1, aR1) {
                    var gradient = new CanvasGradient_('gradientradial');
                    gradient.x0_ = aX0;
                    gradient.y0_ = aY0;
                    gradient.r0_ = aR0;
                    gradient.x1_ = aX1;
                    gradient.y1_ = aY1;
                    gradient.r1_ = aR1;
                    return gradient;
                };

                contextPrototype.drawImage = function(image, var_args) {
                    var dx, dy, dw, dh, sx, sy, sw, sh;

                    // to find the original width we overide the width and height
                    var oldRuntimeWidth = image.runtimeStyle.width;
                    var oldRuntimeHeight = image.runtimeStyle.height;
                    image.runtimeStyle.width = 'auto';
                    image.runtimeStyle.height = 'auto';

                    // get the original size
                    var w = image.width;
                    var h = image.height;

                    // and remove overides
                    image.runtimeStyle.width = oldRuntimeWidth;
                    image.runtimeStyle.height = oldRuntimeHeight;

                    if (arguments.length == 3) {
                        dx = arguments[1];
                        dy = arguments[2];
                        sx = sy = 0;
                        sw = dw = w;
                        sh = dh = h;
                    } else if (arguments.length == 5) {
                        dx = arguments[1];
                        dy = arguments[2];
                        dw = arguments[3];
                        dh = arguments[4];
                        sx = sy = 0;
                        sw = w;
                        sh = h;
                    } else if (arguments.length == 9) {
                        sx = arguments[1];
                        sy = arguments[2];
                        sw = arguments[3];
                        sh = arguments[4];
                        dx = arguments[5];
                        dy = arguments[6];
                        dw = arguments[7];
                        dh = arguments[8];
                    } else {
                        throw Error('Invalid number of arguments');
                    }

                    var d = getCoords(this, dx, dy);

                    var w2 = sw / 2;
                    var h2 = sh / 2;

                    var vmlStr = [];

                    var W = 10;
                    var H = 10;

                    var scaleX = scaleY = 1;

                    // For some reason that I've now forgotten, using divs didn't work
                    vmlStr.push(' <g_vml_:group',
                        ' coordsize="', Z * W, ',', Z * H, '"',
                        ' coordorigin="0,0"',
                        ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

                    // If filters are necessary (rotation exists), create them
                    // filters are bog-slow, so only create them if abbsolutely necessary
                    // The following check doesn't account for skews (which don't exist
                    // in the canvas spec (yet) anyway.

                    if (this.m_[0][0] != 1 || this.m_[0][1] ||
                        this.m_[1][1] != 1 || this.m_[1][0]) {
                        var filter = [];

                        var scaleX = this.scaleX_;
                        var scaleY = this.scaleY_;
                        // Note the 12/21 reversal
                        filter.push('M11=', this.m_[0][0] / scaleX, ',',
                            'M12=', this.m_[1][0] / scaleY, ',',
                            'M21=', this.m_[0][1] / scaleX, ',',
                            'M22=', this.m_[1][1] / scaleY, ',',
                            'Dx=', mr(d.x / Z), ',',
                            'Dy=', mr(d.y / Z), '');

                        // Bounding box calculation (need to minimize displayed area so that
                        // filters don't waste time on unused pixels.
                        var max = d;
                        var c2 = getCoords(this, dx + dw, dy);
                        var c3 = getCoords(this, dx, dy + dh);
                        var c4 = getCoords(this, dx + dw, dy + dh);

                        max.x = m.max(max.x, c2.x, c3.x, c4.x);
                        max.y = m.max(max.y, c2.y, c3.y, c4.y);

                        vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                            'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                            filter.join(''), ", SizingMethod='clip');");

                    } else {
                        vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
                    }

                    vmlStr.push(' ">');

                    // Draw a special cropping div if needed
                    if (sx || sy) {
                        // Apply scales to width and height
                        vmlStr.push('<div style="overflow: hidden; width:', Math.ceil((dw + sx * dw / sw) * scaleX), 'px;',
                            ' height:', Math.ceil((dh + sy * dh / sh) * scaleY), 'px;',
                            ' filter:progid:DxImageTransform.Microsoft.Matrix(Dx=', -sx * dw / sw * scaleX, ',Dy=', -sy * dh / sh * scaleY, ');">');
                    }


                    // Apply scales to width and height
                    vmlStr.push('<div style="width:', Math.round(scaleX * w * dw / sw), 'px;',
                        ' height:', Math.round(scaleY * h * dh / sh), 'px;',
                        ' filter:');

                    // If there is a globalAlpha, apply it to image
                    if (this.globalAlpha < 1) {
                        vmlStr.push(' progid:DXImageTransform.Microsoft.Alpha(opacity=' + (this.globalAlpha * 100) + ')');
                    }

                    vmlStr.push(' progid:DXImageTransform.Microsoft.AlphaImageLoader(src=', image.src, ',sizingMethod=scale)">');

                    // Close the crop div if necessary            
                    if (sx || sy) vmlStr.push('</div>');

                    vmlStr.push('</div></div>');

                    this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
                };

                contextPrototype.stroke = function(aFill) {
                    var lineStr = [];
                    var lineOpen = false;

                    var W = 10;
                    var H = 10;

                    lineStr.push('<g_vml_:shape',
                        ' filled="', !!aFill, '"',
                        ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                        ' coordorigin="0,0"',
                        ' coordsize="', Z * W, ',', Z * H, '"',
                        ' stroked="', !aFill, '"',
                        ' path="');

                    var newSeq = false;
                    var min = {
                        x: null,
                        y: null
                    };
                    var max = {
                        x: null,
                        y: null
                    };

                    for (var i = 0; i < this.currentPath_.length; i++) {
                        var p = this.currentPath_[i];
                        var c;

                        switch (p.type) {
                            case 'moveTo':
                                c = p;
                                lineStr.push(' m ', mr(p.x), ',', mr(p.y));
                                break;
                            case 'lineTo':
                                lineStr.push(' l ', mr(p.x), ',', mr(p.y));
                                break;
                            case 'close':
                                lineStr.push(' x ');
                                p = null;
                                break;
                            case 'bezierCurveTo':
                                lineStr.push(' c ',
                                    mr(p.cp1x), ',', mr(p.cp1y), ',',
                                    mr(p.cp2x), ',', mr(p.cp2y), ',',
                                    mr(p.x), ',', mr(p.y));
                                break;
                            case 'at':
                            case 'wa':
                                lineStr.push(' ', p.type, ' ',
                                    mr(p.x - this.scaleX_ * p.radius), ',',
                                    mr(p.y - this.scaleY_ * p.radius), ' ',
                                    mr(p.x + this.scaleX_ * p.radius), ',',
                                    mr(p.y + this.scaleY_ * p.radius), ' ',
                                    mr(p.xStart), ',', mr(p.yStart), ' ',
                                    mr(p.xEnd), ',', mr(p.yEnd));
                                break;
                        }


                        // TODO: Following is broken for curves due to
                        //       move to proper paths.

                        // Figure out dimensions so we can do gradient fills
                        // properly
                        if (p) {
                            if (min.x == null || p.x < min.x) {
                                min.x = p.x;
                            }
                            if (max.x == null || p.x > max.x) {
                                max.x = p.x;
                            }
                            if (min.y == null || p.y < min.y) {
                                min.y = p.y;
                            }
                            if (max.y == null || p.y > max.y) {
                                max.y = p.y;
                            }
                        }
                    }
                    lineStr.push(' ">');

                    if (!aFill) {
                        appendStroke(this, lineStr);
                    } else {
                        appendFill(this, lineStr, min, max);
                    }

                    lineStr.push('</g_vml_:shape>');

                    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
                };

                function appendStroke(ctx, lineStr) {
                    var a = processStyle(ctx.strokeStyle);
                    var color = a.color;
                    var opacity = a.alpha * ctx.globalAlpha;
                    var lineWidth = ctx.lineScale_ * ctx.lineWidth;

                    // VML cannot correctly render a line if the width is less than 1px.
                    // In that case, we dilute the color to make the line look thinner.
                    if (lineWidth < 1) {
                        opacity *= lineWidth;
                    }

                    lineStr.push(
                        '<g_vml_:stroke',
                        ' opacity="', opacity, '"',
                        ' joinstyle="', ctx.lineJoin, '"',
                        ' miterlimit="', ctx.miterLimit, '"',
                        ' endcap="', processLineCap(ctx.lineCap), '"',
                        ' weight="', lineWidth, 'px"',
                        ' color="', color, '" />'
                    );
                }

                function appendFill(ctx, lineStr, min, max) {
                    var fillStyle = ctx.fillStyle;
                    var arcScaleX = ctx.scaleX_;
                    var arcScaleY = ctx.scaleY_;
                    var width = max.x - min.x;
                    var height = max.y - min.y;
                    if (fillStyle instanceof CanvasGradient_) {
                        // TODO: Gradients transformed with the transformation matrix.
                        var angle = 0;
                        var focus = {
                            x: 0,
                            y: 0
                        };

                        // additional offset
                        var shift = 0;
                        // scale factor for offset
                        var expansion = 1;

                        if (fillStyle.type_ == 'gradient') {
                            var x0 = fillStyle.x0_ / arcScaleX;
                            var y0 = fillStyle.y0_ / arcScaleY;
                            var x1 = fillStyle.x1_ / arcScaleX;
                            var y1 = fillStyle.y1_ / arcScaleY;
                            var p0 = getCoords(ctx, x0, y0);
                            var p1 = getCoords(ctx, x1, y1);
                            var dx = p1.x - p0.x;
                            var dy = p1.y - p0.y;
                            angle = Math.atan2(dx, dy) * 180 / Math.PI;

                            // The angle should be a non-negative number.
                            if (angle < 0) {
                                angle += 360;
                            }

                            // Very small angles produce an unexpected result because they are
                            // converted to a scientific notation string.
                            if (angle < 1e-6) {
                                angle = 0;
                            }
                        } else {
                            var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
                            focus = {
                                x: (p0.x - min.x) / width,
                                y: (p0.y - min.y) / height
                            };

                            width /= arcScaleX * Z;
                            height /= arcScaleY * Z;
                            var dimension = m.max(width, height);
                            shift = 2 * fillStyle.r0_ / dimension;
                            expansion = 2 * fillStyle.r1_ / dimension - shift;
                        }

                        // We need to sort the color stops in ascending order by offset,
                        // otherwise IE won't interpret it correctly.
                        var stops = fillStyle.colors_;
                        stops.sort(function(cs1, cs2) {
                            return cs1.offset - cs2.offset;
                        });

                        var length = stops.length;
                        var color1 = stops[0].color;
                        var color2 = stops[length - 1].color;
                        var opacity1 = stops[0].alpha * ctx.globalAlpha;
                        var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;

                        var colors = [];
                        for (var i = 0; i < length; i++) {
                            var stop = stops[i];
                            colors.push(stop.offset * expansion + shift + ' ' + stop.color);
                        }

                        // When colors attribute is used, the meanings of opacity and o:opacity2
                        // are reversed.
                        lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                            ' method="none" focus="100%"',
                            ' color="', color1, '"',
                            ' color2="', color2, '"',
                            ' colors="', colors.join(','), '"',
                            ' opacity="', opacity2, '"',
                            ' g_o_:opacity2="', opacity1, '"',
                            ' angle="', angle, '"',
                            ' focusposition="', focus.x, ',', focus.y, '" />');
                    } else if (fillStyle instanceof CanvasPattern_) {
                        if (width && height) {
                            var deltaLeft = -min.x;
                            var deltaTop = -min.y;
                            lineStr.push('<g_vml_:fill',
                                ' position="',
                                deltaLeft / width * arcScaleX * arcScaleX, ',',
                                deltaTop / height * arcScaleY * arcScaleY, '"',
                                ' type="tile"',
                                // TODO: Figure out the correct size to fit the scale.
                                //' size="', w, 'px ', h, 'px"',
                                ' src="', fillStyle.src_, '" />');
                        }
                    } else {
                        var a = processStyle(ctx.fillStyle);
                        var color = a.color;
                        var opacity = a.alpha * ctx.globalAlpha;
                        lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                            '" />');
                    }
                }

                contextPrototype.fill = function() {
                    this.stroke(true);
                };

                contextPrototype.closePath = function() {
                    this.currentPath_.push({
                        type: 'close'
                    });
                };

                function getCoords(ctx, aX, aY) {
                    var m = ctx.m_;
                    return {
                        x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
                        y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
                    };
                };

                contextPrototype.save = function() {
                    var o = {};
                    copyState(this, o);
                    this.aStack_.push(o);
                    this.mStack_.push(this.m_);
                    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
                };

                contextPrototype.restore = function() {
                    if (this.aStack_.length) {
                        copyState(this.aStack_.pop(), this);
                        this.m_ = this.mStack_.pop();
                    }
                };

                function matrixIsFinite(m) {
                    return isFinite(m[0][0]) && isFinite(m[0][1]) &&
                        isFinite(m[1][0]) && isFinite(m[1][1]) &&
                        isFinite(m[2][0]) && isFinite(m[2][1]);
                }

                function setM(ctx, m, updateLineScale) {
                    if (!matrixIsFinite(m)) {
                        return;
                    }
                    ctx.m_ = m;

                    ctx.scaleX_ = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1]);
                    ctx.scaleY_ = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1]);

                    if (updateLineScale) {
                        // Get the line scale.
                        // Determinant of this.m_ means how much the area is enlarged by the
                        // transformation. So its square root can be used as a scale factor
                        // for width.
                        var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
                        ctx.lineScale_ = sqrt(abs(det));
                    }
                }

                contextPrototype.translate = function(aX, aY) {
                    var m1 = [
                        [1, 0, 0],
                        [0, 1, 0],
                        [aX, aY, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), false);
                };

                contextPrototype.rotate = function(aRot) {
                    var c = mc(aRot);
                    var s = ms(aRot);

                    var m1 = [
                        [c, s, 0],
                        [-s, c, 0],
                        [0, 0, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), false);
                };

                contextPrototype.scale = function(aX, aY) {
                    var m1 = [
                        [aX, 0, 0],
                        [0, aY, 0],
                        [0, 0, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), true);
                };

                contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
                    var m1 = [
                        [m11, m12, 0],
                        [m21, m22, 0],
                        [dx, dy, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), true);

                };

                contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
                    var m = [
                        [m11, m12, 0],
                        [m21, m22, 0],
                        [dx, dy, 1]
                    ];

                    setM(this, m, true);
                };

                /**
                 * The text drawing function.
                 * The maxWidth argument isn't taken in account, since no browser supports
                 * it yet.
                 */
                contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
                    var m = this.m_,
                        delta = 1000,
                        left = 0,
                        right = delta,
                        offset = {
                            x: 0,
                            y: 0
                        },
                        lineStr = [];

                    var fontStyle = getComputedStyle(processFontStyle(this.font),
                        this.element_);

                    var fontStyleString = buildStyle(fontStyle);

                    var elementStyle = this.element_.currentStyle;
                    var textAlign = this.textAlign.toLowerCase();
                    switch (textAlign) {
                        case 'left':
                        case 'center':
                        case 'right':
                            break;
                        case 'end':
                            textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
                            break;
                        case 'start':
                            textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
                            break;
                        default:
                            textAlign = 'left';
                    }

                    // 1.75 is an arbitrary number, as there is no info about the text baseline
                    switch (this.textBaseline) {
                        case 'hanging':
                        case 'top':
                            offset.y = fontStyle.size / 1.75;
                            break;
                        case 'middle':
                            break;
                        default:
                        case null:
                        case 'alphabetic':
                        case 'ideographic':
                        case 'bottom':
                            offset.y = -fontStyle.size / 2.25;
                            break;
                    }

                    switch (textAlign) {
                        case 'right':
                            left = delta;
                            right = 0.05;
                            break;
                        case 'center':
                            left = right = delta / 2;
                            break;
                    }

                    var d = getCoords(this, x + offset.x, y + offset.y);

                    lineStr.push('<g_vml_:line from="', -left, ' 0" to="', right, ' 0.05" ',
                        ' coordsize="100 100" coordorigin="0 0"',
                        ' filled="', !stroke, '" stroked="', !!stroke,
                        '" style="position:absolute;width:1px;height:1px;">');

                    if (stroke) {
                        appendStroke(this, lineStr);
                    } else {
                        // TODO: Fix the min and max params.
                        appendFill(this, lineStr, {
                            x: -left,
                            y: 0
                        }, {
                            x: right,
                            y: fontStyle.size
                        });
                    }

                    var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' +
                        m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';

                    var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);

                    lineStr.push('<g_vml_:skew on="t" matrix="', skewM, '" ',
                        ' offset="', skewOffset, '" origin="', left, ' 0" />',
                        '<g_vml_:path textpathok="true" />',
                        '<g_vml_:textpath on="true" string="',
                        encodeHtmlAttribute(text),
                        '" style="v-text-align:', textAlign,
                        ';font:', encodeHtmlAttribute(fontStyleString),
                        '" /></g_vml_:line>');

                    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
                };

                contextPrototype.fillText = function(text, x, y, maxWidth) {
                    this.drawText_(text, x, y, maxWidth, false);
                };

                contextPrototype.strokeText = function(text, x, y, maxWidth) {
                    this.drawText_(text, x, y, maxWidth, true);
                };

                contextPrototype.measureText = function(text) {
                    if (!this.textMeasureEl_) {
                        var s = '<span style="position:absolute;' +
                            'top:-20000px;left:0;padding:0;margin:0;border:none;' +
                            'white-space:pre;"></span>';
                        this.element_.insertAdjacentHTML('beforeEnd', s);
                        this.textMeasureEl_ = this.element_.lastChild;
                    }
                    var doc = this.element_.ownerDocument;
                    this.textMeasureEl_.innerHTML = '';
                    try {
                        this.textMeasureEl_.style.font = this.font;
                    } catch (ex) {
                        // Ignore failures to set to invalid font.
                    }

                    // Don't use innerHTML or innerText because they allow markup/whitespace.
                    this.textMeasureEl_.appendChild(doc.createTextNode(text));
                    return {
                        width: this.textMeasureEl_.offsetWidth
                    };
                };

                /******** STUBS ********/
                contextPrototype.clip = function() {
                    // TODO: Implement
                };

                contextPrototype.arcTo = function() {
                    // TODO: Implement
                };

                contextPrototype.createPattern = function(image, repetition) {
                    return new CanvasPattern_(image, repetition);
                };

                // Gradient / Pattern Stubs
                function CanvasGradient_(aType) {
                    this.type_ = aType;
                    this.x0_ = 0;
                    this.y0_ = 0;
                    this.r0_ = 0;
                    this.x1_ = 0;
                    this.y1_ = 0;
                    this.r1_ = 0;
                    this.colors_ = [];
                }

                CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
                    aColor = processStyle(aColor);
                    this.colors_.push({
                        offset: aOffset,
                        color: aColor.color,
                        alpha: aColor.alpha
                    });
                };

                function CanvasPattern_(image, repetition) {
                    assertImageIsValid(image);
                    switch (repetition) {
                        case 'repeat':
                        case null:
                        case '':
                            this.repetition_ = 'repeat';
                            break
                        case 'repeat-x':
                        case 'repeat-y':
                        case 'no-repeat':
                            this.repetition_ = repetition;
                            break;
                        default:
                            throwException('SYNTAX_ERR');
                    }

                    this.src_ = image.src;
                    this.width_ = image.width;
                    this.height_ = image.height;
                }

                function throwException(s) {
                    throw new DOMException_(s);
                }

                function assertImageIsValid(img) {
                    if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
                        throwException('TYPE_MISMATCH_ERR');
                    }
                    if (img.readyState != 'complete') {
                        throwException('INVALID_STATE_ERR');
                    }
                }

                function DOMException_(s) {
                    this.code = this[s];
                    this.message = s + ': DOM Exception ' + this.code;
                }
                var p = DOMException_.prototype = new Error;
                p.INDEX_SIZE_ERR = 1;
                p.DOMSTRING_SIZE_ERR = 2;
                p.HIERARCHY_REQUEST_ERR = 3;
                p.WRONG_DOCUMENT_ERR = 4;
                p.INVALID_CHARACTER_ERR = 5;
                p.NO_DATA_ALLOWED_ERR = 6;
                p.NO_MODIFICATION_ALLOWED_ERR = 7;
                p.NOT_FOUND_ERR = 8;
                p.NOT_SUPPORTED_ERR = 9;
                p.INUSE_ATTRIBUTE_ERR = 10;
                p.INVALID_STATE_ERR = 11;
                p.SYNTAX_ERR = 12;
                p.INVALID_MODIFICATION_ERR = 13;
                p.NAMESPACE_ERR = 14;
                p.INVALID_ACCESS_ERR = 15;
                p.VALIDATION_ERR = 16;
                p.TYPE_MISMATCH_ERR = 17;

                // set up externs
                G_vmlCanvasManager = G_vmlCanvasManager_;
                CanvasRenderingContext2D = CanvasRenderingContext2D_;
                CanvasGradient = CanvasGradient_;
                CanvasPattern = CanvasPattern_;
                DOMException = DOMException_;
            })();

        } // if
        else { // make the canvas test simple by kener.linfeng@gmail.com
            G_vmlCanvasManager = false;
        }
        return G_vmlCanvasManager;
    });
    define('zrender/tool/matrix', [], function() {

        var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
        /**
         * 3x2矩阵操作类
         * @exports zrender/tool/matrix
         */
        var matrix = {
            /**
             * 创建一个单位矩阵
             * @return {Float32Array|Array.<number>}
             */
            create: function() {
                var out = new ArrayCtor(6);
                matrix.identity(out);

                return out;
            },
            /**
             * 设置矩阵为单位矩阵
             * @param {Float32Array|Array.<number>} out
             */
            identity: function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                out[4] = 0;
                out[5] = 0;
                return out;
            },
            /**
             * 复制矩阵
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} m
             */
            copy: function(out, m) {
                out[0] = m[0];
                out[1] = m[1];
                out[2] = m[2];
                out[3] = m[3];
                out[4] = m[4];
                out[5] = m[5];
                return out;
            },
            /**
             * 矩阵相乘
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} m1
             * @param {Float32Array|Array.<number>} m2
             */
            mul: function(out, m1, m2) {
                out[0] = m1[0] * m2[0] + m1[2] * m2[1];
                out[1] = m1[1] * m2[0] + m1[3] * m2[1];
                out[2] = m1[0] * m2[2] + m1[2] * m2[3];
                out[3] = m1[1] * m2[2] + m1[3] * m2[3];
                out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
                out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
                return out;
            },
            /**
             * 平移变换
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             * @param {Float32Array|Array.<number>} v
             */
            translate: function(out, a, v) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4] + v[0];
                out[5] = a[5] + v[1];
                return out;
            },
            /**
             * 旋转变换
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             * @param {number} rad
             */
            rotate: function(out, a, rad) {
                var aa = a[0];
                var ac = a[2];
                var atx = a[4];
                var ab = a[1];
                var ad = a[3];
                var aty = a[5];
                var st = Math.sin(rad);
                var ct = Math.cos(rad);

                out[0] = aa * ct + ab * st;
                out[1] = -aa * st + ab * ct;
                out[2] = ac * ct + ad * st;
                out[3] = -ac * st + ct * ad;
                out[4] = ct * atx + st * aty;
                out[5] = ct * aty - st * atx;
                return out;
            },
            /**
             * 缩放变换
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             * @param {Float32Array|Array.<number>} v
             */
            scale: function(out, a, v) {
                var vx = v[0];
                var vy = v[1];
                out[0] = a[0] * vx;
                out[1] = a[1] * vy;
                out[2] = a[2] * vx;
                out[3] = a[3] * vy;
                out[4] = a[4] * vx;
                out[5] = a[5] * vy;
                return out;
            },
            /**
             * 求逆矩阵
             * @param {Float32Array|Array.<number>} out
             * @param {Float32Array|Array.<number>} a
             */
            invert: function(out, a) {

                var aa = a[0];
                var ac = a[2];
                var atx = a[4];
                var ab = a[1];
                var ad = a[3];
                var aty = a[5];

                var det = aa * ad - ab * ac;
                if (!det) {
                    return null;
                }
                det = 1.0 / det;

                out[0] = ad * det;
                out[1] = -ab * det;
                out[2] = -ac * det;
                out[3] = aa * det;
                out[4] = (ac * aty - ad * atx) * det;
                out[5] = (ab * atx - aa * aty) * det;
                return out;
            }
        };

        return matrix;
    });
    define('zrender/tool/log', ['require', '../config'], function(require) {
        var config = require('../config');

        /**
         * @exports zrender/tool/log
         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
         */
        return function() {
            if (config.debugMode === 0) {
                return;
            } else if (config.debugMode == 1) {
                for (var k in arguments) {
                    throw new Error(arguments[k]);
                }
            } else if (config.debugMode > 1) {
                for (var k in arguments) {
                    console.log(arguments[k]);
                }
            }
        };

        /* for debug
        return function(mes) {
            document.getElementById('wrong-message').innerHTML =
                mes + ' ' + (new Date() - 0)
                + '<br/>' 
                + document.getElementById('wrong-message').innerHTML;
        };
        */
    });
    define('zrender/mixin/Transformable', ['require', '../tool/matrix', '../tool/vector'], function(require) {

        'use strict';

        var matrix = require('../tool/matrix');
        var vector = require('../tool/vector');
        var origin = [0, 0];

        var mTranslate = matrix.translate;

        var EPSILON = 5e-5;

        function isAroundZero(val) {
            return val > -EPSILON && val < EPSILON;
        }

        function isNotAroundZero(val) {
            return val > EPSILON || val < -EPSILON;
        }

        /**
         * @alias module:zrender/mixin/Transformable
         * @constructor
         */
        var Transformable = function() {

            if (!this.position) {
                /**
                 * 平移
                 * @type {Array.<number>}
                 * @default [0, 0]
                 */
                this.position = [0, 0];
            }
            if (typeof(this.rotation) == 'undefined') {
                /**
                 * 旋转，可以通过数组二三项指定旋转的原点
                 * @type {Array.<number>}
                 * @default [0, 0, 0]
                 */
                this.rotation = [0, 0, 0];
            }
            if (!this.scale) {
                /**
                 * 缩放，可以通过数组三四项指定缩放的原点
                 * @type {Array.<number>}
                 * @default [1, 1, 0, 0]
                 */
                this.scale = [1, 1, 0, 0];
            }

            this.needLocalTransform = false;

            /**
             * 是否有坐标变换
             * @type {boolean}
             * @readOnly
             */
            this.needTransform = false;
        };

        Transformable.prototype = {

            constructor: Transformable,

            updateNeedTransform: function() {
                this.needLocalTransform = isNotAroundZero(this.rotation[0]) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
            },

            /**
             * 判断是否需要有坐标变换，更新needTransform属性。
             * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
             */
            updateTransform: function() {

                this.updateNeedTransform();

                var parentHasTransform = this.parent && this.parent.needTransform;
                this.needTransform = this.needLocalTransform || parentHasTransform;

                if (!this.needTransform) {
                    return;
                }

                var m = this.transform || matrix.create();
                matrix.identity(m);

                if (this.needLocalTransform) {
                    var scale = this.scale;
                    if (
                        isNotAroundZero(scale[0]) || isNotAroundZero(scale[1])
                    ) {
                        origin[0] = -scale[2] || 0;
                        origin[1] = -scale[3] || 0;
                        var haveOrigin = isNotAroundZero(origin[0]) || isNotAroundZero(origin[1]);
                        if (haveOrigin) {
                            mTranslate(m, m, origin);
                        }
                        matrix.scale(m, m, scale);
                        if (haveOrigin) {
                            origin[0] = -origin[0];
                            origin[1] = -origin[1];
                            mTranslate(m, m, origin);
                        }
                    }

                    if (this.rotation instanceof Array) {
                        if (this.rotation[0] !== 0) {
                            origin[0] = -this.rotation[1] || 0;
                            origin[1] = -this.rotation[2] || 0;
                            var haveOrigin = isNotAroundZero(origin[0]) || isNotAroundZero(origin[1]);
                            if (haveOrigin) {
                                mTranslate(m, m, origin);
                            }
                            matrix.rotate(m, m, this.rotation[0]);
                            if (haveOrigin) {
                                origin[0] = -origin[0];
                                origin[1] = -origin[1];
                                mTranslate(m, m, origin);
                            }
                        }
                    } else {
                        if (this.rotation !== 0) {
                            matrix.rotate(m, m, this.rotation);
                        }
                    }

                    if (
                        isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1])
                    ) {
                        mTranslate(m, m, this.position);
                    }
                }

                // 应用父节点变换
                if (parentHasTransform) {
                    if (this.needLocalTransform) {
                        matrix.mul(m, this.parent.transform, m);
                    } else {
                        matrix.copy(m, this.parent.transform);
                    }
                }
                // 保存这个变换矩阵
                this.transform = m;

                this.invTransform = this.invTransform || matrix.create();
                matrix.invert(this.invTransform, m);
            },
            /**
             * 将自己的transform应用到context上
             * @param {Context2D} ctx
             */
            setTransform: function(ctx) {
                if (this.needTransform) {
                    var m = this.transform;
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
            },
            /**
             * 设置图形的朝向
             * @param  {Array.<number>|Float32Array} target
             * @method
             */
            lookAt: (function() {
                var v = vector.create();
                return function(target) {
                    if (!this.transform) {
                        this.transform = matrix.create();
                    }
                    var m = this.transform;
                    vector.sub(v, target, this.position);
                    if (isAroundZero(v[0]) && isAroundZero(v[1])) {
                        return;
                    }
                    vector.normalize(v, v);
                    var scale = this.scale;
                    // Y Axis
                    // TODO Scale origin ?
                    m[2] = v[0] * scale[1];
                    m[3] = v[1] * scale[1];
                    // X Axis
                    m[0] = v[1] * scale[0];
                    m[1] = -v[0] * scale[0];
                    // Position
                    m[4] = this.position[0];
                    m[5] = this.position[1];

                    this.decomposeTransform();
                };
            })(),
            /**
             * 分解`transform`矩阵到`position`, `rotation`, `scale`
             */
            decomposeTransform: function() {
                if (!this.transform) {
                    return;
                }
                var m = this.transform;
                var sx = m[0] * m[0] + m[1] * m[1];
                var position = this.position;
                var scale = this.scale;
                var rotation = this.rotation;
                if (isNotAroundZero(sx - 1)) {
                    sx = Math.sqrt(sx);
                }
                var sy = m[2] * m[2] + m[3] * m[3];
                if (isNotAroundZero(sy - 1)) {
                    sy = Math.sqrt(sy);
                }
                position[0] = m[4];
                position[1] = m[5];
                scale[0] = sx;
                scale[1] = sy;
                scale[2] = scale[3] = 0;
                rotation[0] = Math.atan2(-m[1] / sy, m[0] / sx);
                rotation[1] = rotation[2] = 0;
            },

            /**
             * 变换坐标位置到 shape 的局部坐标空间
             * @method
             * @param {number} x
             * @param {number} y
             * @return {Array.<number>}
             */
            transformCoordToLocal: function(x, y) {
                var v2 = [x, y];
                if (this.needTransform && this.invTransform) {
                    vector.applyTransform(v2, v2, this.invTransform);
                }
                return v2;
            }
        };

        return Transformable;
    });
    define('zrender/tool/guid', [], function() {
        var idStart = 0x0907;

        return function() {
            return 'zrender__' + (idStart++);
        };
    });
    define('zrender/mixin/Eventful', ['require'], function(require) {

        /**
         * 事件分发器
         * @alias module:zrender/mixin/Eventful
         * @constructor
         */
        var Eventful = function() {
            this._handlers = {};
        };
        /**
         * 单次触发绑定，dispatch后销毁
         * 
         * @param {string} event 事件名
         * @param {Function} handler 响应函数
         * @param {Object} context
         */
        Eventful.prototype.one = function(event, handler, context) {
            var _h = this._handlers;

            if (!handler || !event) {
                return this;
            }

            if (!_h[event]) {
                _h[event] = [];
            }

            _h[event].push({
                h: handler,
                one: true,
                ctx: context || this
            });

            return this;
        };

        /**
         * 绑定事件
         * @param {string} event 事件名
         * @param {Function} handler 事件处理函数
         * @param {Object} [context]
         */
        Eventful.prototype.bind = function(event, handler, context) {
            var _h = this._handlers;

            if (!handler || !event) {
                return this;
            }

            if (!_h[event]) {
                _h[event] = [];
            }

            _h[event].push({
                h: handler,
                one: false,
                ctx: context || this
            });

            return this;
        };

        /**
         * 解绑事件
         * @param {string} event 事件名
         * @param {Function} [handler] 事件处理函数
         */
        Eventful.prototype.unbind = function(event, handler) {
            var _h = this._handlers;

            if (!event) {
                this._handlers = {};
                return this;
            }

            if (handler) {
                if (_h[event]) {
                    var newList = [];
                    for (var i = 0, l = _h[event].length; i < l; i++) {
                        if (_h[event][i]['h'] != handler) {
                            newList.push(_h[event][i]);
                        }
                    }
                    _h[event] = newList;
                }

                if (_h[event] && _h[event].length === 0) {
                    delete _h[event];
                }
            } else {
                delete _h[event];
            }

            return this;
        };

        /**
         * 事件分发
         * 
         * @param {string} type 事件类型
         */
        Eventful.prototype.dispatch = function(type) {
            if (this._handlers[type]) {
                var args = arguments;
                var argLen = args.length;

                if (argLen > 3) {
                    args = Array.prototype.slice.call(args, 1);
                }

                var _h = this._handlers[type];
                var len = _h.length;
                for (var i = 0; i < len;) {
                    // Optimize advise from backbone
                    switch (argLen) {
                        case 1:
                            _h[i]['h'].call(_h[i]['ctx']);
                            break;
                        case 2:
                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
                            break;
                        case 3:
                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
                            break;
                        default:
                            // have more than 2 given arguments
                            _h[i]['h'].apply(_h[i]['ctx'], args);
                            break;
                    }

                    if (_h[i]['one']) {
                        _h.splice(i, 1);
                        len--;
                    } else {
                        i++;
                    }
                }
            }

            return this;
        };

        /**
         * 带有context的事件分发, 最后一个参数是事件回调的context
         * @param {string} type 事件类型
         */
        Eventful.prototype.dispatchWithContext = function(type) {
            if (this._handlers[type]) {
                var args = arguments;
                var argLen = args.length;

                if (argLen > 4) {
                    args = Array.prototype.slice.call(args, 1, args.length - 1);
                }
                var ctx = args[args.length - 1];

                var _h = this._handlers[type];
                var len = _h.length;
                for (var i = 0; i < len;) {
                    // Optimize advise from backbone
                    switch (argLen) {
                        case 1:
                            _h[i]['h'].call(ctx);
                            break;
                        case 2:
                            _h[i]['h'].call(ctx, args[1]);
                            break;
                        case 3:
                            _h[i]['h'].call(ctx, args[1], args[2]);
                            break;
                        default:
                            // have more than 2 given arguments
                            _h[i]['h'].apply(ctx, args);
                            break;
                    }

                    if (_h[i]['one']) {
                        _h.splice(i, 1);
                        len--;
                    } else {
                        i++;
                    }
                }
            }

            return this;
        };

        // 对象可以通过 onxxxx 绑定事件
        /**
         * @event module:zrender/mixin/Eventful#onclick
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#onmouseover
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#onmouseout
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#onmousemove
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#onmousewheel
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#onmousedown
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#onmouseup
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#ondragstart
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#ondragend
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#ondragenter
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#ondragleave
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#ondragover
         * @type {Function}
         * @default null
         */
        /**
         * @event module:zrender/mixin/Eventful#ondrop
         * @type {Function}
         * @default null
         */

        return Eventful;
    });
    define('echarts/util/ecAnimation', ['require', 'zrender/tool/util', 'zrender/tool/curve', 'zrender/shape/Polygon'], function(require) {
        var zrUtil = require('zrender/tool/util');
        var curveTool = require('zrender/tool/curve');

        /**
         * 折线型动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function pointList(zr, oldShape, newShape, duration, easing) {
            var newPointList = newShape.style.pointList;
            var newPointListLen = newPointList.length;
            var oldPointList;

            if (!oldShape) { // add
                oldPointList = [];
                if (newShape._orient != 'vertical') {
                    var y = newPointList[0][1];
                    for (var i = 0; i < newPointListLen; i++) {
                        oldPointList[i] = [newPointList[i][0], y];
                    }
                } else {
                    var x = newPointList[0][0];
                    for (var i = 0; i < newPointListLen; i++) {
                        oldPointList[i] = [x, newPointList[i][1]];
                    }
                }

                if (newShape.type == 'half-smooth-polygon') {
                    oldPointList[newPointListLen - 1] = zrUtil.clone(newPointList[newPointListLen - 1]);
                    oldPointList[newPointListLen - 2] = zrUtil.clone(newPointList[newPointListLen - 2]);
                }
                oldShape = {
                    style: {
                        pointList: oldPointList
                    }
                };
            }

            oldPointList = oldShape.style.pointList;
            var oldPointListLen = oldPointList.length;
            if (oldPointListLen == newPointListLen) {
                newShape.style.pointList = oldPointList;
            } else if (oldPointListLen < newPointListLen) {
                // 原来短，新的长，补全
                newShape.style.pointList = oldPointList.concat(newPointList.slice(oldPointListLen));
            } else {
                // 原来长，新的短，截断
                newShape.style.pointList = oldPointList.slice(0, newPointListLen);
            }

            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, 'style')
                .when(
                    duration, {
                        pointList: newPointList
                    }
                )
                .during(function() {
                    // Updating bezier points
                    if (newShape.updateControlPoints) {
                        newShape.updateControlPoints(newShape.style);
                    }
                })
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * 复制样式
         * 
         * @inner
         * @param {Object} target 目标对象
         * @param {Object} source 源对象
         * @param {...string} props 复制的属性列表
         */
        function cloneStyle(target, source) {
            var len = arguments.length;
            for (var i = 2; i < len; i++) {
                var prop = arguments[i];
                target.style[prop] = source.style[prop];
            }
        }

        /**
         * 方型动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function rectangle(zr, oldShape, newShape, duration, easing) {
            var newShapeStyle = newShape.style;
            if (!oldShape) { // add
                oldShape = {
                    position: newShape.position,
                    style: {
                        x: newShapeStyle.x,
                        y: newShape._orient == 'vertical' ? newShapeStyle.y + newShapeStyle.height : newShapeStyle.y,
                        width: newShape._orient == 'vertical' ? newShapeStyle.width : 0,
                        height: newShape._orient != 'vertical' ? newShapeStyle.height : 0
                    }
                };
            }

            var newX = newShapeStyle.x;
            var newY = newShapeStyle.y;
            var newWidth = newShapeStyle.width;
            var newHeight = newShapeStyle.height;
            var newPosition = [newShape.position[0], newShape.position[1]];
            cloneStyle(
                newShape, oldShape,
                'x', 'y', 'width', 'height'
            );
            newShape.position = oldShape.position;

            zr.addShape(newShape);
            if (newPosition[0] != oldShape.position[0] || newPosition[1] != oldShape.position[1]) {
                zr.animate(newShape.id, '')
                    .when(
                        duration, {
                            position: newPosition
                        }
                    )
                    .start(easing);
            }

            newShape.__animating = true;
            zr.animate(newShape.id, 'style')
                .when(
                    duration, {
                        x: newX,
                        y: newY,
                        width: newWidth,
                        height: newHeight
                    }
                )
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * 蜡烛动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function candle(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) { // add
                var y = newShape.style.y;
                oldShape = {
                    style: {
                        y: [y[0], y[0], y[0], y[0]]
                    }
                };
            }

            var newY = newShape.style.y;
            newShape.style.y = oldShape.style.y;
            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, 'style')
                .when(
                    duration, {
                        y: newY
                    }
                )
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * 环型动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function ring(zr, oldShape, newShape, duration, easing) {
            var x = newShape.style.x;
            var y = newShape.style.y;
            var r0 = newShape.style.r0;
            var r = newShape.style.r;

            newShape.__animating = true;

            if (newShape._animationAdd != 'r') {
                newShape.style.r0 = 0;
                newShape.style.r = 0;
                newShape.rotation = [Math.PI * 2, x, y];

                zr.addShape(newShape);
                zr.animate(newShape.id, 'style')
                    .when(
                        duration, {
                            r0: r0,
                            r: r
                        }
                    )
                    .done(function() {
                        newShape.__animating = false;
                    })
                    .start(easing);
                zr.animate(newShape.id, '')
                    .when(
                        duration, {
                            rotation: [0, x, y]
                        }
                    )
                    .start(easing);
            } else {
                newShape.style.r0 = newShape.style.r;

                zr.addShape(newShape);
                zr.animate(newShape.id, 'style')
                    .when(
                        duration, {
                            r0: r0
                        }
                    )
                    .done(function() {
                        newShape.__animating = false;
                    })
                    .start(easing);
            }
        }

        /**
         * 扇形动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function sector(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) { // add
                if (newShape._animationAdd != 'r') {
                    oldShape = {
                        style: {
                            startAngle: newShape.style.startAngle,
                            endAngle: newShape.style.startAngle
                        }
                    };
                } else {
                    oldShape = {
                        style: {
                            r0: newShape.style.r
                        }
                    };
                }
            }

            var startAngle = newShape.style.startAngle;
            var endAngle = newShape.style.endAngle;

            cloneStyle(
                newShape, oldShape,
                'startAngle', 'endAngle'
            );

            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, 'style')
                .when(
                    duration, {
                        startAngle: startAngle,
                        endAngle: endAngle
                    }
                )
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * 文本动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function text(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) { // add
                oldShape = {
                    style: {
                        x: newShape.style.textAlign == 'left' ? newShape.style.x + 100 : newShape.style.x - 100,
                        y: newShape.style.y
                    }
                };
            }

            var x = newShape.style.x;
            var y = newShape.style.y;

            cloneStyle(
                newShape, oldShape,
                'x', 'y'
            );

            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, 'style')
                .when(
                    duration, {
                        x: x,
                        y: y
                    }
                )
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * 多边形动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function polygon(zr, oldShape, newShape, duration, easing) {
            var rect = require('zrender/shape/Polygon').prototype.getRect(newShape.style);
            var x = rect.x + rect.width / 2;
            var y = rect.y + rect.height / 2;

            newShape.scale = [0.1, 0.1, x, y];
            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, '')
                .when(
                    duration, {
                        scale: [1, 1, x, y]
                    }
                )
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * 和弦动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function ribbon(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) { // add
                oldShape = {
                    style: {
                        source0: 0,
                        source1: newShape.style.source1 > 0 ? 360 : -360,
                        target0: 0,
                        target1: newShape.style.target1 > 0 ? 360 : -360
                    }
                };
            }

            var source0 = newShape.style.source0;
            var source1 = newShape.style.source1;
            var target0 = newShape.style.target0;
            var target1 = newShape.style.target1;

            if (oldShape.style) {
                cloneStyle(
                    newShape, oldShape,
                    'source0', 'source1', 'target0', 'target1'
                );
            }

            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, 'style')
                .when(
                    duration, {
                        source0: source0,
                        source1: source1,
                        target0: target0,
                        target1: target1
                    }
                )
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * gaugePointer动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function gaugePointer(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) { // add
                oldShape = {
                    style: {
                        angle: newShape.style.startAngle
                    }
                };
            }

            var angle = newShape.style.angle;
            newShape.style.angle = oldShape.style.angle;
            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, 'style')
                .when(
                    duration, {
                        angle: angle
                    }
                )
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * icon动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function icon(zr, oldShape, newShape, duration, easing, delay) {
            // 避免markPoint特效取值在动画帧上
            newShape.style._x = newShape.style.x;
            newShape.style._y = newShape.style.y;
            newShape.style._width = newShape.style.width;
            newShape.style._height = newShape.style.height;

            if (!oldShape) { // add
                var x = newShape._x || 0;
                var y = newShape._y || 0;
                newShape.scale = [0.01, 0.01, x, y];
                zr.addShape(newShape);
                newShape.__animating = true;
                zr.animate(newShape.id, '')
                    .delay(delay)
                    .when(
                        duration, {
                            scale: [1, 1, x, y]
                        }
                    )
                    .done(function() {
                        newShape.__animating = false;
                    })
                    .start(easing || 'QuinticOut');
            } else { // mod
                rectangle(zr, oldShape, newShape, duration, easing);
            }
        }

        /**
         * line动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function line(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) {
                oldShape = {
                    style: {
                        xStart: newShape.style.xStart,
                        yStart: newShape.style.yStart,
                        xEnd: newShape.style.xStart,
                        yEnd: newShape.style.yStart
                    }
                };
            }

            var xStart = newShape.style.xStart;
            var xEnd = newShape.style.xEnd;
            var yStart = newShape.style.yStart;
            var yEnd = newShape.style.yEnd;

            cloneStyle(
                newShape, oldShape,
                'xStart', 'xEnd', 'yStart', 'yEnd'
            );

            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, 'style')
                .when(
                    duration, {
                        xStart: xStart,
                        xEnd: xEnd,
                        yStart: yStart,
                        yEnd: yEnd
                    }
                )
                .done(function() {
                    newShape.__animating = false;
                })
                .start(easing);
        }

        /**
         * markline动画
         * 
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function markline(zr, oldShape, newShape, duration, easing) {
            easing = easing || 'QuinticOut';
            newShape.__animating = true;
            zr.addShape(newShape);
            var newShapeStyle = newShape.style;

            var animationDone = function() {
                newShape.__animating = false;
            };
            var x0 = newShapeStyle.xStart;
            var y0 = newShapeStyle.yStart;
            var x2 = newShapeStyle.xEnd;
            var y2 = newShapeStyle.yEnd;
            if (newShapeStyle.curveness > 0) {
                newShape.updatePoints(newShapeStyle);
                var obj = {
                    p: 0
                };
                var x1 = newShapeStyle.cpX1;
                var y1 = newShapeStyle.cpY1;
                var newXArr = [];
                var newYArr = [];
                var subdivide = curveTool.quadraticSubdivide;
                zr.animation.animate(obj)
                    .when(duration, {
                        p: 1
                    })
                    .during(function() {
                        // Calculate subdivided curve
                        subdivide(x0, x1, x2, obj.p, newXArr);
                        subdivide(y0, y1, y2, obj.p, newYArr);
                        newShapeStyle.cpX1 = newXArr[1];
                        newShapeStyle.cpY1 = newYArr[1];
                        newShapeStyle.xEnd = newXArr[2];
                        newShapeStyle.yEnd = newYArr[2];
                        zr.modShape(newShape);
                    })
                    .done(animationDone)
                    .start(easing);
            } else {
                zr.animate(newShape.id, 'style')
                    .when(0, {
                        xEnd: x0,
                        yEnd: y0
                    })
                    .when(duration, {
                        xEnd: x2,
                        yEnd: y2
                    })
                    .done(animationDone)
                    .start(easing);
            }
        }

        return {
            pointList: pointList,
            rectangle: rectangle,
            candle: candle,
            ring: ring,
            sector: sector,
            text: text,
            polygon: polygon,
            ribbon: ribbon,
            gaugePointer: gaugePointer,
            icon: icon,
            line: line,
            markline: markline
        };
    });
    define('zrender/tool/curve', ['require', './vector'], function(require) {

        var vector = require('./vector');

        'use strict';

        var EPSILON = 1e-4;

        var THREE_SQRT = Math.sqrt(3);
        var ONE_THIRD = 1 / 3;

        // 临时变量
        var _v0 = vector.create();
        var _v1 = vector.create();
        var _v2 = vector.create();
        // var _v3 = vector.create();

        function isAroundZero(val) {
            return val > -EPSILON && val < EPSILON;
        }

        function isNotAroundZero(val) {
            return val > EPSILON || val < -EPSILON;
        }
        /*
        function evalCubicCoeff(a, b, c, d, t) {
            return ((a * t + b) * t + c) * t + d;
        }
        */

        /** 
         * 计算三次贝塞尔值
         * @memberOf module:zrender/tool/curve
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} p3
         * @param  {number} t
         * @return {number}
         */
        function cubicAt(p0, p1, p2, p3, t) {
            var onet = 1 - t;
            return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
        }

        /** 
         * 计算三次贝塞尔导数值
         * @memberOf module:zrender/tool/curve
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} p3
         * @param  {number} t
         * @return {number}
         */
        function cubicDerivativeAt(p0, p1, p2, p3, t) {
            var onet = 1 - t;
            return 3 * (
                ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t
            );
        }

        /**
         * 计算三次贝塞尔方程根，使用盛金公式
         * @memberOf module:zrender/tool/curve
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} p3
         * @param  {number} val
         * @param  {Array.<number>} roots
         * @return {number} 有效根数目
         */
        function cubicRootAt(p0, p1, p2, p3, val, roots) {
            // Evaluate roots of cubic functions
            var a = p3 + 3 * (p1 - p2) - p0;
            var b = 3 * (p2 - p1 * 2 + p0);
            var c = 3 * (p1 - p0);
            var d = p0 - val;

            var A = b * b - 3 * a * c;
            var B = b * c - 9 * a * d;
            var C = c * c - 3 * b * d;

            var n = 0;

            if (isAroundZero(A) && isAroundZero(B)) {
                if (isAroundZero(b)) {
                    roots[0] = 0;
                } else {
                    var t1 = -c / b; //t1, t2, t3, b is not zero
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                }
            } else {
                var disc = B * B - 4 * A * C;

                if (isAroundZero(disc)) {
                    var K = B / A;
                    var t1 = -b / a + K; // t1, a is not zero
                    var t2 = -K / 2; // t2, t3
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                    if (t2 >= 0 && t2 <= 1) {
                        roots[n++] = t2;
                    }
                } else if (disc > 0) {
                    var discSqrt = Math.sqrt(disc);
                    var Y1 = A * b + 1.5 * a * (-B + discSqrt);
                    var Y2 = A * b + 1.5 * a * (-B - discSqrt);
                    if (Y1 < 0) {
                        Y1 = -Math.pow(-Y1, ONE_THIRD);
                    } else {
                        Y1 = Math.pow(Y1, ONE_THIRD);
                    }
                    if (Y2 < 0) {
                        Y2 = -Math.pow(-Y2, ONE_THIRD);
                    } else {
                        Y2 = Math.pow(Y2, ONE_THIRD);
                    }
                    var t1 = (-b - (Y1 + Y2)) / (3 * a);
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                } else {
                    var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));
                    var theta = Math.acos(T) / 3;
                    var ASqrt = Math.sqrt(A);
                    var tmp = Math.cos(theta);

                    var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
                    var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
                    var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                    if (t2 >= 0 && t2 <= 1) {
                        roots[n++] = t2;
                    }
                    if (t3 >= 0 && t3 <= 1) {
                        roots[n++] = t3;
                    }
                }
            }
            return n;
        }

        /**
         * 计算三次贝塞尔方程极限值的位置
         * @memberOf module:zrender/tool/curve
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} p3
         * @param  {Array.<number>} extrema
         * @return {number} 有效数目
         */
        function cubicExtrema(p0, p1, p2, p3, extrema) {
            var b = 6 * p2 - 12 * p1 + 6 * p0;
            var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
            var c = 3 * p1 - 3 * p0;

            var n = 0;
            if (isAroundZero(a)) {
                if (isNotAroundZero(b)) {
                    var t1 = -c / b;
                    if (t1 >= 0 && t1 <= 1) {
                        extrema[n++] = t1;
                    }
                }
            } else {
                var disc = b * b - 4 * a * c;
                if (isAroundZero(disc)) {
                    extrema[0] = -b / (2 * a);
                } else if (disc > 0) {
                    var discSqrt = Math.sqrt(disc);
                    var t1 = (-b + discSqrt) / (2 * a);
                    var t2 = (-b - discSqrt) / (2 * a);
                    if (t1 >= 0 && t1 <= 1) {
                        extrema[n++] = t1;
                    }
                    if (t2 >= 0 && t2 <= 1) {
                        extrema[n++] = t2;
                    }
                }
            }
            return n;
        }

        /**
         * 细分三次贝塞尔曲线
         * @memberOf module:zrender/tool/curve
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} p3
         * @param  {number} t
         * @param  {Array.<number>} out
         */
        function cubicSubdivide(p0, p1, p2, p3, t, out) {
            var p01 = (p1 - p0) * t + p0;
            var p12 = (p2 - p1) * t + p1;
            var p23 = (p3 - p2) * t + p2;

            var p012 = (p12 - p01) * t + p01;
            var p123 = (p23 - p12) * t + p12;

            var p0123 = (p123 - p012) * t + p012;
            // Seg0
            out[0] = p0;
            out[1] = p01;
            out[2] = p012;
            out[3] = p0123;
            // Seg1
            out[4] = p0123;
            out[5] = p123;
            out[6] = p23;
            out[7] = p3;
        }

        /**
         * 投射点到三次贝塞尔曲线上，返回投射距离。
         * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
         * @param {number} x0
         * @param {number} y0
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @param {number} x3
         * @param {number} y3
         * @param {number} x
         * @param {number} y
         * @param {Array.<number>} [out] 投射点
         * @return {number}
         */
        function cubicProjectPoint(
            x0, y0, x1, y1, x2, y2, x3, y3,
            x, y, out
        ) {
            // http://pomax.github.io/bezierinfo/#projections
            var t;
            var interval = 0.005;
            var d = Infinity;

            _v0[0] = x;
            _v0[1] = y;

            // 先粗略估计一下可能的最小距离的 t 值
            // PENDING
            for (var _t = 0; _t < 1; _t += 0.05) {
                _v1[0] = cubicAt(x0, x1, x2, x3, _t);
                _v1[1] = cubicAt(y0, y1, y2, y3, _t);
                var d1 = vector.distSquare(_v0, _v1);
                if (d1 < d) {
                    t = _t;
                    d = d1;
                }
            }
            d = Infinity;

            // At most 32 iteration
            for (var i = 0; i < 32; i++) {
                if (interval < EPSILON) {
                    break;
                }
                var prev = t - interval;
                var next = t + interval;
                // t - interval
                _v1[0] = cubicAt(x0, x1, x2, x3, prev);
                _v1[1] = cubicAt(y0, y1, y2, y3, prev);

                var d1 = vector.distSquare(_v1, _v0);

                if (prev >= 0 && d1 < d) {
                    t = prev;
                    d = d1;
                } else {
                    // t + interval
                    _v2[0] = cubicAt(x0, x1, x2, x3, next);
                    _v2[1] = cubicAt(y0, y1, y2, y3, next);
                    var d2 = vector.distSquare(_v2, _v0);

                    if (next <= 1 && d2 < d) {
                        t = next;
                        d = d2;
                    } else {
                        interval *= 0.5;
                    }
                }
            }
            // t
            if (out) {
                out[0] = cubicAt(x0, x1, x2, x3, t);
                out[1] = cubicAt(y0, y1, y2, y3, t);
            }
            // console.log(interval, i);
            return Math.sqrt(d);
        }

        /**
         * 计算二次方贝塞尔值
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} t
         * @return {number}
         */
        function quadraticAt(p0, p1, p2, t) {
            var onet = 1 - t;
            return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
        }

        /**
         * 计算二次方贝塞尔导数值
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} t
         * @return {number}
         */
        function quadraticDerivativeAt(p0, p1, p2, t) {
            return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
        }

        /**
         * 计算二次方贝塞尔方程根
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} t
         * @param  {Array.<number>} roots
         * @return {number} 有效根数目
         */
        function quadraticRootAt(p0, p1, p2, val, roots) {
            var a = p0 - 2 * p1 + p2;
            var b = 2 * (p1 - p0);
            var c = p0 - val;

            var n = 0;
            if (isAroundZero(a)) {
                if (isNotAroundZero(b)) {
                    var t1 = -c / b;
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                }
            } else {
                var disc = b * b - 4 * a * c;
                if (isAroundZero(disc)) {
                    var t1 = -b / (2 * a);
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                } else if (disc > 0) {
                    var discSqrt = Math.sqrt(disc);
                    var t1 = (-b + discSqrt) / (2 * a);
                    var t2 = (-b - discSqrt) / (2 * a);
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                    if (t2 >= 0 && t2 <= 1) {
                        roots[n++] = t2;
                    }
                }
            }
            return n;
        }

        /**
         * 计算二次贝塞尔方程极限值
         * @memberOf module:zrender/tool/curve
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @return {number}
         */
        function quadraticExtremum(p0, p1, p2) {
            var divider = p0 + p2 - 2 * p1;
            if (divider === 0) {
                // p1 is center of p0 and p2 
                return 0.5;
            } else {
                return (p0 - p1) / divider;
            }
        }

        /**
         * 细分二次贝塞尔曲线
         * @memberOf module:zrender/tool/curve
         * @param  {number} p0
         * @param  {number} p1
         * @param  {number} p2
         * @param  {number} t
         * @param  {Array.<number>} out
         */
        function quadraticSubdivide(p0, p1, p2, t, out) {
            var p01 = (p1 - p0) * t + p0;
            var p12 = (p2 - p1) * t + p1;
            var p012 = (p12 - p01) * t + p01;

            // Seg0
            out[0] = p0;
            out[1] = p01;
            out[2] = p012;

            // Seg1
            out[3] = p012;
            out[4] = p12;
            out[5] = p2;
        }

        /**
         * 投射点到二次贝塞尔曲线上，返回投射距离。
         * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
         * @param {number} x0
         * @param {number} y0
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @param {number} x
         * @param {number} y
         * @param {Array.<number>} out 投射点
         * @return {number}
         */
        function quadraticProjectPoint(
            x0, y0, x1, y1, x2, y2,
            x, y, out
        ) {
            // http://pomax.github.io/bezierinfo/#projections
            var t;
            var interval = 0.005;
            var d = Infinity;

            _v0[0] = x;
            _v0[1] = y;

            // 先粗略估计一下可能的最小距离的 t 值
            // PENDING
            for (var _t = 0; _t < 1; _t += 0.05) {
                _v1[0] = quadraticAt(x0, x1, x2, _t);
                _v1[1] = quadraticAt(y0, y1, y2, _t);
                var d1 = vector.distSquare(_v0, _v1);
                if (d1 < d) {
                    t = _t;
                    d = d1;
                }
            }
            d = Infinity;

            // At most 32 iteration
            for (var i = 0; i < 32; i++) {
                if (interval < EPSILON) {
                    break;
                }
                var prev = t - interval;
                var next = t + interval;
                // t - interval
                _v1[0] = quadraticAt(x0, x1, x2, prev);
                _v1[1] = quadraticAt(y0, y1, y2, prev);

                var d1 = vector.distSquare(_v1, _v0);

                if (prev >= 0 && d1 < d) {
                    t = prev;
                    d = d1;
                } else {
                    // t + interval
                    _v2[0] = quadraticAt(x0, x1, x2, next);
                    _v2[1] = quadraticAt(y0, y1, y2, next);
                    var d2 = vector.distSquare(_v2, _v0);
                    if (next <= 1 && d2 < d) {
                        t = next;
                        d = d2;
                    } else {
                        interval *= 0.5;
                    }
                }
            }
            // t
            if (out) {
                out[0] = quadraticAt(x0, x1, x2, t);
                out[1] = quadraticAt(y0, y1, y2, t);
            }
            // console.log(interval, i);
            return Math.sqrt(d);
        }

        return {

            cubicAt: cubicAt,

            cubicDerivativeAt: cubicDerivativeAt,

            cubicRootAt: cubicRootAt,

            cubicExtrema: cubicExtrema,

            cubicSubdivide: cubicSubdivide,

            cubicProjectPoint: cubicProjectPoint,

            quadraticAt: quadraticAt,

            quadraticDerivativeAt: quadraticDerivativeAt,

            quadraticRootAt: quadraticRootAt,

            quadraticExtremum: quadraticExtremum,

            quadraticSubdivide: quadraticSubdivide,

            quadraticProjectPoint: quadraticProjectPoint
        };
    });
    define('zrender/tool/vector', [], function() {
        var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;

        /**
         * @typedef {Float32Array|Array.<number>} Vector2
         */
        /**
         * 二维向量类
         * @exports zrender/tool/vector
         */
        var vector = {
            /**
             * 创建一个向量
             * @param {number} [x=0]
             * @param {number} [y=0]
             * @return {Vector2}
             */
            create: function(x, y) {
                var out = new ArrayCtor(2);
                out[0] = x || 0;
                out[1] = y || 0;
                return out;
            },

            /**
             * 复制向量数据
             * @param {Vector2} out
             * @param {Vector2} v
             * @return {Vector2}
             */
            copy: function(out, v) {
                out[0] = v[0];
                out[1] = v[1];
                return out;
            },

            /**
             * 克隆一个向量
             * @param {Vector2} v
             * @return {Vector2}
             */
            clone: function(v) {
                var out = new ArrayCtor(2);
                out[0] = v[0];
                out[1] = v[1];
                return out;
            },

            /**
             * 设置向量的两个项
             * @param {Vector2} out
             * @param {number} a
             * @param {number} b
             * @return {Vector2} 结果
             */
            set: function(out, a, b) {
                out[0] = a;
                out[1] = b;
                return out;
            },

            /**
             * 向量相加
             * @param {Vector2} out
             * @param {Vector2} v1
             * @param {Vector2} v2
             */
            add: function(out, v1, v2) {
                out[0] = v1[0] + v2[0];
                out[1] = v1[1] + v2[1];
                return out;
            },

            /**
             * 向量缩放后相加
             * @param {Vector2} out
             * @param {Vector2} v1
             * @param {Vector2} v2
             * @param {number} a
             */
            scaleAndAdd: function(out, v1, v2, a) {
                out[0] = v1[0] + v2[0] * a;
                out[1] = v1[1] + v2[1] * a;
                return out;
            },

            /**
             * 向量相减
             * @param {Vector2} out
             * @param {Vector2} v1
             * @param {Vector2} v2
             */
            sub: function(out, v1, v2) {
                out[0] = v1[0] - v2[0];
                out[1] = v1[1] - v2[1];
                return out;
            },

            /**
             * 向量长度
             * @param {Vector2} v
             * @return {number}
             */
            len: function(v) {
                return Math.sqrt(this.lenSquare(v));
            },

            /**
             * 向量长度平方
             * @param {Vector2} v
             * @return {number}
             */
            lenSquare: function(v) {
                return v[0] * v[0] + v[1] * v[1];
            },

            /**
             * 向量乘法
             * @param {Vector2} out
             * @param {Vector2} v1
             * @param {Vector2} v2
             */
            mul: function(out, v1, v2) {
                out[0] = v1[0] * v2[0];
                out[1] = v1[1] * v2[1];
                return out;
            },

            /**
             * 向量除法
             * @param {Vector2} out
             * @param {Vector2} v1
             * @param {Vector2} v2
             */
            div: function(out, v1, v2) {
                out[0] = v1[0] / v2[0];
                out[1] = v1[1] / v2[1];
                return out;
            },

            /**
             * 向量点乘
             * @param {Vector2} v1
             * @param {Vector2} v2
             * @return {number}
             */
            dot: function(v1, v2) {
                return v1[0] * v2[0] + v1[1] * v2[1];
            },

            /**
             * 向量缩放
             * @param {Vector2} out
             * @param {Vector2} v
             * @param {number} s
             */
            scale: function(out, v, s) {
                out[0] = v[0] * s;
                out[1] = v[1] * s;
                return out;
            },

            /**
             * 向量归一化
             * @param {Vector2} out
             * @param {Vector2} v
             */
            normalize: function(out, v) {
                var d = vector.len(v);
                if (d === 0) {
                    out[0] = 0;
                    out[1] = 0;
                } else {
                    out[0] = v[0] / d;
                    out[1] = v[1] / d;
                }
                return out;
            },

            /**
             * 计算向量间距离
             * @param {Vector2} v1
             * @param {Vector2} v2
             * @return {number}
             */
            distance: function(v1, v2) {
                return Math.sqrt(
                    (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1])
                );
            },

            /**
             * 向量距离平方
             * @param {Vector2} v1
             * @param {Vector2} v2
             * @return {number}
             */
            distanceSquare: function(v1, v2) {
                return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
            },

            /**
             * 求负向量
             * @param {Vector2} out
             * @param {Vector2} v
             */
            negate: function(out, v) {
                out[0] = -v[0];
                out[1] = -v[1];
                return out;
            },

            /**
             * 插值两个点
             * @param {Vector2} out
             * @param {Vector2} v1
             * @param {Vector2} v2
             * @param {number} t
             */
            lerp: function(out, v1, v2, t) {
                // var ax = v1[0];
                // var ay = v1[1];
                out[0] = v1[0] + t * (v2[0] - v1[0]);
                out[1] = v1[1] + t * (v2[1] - v1[1]);
                return out;
            },

            /**
             * 矩阵左乘向量
             * @param {Vector2} out
             * @param {Vector2} v
             * @param {Vector2} m
             */
            applyTransform: function(out, v, m) {
                var x = v[0];
                var y = v[1];
                out[0] = m[0] * x + m[2] * y + m[4];
                out[1] = m[1] * x + m[3] * y + m[5];
                return out;
            },
            /**
             * 求两个向量最小值
             * @param  {Vector2} out
             * @param  {Vector2} v1
             * @param  {Vector2} v2
             */
            min: function(out, v1, v2) {
                out[0] = Math.min(v1[0], v2[0]);
                out[1] = Math.min(v1[1], v2[1]);
                return out;
            },
            /**
             * 求两个向量最大值
             * @param  {Vector2} out
             * @param  {Vector2} v1
             * @param  {Vector2} v2
             */
            max: function(out, v1, v2) {
                out[0] = Math.max(v1[0], v2[0]);
                out[1] = Math.max(v1[1], v2[1]);
                return out;
            }
        };

        vector.length = vector.len;
        vector.lengthSquare = vector.lenSquare;
        vector.dist = vector.distance;
        vector.distSquare = vector.distanceSquare;

        return vector;
    });
    define('zrender/Painter', ['require', './config', './tool/util', './tool/log', './loadingEffect/Base', './Layer', './shape/Image'], function(require) {
        'use strict';

        var config = require('./config');
        var util = require('./tool/util');
        // var vec2 = require('./tool/vector');
        var log = require('./tool/log');
        // var matrix = require('./tool/matrix');
        var BaseLoadingEffect = require('./loadingEffect/Base');

        var Layer = require('./Layer');

        // 返回false的方法，用于避免页面被选中
        function returnFalse() {
            return false;
        }

        // 什么都不干的空方法
        function doNothing() {}

        function isLayerValid(layer) {
            if (!layer) {
                return false;
            }

            if (layer.isBuildin) {
                return true;
            }

            if (typeof(layer.resize) !== 'function' || typeof(layer.refresh) !== 'function') {
                return false;
            }

            return true;
        }

        /**
         * @alias module:zrender/Painter
         * @constructor
         * @param {HTMLElement} root 绘图容器
         * @param {module:zrender/Storage} storage
         */
        var Painter = function(root, storage) {
            /**
             * 绘图容器
             * @type {HTMLElement}
             */
            this.root = root;
            root.style['-webkit-tap-highlight-color'] = 'transparent';
            root.style['-webkit-user-select'] = 'none';
            root.style['user-select'] = 'none';
            root.style['-webkit-touch-callout'] = 'none';

            /**
             * @type {module:zrender/Storage}
             */
            this.storage = storage;

            root.innerHTML = '';
            this._width = this._getWidth(); // 宽，缓存记录
            this._height = this._getHeight(); // 高，缓存记录

            var domRoot = document.createElement('div');
            this._domRoot = domRoot;

            // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
            domRoot.style.position = 'relative';
            domRoot.style.overflow = 'hidden';
            domRoot.style.width = this._width + 'px';
            domRoot.style.height = this._height + 'px';
            root.appendChild(domRoot);

            this._layers = {};

            this._zlevelList = [];

            this._layerConfig = {};

            this._loadingEffect = new BaseLoadingEffect({});
            this.shapeToImage = this._createShapeToImageProcessor();

            // 创建各层canvas
            // 背景
            this._bgDom = document.createElement('div');
            this._bgDom.style.cssText = [
                'position:absolute;left:0px;top:0px;width:',
                this._width, 'px;height:', this._height + 'px;',
                '-webkit-user-select:none;user-select;none;',
                '-webkit-touch-callout:none;'
            ].join('');
            this._bgDom.setAttribute('data-zr-dom-id', 'bg');
            this._bgDom.className = config.elementClassName;

            domRoot.appendChild(this._bgDom);
            this._bgDom.onselectstart = returnFalse;

            // 高亮
            var hoverLayer = new Layer('_zrender_hover_', this);
            this._layers['hover'] = hoverLayer;
            domRoot.appendChild(hoverLayer.dom);
            hoverLayer.initContext();

            hoverLayer.dom.onselectstart = returnFalse;
            hoverLayer.dom.style['-webkit-user-select'] = 'none';
            hoverLayer.dom.style['user-select'] = 'none';
            hoverLayer.dom.style['-webkit-touch-callout'] = 'none';

            // Will be injected by zrender instance
            this.refreshNextFrame = null;
        };

        /**
         * 首次绘图，创建各种dom和context
         * 
         * @param {Function} callback 绘画结束后的回调函数
         */
        Painter.prototype.render = function(callback) {
            if (this.isLoading()) {
                this.hideLoading();
            }
            // TODO
            this.refresh(callback, true);

            return this;
        };

        /**
         * 刷新
         * @param {Function} callback 刷新结束后的回调函数
         * @param {boolean} paintAll 强制绘制所有shape
         */
        Painter.prototype.refresh = function(callback, paintAll) {
            var list = this.storage.getShapeList(true);
            this._paintList(list, paintAll);

            // Paint custum layers
            for (var i = 0; i < this._zlevelList.length; i++) {
                var z = this._zlevelList[i];
                var layer = this._layers[z];
                if (!layer.isBuildin && layer.refresh) {
                    layer.refresh();
                }
            }

            if (typeof callback == 'function') {
                callback();
            }

            return this;
        };

        Painter.prototype._preProcessLayer = function(layer) {
            layer.unusedCount++;
            layer.updateTransform();
        };

        Painter.prototype._postProcessLayer = function(layer) {
            layer.dirty = false;
            // 删除过期的层
            // PENDING
            // if (layer.unusedCount >= 500) {
            //     this.delLayer(z);
            // }
            if (layer.unusedCount == 1) {
                layer.clear();
            }
        };

        Painter.prototype._paintList = function(list, paintAll) {

            if (typeof(paintAll) == 'undefined') {
                paintAll = false;
            }

            this._updateLayerStatus(list);

            var currentLayer;
            var currentZLevel;
            var ctx;

            this.eachBuildinLayer(this._preProcessLayer);

            // var invTransform = [];

            for (var i = 0, l = list.length; i < l; i++) {
                var shape = list[i];

                // Change draw layer
                if (currentZLevel !== shape.zlevel) {
                    if (currentLayer) {
                        if (currentLayer.needTransform) {
                            ctx.restore();
                        }
                        ctx.flush && ctx.flush();
                    }

                    currentZLevel = shape.zlevel;
                    currentLayer = this.getLayer(currentZLevel);

                    if (!currentLayer.isBuildin) {
                        log(
                            'ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id
                        );
                    }

                    ctx = currentLayer.ctx;

                    // Reset the count
                    currentLayer.unusedCount = 0;

                    if (currentLayer.dirty || paintAll) {
                        currentLayer.clear();
                    }

                    if (currentLayer.needTransform) {
                        ctx.save();
                        currentLayer.setTransform(ctx);
                    }
                }

                if ((currentLayer.dirty || paintAll) && !shape.invisible) {
                    if (!shape.onbrush || (shape.onbrush && !shape.onbrush(ctx, false))) {
                        if (config.catchBrushException) {
                            try {
                                shape.brush(ctx, false, this.refreshNextFrame);
                            } catch (error) {
                                log(
                                    error,
                                    'brush error of ' + shape.type,
                                    shape
                                );
                            }
                        } else {
                            shape.brush(ctx, false, this.refreshNextFrame);
                        }
                    }
                }

                shape.__dirty = false;
            }

            if (currentLayer) {
                if (currentLayer.needTransform) {
                    ctx.restore();
                }
                ctx.flush && ctx.flush();
            }

            this.eachBuildinLayer(this._postProcessLayer);
        };

        /**
         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
         * @param {number} zlevel
         * @return {module:zrender/Layer}
         */
        Painter.prototype.getLayer = function(zlevel) {
            var layer = this._layers[zlevel];
            if (!layer) {
                // Create a new layer
                layer = new Layer(zlevel, this);
                layer.isBuildin = true;

                if (this._layerConfig[zlevel]) {
                    util.merge(layer, this._layerConfig[zlevel], true);
                }

                layer.updateTransform();

                this.insertLayer(zlevel, layer);

                // Context is created after dom inserted to document
                // Or excanvas will get 0px clientWidth and clientHeight
                layer.initContext();
            }

            return layer;
        };

        Painter.prototype.insertLayer = function(zlevel, layer) {
            if (this._layers[zlevel]) {
                log('ZLevel ' + zlevel + ' has been used already');
                return;
            }
            // Check if is a valid layer
            if (!isLayerValid(layer)) {
                log('Layer of zlevel ' + zlevel + ' is not valid');
                return;
            }

            var len = this._zlevelList.length;
            var prevLayer = null;
            var i = -1;
            if (len > 0 && zlevel > this._zlevelList[0]) {
                for (i = 0; i < len - 1; i++) {
                    if (
                        this._zlevelList[i] < zlevel && this._zlevelList[i + 1] > zlevel
                    ) {
                        break;
                    }
                }
                prevLayer = this._layers[this._zlevelList[i]];
            }
            this._zlevelList.splice(i + 1, 0, zlevel);

            var prevDom = prevLayer ? prevLayer.dom : this._bgDom;
            if (prevDom.nextSibling) {
                prevDom.parentNode.insertBefore(
                    layer.dom,
                    prevDom.nextSibling
                );
            } else {
                prevDom.parentNode.appendChild(layer.dom);
            }

            this._layers[zlevel] = layer;
        };

        // Iterate each layer
        Painter.prototype.eachLayer = function(cb, context) {
            for (var i = 0; i < this._zlevelList.length; i++) {
                var z = this._zlevelList[i];
                cb.call(context, this._layers[z], z);
            }
        };

        // Iterate each buildin layer
        Painter.prototype.eachBuildinLayer = function(cb, context) {
            for (var i = 0; i < this._zlevelList.length; i++) {
                var z = this._zlevelList[i];
                var layer = this._layers[z];
                if (layer.isBuildin) {
                    cb.call(context, layer, z);
                }
            }
        };

        // Iterate each other layer except buildin layer
        Painter.prototype.eachOtherLayer = function(cb, context) {
            for (var i = 0; i < this._zlevelList.length; i++) {
                var z = this._zlevelList[i];
                var layer = this._layers[z];
                if (!layer.isBuildin) {
                    cb.call(context, layer, z);
                }
            }
        };

        /**
         * 获取所有已创建的层
         * @param {Array.<module:zrender/Layer>} [prevLayer]
         */
        Painter.prototype.getLayers = function() {
            return this._layers;
        };

        Painter.prototype._updateLayerStatus = function(list) {

            var layers = this._layers;

            var elCounts = {};

            this.eachBuildinLayer(function(layer, z) {
                elCounts[z] = layer.elCount;
                layer.elCount = 0;
            });

            for (var i = 0, l = list.length; i < l; i++) {
                var shape = list[i];
                var zlevel = shape.zlevel;
                var layer = layers[zlevel];
                if (layer) {
                    layer.elCount++;
                    // 已经被标记为需要刷新
                    if (layer.dirty) {
                        continue;
                    }
                    layer.dirty = shape.__dirty;
                }
            }

            // 层中的元素数量有发生变化
            this.eachBuildinLayer(function(layer, z) {
                if (elCounts[z] !== layer.elCount) {
                    layer.dirty = true;
                }
            });
        };

        /**
         * 指定的图形列表
         * @param {Array.<module:zrender/shape/Base>} shapeList 需要更新的图形元素列表
         * @param {Function} [callback] 视图更新后回调函数
         */
        Painter.prototype.refreshShapes = function(shapeList, callback) {
            for (var i = 0, l = shapeList.length; i < l; i++) {
                var shape = shapeList[i];
                shape.modSelf();
            }

            this.refresh(callback);
            return this;
        };

        /**
         * 设置loading特效
         * 
         * @param {Object} loadingEffect loading特效
         * @return {Painter}
         */
        Painter.prototype.setLoadingEffect = function(loadingEffect) {
            this._loadingEffect = loadingEffect;
            return this;
        };

        /**
         * 清除hover层外所有内容
         */
        Painter.prototype.clear = function() {
            this.eachBuildinLayer(this._clearLayer);
            return this;
        };

        Painter.prototype._clearLayer = function(layer) {
            layer.clear();
        };

        /**
         * 修改指定zlevel的绘制参数
         * 
         * @param {string} zlevel
         * @param {Object} config 配置对象
         * @param {string} [config.clearColor=0] 每次清空画布的颜色
         * @param {string} [config.motionBlur=false] 是否开启动态模糊
         * @param {number} [config.lastFrameAlpha=0.7]
         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
         * @param {Array.<number>} [position] 层的平移
         * @param {Array.<number>} [rotation] 层的旋转
         * @param {Array.<number>} [scale] 层的缩放
         * @param {boolean} [zoomable=false] 层是否支持鼠标缩放操作
         * @param {boolean} [panable=false] 层是否支持鼠标平移操作
         */
        Painter.prototype.modLayer = function(zlevel, config) {
            if (config) {
                if (!this._layerConfig[zlevel]) {
                    this._layerConfig[zlevel] = config;
                } else {
                    util.merge(this._layerConfig[zlevel], config, true);
                }

                var layer = this._layers[zlevel];

                if (layer) {
                    util.merge(layer, this._layerConfig[zlevel], true);
                }
            }
        };

        /**
         * 删除指定层
         * @param {number} zlevel 层所在的zlevel
         */
        Painter.prototype.delLayer = function(zlevel) {
            var layer = this._layers[zlevel];
            if (!layer) {
                return;
            }
            // Save config
            this.modLayer(zlevel, {
                position: layer.position,
                rotation: layer.rotation,
                scale: layer.scale
            });
            layer.dom.parentNode.removeChild(layer.dom);
            delete this._layers[zlevel];

            this._zlevelList.splice(util.indexOf(this._zlevelList, zlevel), 1);
        };

        /**
         * 刷新hover层
         */
        Painter.prototype.refreshHover = function() {
            this.clearHover();
            var list = this.storage.getHoverShapes(true);
            for (var i = 0, l = list.length; i < l; i++) {
                this._brushHover(list[i]);
            }
            var ctx = this._layers.hover.ctx;
            ctx.flush && ctx.flush();

            this.storage.delHover();

            return this;
        };

        /**
         * 清除hover层所有内容
         */
        Painter.prototype.clearHover = function() {
            var hover = this._layers.hover;
            hover && hover.clear();

            return this;
        };

        /**
         * 显示loading
         * 
         * @param {Object=} loadingEffect loading效果对象
         */
        Painter.prototype.showLoading = function(loadingEffect) {
            this._loadingEffect && this._loadingEffect.stop();
            loadingEffect && this.setLoadingEffect(loadingEffect);
            this._loadingEffect.start(this);
            this.loading = true;

            return this;
        };

        /**
         * loading结束
         */
        Painter.prototype.hideLoading = function() {
            this._loadingEffect.stop();

            this.clearHover();
            this.loading = false;
            return this;
        };

        /**
         * loading结束判断
         */
        Painter.prototype.isLoading = function() {
            return this.loading;
        };

        /**
         * 区域大小变化后重绘
         */
        Painter.prototype.resize = function() {
            var domRoot = this._domRoot;
            domRoot.style.display = 'none';

            var width = this._getWidth();
            var height = this._getHeight();

            domRoot.style.display = '';

            // 优化没有实际改变的resize
            if (this._width != width || height != this._height) {
                this._width = width;
                this._height = height;

                domRoot.style.width = width + 'px';
                domRoot.style.height = height + 'px';

                for (var id in this._layers) {

                    this._layers[id].resize(width, height);
                }

                this.refresh(null, true);
            }

            return this;
        };

        /**
         * 清除单独的一个层
         * @param {number} zLevel
         */
        Painter.prototype.clearLayer = function(zLevel) {
            var layer = this._layers[zLevel];
            if (layer) {
                layer.clear();
            }
        };

        /**
         * 释放
         */
        Painter.prototype.dispose = function() {
            if (this.isLoading()) {
                this.hideLoading();
            }

            this.root.innerHTML = '';

            this.root =
                this.storage =

                this._domRoot =
                this._layers = null;
        };

        Painter.prototype.getDomHover = function() {
            return this._layers.hover.dom;
        };

        /**
         * 图像导出
         * @param {string} type
         * @param {string} [backgroundColor='#fff'] 背景色
         * @return {string} 图片的Base64 url
         */
        Painter.prototype.toDataURL = function(type, backgroundColor, args) {
            if (window['G_vmlCanvasManager']) {
                return null;
            }

            var imageLayer = new Layer('image', this);
            this._bgDom.appendChild(imageLayer.dom);
            imageLayer.initContext();

            var ctx = imageLayer.ctx;
            imageLayer.clearColor = backgroundColor || '#fff';
            imageLayer.clear();

            var self = this;
            // 升序遍历，shape上的zlevel指定绘画图层的z轴层叠

            this.storage.iterShape(
                function(shape) {
                    if (!shape.invisible) {
                        if (!shape.onbrush // 没有onbrush
                            // 有onbrush并且调用执行返回false或undefined则继续粉刷
                            || (shape.onbrush && !shape.onbrush(ctx, false))
                        ) {
                            if (config.catchBrushException) {
                                try {
                                    shape.brush(ctx, false, self.refreshNextFrame);
                                } catch (error) {
                                    log(
                                        error,
                                        'brush error of ' + shape.type,
                                        shape
                                    );
                                }
                            } else {
                                shape.brush(ctx, false, self.refreshNextFrame);
                            }
                        }
                    }
                }, {
                    normal: 'up',
                    update: true
                }
            );
            var image = imageLayer.dom.toDataURL(type, args);
            ctx = null;
            this._bgDom.removeChild(imageLayer.dom);
            return image;
        };

        /**
         * 获取绘图区域宽度
         */
        Painter.prototype.getWidth = function() {
            return this._width;
        };

        /**
         * 获取绘图区域高度
         */
        Painter.prototype.getHeight = function() {
            return this._height;
        };

        Painter.prototype._getWidth = function() {
            var root = this.root;
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);

            return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) // 请原谅我这比较粗暴
                - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
        };

        Painter.prototype._getHeight = function() {
            var root = this.root;
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);

            return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) // 请原谅我这比较粗暴
                - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
        };

        Painter.prototype._brushHover = function(shape) {
            var ctx = this._layers.hover.ctx;

            if (!shape.onbrush // 没有onbrush
                // 有onbrush并且调用执行返回false或undefined则继续粉刷
                || (shape.onbrush && !shape.onbrush(ctx, true))
            ) {
                var layer = this.getLayer(shape.zlevel);
                if (layer.needTransform) {
                    ctx.save();
                    layer.setTransform(ctx);
                }
                // Retina 优化
                if (config.catchBrushException) {
                    try {
                        shape.brush(ctx, true, this.refreshNextFrame);
                    } catch (error) {
                        log(
                            error, 'hoverBrush error of ' + shape.type, shape
                        );
                    }
                } else {
                    shape.brush(ctx, true, this.refreshNextFrame);
                }
                if (layer.needTransform) {
                    ctx.restore();
                }
            }
        };

        Painter.prototype._shapeToImage = function(
            id, shape, width, height, devicePixelRatio
        ) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');

            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.setAttribute('width', width * devicePixelRatio);
            canvas.setAttribute('height', height * devicePixelRatio);

            ctx.clearRect(0, 0, width * devicePixelRatio, height * devicePixelRatio);

            var shapeTransform = {
                position: shape.position,
                rotation: shape.rotation,
                scale: shape.scale
            };
            shape.position = [0, 0, 0];
            shape.rotation = 0;
            shape.scale = [1, 1];
            if (shape) {
                shape.brush(ctx, false);
            }

            var ImageShape = require('./shape/Image');
            var imgShape = new ImageShape({
                id: id,
                style: {
                    x: 0,
                    y: 0,
                    image: canvas
                }
            });

            if (shapeTransform.position != null) {
                imgShape.position = shape.position = shapeTransform.position;
            }

            if (shapeTransform.rotation != null) {
                imgShape.rotation = shape.rotation = shapeTransform.rotation;
            }

            if (shapeTransform.scale != null) {
                imgShape.scale = shape.scale = shapeTransform.scale;
            }

            return imgShape;
        };

        Painter.prototype._createShapeToImageProcessor = function() {
            if (window['G_vmlCanvasManager']) {
                return doNothing;
            }

            var me = this;

            return function(id, e, width, height) {
                return me._shapeToImage(
                    id, e, width, height, config.devicePixelRatio
                );
            };
        };

        return Painter;
    });
    define('zrender/Storage', ['require', './tool/util', './Group'], function(require) {

        'use strict';

        var util = require('./tool/util');

        var Group = require('./Group');

        var defaultIterateOption = {
            hover: false,
            normal: 'down',
            update: false
        };

        function shapeCompareFunc(a, b) {
            if (a.zlevel == b.zlevel) {
                if (a.z == b.z) {
                    return a.__renderidx - b.__renderidx;
                }
                return a.z - b.z;
            }
            return a.zlevel - b.zlevel;
        }
        /**
         * 内容仓库 (M)
         * @alias module:zrender/Storage
         * @constructor
         */
        var Storage = function() {
            // 所有常规形状，id索引的map
            this._elements = {};

            // 高亮层形状，不稳定，动态增删，数组位置也是z轴方向，靠前显示在下方
            this._hoverElements = [];

            this._roots = [];

            this._shapeList = [];

            this._shapeListOffset = 0;
        };

        /**
         * 遍历迭代器
         * 
         * @param {Function} fun 迭代回调函数，return true终止迭代
         * @param {Object} [option] 迭代参数，缺省为仅降序遍历普通层图形
         * @param {boolean} [option.hover=true] 是否是高亮层图形
         * @param {string} [option.normal='up'] 是否是普通层图形，迭代时是否指定及z轴顺序
         * @param {boolean} [option.update=false] 是否在迭代前更新形状列表
         * 
         */
        Storage.prototype.iterShape = function(fun, option) {
            if (!option) {
                option = defaultIterateOption;
            }

            if (option.hover) {
                // 高亮层数据遍历
                for (var i = 0, l = this._hoverElements.length; i < l; i++) {
                    var el = this._hoverElements[i];
                    el.updateTransform();
                    if (fun(el)) {
                        return this;
                    }
                }
            }

            if (option.update) {
                this.updateShapeList();
            }

            // 遍历: 'down' | 'up'
            switch (option.normal) {
                case 'down':
                    // 降序遍历，高层优先
                    var l = this._shapeList.length;
                    while (l--) {
                        if (fun(this._shapeList[l])) {
                            return this;
                        }
                    }
                    break;
                    // case 'up':
                default:
                    // 升序遍历，底层优先
                    for (var i = 0, l = this._shapeList.length; i < l; i++) {
                        if (fun(this._shapeList[i])) {
                            return this;
                        }
                    }
                    break;
            }

            return this;
        };

        /**
         * 返回hover层的形状数组
         * @param  {boolean} [update=false] 是否在返回前更新图形的变换
         * @return {Array.<module:zrender/shape/Base>}
         */
        Storage.prototype.getHoverShapes = function(update) {
            // hoverConnect
            var hoverElements = [];
            for (var i = 0, l = this._hoverElements.length; i < l; i++) {
                hoverElements.push(this._hoverElements[i]);
                var target = this._hoverElements[i].hoverConnect;
                if (target) {
                    var shape;
                    target = target instanceof Array ? target : [target];
                    for (var j = 0, k = target.length; j < k; j++) {
                        shape = target[j].id ? target[j] : this.get(target[j]);
                        if (shape) {
                            hoverElements.push(shape);
                        }
                    }
                }
            }
            hoverElements.sort(shapeCompareFunc);
            if (update) {
                for (var i = 0, l = hoverElements.length; i < l; i++) {
                    hoverElements[i].updateTransform();
                }
            }
            return hoverElements;
        };

        /**
         * 返回所有图形的绘制队列
         * @param  {boolean} [update=false] 是否在返回前更新该数组
         * 详见{@link module:zrender/shape/Base.prototype.updateShapeList}
         * @return {Array.<module:zrender/shape/Base>}
         */
        Storage.prototype.getShapeList = function(update) {
            if (update) {
                this.updateShapeList();
            }
            return this._shapeList;
        };

        /**
         * 更新图形的绘制队列。
         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
         */
        Storage.prototype.updateShapeList = function() {
            this._shapeListOffset = 0;
            for (var i = 0, len = this._roots.length; i < len; i++) {
                var root = this._roots[i];
                this._updateAndAddShape(root);
            }
            this._shapeList.length = this._shapeListOffset;

            for (var i = 0, len = this._shapeList.length; i < len; i++) {
                this._shapeList[i].__renderidx = i;
            }

            this._shapeList.sort(shapeCompareFunc);
        };

        Storage.prototype._updateAndAddShape = function(el, clipShapes) {

            if (el.ignore) {
                return;
            }

            el.updateTransform();

            if (el.clipShape) {
                // clipShape 的变换是基于 group 的变换
                el.clipShape.parent = el;
                el.clipShape.updateTransform();

                // PENDING 效率影响
                if (clipShapes) {
                    clipShapes = clipShapes.slice();
                    clipShapes.push(el.clipShape);
                } else {
                    clipShapes = [el.clipShape];
                }
            }

            if (el.type == 'group') {

                for (var i = 0; i < el._children.length; i++) {
                    var child = el._children[i];

                    // Force to mark as dirty if group is dirty
                    child.__dirty = el.__dirty || child.__dirty;

                    this._updateAndAddShape(child, clipShapes);
                }

                // Mark group clean here
                el.__dirty = false;

            } else {
                el.__clipShapes = clipShapes;

                this._shapeList[this._shapeListOffset++] = el;
            }
        };

        /**
         * 修改图形(Shape)或者组(Group)
         * 
         * @param {string|module:zrender/shape/Base|module:zrender/Group} el
         * @param {Object} [params] 参数
         */
        Storage.prototype.mod = function(el, params) {
            if (typeof(el) === 'string') {
                el = this._elements[el];
            }
            if (el) {

                el.modSelf();

                if (params) {
                    // 如果第二个参数直接使用 shape
                    // parent, _storage, __clipShapes 三个属性会有循环引用
                    // 主要为了向 1.x 版本兼容，2.x 版本不建议使用第二个参数
                    if (params.parent || params._storage || params.__clipShapes) {
                        var target = {};
                        for (var name in params) {
                            if (
                                name === 'parent' || name === '_storage' || name === '__clipShapes'
                            ) {
                                continue;
                            }
                            if (params.hasOwnProperty(name)) {
                                target[name] = params[name];
                            }
                        }
                        util.merge(el, target, true);
                    } else {
                        util.merge(el, params, true);
                    }
                }
            }

            return this;
        };

        /**
         * 移动指定的图形(Shape)或者组(Group)的位置
         * @param {string} shapeId 形状唯一标识
         * @param {number} dx
         * @param {number} dy
         */
        Storage.prototype.drift = function(shapeId, dx, dy) {
            var shape = this._elements[shapeId];
            if (shape) {
                shape.needTransform = true;
                if (shape.draggable === 'horizontal') {
                    dy = 0;
                } else if (shape.draggable === 'vertical') {
                    dx = 0;
                }
                if (!shape.ondrift // ondrift
                    // 有onbrush并且调用执行返回false或undefined则继续
                    || (shape.ondrift && !shape.ondrift(dx, dy))
                ) {
                    shape.drift(dx, dy);
                }
            }

            return this;
        };

        /**
         * 添加高亮层数据
         * 
         * @param {module:zrender/shape/Base} shape
         */
        Storage.prototype.addHover = function(shape) {
            shape.updateNeedTransform();
            this._hoverElements.push(shape);
            return this;
        };

        /**
         * 清空高亮层数据
         */
        Storage.prototype.delHover = function() {
            this._hoverElements = [];
            return this;
        };

        /**
         * 是否有图形在高亮层里
         * @return {boolean}
         */
        Storage.prototype.hasHoverShape = function() {
            return this._hoverElements.length > 0;
        };

        /**
         * 添加图形(Shape)或者组(Group)到根节点
         * @param {module:zrender/shape/Shape|module:zrender/Group} el
         */
        Storage.prototype.addRoot = function(el) {
            // Element has been added
            if (this._elements[el.id]) {
                return;
            }

            if (el instanceof Group) {
                el.addChildrenToStorage(this);
            }

            this.addToMap(el);
            this._roots.push(el);
        };

        /**
         * 删除指定的图形(Shape)或者组(Group)
         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
         */
        Storage.prototype.delRoot = function(elId) {
            if (typeof(elId) == 'undefined') {
                // 不指定elId清空
                for (var i = 0; i < this._roots.length; i++) {
                    var root = this._roots[i];
                    if (root instanceof Group) {
                        root.delChildrenFromStorage(this);
                    }
                }

                this._elements = {};
                this._hoverElements = [];
                this._roots = [];
                this._shapeList = [];
                this._shapeListOffset = 0;

                return;
            }

            if (elId instanceof Array) {
                for (var i = 0, l = elId.length; i < l; i++) {
                    this.delRoot(elId[i]);
                }
                return;
            }

            var el;
            if (typeof(elId) == 'string') {
                el = this._elements[elId];
            } else {
                el = elId;
            }

            var idx = util.indexOf(this._roots, el);
            if (idx >= 0) {
                this.delFromMap(el.id);
                this._roots.splice(idx, 1);
                if (el instanceof Group) {
                    el.delChildrenFromStorage(this);
                }
            }
        };

        Storage.prototype.addToMap = function(el) {
            if (el instanceof Group) {
                el._storage = this;
            }
            el.modSelf();

            this._elements[el.id] = el;

            return this;
        };

        Storage.prototype.get = function(elId) {
            return this._elements[elId];
        };

        Storage.prototype.delFromMap = function(elId) {
            var el = this._elements[elId];
            if (el) {
                delete this._elements[elId];

                if (el instanceof Group) {
                    el._storage = null;
                }
            }

            return this;
        };

        /**
         * 清空并且释放Storage
         */
        Storage.prototype.dispose = function() {
            this._elements =
                this._renderList =
                this._roots =
                this._hoverElements = null;
        };

        return Storage;
    });
    define('zrender/Handler', ['require', './config', './tool/env', './tool/event', './tool/util', './tool/vector', './tool/matrix', './mixin/Eventful'], function(require) {

        'use strict';

        var config = require('./config');
        var env = require('./tool/env');
        var eventTool = require('./tool/event');
        var util = require('./tool/util');
        var vec2 = require('./tool/vector');
        var mat2d = require('./tool/matrix');
        var EVENT = config.EVENT;

        var Eventful = require('./mixin/Eventful');

        var domHandlerNames = [
            'resize', 'click', 'dblclick',
            'mousewheel', 'mousemove', 'mouseout', 'mouseup', 'mousedown',
            'touchstart', 'touchend', 'touchmove'
        ];

        var isZRenderElement = function(event) {
            // 暂时忽略 IE8-
            if (window.G_vmlCanvasManager) {
                return true;
            }

            event = event || window.event;

            // 进入对象优先~
            var target = event.toElement || event.relatedTarget || event.srcElement || event.target;

            return target && target.className.match(config.elementClassName)
        };

        var domHandlers = {
            /**
             * 窗口大小改变响应函数
             * @inner
             * @param {Event} event
             */
            resize: function(event) {
                event = event || window.event;
                this._lastHover = null;
                this._isMouseDown = 0;

                // 分发config.EVENT.RESIZE事件，global
                this.dispatch(EVENT.RESIZE, event);
            },

            /**
             * 点击响应函数
             * @inner
             * @param {Event} event
             */
            click: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                event = this._zrenderEventFixed(event);

                // 分发config.EVENT.CLICK事件
                var _lastHover = this._lastHover;
                if ((_lastHover && _lastHover.clickable) || !_lastHover) {

                    // 判断没有发生拖拽才触发click事件
                    if (this._clickThreshold < 5) {
                        this._dispatchAgency(_lastHover, EVENT.CLICK, event);
                    }
                }

                this._mousemoveHandler(event);
            },

            /**
             * 双击响应函数
             * @inner
             * @param {Event} event
             */
            dblclick: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                event = event || window.event;
                event = this._zrenderEventFixed(event);

                // 分发config.EVENT.DBLCLICK事件
                var _lastHover = this._lastHover;
                if ((_lastHover && _lastHover.clickable) || !_lastHover) {

                    // 判断没有发生拖拽才触发dblclick事件
                    if (this._clickThreshold < 5) {
                        this._dispatchAgency(_lastHover, EVENT.DBLCLICK, event);
                    }
                }

                this._mousemoveHandler(event);
            },


            /**
             * 鼠标滚轮响应函数
             * @inner
             * @param {Event} event
             */
            mousewheel: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                event = this._zrenderEventFixed(event);

                // http://www.sitepoint.com/html5-javascript-mouse-wheel/
                // https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/mousewheel
                var delta = event.wheelDelta // Webkit
                    || -event.detail; // Firefox
                var scale = delta > 0 ? 1.1 : 1 / 1.1;

                var needsRefresh = false;

                var mouseX = this._mouseX;
                var mouseY = this._mouseY;
                this.painter.eachBuildinLayer(function(layer) {
                    var pos = layer.position;
                    if (layer.zoomable) {
                        layer.__zoom = layer.__zoom || 1;
                        var newZoom = layer.__zoom;
                        newZoom *= scale;
                        newZoom = Math.max(
                            Math.min(layer.maxZoom, newZoom),
                            layer.minZoom
                        );
                        scale = newZoom / layer.__zoom;
                        layer.__zoom = newZoom;
                        // Keep the mouse center when scaling
                        pos[0] -= (mouseX - pos[0]) * (scale - 1);
                        pos[1] -= (mouseY - pos[1]) * (scale - 1);
                        layer.scale[0] *= scale;
                        layer.scale[1] *= scale;
                        layer.dirty = true;
                        needsRefresh = true;

                        // Prevent browser default scroll action 
                        eventTool.stop(event);
                    }
                });
                if (needsRefresh) {
                    this.painter.refresh();
                }

                // 分发config.EVENT.MOUSEWHEEL事件
                this._dispatchAgency(this._lastHover, EVENT.MOUSEWHEEL, event);
                this._mousemoveHandler(event);
            },

            /**
             * 鼠标（手指）移动响应函数
             * @inner
             * @param {Event} event
             */
            mousemove: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                if (this.painter.isLoading()) {
                    return;
                }

                event = this._zrenderEventFixed(event);
                this._lastX = this._mouseX;
                this._lastY = this._mouseY;
                this._mouseX = eventTool.getX(event);
                this._mouseY = eventTool.getY(event);
                var dx = this._mouseX - this._lastX;
                var dy = this._mouseY - this._lastY;

                // 可能出现config.EVENT.DRAGSTART事件
                // 避免手抖点击误认为拖拽
                // if (this._mouseX - this._lastX > 1 || this._mouseY - this._lastY > 1) {
                this._processDragStart(event);
                // }
                this._hasfound = 0;
                this._event = event;

                this._iterateAndFindHover();

                // 找到的在迭代函数里做了处理，没找到得在迭代完后处理
                if (!this._hasfound) {
                    // 过滤首次拖拽产生的mouseout和dragLeave
                    if (!this._draggingTarget || (this._lastHover && this._lastHover != this._draggingTarget)) {
                        // 可能出现config.EVENT.MOUSEOUT事件
                        this._processOutShape(event);

                        // 可能出现config.EVENT.DRAGLEAVE事件
                        this._processDragLeave(event);
                    }

                    this._lastHover = null;
                    this.storage.delHover();
                    this.painter.clearHover();
                }

                // set cursor for root element
                var cursor = 'default';

                // 如果存在拖拽中元素，被拖拽的图形元素最后addHover
                if (this._draggingTarget) {
                    this.storage.drift(this._draggingTarget.id, dx, dy);
                    this._draggingTarget.modSelf();
                    this.storage.addHover(this._draggingTarget);

                    // 拖拽不触发click事件
                    this._clickThreshold++;
                } else if (this._isMouseDown) {
                    var needsRefresh = false;
                    // Layer dragging
                    this.painter.eachBuildinLayer(function(layer) {
                        if (layer.panable) {
                            // PENDING
                            cursor = 'move';
                            // Keep the mouse center when scaling
                            layer.position[0] += dx;
                            layer.position[1] += dy;
                            needsRefresh = true;
                            layer.dirty = true;
                        }
                    });
                    if (needsRefresh) {
                        this.painter.refresh();
                    }
                }

                if (this._draggingTarget || (this._hasfound && this._lastHover.draggable)) {
                    cursor = 'move';
                } else if (this._hasfound && this._lastHover.clickable) {
                    cursor = 'pointer';
                }
                this.root.style.cursor = cursor;

                // 分发config.EVENT.MOUSEMOVE事件
                this._dispatchAgency(this._lastHover, EVENT.MOUSEMOVE, event);

                if (this._draggingTarget || this._hasfound || this.storage.hasHoverShape()) {
                    this.painter.refreshHover();
                }
            },

            /**
             * 鼠标（手指）离开响应函数
             * @inner
             * @param {Event} event
             */
            mouseout: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                event = this._zrenderEventFixed(event);

                var element = event.toElement || event.relatedTarget;
                if (element != this.root) {
                    while (element && element.nodeType != 9) {
                        // 忽略包含在root中的dom引起的mouseOut
                        if (element == this.root) {
                            this._mousemoveHandler(event);
                            return;
                        }

                        element = element.parentNode;
                    }
                }

                event.zrenderX = this._lastX;
                event.zrenderY = this._lastY;
                this.root.style.cursor = 'default';
                this._isMouseDown = 0;

                this._processOutShape(event);
                this._processDrop(event);
                this._processDragEnd(event);
                if (!this.painter.isLoading()) {
                    this.painter.refreshHover();
                }

                this.dispatch(EVENT.GLOBALOUT, event);
            },

            /**
             * 鼠标（手指）按下响应函数
             * @inner
             * @param {Event} event
             */
            mousedown: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                // 重置 clickThreshold
                this._clickThreshold = 0;

                if (this._lastDownButton == 2) {
                    this._lastDownButton = event.button;
                    this._mouseDownTarget = null;
                    // 仅作为关闭右键菜单使用
                    return;
                }

                this._lastMouseDownMoment = new Date();
                event = this._zrenderEventFixed(event);
                this._isMouseDown = 1;

                // 分发config.EVENT.MOUSEDOWN事件
                this._mouseDownTarget = this._lastHover;
                this._dispatchAgency(this._lastHover, EVENT.MOUSEDOWN, event);
                this._lastDownButton = event.button;
            },

            /**
             * 鼠标（手指）抬起响应函数
             * @inner
             * @param {Event} event
             */
            mouseup: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                event = this._zrenderEventFixed(event);
                this.root.style.cursor = 'default';
                this._isMouseDown = 0;
                this._mouseDownTarget = null;

                // 分发config.EVENT.MOUSEUP事件
                this._dispatchAgency(this._lastHover, EVENT.MOUSEUP, event);
                this._processDrop(event);
                this._processDragEnd(event);
            },

            /**
             * Touch开始响应函数
             * @inner
             * @param {Event} event
             */
            touchstart: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                // eventTool.stop(event);// 阻止浏览器默认事件，重要
                event = this._zrenderEventFixed(event, true);
                this._lastTouchMoment = new Date();

                // 平板补充一次findHover
                this._mobileFindFixed(event);
                this._mousedownHandler(event);
            },

            /**
             * Touch移动响应函数
             * @inner
             * @param {Event} event
             */
            touchmove: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                event = this._zrenderEventFixed(event, true);
                this._mousemoveHandler(event);
                if (this._isDragging) {
                    eventTool.stop(event); // 阻止浏览器默认事件，重要
                }
            },

            /**
             * Touch结束响应函数
             * @inner
             * @param {Event} event
             */
            touchend: function(event, manually) {
                if (!isZRenderElement(event) && !manually) {
                    return;
                }

                // eventTool.stop(event);// 阻止浏览器默认事件，重要
                event = this._zrenderEventFixed(event, true);
                this._mouseupHandler(event);

                var now = new Date();
                if (now - this._lastTouchMoment < EVENT.touchClickDelay) {
                    this._mobileFindFixed(event);
                    this._clickHandler(event);
                    if (now - this._lastClickMoment < EVENT.touchClickDelay / 2) {
                        this._dblclickHandler(event);
                        if (this._lastHover && this._lastHover.clickable) {
                            eventTool.stop(event); // 阻止浏览器默认事件，重要
                        }
                    }
                    this._lastClickMoment = now;
                }
                this.painter.clearHover();
            }
        };

        /**
         * bind一个参数的function
         * 
         * @inner
         * @param {Function} handler 要bind的function
         * @param {Object} context 运行时this环境
         * @return {Function}
         */
        // function bind1Arg(handler, context) {
        //     return function (e) {
        //         return handler.call(context, e);
        //     };
        // }
        function bind2Arg(handler, context) {
            return function(arg1, arg2) {
                return handler.call(context, arg1, arg2);
            };
        }

        function bind3Arg(handler, context) {
            return function(arg1, arg2, arg3) {
                return handler.call(context, arg1, arg2, arg3);
            };
        }
        /**
         * 为控制类实例初始化dom 事件处理函数
         * 
         * @inner
         * @param {module:zrender/Handler} instance 控制类实例
         */
        function initDomHandler(instance) {
            var len = domHandlerNames.length;
            while (len--) {
                var name = domHandlerNames[len];
                instance['_' + name + 'Handler'] = bind2Arg(domHandlers[name], instance);
            }
        }

        /**
         * @alias module:zrender/Handler
         * @constructor
         * @extends module:zrender/mixin/Eventful
         * @param {HTMLElement} root 绘图区域
         * @param {module:zrender/Storage} storage Storage实例
         * @param {module:zrender/Painter} painter Painter实例
         */
        var Handler = function(root, storage, painter) {
            // 添加事件分发器特性
            Eventful.call(this);

            this.root = root;
            this.storage = storage;
            this.painter = painter;

            // 各种事件标识的私有变量
            // this._hasfound = false;              //是否找到hover图形元素
            // this._lastHover = null;              //最后一个hover图形元素
            // this._mouseDownTarget = null;
            // this._draggingTarget = null;         //当前被拖拽的图形元素
            // this._isMouseDown = false;
            // this._isDragging = false;
            // this._lastMouseDownMoment;
            // this._lastTouchMoment;
            // this._lastDownButton;

            this._lastX =
                this._lastY =
                this._mouseX =
                this._mouseY = 0;

            this._findHover = bind3Arg(findHover, this);
            this._domHover = painter.getDomHover();
            initDomHandler(this);

            // 初始化，事件绑定，支持的所有事件都由如下原生事件计算得来
            if (window.addEventListener) {
                window.addEventListener('resize', this._resizeHandler);

                if (env.os.tablet || env.os.phone) {
                    // mobile支持
                    root.addEventListener('touchstart', this._touchstartHandler);
                    root.addEventListener('touchmove', this._touchmoveHandler);
                    root.addEventListener('touchend', this._touchendHandler);
                } else {
                    // mobile的click/move/up/down自己模拟
                    root.addEventListener('click', this._clickHandler);
                    root.addEventListener('dblclick', this._dblclickHandler);
                //    root.addEventListener('mousewheel', this._mousewheelHandler);
                    root.addEventListener('mousemove', this._mousemoveHandler);
                    root.addEventListener('mousedown', this._mousedownHandler);
                    root.addEventListener('mouseup', this._mouseupHandler);
                }
                root.addEventListener('DOMMouseScroll', this._mousewheelHandler);
                root.addEventListener('mouseout', this._mouseoutHandler);
            } else {
                window.attachEvent('onresize', this._resizeHandler);

                root.attachEvent('onclick', this._clickHandler);
                //root.attachEvent('ondblclick ', this._dblclickHandler);
                root.ondblclick = this._dblclickHandler;
                root.attachEvent('onmousewheel', this._mousewheelHandler);
                root.attachEvent('onmousemove', this._mousemoveHandler);
                root.attachEvent('onmouseout', this._mouseoutHandler);
                root.attachEvent('onmousedown', this._mousedownHandler);
                root.attachEvent('onmouseup', this._mouseupHandler);
            }
        };

        /**
         * 自定义事件绑定
         * @param {string} eventName 事件名称，resize，hover，drag，etc~
         * @param {Function} handler 响应函数
         * @param {Object} [context] 响应函数
         */
        Handler.prototype.on = function(eventName, handler, context) {
            this.bind(eventName, handler, context);
            return this;
        };

        /**
         * 自定义事件解绑
         * @param {string} eventName 事件名称，resize，hover，drag，etc~
         * @param {Function} handler 响应函数
         */
        Handler.prototype.un = function(eventName, handler) {
            this.unbind(eventName, handler);
            return this;
        };

        /**
         * 事件触发
         * @param {string} eventName 事件名称，resize，hover，drag，etc~
         * @param {event=} eventArgs event dom事件对象
         */
        Handler.prototype.trigger = function(eventName, eventArgs) {
            switch (eventName) {
                case EVENT.RESIZE:
                case EVENT.CLICK:
                case EVENT.DBLCLICK:
                case EVENT.MOUSEWHEEL:
                case EVENT.MOUSEMOVE:
                case EVENT.MOUSEDOWN:
                case EVENT.MOUSEUP:
                case EVENT.MOUSEOUT:
                    this['_' + eventName + 'Handler'](eventArgs, true);
                    break;
            }
        };

        /**
         * 释放，解绑所有事件
         */
        Handler.prototype.dispose = function() {
            var root = this.root;

            if (window.removeEventListener) {
                window.removeEventListener('resize', this._resizeHandler);

                if (env.os.tablet || env.os.phone) {
                    // mobile支持
                    root.removeEventListener('touchstart', this._touchstartHandler);
                    root.removeEventListener('touchmove', this._touchmoveHandler);
                    root.removeEventListener('touchend', this._touchendHandler);
                } else {
                    // mobile的click自己模拟
                    root.removeEventListener('click', this._clickHandler);
                    root.removeEventListener('dblclick', this._dblclickHandler);
                    root.removeEventListener('mousewheel', this._mousewheelHandler);
                    root.removeEventListener('mousemove', this._mousemoveHandler);
                    root.removeEventListener('mousedown', this._mousedownHandler);
                    root.removeEventListener('mouseup', this._mouseupHandler);
                }
                root.removeEventListener('DOMMouseScroll', this._mousewheelHandler);
                root.removeEventListener('mouseout', this._mouseoutHandler);
            } else {
                window.detachEvent('onresize', this._resizeHandler);

                root.detachEvent('onclick', this._clickHandler);
                root.detachEvent('dblclick', this._dblclickHandler);
                root.detachEvent('onmousewheel', this._mousewheelHandler);
                root.detachEvent('onmousemove', this._mousemoveHandler);
                root.detachEvent('onmouseout', this._mouseoutHandler);
                root.detachEvent('onmousedown', this._mousedownHandler);
                root.detachEvent('onmouseup', this._mouseupHandler);
            }

            this.root =
                this._domHover =
                this.storage =
                this.painter = null;

            this.un();
        };

        /**
         * 拖拽开始
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragStart = function(event) {
            var _lastHover = this._lastHover;

            if (this._isMouseDown && _lastHover && _lastHover.draggable && !this._draggingTarget && this._mouseDownTarget == _lastHover) {
                // 拖拽点击生效时长阀门，某些场景需要降低拖拽敏感度
                if (_lastHover.dragEnableTime &&
                    new Date() - this._lastMouseDownMoment < _lastHover.dragEnableTime
                ) {
                    return;
                }

                var _draggingTarget = _lastHover;
                this._draggingTarget = _draggingTarget;
                this._isDragging = 1;

                _draggingTarget.invisible = true;
                this.storage.mod(_draggingTarget.id);

                // 分发config.EVENT.DRAGSTART事件
                this._dispatchAgency(
                    _draggingTarget,
                    EVENT.DRAGSTART,
                    event
                );
                this.painter.refresh();
            }
        };

        /**
         * 拖拽进入目标元素
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragEnter = function(event) {
            if (this._draggingTarget) {
                // 分发config.EVENT.DRAGENTER事件
                this._dispatchAgency(
                    this._lastHover,
                    EVENT.DRAGENTER,
                    event,
                    this._draggingTarget
                );
            }
        };

        /**
         * 拖拽在目标元素上移动
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragOver = function(event) {
            if (this._draggingTarget) {
                // 分发config.EVENT.DRAGOVER事件
                this._dispatchAgency(
                    this._lastHover,
                    EVENT.DRAGOVER,
                    event,
                    this._draggingTarget
                );
            }
        };

        /**
         * 拖拽离开目标元素
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragLeave = function(event) {
            if (this._draggingTarget) {
                // 分发config.EVENT.DRAGLEAVE事件
                this._dispatchAgency(
                    this._lastHover,
                    EVENT.DRAGLEAVE,
                    event,
                    this._draggingTarget
                );
            }
        };

        /**
         * 拖拽在目标元素上完成
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDrop = function(event) {
            if (this._draggingTarget) {
                this._draggingTarget.invisible = false;
                this.storage.mod(this._draggingTarget.id);
                this.painter.refresh();

                // 分发config.EVENT.DROP事件
                this._dispatchAgency(
                    this._lastHover,
                    EVENT.DROP,
                    event,
                    this._draggingTarget
                );
            }
        };

        /**
         * 拖拽结束
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processDragEnd = function(event) {
            if (this._draggingTarget) {
                // 分发config.EVENT.DRAGEND事件
                this._dispatchAgency(
                    this._draggingTarget,
                    EVENT.DRAGEND,
                    event
                );

                this._lastHover = null;
            }

            this._isDragging = 0;
            this._draggingTarget = null;
        };

        /**
         * 鼠标在某个图形元素上移动
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processOverShape = function(event) {
            // 分发config.EVENT.MOUSEOVER事件
            this._dispatchAgency(this._lastHover, EVENT.MOUSEOVER, event);
        };

        /**
         * 鼠标离开某个图形元素
         * 
         * @private
         * @param {Object} event 事件对象
         */
        Handler.prototype._processOutShape = function(event) {
            // 分发config.EVENT.MOUSEOUT事件
            this._dispatchAgency(this._lastHover, EVENT.MOUSEOUT, event);
        };

        /**
         * 事件分发代理
         * 
         * @private
         * @param {Object} targetShape 目标图形元素
         * @param {string} eventName 事件名称
         * @param {Object} event 事件对象
         * @param {Object=} draggedShape 拖拽事件特有，当前被拖拽图形元素
         */
        Handler.prototype._dispatchAgency = function(targetShape, eventName, event, draggedShape) {
            var eventHandler = 'on' + eventName;
            var eventPacket = {
                type: eventName,
                event: event,
                target: targetShape,
                cancelBubble: false
            };

            var el = targetShape;

            if (draggedShape) {
                eventPacket.dragged = draggedShape;
            }

            while (el) {
                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler](eventPacket));
                el.dispatch(eventName, eventPacket);

                el = el.parent;

                if (eventPacket.cancelBubble) {
                    break;
                }
            }

            if (targetShape) {
                // 冒泡到顶级 zrender 对象
                if (!eventPacket.cancelBubble) {
                    this.dispatch(eventName, eventPacket);
                }
            } else if (!draggedShape) {
                // 无hover目标，无拖拽对象，原生事件分发
                var eveObj = {
                    type: eventName,
                    event: event
                };
                this.dispatch(eventName, eveObj);
                // 分发事件到用户自定义层
                this.painter.eachOtherLayer(function(layer) {
                    if (typeof(layer[eventHandler]) == 'function') {
                        layer[eventHandler](eveObj);
                    }
                    if (layer.dispatch) {
                        layer.dispatch(eventName, eveObj);
                    }
                });
            }
        };

        /**
         * 迭代寻找hover shape
         * @private
         * @method
         */
        Handler.prototype._iterateAndFindHover = (function() {
            var invTransform = mat2d.create();
            return function() {
                var list = this.storage.getShapeList();
                var currentZLevel;
                var currentLayer;
                var tmp = [0, 0];
                for (var i = list.length - 1; i >= 0; i--) {
                    var shape = list[i];

                    if (currentZLevel !== shape.zlevel) {
                        currentLayer = this.painter.getLayer(shape.zlevel, currentLayer);
                        tmp[0] = this._mouseX;
                        tmp[1] = this._mouseY;

                        if (currentLayer.needTransform) {
                            mat2d.invert(invTransform, currentLayer.transform);
                            vec2.applyTransform(tmp, tmp, invTransform);
                        }
                    }

                    if (this._findHover(shape, tmp[0], tmp[1])) {
                        break;
                    }
                }
            };
        })();

        // touch指尖错觉的尝试偏移量配置
        var MOBILE_TOUCH_OFFSETS = [{
            x: 10
        }, {
            x: -20
        }, {
            x: 10,
            y: 10
        }, {
            y: -20
        }];

        // touch有指尖错觉，四向尝试，让touch上的点击更好触发事件
        Handler.prototype._mobileFindFixed = function(event) {
            this._lastHover = null;
            this._mouseX = event.zrenderX;
            this._mouseY = event.zrenderY;

            this._event = event;

            this._iterateAndFindHover();
            for (var i = 0; !this._lastHover && i < MOBILE_TOUCH_OFFSETS.length; i++) {
                var offset = MOBILE_TOUCH_OFFSETS[i];
                offset.x && (this._mouseX += offset.x);
                offset.y && (this._mouseY += offset.y);

                this._iterateAndFindHover();
            }

            if (this._lastHover) {
                event.zrenderX = this._mouseX;
                event.zrenderY = this._mouseY;
            }
        };

        /**
         * 迭代函数，查找hover到的图形元素并即时做些事件分发
         * 
         * @inner
         * @param {Object} shape 图形元素
         * @param {number} x
         * @param {number} y
         */
        function findHover(shape, x, y) {
            if (
                (this._draggingTarget && this._draggingTarget.id == shape.id) // 迭代到当前拖拽的图形上
                || shape.isSilent() // 打酱油的路过，啥都不响应的shape~
            ) {
                return false;
            }

            var event = this._event;
            if (shape.isCover(x, y)) {
                if (shape.hoverable) {
                    this.storage.addHover(shape);
                }
                // 查找是否在 clipShape 中
                var p = shape.parent;
                while (p) {
                    if (p.clipShape && !p.clipShape.isCover(this._mouseX, this._mouseY)) {
                        // 已经被祖先 clip 掉了
                        return false;
                    }
                    p = p.parent;
                }

                if (this._lastHover != shape) {
                    this._processOutShape(event);

                    // 可能出现config.EVENT.DRAGLEAVE事件
                    this._processDragLeave(event);

                    this._lastHover = shape;

                    // 可能出现config.EVENT.DRAGENTER事件
                    this._processDragEnter(event);
                }

                this._processOverShape(event);

                // 可能出现config.EVENT.DRAGOVER
                this._processDragOver(event);

                this._hasfound = 1;

                return true; // 找到则中断迭代查找
            }

            return false;
        }

        /**
         * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
         * 
         * @private
         */
        Handler.prototype._zrenderEventFixed = function(event, isTouch) {
            if (event.zrenderFixed) {
                return event;
            }

            if (!isTouch) {
                event = event || window.event;
                // 进入对象优先~
                var target = event.toElement || event.relatedTarget || event.srcElement || event.target;

                if (target && target != this._domHover) {
                    event.zrenderX = (typeof event.offsetX != 'undefined' ? event.offsetX : event.layerX) + target.offsetLeft;
                    event.zrenderY = (typeof event.offsetY != 'undefined' ? event.offsetY : event.layerY) + target.offsetTop;
                }
            } else {
                var touch = event.type != 'touchend' ? event.targetTouches[0] : event.changedTouches[0];
                if (touch) {
                    var rBounding = this.painter._domRoot.getBoundingClientRect();
                    // touch事件坐标是全屏的~
                    event.zrenderX = touch.clientX - rBounding.left;
                    event.zrenderY = touch.clientY - rBounding.top;
                }
            }

            event.zrenderFixed = 1;
            return event;
        };

        util.merge(Handler.prototype, Eventful.prototype, true);

        return Handler;
    });
    define('zrender/animation/Animation', ['require', './Clip', '../tool/color', '../tool/util', '../tool/event'], function(require) {

        'use strict';

        var Clip = require('./Clip');
        var color = require('../tool/color');
        var util = require('../tool/util');
        var Dispatcher = require('../tool/event').Dispatcher;

        var requestAnimationFrame = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(func) {
            setTimeout(func, 16);
        };

        var arraySlice = Array.prototype.slice;

        /**
         * @typedef {Object} IZRenderStage
         * @property {Function} update
         */

        /** 
         * @alias module:zrender/animation/Animation
         * @constructor
         * @param {Object} [options]
         * @param {Function} [options.onframe]
         * @param {IZRenderStage} [options.stage]
         * @example
         *     var animation = new Animation();
         *     var obj = {
         *         x: 100,
         *         y: 100
         *     };
         *     animation.animate(node.position)
         *         .when(1000, {
         *             x: 500,
         *             y: 500
         *         })
         *         .when(2000, {
         *             x: 100,
         *             y: 100
         *         })
         *         .start('spline');
         */
        var Animation = function(options) {

            options = options || {};

            this.stage = options.stage || {};

            this.onframe = options.onframe || function() {};

            // private properties
            this._clips = [];

            this._running = false;

            this._time = 0;

            Dispatcher.call(this);
        };

        Animation.prototype = {
            /**
             * 添加动画片段
             * @param {module:zrender/animation/Clip} clip
             */
            add: function(clip) {
                this._clips.push(clip);
            },
            /**
             * 删除动画片段
             * @param {module:zrender/animation/Clip} clip
             */
            remove: function(clip) {
                if (clip.__inStep) {
                    // 如果是在 step 中，不能直接移除
                    // 需要标记为 needsRemove 然后在所有 clip step 完成后移除
                    clip.__needsRemove = true;
                } else {
                    var idx = util.indexOf(this._clips, clip);
                    if (idx >= 0) {
                        this._clips.splice(idx, 1);
                    }
                }
            },
            _update: function() {

                var time = new Date().getTime();
                var delta = time - this._time;
                var clips = this._clips;
                var len = clips.length;

                var deferredEvents = [];
                var deferredClips = [];
                for (var i = 0; i < len; i++) {
                    var clip = clips[i];
                    clip.__inStep = true;
                    var e = clip.step(time);
                    clip.__inStep = false;
                    // Throw out the events need to be called after
                    // stage.update, like destroy
                    if (e) {
                        deferredEvents.push(e);
                        deferredClips.push(clip);
                    }
                }

                // Remove the finished clip
                for (var i = 0; i < len;) {
                    if (clips[i].__needsRemove) {
                        clips[i] = clips[len - 1];
                        clips.pop();
                        len--;
                    } else {
                        i++;
                    }
                }

                len = deferredEvents.length;
                for (var i = 0; i < len; i++) {
                    deferredClips[i].fire(deferredEvents[i]);
                }

                this._time = time;

                this.onframe(delta);

                this.dispatch('frame', delta);

                if (this.stage.update) {
                    this.stage.update();
                }
            },
            /**
             * 开始运行动画
             */
            start: function() {
                var self = this;

                this._running = true;

                function step() {
                    if (self._running) {

                        requestAnimationFrame(step);

                        self._update();
                    }
                }

                this._time = new Date().getTime();
                requestAnimationFrame(step);
            },
            /**
             * 停止运行动画
             */
            stop: function() {
                this._running = false;
            },
            /**
             * 清除所有动画片段
             */
            clear: function() {
                this._clips = [];
            },
            /**
             * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
             * @param  {Object} target
             * @param  {Object} options
             * @param  {boolean} [options.loop=false] 是否循环播放动画
             * @param  {Function} [options.getter=null]
             *         如果指定getter函数，会通过getter函数取属性值
             * @param  {Function} [options.setter=null]
             *         如果指定setter函数，会通过setter函数设置属性值
             * @return {module:zrender/animation/Animation~Animator}
             */
            animate: function(target, options) {
                options = options || {};
                var deferred = new Animator(
                    target,
                    options.loop,
                    options.getter,
                    options.setter
                );
                deferred.animation = this;
                return deferred;
            },
            constructor: Animation
        };

        util.merge(Animation.prototype, Dispatcher.prototype, true);

        function _defaultGetter(target, key) {
            return target[key];
        }

        function _defaultSetter(target, key, value) {
            target[key] = value;
        }

        function _interpolateNumber(p0, p1, percent) {
            return (p1 - p0) * percent + p0;
        }

        function _interpolateArray(p0, p1, percent, out, arrDim) {
            var len = p0.length;
            if (arrDim == 1) {
                for (var i = 0; i < len; i++) {
                    out[i] = _interpolateNumber(p0[i], p1[i], percent);
                }
            } else {
                var len2 = p0[0].length;
                for (var i = 0; i < len; i++) {
                    for (var j = 0; j < len2; j++) {
                        out[i][j] = _interpolateNumber(
                            p0[i][j], p1[i][j], percent
                        );
                    }
                }
            }
        }

        function _isArrayLike(data) {
            switch (typeof data) {
                case 'undefined':
                case 'string':
                    return false;
            }

            return typeof data.length !== 'undefined';
        }

        function _catmullRomInterpolateArray(
            p0, p1, p2, p3, t, t2, t3, out, arrDim
        ) {
            var len = p0.length;
            if (arrDim == 1) {
                for (var i = 0; i < len; i++) {
                    out[i] = _catmullRomInterpolate(
                        p0[i], p1[i], p2[i], p3[i], t, t2, t3
                    );
                }
            } else {
                var len2 = p0[0].length;
                for (var i = 0; i < len; i++) {
                    for (var j = 0; j < len2; j++) {
                        out[i][j] = _catmullRomInterpolate(
                            p0[i][j], p1[i][j], p2[i][j], p3[i][j],
                            t, t2, t3
                        );
                    }
                }
            }
        }

        function _catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        }

        function _cloneValue(value) {
            if (_isArrayLike(value)) {
                var len = value.length;
                if (_isArrayLike(value[0])) {
                    var ret = [];
                    for (var i = 0; i < len; i++) {
                        ret.push(arraySlice.call(value[i]));
                    }
                    return ret;
                } else {
                    return arraySlice.call(value);
                }
            } else {
                return value;
            }
        }

        function rgba2String(rgba) {
            rgba[0] = Math.floor(rgba[0]);
            rgba[1] = Math.floor(rgba[1]);
            rgba[2] = Math.floor(rgba[2]);

            return 'rgba(' + rgba.join(',') + ')';
        }

        /**
         * @alias module:zrender/animation/Animation~Animator
         * @constructor
         * @param {Object} target
         * @param {boolean} loop
         * @param {Function} getter
         * @param {Function} setter
         */
        var Animator = function(target, loop, getter, setter) {
            this._tracks = {};
            this._target = target;

            this._loop = loop || false;

            this._getter = getter || _defaultGetter;
            this._setter = setter || _defaultSetter;

            this._clipCount = 0;

            this._delay = 0;

            this._doneList = [];

            this._onframeList = [];

            this._clipList = [];
        };

        Animator.prototype = {
            /**
             * 设置动画关键帧
             * @param  {number} time 关键帧时间，单位是ms
             * @param  {Object} props 关键帧的属性值，key-value表示
             * @return {module:zrender/animation/Animation~Animator}
             */
            when: function(time /* ms */ , props) {
                for (var propName in props) {
                    if (!this._tracks[propName]) {
                        this._tracks[propName] = [];
                        // If time is 0 
                        //  Then props is given initialize value
                        // Else
                        //  Initialize value from current prop value
                        if (time !== 0) {
                            this._tracks[propName].push({
                                time: 0,
                                value: _cloneValue(
                                    this._getter(this._target, propName)
                                )
                            });
                        }
                    }
                    this._tracks[propName].push({
                        time: parseInt(time, 10),
                        value: props[propName]
                    });
                }
                return this;
            },
            /**
             * 添加动画每一帧的回调函数
             * @param  {Function} callback
             * @return {module:zrender/animation/Animation~Animator}
             */
            during: function(callback) {
                this._onframeList.push(callback);
                return this;
            },
            /**
             * 开始执行动画
             * @param  {string|Function} easing 
             *         动画缓动函数，详见{@link module:zrender/animation/easing}
             * @return {module:zrender/animation/Animation~Animator}
             */
            start: function(easing) {

                var self = this;
                var setter = this._setter;
                var getter = this._getter;
                var useSpline = easing === 'spline';

                var ondestroy = function() {
                    self._clipCount--;
                    if (self._clipCount === 0) {
                        // Clear all tracks
                        self._tracks = {};

                        var len = self._doneList.length;
                        for (var i = 0; i < len; i++) {
                            self._doneList[i].call(self);
                        }
                    }
                };

                var createTrackClip = function(keyframes, propName) {
                    var trackLen = keyframes.length;
                    if (!trackLen) {
                        return;
                    }
                    // Guess data type
                    var firstVal = keyframes[0].value;
                    var isValueArray = _isArrayLike(firstVal);
                    var isValueColor = false;

                    // For vertices morphing
                    var arrDim = (
                        isValueArray && _isArrayLike(firstVal[0])
                    ) ? 2 : 1;
                    // Sort keyframe as ascending
                    keyframes.sort(function(a, b) {
                        return a.time - b.time;
                    });
                    var trackMaxTime;
                    if (trackLen) {
                        trackMaxTime = keyframes[trackLen - 1].time;
                    } else {
                        return;
                    }
                    // Percents of each keyframe
                    var kfPercents = [];
                    // Value of each keyframe
                    var kfValues = [];
                    for (var i = 0; i < trackLen; i++) {
                        kfPercents.push(keyframes[i].time / trackMaxTime);
                        // Assume value is a color when it is a string
                        var value = keyframes[i].value;
                        if (typeof(value) == 'string') {
                            value = color.toArray(value);
                            if (value.length === 0) { // Invalid color
                                value[0] = value[1] = value[2] = 0;
                                value[3] = 1;
                            }
                            isValueColor = true;
                        }
                        kfValues.push(value);
                    }

                    // Cache the key of last frame to speed up when 
                    // animation playback is sequency
                    var cacheKey = 0;
                    var cachePercent = 0;
                    var start;
                    var i;
                    var w;
                    var p0;
                    var p1;
                    var p2;
                    var p3;


                    if (isValueColor) {
                        var rgba = [0, 0, 0, 0];
                    }

                    var onframe = function(target, percent) {
                        // Find the range keyframes
                        // kf1-----kf2---------current--------kf3
                        // find kf2 and kf3 and do interpolation
                        if (percent < cachePercent) {
                            // Start from next key
                            start = Math.min(cacheKey + 1, trackLen - 1);
                            for (i = start; i >= 0; i--) {
                                if (kfPercents[i] <= percent) {
                                    break;
                                }
                            }
                            i = Math.min(i, trackLen - 2);
                        } else {
                            for (i = cacheKey; i < trackLen; i++) {
                                if (kfPercents[i] > percent) {
                                    break;
                                }
                            }
                            i = Math.min(i - 1, trackLen - 2);
                        }
                        cacheKey = i;
                        cachePercent = percent;

                        var range = (kfPercents[i + 1] - kfPercents[i]);
                        if (range === 0) {
                            return;
                        } else {
                            w = (percent - kfPercents[i]) / range;
                        }
                        if (useSpline) {
                            p1 = kfValues[i];
                            p0 = kfValues[i === 0 ? i : i - 1];
                            p2 = kfValues[i > trackLen - 2 ? trackLen - 1 : i + 1];
                            p3 = kfValues[i > trackLen - 3 ? trackLen - 1 : i + 2];
                            if (isValueArray) {
                                _catmullRomInterpolateArray(
                                    p0, p1, p2, p3, w, w * w, w * w * w,
                                    getter(target, propName),
                                    arrDim
                                );
                            } else {
                                var value;
                                if (isValueColor) {
                                    value = _catmullRomInterpolateArray(
                                        p0, p1, p2, p3, w, w * w, w * w * w,
                                        rgba, 1
                                    );
                                    value = rgba2String(rgba);
                                } else {
                                    value = _catmullRomInterpolate(
                                        p0, p1, p2, p3, w, w * w, w * w * w
                                    );
                                }
                                setter(
                                    target,
                                    propName,
                                    value
                                );
                            }
                        } else {
                            if (isValueArray) {
                                _interpolateArray(
                                    kfValues[i], kfValues[i + 1], w,
                                    getter(target, propName),
                                    arrDim
                                );
                            } else {
                                var value;
                                if (isValueColor) {
                                    _interpolateArray(
                                        kfValues[i], kfValues[i + 1], w,
                                        rgba, 1
                                    );
                                    value = rgba2String(rgba);
                                } else {
                                    value = _interpolateNumber(kfValues[i], kfValues[i + 1], w);
                                }
                                setter(
                                    target,
                                    propName,
                                    value
                                );
                            }
                        }

                        for (i = 0; i < self._onframeList.length; i++) {
                            self._onframeList[i](target, percent);
                        }
                    };

                    var clip = new Clip({
                        target: self._target,
                        life: trackMaxTime,
                        loop: self._loop,
                        delay: self._delay,
                        onframe: onframe,
                        ondestroy: ondestroy
                    });

                    if (easing && easing !== 'spline') {
                        clip.easing = easing;
                    }
                    self._clipList.push(clip);
                    self._clipCount++;
                    self.animation.add(clip);
                };

                for (var propName in this._tracks) {
                    createTrackClip(this._tracks[propName], propName);
                }
                return this;
            },
            /**
             * 停止动画
             */
            stop: function() {
                for (var i = 0; i < this._clipList.length; i++) {
                    var clip = this._clipList[i];
                    this.animation.remove(clip);
                }
                this._clipList = [];
            },
            /**
             * 设置动画延迟开始的时间
             * @param  {number} time 单位ms
             * @return {module:zrender/animation/Animation~Animator}
             */
            delay: function(time) {
                this._delay = time;
                return this;
            },
            /**
             * 添加动画结束的回调
             * @param  {Function} cb
             * @return {module:zrender/animation/Animation~Animator}
             */
            done: function(cb) {
                if (cb) {
                    this._doneList.push(cb);
                }
                return this;
            }
        };

        return Animation;
    });
    define('zrender/shape/Heart', ['require', './Base', './util/PathProxy', '../tool/area', '../tool/util'], function(require) {
        'use strict';

        var Base = require('./Base');
        var PathProxy = require('./util/PathProxy');
        var area = require('../tool/area');

        /**
         * @alias module:zrender/shape/Heart
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Heart = function(options) {
            Base.call(this, options);

            this._pathProxy = new PathProxy();
            /**
             * 心形绘制样式
             * @name module:zrender/shape/Heart#style
             * @type {module:zrender/shape/Heart~IHeartStyle}
             */
            /**
             * 心形高亮绘制样式
             * @name module:zrender/shape/Heart#highlightStyle
             * @type {module:zrender/shape/Heart~IHeartStyle}
             */
        };

        Heart.prototype = {
            type: 'heart',

            /**
             * 创建扇形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Heart~IHeartStyle} style
             */
            buildPath: function(ctx, style) {
                var path = this._pathProxy || new PathProxy();
                path.begin(ctx);

                path.moveTo(style.x, style.y);
                path.bezierCurveTo(
                    style.x + style.a / 2,
                    style.y - style.b * 2 / 3,
                    style.x + style.a * 2,
                    style.y + style.b / 3,
                    style.x,
                    style.y + style.b
                );
                path.bezierCurveTo(
                    style.x - style.a * 2,
                    style.y + style.b / 3,
                    style.x - style.a / 2,
                    style.y - style.b * 2 / 3,
                    style.x,
                    style.y
                );
                path.closePath();
                return;
            },

            /**
             * 计算返回心形的包围盒矩形
             * @param {module:zrender/shape/Heart~IHeartStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }
                if (!this._pathProxy.isEmpty()) {
                    this.buildPath(null, style);
                }
                return this._pathProxy.fastBoundingRect();
            },

            isCover: function(x, y) {
                var originPos = this.transformCoordToLocal(x, y);
                x = originPos[0];
                y = originPos[1];

                if (this.isCoverRect(x, y)) {
                    return area.isInsidePath(
                        this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y
                    );
                }
            }
        };

        require('../tool/util').inherits(Heart, Base);
        return Heart;
    });
    define('zrender/shape/Star', ['require', '../tool/math', './Base', '../tool/util'], function(require) {

        var math = require('../tool/math');
        var sin = math.sin;
        var cos = math.cos;
        var PI = Math.PI;

        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Star
         * @param {Object} options
         * @constructor
         * @extends module:zrender/shape/Base
         */
        var Star = function(options) {
            Base.call(this, options);
            /**
             * n角星绘制样式
             * @name module:zrender/shape/Star#style
             * @type {module:zrender/shape/Star~IStarStyle}
             */
            /**
             * n角星高亮绘制样式
             * @name module:zrender/shape/Star#highlightStyle
             * @type {module:zrender/shape/Star~IStarStyle}
             */
        };

        Star.prototype = {
            type: 'star',

            /**
             * 创建n角星（n>3）路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Star~IStarStyle} style
             */
            buildPath: function(ctx, style) {
                var n = style.n;
                if (!n || n < 2) {
                    return;
                }

                var x = style.x;
                var y = style.y;
                var r = style.r;
                var r0 = style.r0;

                // 如果未指定内部顶点外接圆半径，则自动计算
                if (r0 == null) {
                    r0 = n > 4
                        // 相隔的外部顶点的连线的交点，
                        // 被取为内部交点，以此计算r0
                        ? r * cos(2 * PI / n) / cos(PI / n)
                        // 二三四角星的特殊处理
                        : r / 3;
                }

                var dStep = PI / n;
                var deg = -PI / 2;
                var xStart = x + r * cos(deg);
                var yStart = y + r * sin(deg);
                deg += dStep;

                // 记录边界点，用于判断inside
                var pointList = style.pointList = [];
                pointList.push([xStart, yStart]);
                for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
                    ri = i % 2 === 0 ? r0 : r;
                    pointList.push([x + ri * cos(deg), y + ri * sin(deg)]);
                    deg += dStep;
                }
                pointList.push([xStart, yStart]);

                // 绘制
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                for (var i = 0; i < pointList.length; i++) {
                    ctx.lineTo(pointList[i][0], pointList[i][1]);
                }

                ctx.closePath();

                return;
            },

            /**
             * 返回n角星包围盒矩形
             * @param {module:zrender/shape/Star~IStarStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x: Math.round(style.x - style.r - lineWidth / 2),
                    y: Math.round(style.y - style.r - lineWidth / 2),
                    width: style.r * 2 + lineWidth,
                    height: style.r * 2 + lineWidth
                };

                return style.__rect;
            }
        };

        require('../tool/util').inherits(Star, Base);
        return Star;
    });
    define('zrender/shape/Droplet', ['require', './Base', './util/PathProxy', '../tool/area', '../tool/util'], function(require) {
        'use strict';

        var Base = require('./Base');
        var PathProxy = require('./util/PathProxy');
        var area = require('../tool/area');

        /**
         * @alias module:zrender/shape/Droplet
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Droplet = function(options) {
            Base.call(this, options);
            this._pathProxy = new PathProxy();
            /**
             * 水滴绘制样式
             * @name module:zrender/shape/Droplet#style
             * @type {module:zrender/shape/Droplet~IDropletStyle}
             */
            /**
             * 水滴高亮绘制样式
             * @name module:zrender/shape/Droplet#highlightStyle
             * @type {module:zrender/shape/Droplet~IDropletStyle}
             */
        };

        Droplet.prototype = {
            type: 'droplet',

            /**
             * 创建水滴路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Droplet~IDropletStyle} style
             */
            buildPath: function(ctx, style) {
                var path = this._pathProxy || new PathProxy();
                path.begin(ctx);

                path.moveTo(style.x, style.y + style.a);
                path.bezierCurveTo(
                    style.x + style.a,
                    style.y + style.a,
                    style.x + style.a * 3 / 2,
                    style.y - style.a / 3,
                    style.x,
                    style.y - style.b
                );
                path.bezierCurveTo(
                    style.x - style.a * 3 / 2,
                    style.y - style.a / 3,
                    style.x - style.a,
                    style.y + style.a,
                    style.x,
                    style.y + style.a
                );
                path.closePath();
            },

            /**
             * 计算返回水滴的包围盒矩形
             * @param {module:zrender/shape/Droplet~IDropletStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }
                if (!this._pathProxy.isEmpty()) {
                    this.buildPath(null, style);
                }
                return this._pathProxy.fastBoundingRect();
            },

            isCover: function(x, y) {
                var originPos = this.transformCoordToLocal(x, y);
                x = originPos[0];
                y = originPos[1];

                if (this.isCoverRect(x, y)) {
                    return area.isInsidePath(
                        this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y
                    );
                }
            }
        };

        require('../tool/util').inherits(Droplet, Base);
        return Droplet;
    });
    define('zrender/shape/util/smoothSpline', ['require', '../../tool/vector'], function(require) {
        var vector = require('../../tool/vector');

        /**
         * @inner
         */
        function interpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        }

        /**
         * @alias module:zrender/shape/util/smoothSpline
         * @param {Array} points 线段顶点数组
         * @param {boolean} isLoop
         * @param {Array} constraint 
         * @return {Array}
         */
        return function(points, isLoop, constraint) {
            var len = points.length;
            var ret = [];

            var distance = 0;
            for (var i = 1; i < len; i++) {
                distance += vector.distance(points[i - 1], points[i]);
            }

            var segs = distance / 5;
            segs = segs < len ? len : segs;
            for (var i = 0; i < segs; i++) {
                var pos = i / (segs - 1) * (isLoop ? len : len - 1);
                var idx = Math.floor(pos);

                var w = pos - idx;

                var p0;
                var p1 = points[idx % len];
                var p2;
                var p3;
                if (!isLoop) {
                    p0 = points[idx === 0 ? idx : idx - 1];
                    p2 = points[idx > len - 2 ? len - 1 : idx + 1];
                    p3 = points[idx > len - 3 ? len - 1 : idx + 2];
                } else {
                    p0 = points[(idx - 1 + len) % len];
                    p2 = points[(idx + 1) % len];
                    p3 = points[(idx + 2) % len];
                }

                var w2 = w * w;
                var w3 = w * w2;

                ret.push([
                    interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
                    interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
                ]);
            }
            return ret;
        };
    });
    define('zrender/shape/util/smoothBezier', ['require', '../../tool/vector'], function(require) {
        var vector = require('../../tool/vector');

        /**
         * 贝塞尔平滑曲线
         * @alias module:zrender/shape/util/smoothBezier
         * @param {Array} points 线段顶点数组
         * @param {number} smooth 平滑等级, 0-1
         * @param {boolean} isLoop
         * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
         *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
         *                           整个折线的包围盒做一个并集用来约束控制点。
         * @param {Array} 计算出来的控制点数组
         */
        return function(points, smooth, isLoop, constraint) {
            var cps = [];

            var v = [];
            var v1 = [];
            var v2 = [];
            var prevPoint;
            var nextPoint;

            var hasConstraint = !!constraint;
            var min, max;
            if (hasConstraint) {
                min = [Infinity, Infinity];
                max = [-Infinity, -Infinity];
                for (var i = 0, len = points.length; i < len; i++) {
                    vector.min(min, min, points[i]);
                    vector.max(max, max, points[i]);
                }
                // 与指定的包围盒做并集
                vector.min(min, min, constraint[0]);
                vector.max(max, max, constraint[1]);
            }

            for (var i = 0, len = points.length; i < len; i++) {
                var point = points[i];
                var prevPoint;
                var nextPoint;

                if (isLoop) {
                    prevPoint = points[i ? i - 1 : len - 1];
                    nextPoint = points[(i + 1) % len];
                } else {
                    if (i === 0 || i === len - 1) {
                        cps.push(vector.clone(points[i]));
                        continue;
                    } else {
                        prevPoint = points[i - 1];
                        nextPoint = points[i + 1];
                    }
                }

                vector.sub(v, nextPoint, prevPoint);

                // use degree to scale the handle length
                vector.scale(v, v, smooth);

                var d0 = vector.distance(point, prevPoint);
                var d1 = vector.distance(point, nextPoint);
                var sum = d0 + d1;
                if (sum !== 0) {
                    d0 /= sum;
                    d1 /= sum;
                }

                vector.scale(v1, v, -d0);
                vector.scale(v2, v, d1);
                var cp0 = vector.add([], point, v1);
                var cp1 = vector.add([], point, v2);
                if (hasConstraint) {
                    vector.max(cp0, cp0, min);
                    vector.min(cp0, cp0, max);
                    vector.max(cp1, cp1, min);
                    vector.min(cp1, cp1, max);
                }
                cps.push(cp0);
                cps.push(cp1);
            }

            if (isLoop) {
                cps.push(vector.clone(cps.shift()));
            }

            return cps;
        };
    });
    define('zrender/shape/util/dashedLineTo', [], function( /* require */ ) {

        var dashPattern = [5, 5];
        /**
         * 虚线lineTo 
         */
        return function(ctx, x1, y1, x2, y2, dashLength) {
            // http://msdn.microsoft.com/en-us/library/ie/dn265063(v=vs.85).aspx
            if (ctx.setLineDash) {
                dashPattern[0] = dashPattern[1] = dashLength;
                ctx.setLineDash(dashPattern);
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                return;
            }

            dashLength = typeof dashLength != 'number' ? 5 : dashLength;

            var dx = x2 - x1;
            var dy = y2 - y1;
            var numDashes = Math.floor(
                Math.sqrt(dx * dx + dy * dy) / dashLength
            );
            dx = dx / numDashes;
            dy = dy / numDashes;
            var flag = true;
            for (var i = 0; i < numDashes; ++i) {
                if (flag) {
                    ctx.moveTo(x1, y1);
                } else {
                    ctx.lineTo(x1, y1);
                }
                flag = !flag;
                x1 += dx;
                y1 += dy;
            }
            ctx.lineTo(x2, y2);
        };
    });
    define('zrender/loadingEffect/Base', ['require', '../tool/util', '../shape/Text', '../shape/Rectangle'], function(require) {
        var util = require('../tool/util');
        var TextShape = require('../shape/Text');
        var RectangleShape = require('../shape/Rectangle');


        var DEFAULT_TEXT = 'Loading...';
        var DEFAULT_TEXT_FONT = 'normal 16px Arial';

        /**
         * @constructor
         * 
         * @param {Object} options 选项
         * @param {color} options.backgroundColor 背景颜色
         * @param {Object} options.textStyle 文字样式，同shape/text.style
         * @param {number=} options.progress 进度参数，部分特效有用
         * @param {Object=} options.effect 特效参数，部分特效有用
         * 
         * {
         *     effect,
         *     //loading话术
         *     text:'',
         *     // 水平安放位置，默认为 'center'，可指定x坐标
         *     x:'center' || 'left' || 'right' || {number},
         *     // 垂直安放位置，默认为'top'，可指定y坐标
         *     y:'top' || 'bottom' || {number},
         *
         *     textStyle:{
         *         textFont: 'normal 20px Arial' || {textFont}, //文本字体
         *         color: {color}
         *     }
         * }
         */
        function Base(options) {
            this.setOptions(options);
        }

        /**
         * 创建loading文字图形
         * 
         * @param {Object} textStyle 文字style，同shape/text.style
         */
        Base.prototype.createTextShape = function(textStyle) {
            return new TextShape({
                highlightStyle: util.merge({
                        x: this.canvasWidth / 2,
                        y: this.canvasHeight / 2,
                        text: DEFAULT_TEXT,
                        textAlign: 'center',
                        textBaseline: 'middle',
                        textFont: DEFAULT_TEXT_FONT,
                        color: '#333',
                        brushType: 'fill'
                    },
                    textStyle,
                    true
                )
            });
        };

        /**
         * 获取loading背景图形
         * 
         * @param {color} color 背景颜色
         */
        Base.prototype.createBackgroundShape = function(color) {
            return new RectangleShape({
                highlightStyle: {
                    x: 0,
                    y: 0,
                    width: this.canvasWidth,
                    height: this.canvasHeight,
                    brushType: 'fill',
                    color: color
                }
            });
        };

        Base.prototype.start = function(painter) {
            this.canvasWidth = painter._width;
            this.canvasHeight = painter._height;

            function addShapeHandle(param) {
                painter.storage.addHover(param);
            }

            function refreshHandle() {
                painter.refreshHover();
            }
            this.loadingTimer = this._start(addShapeHandle, refreshHandle);
        };

        Base.prototype._start = function( /*addShapeHandle, refreshHandle*/ ) {
            return setInterval(function() {}, 10000);
        };

        Base.prototype.stop = function() {
            clearInterval(this.loadingTimer);
        };

        Base.prototype.setOptions = function(options) {
            this.options = options || {};
        };

        Base.prototype.adjust = function(value, region) {
            if (value <= region[0]) {
                value = region[0];
            } else if (value >= region[1]) {
                value = region[1];
            }
            return value;
        };

        Base.prototype.getLocation = function(loc, totalWidth, totalHeight) {
            var x = loc.x != null ? loc.x : 'center';
            switch (x) {
                case 'center':
                    x = Math.floor((this.canvasWidth - totalWidth) / 2);
                    break;
                case 'left':
                    x = 0;
                    break;
                case 'right':
                    x = this.canvasWidth - totalWidth;
                    break;
            }
            var y = loc.y != null ? loc.y : 'center';
            switch (y) {
                case 'center':
                    y = Math.floor((this.canvasHeight - totalHeight) / 2);
                    break;
                case 'top':
                    y = 0;
                    break;
                case 'bottom':
                    y = this.canvasHeight - totalHeight;
                    break;
            }
            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight
            };
        };

        return Base;
    });
    define('zrender/tool/math', [], function() {

        var _radians = Math.PI / 180;

        /**
         * @param {number} angle 弧度（角度）参数
         * @param {boolean} isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
         */
        function sin(angle, isDegrees) {
            return Math.sin(isDegrees ? angle * _radians : angle);
        }

        /**
         * @param {number} angle 弧度（角度）参数
         * @param {boolean} isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
         */
        function cos(angle, isDegrees) {
            return Math.cos(isDegrees ? angle * _radians : angle);
        }

        /**
         * 角度转弧度
         * @param {Object} angle
         */
        function degreeToRadian(angle) {
            return angle * _radians;
        }

        /**
         * 弧度转角度
         * @param {Object} angle
         */
        function radianToDegree(angle) {
            return angle / _radians;
        }

        return {
            sin: sin,
            cos: cos,
            degreeToRadian: degreeToRadian,
            radianToDegree: radianToDegree
        };
    });
    define('zrender/Layer', ['require', './mixin/Transformable', './tool/util', './config'], function(require) {

        var Transformable = require('./mixin/Transformable');
        var util = require('./tool/util');
        var vmlCanvasManager = window['G_vmlCanvasManager'];
        var config = require('./config');

        function returnFalse() {
            return false;
        }

        /**
         * 创建dom
         * 
         * @inner
         * @param {string} id dom id 待用
         * @param {string} type dom type，such as canvas, div etc.
         * @param {Painter} painter painter instance
         */
        function createDom(id, type, painter) {
            var newDom = document.createElement(type);
            var width = painter.getWidth();
            var height = painter.getHeight();

            // 没append呢，请原谅我这样写，清晰~
            newDom.style.position = 'absolute';
            newDom.style.left = 0;
            newDom.style.top = 0;
            newDom.style.width = width + 'px';
            newDom.style.height = height + 'px';
            newDom.width = width * config.devicePixelRatio;
            newDom.height = height * config.devicePixelRatio;

            // id不作为索引用，避免可能造成的重名，定义为私有属性
            newDom.setAttribute('data-zr-dom-id', id);
            return newDom;
        }

        /**
         * @alias module:zrender/Layer
         * @constructor
         * @extends module:zrender/mixin/Transformable
         * @param {string} id
         * @param {module:zrender/Painter} painter
         */
        var Layer = function(id, painter) {

            this.id = id;

            this.dom = createDom(id, 'canvas', painter);
            this.dom.onselectstart = returnFalse; // 避免页面选中的尴尬
            this.dom.style['-webkit-user-select'] = 'none';
            this.dom.style['user-select'] = 'none';
            this.dom.style['-webkit-touch-callout'] = 'none';
            this.dom.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';

            this.dom.className = config.elementClassName;

            vmlCanvasManager && vmlCanvasManager.initElement(this.dom);

            this.domBack = null;
            this.ctxBack = null;

            this.painter = painter;

            this.unusedCount = 0;

            this.config = null;

            this.dirty = true;

            this.elCount = 0;

            // Configs
            /**
             * 每次清空画布的颜色
             * @type {string}
             * @default 0
             */
            this.clearColor = 0;
            /**
             * 是否开启动态模糊
             * @type {boolean}
             * @default false
             */
            this.motionBlur = false;
            /**
             * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
             * @type {number}
             * @default 0.7
             */
            this.lastFrameAlpha = 0.7;
            /**
             * 层是否支持鼠标平移操作
             * @type {boolean}
             * @default false
             */
            this.zoomable = false;
            /**
             * 层是否支持鼠标缩放操作
             * @type {boolean}
             * @default false
             */
            this.panable = false;

            this.maxZoom = Infinity;
            this.minZoom = 0;

            Transformable.call(this);
        };

        Layer.prototype.initContext = function() {
            this.ctx = this.dom.getContext('2d');

            var dpr = config.devicePixelRatio;
            if (dpr != 1) {
                this.ctx.scale(dpr, dpr);
            }
        };

        Layer.prototype.createBackBuffer = function() {
            if (vmlCanvasManager) { // IE 8- should not support back buffer
                return;
            }
            this.domBack = createDom('back-' + this.id, 'canvas', this.painter);
            this.ctxBack = this.domBack.getContext('2d');

            var dpr = config.devicePixelRatio;

            if (dpr != 1) {
                this.ctxBack.scale(dpr, dpr);
            }
        };

        /**
         * @param  {number} width
         * @param  {number} height
         */
        Layer.prototype.resize = function(width, height) {
            var dpr = config.devicePixelRatio;

            this.dom.style.width = width + 'px';
            this.dom.style.height = height + 'px';

            this.dom.setAttribute('width', width * dpr);
            this.dom.setAttribute('height', height * dpr);

            if (dpr != 1) {
                this.ctx.scale(dpr, dpr);
            }

            if (this.domBack) {
                this.domBack.setAttribute('width', width * dpr);
                this.domBack.setAttribute('height', height * dpr);

                if (dpr != 1) {
                    this.ctxBack.scale(dpr, dpr);
                }
            }
        };

        /**
         * 清空该层画布
         */
        Layer.prototype.clear = function() {
            var dom = this.dom;
            var ctx = this.ctx;
            var width = dom.width;
            var height = dom.height;

            var haveClearColor = this.clearColor && !vmlCanvasManager;
            var haveMotionBLur = this.motionBlur && !vmlCanvasManager;
            var lastFrameAlpha = this.lastFrameAlpha;

            var dpr = config.devicePixelRatio;

            if (haveMotionBLur) {
                if (!this.domBack) {
                    this.createBackBuffer();
                }

                this.ctxBack.globalCompositeOperation = 'copy';
                this.ctxBack.drawImage(
                    dom, 0, 0,
                    width / dpr,
                    height / dpr
                );
            }

            ctx.clearRect(0, 0, width / dpr, height / dpr);
            if (haveClearColor) {
                ctx.save();
                ctx.fillStyle = this.clearColor;
                ctx.fillRect(0, 0, width / dpr, height / dpr);
                ctx.restore();
            }

            if (haveMotionBLur) {
                var domBack = this.domBack;
                ctx.save();
                ctx.globalAlpha = lastFrameAlpha;
                ctx.drawImage(domBack, 0, 0, width / dpr, height / dpr);
                ctx.restore();
            }
        };

        util.merge(Layer.prototype, Transformable.prototype);

        return Layer;
    });
    define('zrender/shape/util/PathProxy', ['require', '../../tool/vector'], function(require) {

        var vector = require('../../tool/vector');
        // var computeBoundingBox = require('../../tool/computeBoundingBox');

        var PathSegment = function(command, points) {
            this.command = command;
            this.points = points || null;
        };

        /**
         * @alias module:zrender/shape/tool/PathProxy
         * @constructor
         */
        var PathProxy = function() {

            /**
             * Path描述的数组，用于`isInsidePath`的判断
             * @type {Array.<Object>}
             */
            this.pathCommands = [];

            this._ctx = null;

            this._min = [];
            this._max = [];
        };

        /**
         * 快速计算Path包围盒（并不是最小包围盒）
         * @return {Object}
         */
        PathProxy.prototype.fastBoundingRect = function() {
            var min = this._min;
            var max = this._max;
            min[0] = min[1] = Infinity;
            max[0] = max[1] = -Infinity;
            for (var i = 0; i < this.pathCommands.length; i++) {
                var seg = this.pathCommands[i];
                var p = seg.points;
                switch (seg.command) {
                    case 'M':
                        vector.min(min, min, p);
                        vector.max(max, max, p);
                        break;
                    case 'L':
                        vector.min(min, min, p);
                        vector.max(max, max, p);
                        break;
                    case 'C':
                        for (var j = 0; j < 6; j += 2) {
                            min[0] = Math.min(min[0], min[0], p[j]);
                            min[1] = Math.min(min[1], min[1], p[j + 1]);
                            max[0] = Math.max(max[0], max[0], p[j]);
                            max[1] = Math.max(max[1], max[1], p[j + 1]);
                        }
                        break;
                    case 'Q':
                        for (var j = 0; j < 4; j += 2) {
                            min[0] = Math.min(min[0], min[0], p[j]);
                            min[1] = Math.min(min[1], min[1], p[j + 1]);
                            max[0] = Math.max(max[0], max[0], p[j]);
                            max[1] = Math.max(max[1], max[1], p[j + 1]);
                        }
                        break;
                    case 'A':
                        var cx = p[0];
                        var cy = p[1];
                        var rx = p[2];
                        var ry = p[3];
                        min[0] = Math.min(min[0], min[0], cx - rx);
                        min[1] = Math.min(min[1], min[1], cy - ry);
                        max[0] = Math.max(max[0], max[0], cx + rx);
                        max[1] = Math.max(max[1], max[1], cy + ry);
                        break;
                }
            }

            return {
                x: min[0],
                y: min[1],
                width: max[0] - min[0],
                height: max[1] - min[1]
            };
        };

        /**
         * @param  {CanvasRenderingContext2D} ctx
         * @return {module:zrender/shape/util/PathProxy}
         */
        PathProxy.prototype.begin = function(ctx) {
            this._ctx = ctx || null;
            // 清空pathCommands
            this.pathCommands.length = 0;

            return this;
        };

        /**
         * @param  {number} x
         * @param  {number} y
         * @return {module:zrender/shape/util/PathProxy}
         */
        PathProxy.prototype.moveTo = function(x, y) {
            this.pathCommands.push(new PathSegment('M', [x, y]));
            if (this._ctx) {
                this._ctx.moveTo(x, y);
            }
            return this;
        };

        /**
         * @param  {number} x
         * @param  {number} y
         * @return {module:zrender/shape/util/PathProxy}
         */
        PathProxy.prototype.lineTo = function(x, y) {
            this.pathCommands.push(new PathSegment('L', [x, y]));
            if (this._ctx) {
                this._ctx.lineTo(x, y);
            }
            return this;
        };

        /**
         * @param  {number} x1
         * @param  {number} y1
         * @param  {number} x2
         * @param  {number} y2
         * @param  {number} x3
         * @param  {number} y3
         * @return {module:zrender/shape/util/PathProxy}
         */
        PathProxy.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
            this.pathCommands.push(new PathSegment('C', [x1, y1, x2, y2, x3, y3]));
            if (this._ctx) {
                this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
            }
            return this;
        };

        /**
         * @param  {number} x1
         * @param  {number} y1
         * @param  {number} x2
         * @param  {number} y2
         * @return {module:zrender/shape/util/PathProxy}
         */
        PathProxy.prototype.quadraticCurveTo = function(x1, y1, x2, y2) {
            this.pathCommands.push(new PathSegment('Q', [x1, y1, x2, y2]));
            if (this._ctx) {
                this._ctx.quadraticCurveTo(x1, y1, x2, y2);
            }
            return this;
        };

        /**
         * @param  {number} cx
         * @param  {number} cy
         * @param  {number} r
         * @param  {number} startAngle
         * @param  {number} endAngle
         * @param  {boolean} anticlockwise
         * @return {module:zrender/shape/util/PathProxy}
         */
        PathProxy.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
            this.pathCommands.push(new PathSegment(
                'A', [cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1]
            ));
            if (this._ctx) {
                this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
            }
            return this;
        };

        // TODO
        PathProxy.prototype.arcTo = function(x1, y1, x2, y2, radius) {
            if (this._ctx) {
                this._ctx.arcTo(x1, y1, x2, y2, radius);
            }
            return this;
        };

        // TODO
        PathProxy.prototype.rect = function(x, y, w, h) {
            if (this._ctx) {
                this._ctx.rect(x, y, w, h);
            }
            return this;
        };

        /**
         * @return {module:zrender/shape/util/PathProxy}
         */
        PathProxy.prototype.closePath = function() {
            this.pathCommands.push(new PathSegment('z'));
            if (this._ctx) {
                this._ctx.closePath();
            }
            return this;
        };

        /**
         * 是否没有Path命令
         * @return {boolean}
         */
        PathProxy.prototype.isEmpty = function() {
            return this.pathCommands.length === 0;
        };

        PathProxy.PathSegment = PathSegment;

        return PathProxy;
    });
    define('zrender/Group', ['require', './tool/guid', './tool/util', './mixin/Transformable', './mixin/Eventful'], function(require) {

        var guid = require('./tool/guid');
        var util = require('./tool/util');

        var Transformable = require('./mixin/Transformable');
        var Eventful = require('./mixin/Eventful');

        /**
         * @alias module:zrender/Group
         * @constructor
         * @extends module:zrender/mixin/Transformable
         * @extends module:zrender/mixin/Eventful
         */
        var Group = function(options) {

            options = options || {};

            /**
             * Group id
             * @type {string}
             */
            this.id = options.id || guid();

            for (var key in options) {
                this[key] = options[key];
            }

            /**
             * @type {string}
             */
            this.type = 'group';

            /**
             * 用于裁剪的图形(shape)，所有 Group 内的图形在绘制时都会被这个图形裁剪
             * 该图形会继承Group的变换
             * @type {module:zrender/shape/Base}
             * @see http://www.w3.org/TR/2dcontext/#clipping-region
             */
            this.clipShape = null;

            this._children = [];

            this._storage = null;

            this.__dirty = true;

            // Mixin
            Transformable.call(this);
            Eventful.call(this);
        };

        /**
         * 是否忽略该 Group 及其所有子节点
         * @type {boolean}
         * @default false
         */
        Group.prototype.ignore = false;

        /**
         * 复制并返回一份新的包含所有儿子节点的数组
         * @return {Array.<module:zrender/Group|module:zrender/shape/Base>}
         */
        Group.prototype.children = function() {
            return this._children.slice();
        };

        /**
         * 获取指定 index 的儿子节点
         * @param  {number} idx
         * @return {module:zrender/Group|module:zrender/shape/Base}
         */
        Group.prototype.childAt = function(idx) {
            return this._children[idx];
        };

        /**
         * 添加子节点，可以是Shape或者Group
         * @param {module:zrender/Group|module:zrender/shape/Base} child
         */
        // TODO Type Check
        Group.prototype.addChild = function(child) {
            if (child == this) {
                return;
            }

            if (child.parent == this) {
                return;
            }
            if (child.parent) {
                child.parent.removeChild(child);
            }

            this._children.push(child);
            child.parent = this;

            if (this._storage && this._storage !== child._storage) {

                this._storage.addToMap(child);

                if (child instanceof Group) {
                    child.addChildrenToStorage(this._storage);
                }
            }
        };

        /**
         * 移除子节点
         * @param {module:zrender/Group|module:zrender/shape/Base} child
         */
        // TODO Type Check
        Group.prototype.removeChild = function(child) {
            var idx = util.indexOf(this._children, child);

            if (idx >= 0) {
                this._children.splice(idx, 1);
            }
            child.parent = null;

            if (this._storage) {

                this._storage.delFromMap(child.id);

                if (child instanceof Group) {
                    child.delChildrenFromStorage(this._storage);
                }
            }
        };

        /**
         * 移除所有子节点
         */
        Group.prototype.clearChildren = function() {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (this._storage) {
                    this._storage.delFromMap(child.id);
                    if (child instanceof Group) {
                        child.delChildrenFromStorage(this._storage);
                    }
                }
            }
            this._children.length = 0;
        };

        /**
         * 遍历所有子节点
         * @param  {Function} cb
         * @param  {}   context
         */
        Group.prototype.eachChild = function(cb, context) {
            var haveContext = !!context;
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (haveContext) {
                    cb.call(context, child);
                } else {
                    cb(child);
                }
            }
        };

        /**
         * 深度优先遍历所有子孙节点
         * @param  {Function} cb
         * @param  {}   context
         */
        Group.prototype.traverse = function(cb, context) {
            var haveContext = !!context;
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (haveContext) {
                    cb.call(context, child);
                } else {
                    cb(child);
                }

                if (child.type === 'group') {
                    child.traverse(cb, context);
                }
            }
        };

        Group.prototype.addChildrenToStorage = function(storage) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                storage.addToMap(child);
                if (child instanceof Group) {
                    child.addChildrenToStorage(storage);
                }
            }
        };

        Group.prototype.delChildrenFromStorage = function(storage) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                storage.delFromMap(child.id);
                if (child instanceof Group) {
                    child.delChildrenFromStorage(storage);
                }
            }
        };

        Group.prototype.modSelf = function() {
            this.__dirty = true;
        };

        util.merge(Group.prototype, Transformable.prototype, true);
        util.merge(Group.prototype, Eventful.prototype, true);

        return Group;
    });
    define('zrender/shape/BezierCurve', ['require', './Base', '../tool/util'], function(require) {
        'use strict';

        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/BezierCurve
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var BezierCurve = function(options) {
            this.brushTypeOnly = 'stroke'; // 线条只能描边，填充后果自负
            this.textPosition = 'end';
            Base.call(this, options);
            /**
             * 贝赛尔曲线绘制样式
             * @name module:zrender/shape/BezierCurve#style
             * @type {module:zrender/shape/BezierCurve~IBezierCurveStyle}
             */
            /**
             * 贝赛尔曲线高亮绘制样式
             * @name module:zrender/shape/BezierCurve#highlightStyle
             * @type {module:zrender/shape/BezierCurve~IBezierCurveStyle}
             */
        };

        BezierCurve.prototype = {
            type: 'bezier-curve',

            /**
             * 创建贝塞尔曲线路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/BezierCurve~IBezierCurveStyle} style
             */
            buildPath: function(ctx, style) {
                ctx.moveTo(style.xStart, style.yStart);
                if (typeof style.cpX2 != 'undefined' && typeof style.cpY2 != 'undefined') {
                    ctx.bezierCurveTo(
                        style.cpX1, style.cpY1,
                        style.cpX2, style.cpY2,
                        style.xEnd, style.yEnd
                    );
                } else {
                    ctx.quadraticCurveTo(
                        style.cpX1, style.cpY1,
                        style.xEnd, style.yEnd
                    );
                }
            },

            /**
             * 计算返回贝赛尔曲线包围盒矩形。
             * 该包围盒是直接从四个控制点计算，并非最小包围盒。
             * @param {module:zrender/shape/BezierCurve~IBezierCurveStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var _minX = Math.min(style.xStart, style.xEnd, style.cpX1);
                var _minY = Math.min(style.yStart, style.yEnd, style.cpY1);
                var _maxX = Math.max(style.xStart, style.xEnd, style.cpX1);
                var _maxY = Math.max(style.yStart, style.yEnd, style.cpY1);
                var _x2 = style.cpX2;
                var _y2 = style.cpY2;

                if (typeof _x2 != 'undefined' && typeof _y2 != 'undefined') {
                    _minX = Math.min(_minX, _x2);
                    _minY = Math.min(_minY, _y2);
                    _maxX = Math.max(_maxX, _x2);
                    _maxY = Math.max(_maxY, _y2);
                }

                var lineWidth = style.lineWidth || 1;
                style.__rect = {
                    x: _minX - lineWidth,
                    y: _minY - lineWidth,
                    width: _maxX - _minX + lineWidth,
                    height: _maxY - _minY + lineWidth
                };

                return style.__rect;
            }
        };

        require('../tool/util').inherits(BezierCurve, Base);
        return BezierCurve;
    });
    define('zrender/animation/Clip', ['require', './easing'], function(require) {

        var Easing = require('./easing');

        function Clip(options) {

            this._targetPool = options.target || {};
            if (!(this._targetPool instanceof Array)) {
                this._targetPool = [this._targetPool];
            }

            // 生命周期
            this._life = options.life || 1000;
            // 延时
            this._delay = options.delay || 0;
            // 开始时间
            this._startTime = new Date().getTime() + this._delay; // 单位毫秒

            // 结束时间
            this._endTime = this._startTime + this._life * 1000;

            // 是否循环
            this.loop = typeof options.loop == 'undefined' ? false : options.loop;

            this.gap = options.gap || 0;

            this.easing = options.easing || 'Linear';

            this.onframe = options.onframe;
            this.ondestroy = options.ondestroy;
            this.onrestart = options.onrestart;
        }

        Clip.prototype = {
            step: function(time) {
                var percent = (time - this._startTime) / this._life;

                // 还没开始
                if (percent < 0) {
                    return;
                }

                percent = Math.min(percent, 1);

                var easingFunc = typeof this.easing == 'string' ? Easing[this.easing] : this.easing;
                var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;

                this.fire('frame', schedule);

                // 结束
                if (percent == 1) {
                    if (this.loop) {
                        this.restart();
                        // 重新开始周期
                        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
                        return 'restart';
                    }

                    // 动画完成将这个控制器标识为待删除
                    // 在Animation.update中进行批量删除
                    this.__needsRemove = true;
                    return 'destroy';
                }

                return null;
            },
            restart: function() {
                var time = new Date().getTime();
                var remainder = (time - this._startTime) % this._life;
                this._startTime = new Date().getTime() - remainder + this.gap;

                this.__needsRemove = false;
            },
            fire: function(eventType, arg) {
                for (var i = 0, len = this._targetPool.length; i < len; i++) {
                    if (this['on' + eventType]) {
                        this['on' + eventType](this._targetPool[i], arg);
                    }
                }
            },
            constructor: Clip
        };

        return Clip;
    });
    define('echarts/util/shape/normalIsCover', [], function() {
        return function(x, y) {
            var originPos = this.transformCoordToLocal(x, y);
            x = originPos[0];
            y = originPos[1];

            return this.isCoverRect(x, y);
        };
    });
    define('zrender/animation/easing', [], function() {
        /**
         * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
         * @see http://sole.github.io/tween.js/examples/03_graphs.html
         * @exports zrender/animation/easing
         */
        var easing = {
            // 线性
            /**
             * @param {number} k
             * @return {number}
             */
            Linear: function(k) {
                return k;
            },

            // 二次方的缓动（t^2）
            /**
             * @param {number} k
             * @return {number}
             */
            QuadraticIn: function(k) {
                return k * k;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuadraticOut: function(k) {
                return k * (2 - k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuadraticInOut: function(k) {
                if ((k *= 2) < 1) {
                    return 0.5 * k * k;
                }
                return -0.5 * (--k * (k - 2) - 1);
            },

            // 三次方的缓动（t^3）
            /**
             * @param {number} k
             * @return {number}
             */
            CubicIn: function(k) {
                return k * k * k;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            CubicOut: function(k) {
                return --k * k * k + 1;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            CubicInOut: function(k) {
                if ((k *= 2) < 1) {
                    return 0.5 * k * k * k;
                }
                return 0.5 * ((k -= 2) * k * k + 2);
            },

            // 四次方的缓动（t^4）
            /**
             * @param {number} k
             * @return {number}
             */
            QuarticIn: function(k) {
                return k * k * k * k;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuarticOut: function(k) {
                return 1 - (--k * k * k * k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuarticInOut: function(k) {
                if ((k *= 2) < 1) {
                    return 0.5 * k * k * k * k;
                }
                return -0.5 * ((k -= 2) * k * k * k - 2);
            },

            // 五次方的缓动（t^5）
            /**
             * @param {number} k
             * @return {number}
             */
            QuinticIn: function(k) {
                return k * k * k * k * k;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuinticOut: function(k) {
                return --k * k * k * k * k + 1;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            QuinticInOut: function(k) {
                if ((k *= 2) < 1) {
                    return 0.5 * k * k * k * k * k;
                }
                return 0.5 * ((k -= 2) * k * k * k * k + 2);
            },

            // 正弦曲线的缓动（sin(t)）
            /**
             * @param {number} k
             * @return {number}
             */
            SinusoidalIn: function(k) {
                return 1 - Math.cos(k * Math.PI / 2);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            SinusoidalOut: function(k) {
                return Math.sin(k * Math.PI / 2);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            SinusoidalInOut: function(k) {
                return 0.5 * (1 - Math.cos(Math.PI * k));
            },

            // 指数曲线的缓动（2^t）
            /**
             * @param {number} k
             * @return {number}
             */
            ExponentialIn: function(k) {
                return k === 0 ? 0 : Math.pow(1024, k - 1);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            ExponentialOut: function(k) {
                return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            ExponentialInOut: function(k) {
                if (k === 0) {
                    return 0;
                }
                if (k === 1) {
                    return 1;
                }
                if ((k *= 2) < 1) {
                    return 0.5 * Math.pow(1024, k - 1);
                }
                return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            },

            // 圆形曲线的缓动（sqrt(1-t^2)）
            /**
             * @param {number} k
             * @return {number}
             */
            CircularIn: function(k) {
                return 1 - Math.sqrt(1 - k * k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            CircularOut: function(k) {
                return Math.sqrt(1 - (--k * k));
            },
            /**
             * @param {number} k
             * @return {number}
             */
            CircularInOut: function(k) {
                if ((k *= 2) < 1) {
                    return -0.5 * (Math.sqrt(1 - k * k) - 1);
                }
                return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            },

            // 创建类似于弹簧在停止前来回振荡的动画
            /**
             * @param {number} k
             * @return {number}
             */
            ElasticIn: function(k) {
                var s;
                var a = 0.1;
                var p = 0.4;
                if (k === 0) {
                    return 0;
                }
                if (k === 1) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                return -(a * Math.pow(2, 10 * (k -= 1)) *
                    Math.sin((k - s) * (2 * Math.PI) / p));
            },
            /**
             * @param {number} k
             * @return {number}
             */
            ElasticOut: function(k) {
                var s;
                var a = 0.1;
                var p = 0.4;
                if (k === 0) {
                    return 0;
                }
                if (k === 1) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                return (a * Math.pow(2, -10 * k) *
                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            ElasticInOut: function(k) {
                var s;
                var a = 0.1;
                var p = 0.4;
                if (k === 0) {
                    return 0;
                }
                if (k === 1) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                if ((k *= 2) < 1) {
                    return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                }
                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

            },

            // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
            /**
             * @param {number} k
             * @return {number}
             */
            BackIn: function(k) {
                var s = 1.70158;
                return k * k * ((s + 1) * k - s);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            BackOut: function(k) {
                var s = 1.70158;
                return --k * k * ((s + 1) * k + s) + 1;
            },
            /**
             * @param {number} k
             * @return {number}
             */
            BackInOut: function(k) {
                var s = 1.70158 * 1.525;
                if ((k *= 2) < 1) {
                    return 0.5 * (k * k * ((s + 1) * k - s));
                }
                return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            },

            // 创建弹跳效果
            /**
             * @param {number} k
             * @return {number}
             */
            BounceIn: function(k) {
                return 1 - easing.BounceOut(1 - k);
            },
            /**
             * @param {number} k
             * @return {number}
             */
            BounceOut: function(k) {
                if (k < (1 / 2.75)) {
                    return 7.5625 * k * k;
                } else if (k < (2 / 2.75)) {
                    return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
                } else if (k < (2.5 / 2.75)) {
                    return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
                } else {
                    return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
                }
            },
            /**
             * @param {number} k
             * @return {number}
             */
            BounceInOut: function(k) {
                if (k < 0.5) {
                    return easing.BounceIn(k * 2) * 0.5;
                }
                return easing.BounceOut(k * 2 - 1) * 0.5 + 0.5;
            }
        };

        return easing;
    });
    define('echarts/data/KDTree', ['require', './quickSelect'], function(require) {

        var quickSelect = require('./quickSelect');

        function Node(axis, data) {
            this.left = null;
            this.right = null;
            this.axis = axis;

            this.data = data;
        }

        /**
         * @constructor
         * @alias module:echarts/data/KDTree
         * @param {Array} points List of points.
         * each point needs an array property to repesent the actual data
         * @param {Number} [dimension]
         *        Point dimension.
         *        Default will use the first point's length as dimensiont
         */
        var KDTree = function(points, dimension) {
            if (!points.length) {
                return;
            }

            if (!dimension) {
                dimension = points[0].array.length;
            }
            this.dimension = dimension;
            this.root = this._buildTree(points, 0, points.length - 1, 0);

            // Use one stack to avoid allocation 
            // each time searching the nearest point
            this._stack = [];
            // Again avoid allocating a new array
            // each time searching nearest N points
            this._nearstNList = [];
        };

        /**
         * Resursively build the tree
         */
        KDTree.prototype._buildTree = function(points, left, right, axis) {
            if (right < left) {
                return null;
            }

            var medianIndex = Math.floor((left + right) / 2);
            medianIndex = quickSelect(
                points, left, right, medianIndex,
                function(a, b) {
                    return a.array[axis] - b.array[axis];
                }
            );
            var median = points[medianIndex];

            var node = new Node(axis, median);

            axis = (axis + 1) % this.dimension;
            if (right > left) {
                node.left = this._buildTree(points, left, medianIndex - 1, axis);
                node.right = this._buildTree(points, medianIndex + 1, right, axis);
            }

            return node;
        };

        /**
         * Find nearest point
         * @param  {Array} target Target point
         * @param  {Function} squaredDistance Squared distance function
         * @return {Array} Nearest point
         */
        KDTree.prototype.nearest = function(target, squaredDistance) {
            var curr = this.root;
            var stack = this._stack;
            var idx = 0;
            var minDist = Infinity;
            var nearestNode = null;
            if (curr.data !== target) {
                minDist = squaredDistance(curr.data, target);
                nearestNode = curr;
            }

            if (target.array[curr.axis] < curr.data.array[curr.axis]) {
                // Left first
                curr.right && (stack[idx++] = curr.right);
                curr.left && (stack[idx++] = curr.left);
            } else {
                // Right first
                curr.left && (stack[idx++] = curr.left);
                curr.right && (stack[idx++] = curr.right);
            }

            while (idx--) {
                curr = stack[idx];
                var currDist = target.array[curr.axis] - curr.data.array[curr.axis];
                var isLeft = currDist < 0;
                var needsCheckOtherSide = false;
                currDist = currDist * currDist;
                // Intersecting right hyperplane with minDist hypersphere
                if (currDist < minDist) {
                    currDist = squaredDistance(curr.data, target);
                    if (currDist < minDist && curr.data !== target) {
                        minDist = currDist;
                        nearestNode = curr;
                    }
                    needsCheckOtherSide = true;
                }
                if (isLeft) {
                    if (needsCheckOtherSide) {
                        curr.right && (stack[idx++] = curr.right);
                    }
                    // Search in the left area
                    curr.left && (stack[idx++] = curr.left);
                } else {
                    if (needsCheckOtherSide) {
                        curr.left && (stack[idx++] = curr.left);
                    }
                    // Search the right area
                    curr.right && (stack[idx++] = curr.right);
                }
            }

            return nearestNode.data;
        };

        KDTree.prototype._addNearest = function(found, dist, node) {
            var nearestNList = this._nearstNList;

            // Insert to the right position
            // Sort from small to large
            for (var i = found - 1; i > 0; i--) {
                if (dist >= nearestNList[i - 1].dist) {
                    break;
                } else {
                    nearestNList[i].dist = nearestNList[i - 1].dist;
                    nearestNList[i].node = nearestNList[i - 1].node;
                }
            }

            nearestNList[i].dist = dist;
            nearestNList[i].node = node;
        };

        /**
         * Find nearest N points
         * @param  {Array} target Target point
         * @param  {number} N
         * @param  {Function} squaredDistance Squared distance function
         * @param  {Array} [output] Output nearest N points
         */
        KDTree.prototype.nearestN = function(target, N, squaredDistance, output) {
            if (N <= 0) {
                output.length = 0;
                return output;
            }

            var curr = this.root;
            var stack = this._stack;
            var idx = 0;

            var nearestNList = this._nearstNList;
            for (var i = 0; i < N; i++) {
                // Allocate
                if (!nearestNList[i]) {
                    nearestNList[i] = {};
                }
                nearestNList[i].dist = 0;
                nearestNList[i].node = null;
            }
            var currDist = squaredDistance(curr.data, target);

            var found = 0;
            if (curr.data !== target) {
                found++;
                this._addNearest(found, currDist, curr);
            }

            if (target.array[curr.axis] < curr.data.array[curr.axis]) {
                // Left first
                curr.right && (stack[idx++] = curr.right);
                curr.left && (stack[idx++] = curr.left);
            } else {
                // Right first
                curr.left && (stack[idx++] = curr.left);
                curr.right && (stack[idx++] = curr.right);
            }

            while (idx--) {
                curr = stack[idx];
                var currDist = target.array[curr.axis] - curr.data.array[curr.axis];
                var isLeft = currDist < 0;
                var needsCheckOtherSide = false;
                currDist = currDist * currDist;
                // Intersecting right hyperplane with minDist hypersphere
                if (found < N || currDist < nearestNList[found - 1].dist) {
                    currDist = squaredDistance(curr.data, target);
                    if (
                        (found < N || currDist < nearestNList[found - 1].dist) && curr.data !== target
                    ) {
                        if (found < N) {
                            found++;
                        }
                        this._addNearest(found, currDist, curr);
                    }
                    needsCheckOtherSide = true;
                }
                if (isLeft) {
                    if (needsCheckOtherSide) {
                        curr.right && (stack[idx++] = curr.right);
                    }
                    // Search in the left area
                    curr.left && (stack[idx++] = curr.left);
                } else {
                    if (needsCheckOtherSide) {
                        curr.left && (stack[idx++] = curr.left);
                    }
                    // Search the right area
                    curr.right && (stack[idx++] = curr.right);
                }
            }

            // Copy to output
            for (var i = 0; i < found; i++) {
                output[i] = nearestNList[i].node.data;
            }
            output.length = found;

            return output;
        };

        return KDTree;
    });
    define('echarts/data/quickSelect', ['require'], function(require) {

        function defaultCompareFunc(a, b) {
            return a - b;
        }

        function swapElement(list, idx0, idx1) {
            var tmp = list[idx0];
            list[idx0] = list[idx1];
            list[idx1] = tmp;
        }

        function select(list, left, right, nth, compareFunc) {
            var pivotIdx = left;
            while (right > left) {
                var pivotIdx = Math.round((right + left) / 2);
                var pivotValue = list[pivotIdx];
                // Swap pivot to the end
                swapElement(list, pivotIdx, right);
                pivotIdx = left;
                for (var i = left; i <= right - 1; i++) {
                    if (compareFunc(pivotValue, list[i]) >= 0) {
                        swapElement(list, i, pivotIdx);
                        pivotIdx++;
                    }
                }
                swapElement(list, right, pivotIdx);

                if (pivotIdx === nth) {
                    return pivotIdx;
                } else if (pivotIdx < nth) {
                    left = pivotIdx + 1;
                } else {
                    right = pivotIdx - 1;
                }
            }
            // Left == right
            return left;
        }

        /**
         * @alias module:echarts/data/quickSelect
         * @param {Array} list
         * @param {number} [left]
         * @param {number} [right]
         * @param {number} nth
         * @param {Function} [compareFunc]
         * @example
         *     var quickSelect = require('echarts/data/quickSelect');
         *     var list = [5, 2, 1, 4, 3]
         *     quickSelect(list, 3);
         *     quickSelect(list, 0, 3, 1, function (a, b) {return a - b});
         *
         * @return {number}
         */
        function quickSelect(list, left, right, nth, compareFunc) {
            if (arguments.length <= 3) {
                nth = left;
                if (arguments.length == 2) {
                    compareFunc = defaultCompareFunc;
                } else {
                    compareFunc = right;
                }
                left = 0;
                right = list.length - 1;
            }
            return select(list, left, right, nth, compareFunc);
        }

        return quickSelect;
    });
    define('echarts/component/dataView', ['require', './base', '../config', 'zrender/tool/util', '../component'], function(require) {
        var Base = require('./base');

        var ecConfig = require('../config');
        var zrUtil = require('zrender/tool/util');

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 提示框参数
         * @param {HtmlElement} dom 目标对象
         */
        function DataView(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.dom = myChart.dom;

            // dataview dom & css
            this._tDom = document.createElement('div');
            this._textArea = document.createElement('textArea');
            this._buttonRefresh = document.createElement('button');
            // 高级浏览器默认type为submit
            // 如果图表出现在form表单时，点击button后会提交表单
            // 设置为button，防止点击button后提交表单
            this._buttonRefresh.setAttribute('type', 'button');
            this._buttonClose = document.createElement('button');
            this._buttonClose.setAttribute('type', 'button');
            this._hasShow = false;

            // 缓存一些高宽数据
            this._zrHeight = zr.getHeight();
            this._zrWidth = zr.getWidth();

            this._tDom.className = 'echarts-dataview';
            this.hide();
            this.dom.firstChild.appendChild(this._tDom);

            if (window.addEventListener) {
                this._tDom.addEventListener('click', this._stop);
                this._tDom.addEventListener('mousewheel', this._stop);
                this._tDom.addEventListener('mousemove', this._stop);
                this._tDom.addEventListener('mousedown', this._stop);
                this._tDom.addEventListener('mouseup', this._stop);

                // mobile支持
                this._tDom.addEventListener('touchstart', this._stop);
                this._tDom.addEventListener('touchmove', this._stop);
                this._tDom.addEventListener('touchend', this._stop);
            } else {
                this._tDom.attachEvent('onclick', this._stop);
                this._tDom.attachEvent('onmousewheel', this._stop);
                this._tDom.attachEvent('onmousemove', this._stop);
                this._tDom.attachEvent('onmousedown', this._stop);
                this._tDom.attachEvent('onmouseup', this._stop);
            }
        }

        DataView.prototype = {
            type: ecConfig.COMPONENT_TYPE_DATAVIEW,
            _lang: ['Data View', 'close', 'refresh'],
            // 通用样式
            _gCssText: 'position:absolute;' + 'display:block;' + 'overflow:hidden;' + 'transition:height 0.8s,background-color 1s;' + '-moz-transition:height 0.8s,background-color 1s;' + '-webkit-transition:height 0.8s,background-color 1s;' + '-o-transition:height 0.8s,background-color 1s;' + 'z-index:1;' + 'left:0;' + 'top:0;',
            hide: function() {
                this._sizeCssText = 'width:' + this._zrWidth + 'px;' + 'height:' + 0 + 'px;' + 'background-color:#f0ffff;';
                this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                // 这是个很恶心的事情
                /*
                this.dom.onselectstart = function () {
                    return false;
                };
                */
            },

            show: function(newOption) {
                this._hasShow = true;
                var lang = this.query(this.option, 'toolbox.feature.dataView.lang') || this._lang;

                this.option = newOption;

                this._tDom.innerHTML = '<p style="padding:8px 0;margin:0 0 10px 0;' + 'border-bottom:1px solid #eee">' + (lang[0] || this._lang[0]) + '</p>';

                var customContent = this.query(
                    this.option, 'toolbox.feature.dataView.optionToContent'
                );
                if (typeof customContent != 'function') {
                    this._textArea.value = this._optionToContent();
                } else {
                    // innerHTML the custom optionToContent;
                    this._textArea = document.createElement('div');
                    this._textArea.innerHTML = customContent(this.option);
                }

                this._textArea.style.cssText =
                    'display:block;margin:0 0 8px 0;padding:4px 6px;overflow:auto;' + 'width:100%;' + 'height:' + (this._zrHeight - 100) + 'px;';

                this._tDom.appendChild(this._textArea);

                this._buttonClose.style.cssText = 'float:right;padding:1px 6px;';
                this._buttonClose.innerHTML = lang[1] || this._lang[1];
                var self = this;
                this._buttonClose.onclick = function() {
                    self.hide();
                };
                this._tDom.appendChild(this._buttonClose);

                if (this.query(this.option, 'toolbox.feature.dataView.readOnly') === false) {
                    this._buttonRefresh.style.cssText =
                        'float:right;margin-right:10px;padding:1px 6px;';
                    this._buttonRefresh.innerHTML = lang[2] || this._lang[2];
                    this._buttonRefresh.onclick = function() {
                        self._save();
                    };
                    this._textArea.readOnly = false;
                    this._textArea.style.cursor = 'default';
                } else {
                    this._buttonRefresh.style.cssText =
                        'display:none';
                    this._textArea.readOnly = true;
                    this._textArea.style.cursor = 'text';
                }
                this._tDom.appendChild(this._buttonRefresh);

                this._sizeCssText = 'width:' + this._zrWidth + 'px;' + 'height:' + this._zrHeight + 'px;' + 'background-color:#fff;';
                this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                // 这是个很恶心的事情
                /*
                this.dom.onselectstart = function () {
                    return true;
                };
                */
            },

            _optionToContent: function() {
                var i;
                var j;
                var k;
                var len;
                var data;
                var valueList;
                var axisList = [];
                var content = '';
                if (this.option.xAxis) {
                    if (this.option.xAxis instanceof Array) {
                        axisList = this.option.xAxis;
                    } else {
                        axisList = [this.option.xAxis];
                    }
                    for (i = 0, len = axisList.length; i < len; i++) {
                        // 横纵默认为类目
                        if ((axisList[i].type || 'category') == 'category') {
                            valueList = [];
                            for (j = 0, k = axisList[i].data.length; j < k; j++) {
                                valueList.push(this.getDataFromOption(axisList[i].data[j]));
                            }
                            content += valueList.join(', ') + '\n\n';
                        }
                    }
                }

                if (this.option.yAxis) {
                    if (this.option.yAxis instanceof Array) {
                        axisList = this.option.yAxis;
                    } else {
                        axisList = [this.option.yAxis];
                    }
                    for (i = 0, len = axisList.length; i < len; i++) {
                        if (axisList[i].type == 'category') {
                            valueList = [];
                            for (j = 0, k = axisList[i].data.length; j < k; j++) {
                                valueList.push(this.getDataFromOption(axisList[i].data[j]));
                            }
                            content += valueList.join(', ') + '\n\n';
                        }
                    }
                }

                var series = this.option.series;
                var itemName;
                for (i = 0, len = series.length; i < len; i++) {
                    valueList = [];
                    for (j = 0, k = series[i].data.length; j < k; j++) {
                        data = series[i].data[j];
                        if (series[i].type == ecConfig.CHART_TYPE_PIE || series[i].type == ecConfig.CHART_TYPE_MAP) {
                            itemName = (data.name || '-') + ':';
                        } else {
                            itemName = '';
                        }

                        if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                            data = this.getDataFromOption(data).join(', ');
                        }
                        valueList.push(itemName + this.getDataFromOption(data));
                    }
                    content += (series[i].name || '-') + ' : \n';
                    content += valueList.join(
                        series[i].type == ecConfig.CHART_TYPE_SCATTER ? '\n' : ', '
                    );
                    content += '\n\n';
                }

                return content;
            },

            _save: function() {
                var customContent = this.query(
                    this.option, 'toolbox.feature.dataView.contentToOption'
                );
                if (typeof customContent != 'function') {
                    var text = this._textArea.value.split('\n');
                    var content = [];
                    for (var i = 0, l = text.length; i < l; i++) {
                        text[i] = this._trim(text[i]);
                        if (text[i] !== '') {
                            content.push(text[i]);
                        }
                    }
                    this._contentToOption(content);
                } else {
                    // return the textArea dom for custom contentToOption
                    customContent(this._textArea, this.option);
                }

                this.hide();

                var self = this;
                setTimeout(
                    function() {
                        self.messageCenter && self.messageCenter.dispatch(
                            ecConfig.EVENT.DATA_VIEW_CHANGED,
                            null, {
                                option: self.option
                            },
                            self.myChart
                        );
                    },
                    // 有动画，所以高级浏览器时间更长点
                    self.canvasSupported ? 800 : 100
                );
            },

            _contentToOption: function(content) {
                var i;
                var j;
                var k;
                var len;
                var data;
                var axisList = [];

                var contentIdx = 0;
                var contentValueList;
                var value;

                if (this.option.xAxis) {
                    if (this.option.xAxis instanceof Array) {
                        axisList = this.option.xAxis;
                    } else {
                        axisList = [this.option.xAxis];
                    }
                    for (i = 0, len = axisList.length; i < len; i++) {
                        // 横纵默认为类目
                        if ((axisList[i].type || 'category') == 'category') {
                            contentValueList = content[contentIdx].split(',');
                            for (j = 0, k = axisList[i].data.length; j < k; j++) {
                                value = this._trim(contentValueList[j] || '');
                                data = axisList[i].data[j];
                                if (typeof axisList[i].data[j].value != 'undefined') {
                                    axisList[i].data[j].value = value;
                                } else {
                                    axisList[i].data[j] = value;
                                }
                            }
                            contentIdx++;
                        }
                    }
                }

                if (this.option.yAxis) {
                    if (this.option.yAxis instanceof Array) {
                        axisList = this.option.yAxis;
                    } else {
                        axisList = [this.option.yAxis];
                    }
                    for (i = 0, len = axisList.length; i < len; i++) {
                        if (axisList[i].type == 'category') {
                            contentValueList = content[contentIdx].split(',');
                            for (j = 0, k = axisList[i].data.length; j < k; j++) {
                                value = this._trim(contentValueList[j] || '');
                                data = axisList[i].data[j];
                                if (typeof axisList[i].data[j].value != 'undefined') {
                                    axisList[i].data[j].value = value;
                                } else {
                                    axisList[i].data[j] = value;
                                }
                            }
                            contentIdx++;
                        }
                    }
                }

                var series = this.option.series;
                for (i = 0, len = series.length; i < len; i++) {
                    contentIdx++;
                    if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                        for (var j = 0, k = series[i].data.length; j < k; j++) {
                            contentValueList = content[contentIdx];
                            value = contentValueList.replace(' ', '').split(',');
                            if (typeof series[i].data[j].value != 'undefined') {
                                series[i].data[j].value = value;
                            } else {
                                series[i].data[j] = value;
                            }
                            contentIdx++;
                        }
                    } else {
                        contentValueList = content[contentIdx].split(',');
                        for (var j = 0, k = series[i].data.length; j < k; j++) {
                            value = (contentValueList[j] || '').replace(/.*:/, '');
                            value = this._trim(value);
                            value = (value != '-' && value !== '') ? (value - 0) : '-';
                            if (typeof series[i].data[j].value != 'undefined') {
                                series[i].data[j].value = value;
                            } else {
                                series[i].data[j] = value;
                            }
                        }
                        contentIdx++;
                    }
                }
            },

            _trim: function(str) {
                var trimer = new RegExp(
                    '(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)', 'g'
                );
                return str.replace(trimer, '');
            },

            // 阻塞zrender事件
            _stop: function(e) {
                e = e || window.event;
                if (e.stopPropagation) {
                    e.stopPropagation();
                } else {
                    e.cancelBubble = true;
                }
            },

            /**
             * zrender事件响应：窗口大小改变
             */
            resize: function() {
                this._zrHeight = this.zr.getHeight();
                this._zrWidth = this.zr.getWidth();
                if (this._tDom.offsetHeight > 10) {
                    this._sizeCssText = 'width:' + this._zrWidth + 'px;' + 'height:' + this._zrHeight + 'px;' + 'background-color:#fff;';
                    this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                    this._textArea.style.cssText = 'display:block;margin:0 0 8px 0;' + 'padding:4px 6px;overflow:auto;' + 'width:100%;' + 'height:' + (this._zrHeight - 100) + 'px;';
                }
            },

            /**
             * 释放后实例不可用，重载基类方法
             */
            dispose: function() {
                if (window.removeEventListener) {
                    this._tDom.removeEventListener('click', this._stop);
                    this._tDom.removeEventListener('mousewheel', this._stop);
                    this._tDom.removeEventListener('mousemove', this._stop);
                    this._tDom.removeEventListener('mousedown', this._stop);
                    this._tDom.removeEventListener('mouseup', this._stop);

                    // mobile支持
                    this._tDom.removeEventListener('touchstart', this._stop);
                    this._tDom.removeEventListener('touchmove', this._stop);
                    this._tDom.removeEventListener('touchend', this._stop);
                } else {
                    this._tDom.detachEvent('onclick', this._stop);
                    this._tDom.detachEvent('onmousewheel', this._stop);
                    this._tDom.detachEvent('onmousemove', this._stop);
                    this._tDom.detachEvent('onmousedown', this._stop);
                    this._tDom.detachEvent('onmouseup', this._stop);
                }

                this._buttonRefresh.onclick = null;
                this._buttonClose.onclick = null;

                if (this._hasShow) {
                    this._tDom.removeChild(this._textArea);
                    this._tDom.removeChild(this._buttonRefresh);
                    this._tDom.removeChild(this._buttonClose);
                }

                this._textArea = null;
                this._buttonRefresh = null;
                this._buttonClose = null;

                this.dom.firstChild.removeChild(this._tDom);
                this._tDom = null;
            }
        };

        zrUtil.inherits(DataView, Base);

        require('../component').define('dataView', DataView);

        return DataView;
    });
    define('zrender/shape/Sector', ['require', '../tool/math', '../tool/computeBoundingBox', '../tool/vector', './Base', '../tool/util'], function(require) {

        var math = require('../tool/math');
        var computeBoundingBox = require('../tool/computeBoundingBox');
        var vec2 = require('../tool/vector');
        var Base = require('./Base');

        var min0 = vec2.create();
        var min1 = vec2.create();
        var max0 = vec2.create();
        var max1 = vec2.create();
        /**
         * @alias module:zrender/shape/Sector
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Sector = function(options) {
            Base.call(this, options);
            /**
             * 扇形绘制样式
             * @name module:zrender/shape/Sector#style
             * @type {module:zrender/shape/Sector~ISectorStyle}
             */
            /**
             * 扇形高亮绘制样式
             * @name module:zrender/shape/Sector#highlightStyle
             * @type {module:zrender/shape/Sector~ISectorStyle}
             */
        };

        Sector.prototype = {
            type: 'sector',

            /**
             * 创建扇形路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Sector~ISectorStyle} style
             */
            buildPath: function(ctx, style) {
                var x = style.x; // 圆心x
                var y = style.y; // 圆心y
                var r0 = style.r0 || 0; // 形内半径[0,r)
                var r = style.r; // 扇形外半径(0,r]
                var startAngle = style.startAngle; // 起始角度[0,360)
                var endAngle = style.endAngle; // 结束角度(0,360]
                var clockWise = style.clockWise || false;

                startAngle = math.degreeToRadian(startAngle);
                endAngle = math.degreeToRadian(endAngle);

                if (!clockWise) {
                    // 扇形默认是逆时针方向，Y轴向上
                    // 这个跟arc的标准不一样，为了兼容echarts
                    startAngle = -startAngle;
                    endAngle = -endAngle;
                }

                var unitX = math.cos(startAngle);
                var unitY = math.sin(startAngle);
                ctx.moveTo(
                    unitX * r0 + x,
                    unitY * r0 + y
                );

                ctx.lineTo(
                    unitX * r + x,
                    unitY * r + y
                );

                ctx.arc(x, y, r, startAngle, endAngle, !clockWise);

                ctx.lineTo(
                    math.cos(endAngle) * r0 + x,
                    math.sin(endAngle) * r0 + y
                );

                if (r0 !== 0) {
                    ctx.arc(x, y, r0, endAngle, startAngle, clockWise);
                }

                ctx.closePath();

                return;
            },

            /**
             * 返回扇形包围盒矩形
             * @param {module:zrender/shape/Sector~ISectorStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var x = style.x; // 圆心x
                var y = style.y; // 圆心y
                var r0 = style.r0 || 0; // 形内半径[0,r)
                var r = style.r; // 扇形外半径(0,r]
                var startAngle = math.degreeToRadian(style.startAngle);
                var endAngle = math.degreeToRadian(style.endAngle);
                var clockWise = style.clockWise;

                if (!clockWise) {
                    startAngle = -startAngle;
                    endAngle = -endAngle;
                }

                if (r0 > 1) {
                    computeBoundingBox.arc(
                        x, y, r0, startAngle, endAngle, !clockWise, min0, max0
                    );
                } else {
                    min0[0] = max0[0] = x;
                    min0[1] = max0[1] = y;
                }
                computeBoundingBox.arc(
                    x, y, r, startAngle, endAngle, !clockWise, min1, max1
                );

                vec2.min(min0, min0, min1);
                vec2.max(max0, max0, max1);
                style.__rect = {
                    x: min0[0],
                    y: min0[1],
                    width: max0[0] - min0[0],
                    height: max0[1] - min0[1]
                };
                return style.__rect;
            }
        };


        require('../tool/util').inherits(Sector, Base);
        return Sector;
    });
    define('echarts/util/shape/Cross', ['require', 'zrender/shape/Base', 'zrender/shape/Line', 'zrender/tool/util', './normalIsCover'], function(require) {
        var Base = require('zrender/shape/Base');
        var LineShape = require('zrender/shape/Line');
        var zrUtil = require('zrender/tool/util');

        function Cross(options) {
            Base.call(this, options);
        }

        Cross.prototype = {
            type: 'cross',

            /**
             * 创建矩形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var rect = style.rect;
                style.xStart = rect.x;
                style.xEnd = rect.x + rect.width;
                style.yStart = style.yEnd = style.y;
                LineShape.prototype.buildPath(ctx, style);
                style.xStart = style.xEnd = style.x;
                style.yStart = rect.y;
                style.yEnd = rect.y + rect.height;
                LineShape.prototype.buildPath(ctx, style);
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                return style.rect;
            },

            isCover: require('./normalIsCover')
        };

        zrUtil.inherits(Cross, Base);

        return Cross;
    });
    define('echarts/util/shape/Candle', ['require', 'zrender/shape/Base', 'zrender/tool/util', './normalIsCover'], function(require) {
        var Base = require('zrender/shape/Base');
        var zrUtil = require('zrender/tool/util');

        function Candle(options) {
            Base.call(this, options);
        }

        Candle.prototype = {
            type: 'candle',
            _numberOrder: function(a, b) {
                return b - a;
            },

            /**
             * 创建矩形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var yList = zrUtil.clone(style.y).sort(this._numberOrder);

                ctx.moveTo(style.x, yList[3]);
                ctx.lineTo(style.x, yList[2]);
                ctx.moveTo(style.x - style.width / 2, yList[2]);
                ctx.rect(
                    style.x - style.width / 2,
                    yList[2],
                    style.width,
                    yList[1] - yList[2]
                );
                ctx.moveTo(style.x, yList[1]);
                ctx.lineTo(style.x, yList[0]);
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                if (!style.__rect) {
                    var lineWidth = 0;
                    if (style.brushType == 'stroke' || style.brushType == 'fill') {
                        lineWidth = style.lineWidth || 1;
                    }

                    var yList = zrUtil.clone(style.y).sort(this._numberOrder);
                    style.__rect = {
                        x: Math.round(style.x - style.width / 2 - lineWidth / 2),
                        y: Math.round(yList[3] - lineWidth / 2),
                        width: style.width + lineWidth,
                        height: yList[0] - yList[3] + lineWidth
                    };
                }

                return style.__rect;
            },


            isCover: require('./normalIsCover')
        };

        zrUtil.inherits(Candle, Base);

        return Candle;
    });
    define('zrender/tool/computeBoundingBox', ['require', './vector', './curve'], function(require) {
        var vec2 = require('./vector');
        var curve = require('./curve');

        /**
         * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
         * @module zrender/tool/computeBoundingBox
         * @param {Array<Object>} points 顶点数组
         * @param {number} min
         * @param {number} max
         */
        function computeBoundingBox(points, min, max) {
            if (points.length === 0) {
                return;
            }
            var left = points[0][0];
            var right = points[0][0];
            var top = points[0][1];
            var bottom = points[0][1];

            for (var i = 1; i < points.length; i++) {
                var p = points[i];
                if (p[0] < left) {
                    left = p[0];
                }
                if (p[0] > right) {
                    right = p[0];
                }
                if (p[1] < top) {
                    top = p[1];
                }
                if (p[1] > bottom) {
                    bottom = p[1];
                }
            }

            min[0] = left;
            min[1] = top;
            max[0] = right;
            max[1] = bottom;
        }

        /**
         * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
         * @memberOf module:zrender/tool/computeBoundingBox
         * @param {Array.<number>} p0
         * @param {Array.<number>} p1
         * @param {Array.<number>} p2
         * @param {Array.<number>} p3
         * @param {Array.<number>} min
         * @param {Array.<number>} max
         */
        function computeCubeBezierBoundingBox(p0, p1, p2, p3, min, max) {
            var xDim = [];
            curve.cubicExtrema(p0[0], p1[0], p2[0], p3[0], xDim);
            for (var i = 0; i < xDim.length; i++) {
                xDim[i] = curve.cubicAt(p0[0], p1[0], p2[0], p3[0], xDim[i]);
            }
            var yDim = [];
            curve.cubicExtrema(p0[1], p1[1], p2[1], p3[1], yDim);
            for (var i = 0; i < yDim.length; i++) {
                yDim[i] = curve.cubicAt(p0[1], p1[1], p2[1], p3[1], yDim[i]);
            }

            xDim.push(p0[0], p3[0]);
            yDim.push(p0[1], p3[1]);

            var left = Math.min.apply(null, xDim);
            var right = Math.max.apply(null, xDim);
            var top = Math.min.apply(null, yDim);
            var bottom = Math.max.apply(null, yDim);

            min[0] = left;
            min[1] = top;
            max[0] = right;
            max[1] = bottom;
        }

        /**
         * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
         * @memberOf module:zrender/tool/computeBoundingBox
         * @param {Array.<number>} p0
         * @param {Array.<number>} p1
         * @param {Array.<number>} p2
         * @param {Array.<number>} min
         * @param {Array.<number>} max
         */
        function computeQuadraticBezierBoundingBox(p0, p1, p2, min, max) {
            // Find extremities, where derivative in x dim or y dim is zero
            var t1 = curve.quadraticExtremum(p0[0], p1[0], p2[0]);
            var t2 = curve.quadraticExtremum(p0[1], p1[1], p2[1]);

            t1 = Math.max(Math.min(t1, 1), 0);
            t2 = Math.max(Math.min(t2, 1), 0);

            var ct1 = 1 - t1;
            var ct2 = 1 - t2;

            var x1 = ct1 * ct1 * p0[0] + 2 * ct1 * t1 * p1[0] + t1 * t1 * p2[0];
            var y1 = ct1 * ct1 * p0[1] + 2 * ct1 * t1 * p1[1] + t1 * t1 * p2[1];

            var x2 = ct2 * ct2 * p0[0] + 2 * ct2 * t2 * p1[0] + t2 * t2 * p2[0];
            var y2 = ct2 * ct2 * p0[1] + 2 * ct2 * t2 * p1[1] + t2 * t2 * p2[1];
            min[0] = Math.min(p0[0], p2[0], x1, x2);
            min[1] = Math.min(p0[1], p2[1], y1, y2);
            max[0] = Math.max(p0[0], p2[0], x1, x2);
            max[1] = Math.max(p0[1], p2[1], y1, y2);
        }

        var start = vec2.create();
        var end = vec2.create();
        var extremity = vec2.create();
        /**
         * 从圆弧中计算出最小包围盒，写入`min`和`max`中
         * @method
         * @memberOf module:zrender/tool/computeBoundingBox
         * @param {Array.<number>} center 圆弧中心点
         * @param {number} radius 圆弧半径
         * @param {number} startAngle 圆弧开始角度
         * @param {number} endAngle 圆弧结束角度
         * @param {number} anticlockwise 是否是顺时针
         * @param {Array.<number>} min
         * @param {Array.<number>} max
         */
        var computeArcBoundingBox = function(
            x, y, r, startAngle, endAngle, anticlockwise, min, max
        ) {
            if (Math.abs(startAngle - endAngle) >= Math.PI * 2) {
                // Is a circle
                min[0] = x - r;
                min[1] = y - r;
                max[0] = x + r;
                max[1] = y + r;
                return;
            }

            start[0] = Math.cos(startAngle) * r + x;
            start[1] = Math.sin(startAngle) * r + y;

            end[0] = Math.cos(endAngle) * r + x;
            end[1] = Math.sin(endAngle) * r + y;

            vec2.min(min, start, end);
            vec2.max(max, start, end);

            // Thresh to [0, Math.PI * 2]
            startAngle = startAngle % (Math.PI * 2);
            if (startAngle < 0) {
                startAngle = startAngle + Math.PI * 2;
            }
            endAngle = endAngle % (Math.PI * 2);
            if (endAngle < 0) {
                endAngle = endAngle + Math.PI * 2;
            }

            if (startAngle > endAngle && !anticlockwise) {
                endAngle += Math.PI * 2;
            } else if (startAngle < endAngle && anticlockwise) {
                startAngle += Math.PI * 2;
            }
            if (anticlockwise) {
                var tmp = endAngle;
                endAngle = startAngle;
                startAngle = tmp;
            }

            // var number = 0;
            // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
            for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
                if (angle > startAngle) {
                    extremity[0] = Math.cos(angle) * r + x;
                    extremity[1] = Math.sin(angle) * r + y;

                    vec2.min(min, extremity, min);
                    vec2.max(max, extremity, max);
                }
            }
        };

        computeBoundingBox.cubeBezier = computeCubeBezierBoundingBox;
        computeBoundingBox.quadraticBezier = computeQuadraticBezierBoundingBox;
        computeBoundingBox.arc = computeArcBoundingBox;

        return computeBoundingBox;
    });
    define('echarts/util/shape/Chain', ['require', 'zrender/shape/Base', './Icon', 'zrender/shape/util/dashedLineTo', 'zrender/tool/util', 'zrender/tool/matrix'], function(require) {
        var Base = require('zrender/shape/Base');
        var IconShape = require('./Icon');

        var dashedLineTo = require('zrender/shape/util/dashedLineTo');
        var zrUtil = require('zrender/tool/util');
        var matrix = require('zrender/tool/matrix');

        function Chain(options) {
            Base.call(this, options);
        }

        Chain.prototype = {
            type: 'chain',

            /**
             * 画刷
             * @param ctx       画布句柄
             * @param e         形状实体
             * @param isHighlight   是否为高亮状态
             * @param updateCallback 需要异步加载资源的shape可以通过这个callback(e)
             *                       让painter更新视图，base.brush没用，需要的话重载brush
             */
            brush: function(ctx, isHighlight) {
                var style = this.style;

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style,
                        this.highlightStyle || {}
                    );
                }

                ctx.save();
                this.setContext(ctx, style);

                // 设置transform
                this.setTransform(ctx);

                ctx.save();
                ctx.beginPath();
                this.buildLinePath(ctx, style);
                ctx.stroke();
                ctx.restore();

                this.brushSymbol(ctx, style);

                ctx.restore();
                return;
            },

            /**
             * 创建线条路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildLinePath: function(ctx, style) {
                var x = style.x;
                var y = style.y + 5;
                var width = style.width;
                var height = style.height / 2 - 10;

                ctx.moveTo(x, y);
                ctx.lineTo(x, y + height);
                ctx.moveTo(x + width, y);
                ctx.lineTo(x + width, y + height);

                ctx.moveTo(x, y + height / 2);
                if (!style.lineType || style.lineType == 'solid') {
                    ctx.lineTo(x + width, y + height / 2);
                } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                    var dashLength = (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                    dashedLineTo(ctx, x, y + height / 2, x + width, y + height / 2, dashLength);
                }
            },

            /**
             * 标线始末标注
             */
            brushSymbol: function(ctx, style) {
                var y = style.y + style.height / 4;
                ctx.save();

                var chainPoint = style.chainPoint;
                var curPoint;
                for (var idx = 0, l = chainPoint.length; idx < l; idx++) {
                    curPoint = chainPoint[idx];
                    if (curPoint.symbol != 'none') {
                        ctx.beginPath();
                        var symbolSize = curPoint.symbolSize;
                        IconShape.prototype.buildPath(
                            ctx, {
                                iconType: curPoint.symbol,
                                x: curPoint.x - symbolSize,
                                y: y - symbolSize,
                                width: symbolSize * 2,
                                height: symbolSize * 2,
                                n: curPoint.n
                            }
                        );
                        ctx.fillStyle = curPoint.isEmpty ? '#fff' : style.strokeColor;
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }

                    if (curPoint.showLabel) {
                        ctx.font = curPoint.textFont;
                        ctx.fillStyle = curPoint.textColor;
                        ctx.textAlign = curPoint.textAlign;
                        ctx.textBaseline = curPoint.textBaseline;
                        if (curPoint.rotation) {
                            ctx.save();
                            this._updateTextTransform(ctx, curPoint.rotation);
                            ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                            ctx.restore();
                        } else {
                            ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                        }
                    }
                }

                ctx.restore();
            },

            _updateTextTransform: function(ctx, rotation) {
                var _transform = matrix.create();
                matrix.identity(_transform);

                if (rotation[0] !== 0) {
                    var originX = rotation[1] || 0;
                    var originY = rotation[2] || 0;
                    if (originX || originY) {
                        matrix.translate(
                            _transform, _transform, [-originX, -originY]
                        );
                    }
                    matrix.rotate(_transform, _transform, rotation[0]);
                    if (originX || originY) {
                        matrix.translate(
                            _transform, _transform, [originX, originY]
                        );
                    }
                }

                // 保存这个变换矩阵
                ctx.transform.apply(ctx, _transform);
            },

            isCover: function(x, y) {
                var rect = this.style;
                if (x >= rect.x && x <= (rect.x + rect.width) && y >= rect.y && y <= (rect.y + rect.height)) {
                    // 矩形内
                    return true;
                } else {
                    return false;
                }
            }
        };

        zrUtil.inherits(Chain, Base);

        return Chain;
    });
    define('zrender/shape/Ring', ['require', './Base', '../tool/util'], function(require) {
        var Base = require('./Base');

        /**
         * @alias module:zrender/shape/Ring
         * @constructor
         * @extends module:zrender/shape/Base
         * @param {Object} options
         */
        var Ring = function(options) {
            Base.call(this, options);
            /**
             * 圆环绘制样式
             * @name module:zrender/shape/Ring#style
             * @type {module:zrender/shape/Ring~IRingStyle}
             */
            /**
             * 圆环高亮绘制样式
             * @name module:zrender/shape/Ring#highlightStyle
             * @type {module:zrender/shape/Ring~IRingStyle}
             */
        };

        Ring.prototype = {
            type: 'ring',

            /**
             * 创建圆环路径
             * @param {CanvasRenderingContext2D} ctx
             * @param {module:zrender/shape/Ring~IRingStyle} style
             */
            buildPath: function(ctx, style) {
                // 非零环绕填充优化
                ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, false);
                ctx.moveTo(style.x + style.r0, style.y);
                ctx.arc(style.x, style.y, style.r0, 0, Math.PI * 2, true);
                return;
            },

            /**
             * 计算返回圆环包围盒矩阵
             * @param {module:zrender/shape/Ring~IRingStyle} style
             * @return {module:zrender/shape/Base~IBoundingRect}
             */
            getRect: function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                style.__rect = {
                    x: Math.round(style.x - style.r - lineWidth / 2),
                    y: Math.round(style.y - style.r - lineWidth / 2),
                    width: style.r * 2 + lineWidth,
                    height: style.r * 2 + lineWidth
                };

                return style.__rect;
            }
        };

        require('../tool/util').inherits(Ring, Base);
        return Ring;
    });
    define('zrender', ['zrender/zrender'], function(zrender) {
        return zrender;
    });
    define('echarts', ['echarts/echarts'], function(echarts) {
        return echarts;
    });

    var zrender = require('zrender');
    zrender.tool = {
        color: require('zrender/tool/color'),
        math: require('zrender/tool/math'),
        util: require('zrender/tool/util'),
        vector: require('zrender/tool/vector'),
        area: require('zrender/tool/area'),
        event: require('zrender/tool/event')
    }

    zrender.animation = {
        Animation: require('zrender/animation/Animation'),
        Cip: require('zrender/animation/Clip'),
        easing: require('zrender/animation/easing')
    }
    var echarts = require('echarts');
    echarts.config = require('echarts/config');


    echarts.util = {
        mapData: {
            params: require('echarts/util/mapData/params')
        }
    }


    require("echarts/chart/map");

    _global['echarts'] = echarts;
    _global['zrender'] = zrender;

    return echarts;

})(window);